{"version":3,"sources":["../../src/react/index.ts","../../src/react/hooks/use-zoom.ts","../../src/react/hooks/use-pinch-zoom.ts","../../src/react/components/pinch-wrapper.tsx","../../src/react/components/marquee-zoom.tsx"],"sourcesContent":["export * from './hooks';\nexport * from './components';\n","import { useCapability, usePlugin } from '@embedpdf/core/react';\nimport { initialState, ZoomPlugin, ZoomState } from '@embedpdf/plugin-zoom';\nimport { useEffect, useState } from 'react';\n\nexport const useZoomCapability = () => useCapability<ZoomPlugin>(ZoomPlugin.id);\nexport const useZoomPlugin = () => usePlugin<ZoomPlugin>(ZoomPlugin.id);\n\nexport const useZoom = () => {\n  const { provides } = useZoomCapability();\n  const [state, setState] = useState<ZoomState>(initialState);\n\n  useEffect(() => {\n    return provides?.onStateChange((action) => {\n      setState(action);\n    });\n  }, [provides]);\n\n  return {\n    state,\n    provides,\n  };\n};\n","import { useEffect, useRef } from 'react';\nimport { useCapability } from '@embedpdf/core/react';\nimport { ViewportPlugin } from '@embedpdf/plugin-viewport';\nimport { ZoomState } from '@embedpdf/plugin-zoom';\n\nimport { useZoomCapability } from './use-zoom';\n\nexport function usePinch() {\n  const { provides: viewportProvides } = useCapability<ViewportPlugin>('viewport');\n  const { provides: zoomProvides } = useZoomCapability();\n  const elementRef = useRef<HTMLDivElement>(null);\n\n  useEffect(() => {\n    const element = elementRef.current;\n    if (!element || !viewportProvides || !zoomProvides) {\n      return;\n    }\n\n    // Check if we're on the client side\n    if (typeof window === 'undefined') {\n      return;\n    }\n\n    let hammer: any | undefined;\n    let initialZoom = 0; // numeric scale at pinchstart\n    let lastCenter = { x: 0, y: 0 };\n\n    const getState = (): ZoomState => zoomProvides.getState();\n\n    const updateTransform = (scale: number) => {\n      // 1 → no scale; we only scale *relatively* to the start\n      element.style.transform = `scale(${scale})`;\n    };\n\n    const resetTransform = () => {\n      element.style.transform = 'none';\n      element.style.transformOrigin = '0 0';\n    };\n\n    const pinchStart = (e: HammerInput) => {\n      initialZoom = getState().currentZoomLevel;\n\n      const contRect = viewportProvides.getBoundingRect();\n\n      lastCenter = {\n        x: e.center.x - contRect.origin.x,\n        y: e.center.y - contRect.origin.y,\n      };\n\n      // put the transform-origin under the fingers so the preview feels right\n      const innerRect = element.getBoundingClientRect();\n      element.style.transformOrigin = `${e.center.x - innerRect.left}px ${e.center.y - innerRect.top}px`;\n\n      // stop the browser’s own pinch-zoom\n      if (e.srcEvent?.cancelable) {\n        e.srcEvent.preventDefault();\n        e.srcEvent.stopPropagation();\n      }\n    };\n\n    const pinchMove = (e: HammerInput) => {\n      updateTransform(e.scale); // *only* CSS, no real zoom yet\n      if (e.srcEvent?.cancelable) {\n        e.srcEvent.preventDefault();\n        e.srcEvent.stopPropagation();\n      }\n    };\n\n    const pinchEnd = (e: HammerInput) => {\n      // translate the relative hammer scale into a delta for requestZoomBy\n      const delta = (e.scale - 1) * initialZoom;\n      zoomProvides.requestZoomBy(delta, { vx: lastCenter.x, vy: lastCenter.y });\n\n      resetTransform();\n      initialZoom = 0;\n    };\n\n    // Dynamically import and setup Hammer\n    const setupHammer = async () => {\n      try {\n        const Hammer = (await import('hammerjs')).default;\n\n        /* ------------------------------------------------------------------ */\n        /* Hammer setup                                                        */\n        /* ------------------------------------------------------------------ */\n        const inputClass = (() => {\n          const MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\n          const SUPPORT_TOUCH = 'ontouchstart' in window || navigator.maxTouchPoints > 0;\n          const SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);\n          if (SUPPORT_ONLY_TOUCH) return Hammer.TouchInput;\n          if (!SUPPORT_TOUCH) return Hammer.MouseInput;\n          return Hammer.TouchMouseInput;\n        })();\n\n        hammer = new Hammer(element, {\n          touchAction: 'pan-x pan-y', // allow scroll in every direction\n          inputClass,\n        });\n\n        hammer.get('pinch').set({ enable: true, pointers: 2, threshold: 0.1 });\n\n        hammer.on('pinchstart', pinchStart);\n        hammer.on('pinchmove', pinchMove);\n        hammer.on('pinchend', pinchEnd);\n      } catch (error) {\n        console.warn('Failed to load HammerJS:', error);\n      }\n    };\n\n    setupHammer();\n\n    return () => {\n      hammer?.destroy();\n      resetTransform();\n    };\n  }, [viewportProvides, zoomProvides]);\n\n  return { elementRef };\n}\n","import { ReactNode } from 'react';\n\nimport { usePinch } from '../hooks';\n\ntype PinchWrapperProps = Omit<React.HTMLAttributes<HTMLDivElement>, 'style'> & {\n  children: ReactNode;\n  style?: React.CSSProperties;\n};\n\nexport function PinchWrapper({ children, style, ...props }: PinchWrapperProps) {\n  const { elementRef } = usePinch();\n\n  return (\n    <div\n      ref={elementRef}\n      {...props}\n      style={{\n        ...style,\n        display: 'block',\n        width: 'fit-content',\n        overflow: 'visible',\n        boxSizing: 'border-box',\n        margin: '0px auto',\n      }}\n    >\n      {children}\n    </div>\n  );\n}\n","import { useEffect, useMemo, useRef, useState } from 'react';\nimport type { PointerEventHandlers } from '@embedpdf/plugin-interaction-manager';\nimport { usePointerHandlers } from '@embedpdf/plugin-interaction-manager/react';\nimport { Rect } from '@embedpdf/models';\n\nimport { useZoomCapability } from '../hooks/use-zoom';\n\ninterface MarqueeZoomProps {\n  /** Index of the page this layer lives on */\n  pageIndex: number;\n  /** Scale of the page */\n  scale: number;\n  /** Width of the page */\n  pageWidth: number;\n  /** Height of the page */\n  pageHeight: number;\n  /** Optional CSS class applied to the marquee rectangle */\n  className?: string;\n  /** Stroke / fill colours (defaults below) */\n  stroke?: string;\n  fill?: string;\n}\n\n/**\n * Draws a marquee rectangle while the user drags.\n * Hook it into the interaction-manager with modeId = 'marqueeZoom'.\n */\nexport const MarqueeZoom = ({\n  pageIndex,\n  scale,\n  pageWidth,\n  pageHeight,\n  className,\n  stroke = 'rgba(33,150,243,0.8)',\n  fill = 'rgba(33,150,243,0.15)',\n}: MarqueeZoomProps) => {\n  /* ------------------------------------------------------------------ */\n  /* zoom capability                                                   */\n  /* ------------------------------------------------------------------ */\n  const { provides: zoom } = useZoomCapability();\n\n  /* ------------------------------------------------------------------ */\n  /* integration with interaction-manager                               */\n  /* ------------------------------------------------------------------ */\n  const { register } = usePointerHandlers({ modeId: 'marqueeZoom', pageIndex });\n\n  /* ------------------------------------------------------------------ */\n  /* helpers                                                            */\n  /* ------------------------------------------------------------------ */\n  const clamp = (v: number, min: number, max: number) => Math.max(min, Math.min(max, v));\n\n  /* ------------------------------------------------------------------ */\n  /* local state – start / current drag position                        */\n  /* ------------------------------------------------------------------ */\n  const startRef = useRef<{ x: number; y: number } | null>(null);\n  const [rect, setRect] = useState<Rect | null>(null);\n\n  /* page size in **PDF-space** (unscaled) ----------------------------- */\n  const pageWidthPDF = pageWidth / scale;\n  const pageHeightPDF = pageHeight / scale;\n\n  /* ------------------------------------------------------------------ */\n  /* pointer handlers                                                   */\n  /* ------------------------------------------------------------------ */\n  const handlers = useMemo<PointerEventHandlers<PointerEvent>>(\n    () => ({\n      onPointerDown: (pos, evt) => {\n        startRef.current = pos;\n        setRect({ origin: { x: pos.x, y: pos.y }, size: { width: 0, height: 0 } });\n        (evt.target as HTMLElement)?.setPointerCapture?.(evt.pointerId);\n      },\n      onPointerMove: (pos) => {\n        if (!startRef.current) return;\n        /* clamp current position to the page bounds */\n        const curX = clamp(pos.x, 0, pageWidthPDF);\n        const curY = clamp(pos.y, 0, pageHeightPDF);\n\n        const { x: sx, y: sy } = startRef.current;\n        const left = Math.min(sx, curX);\n        const top = Math.min(sy, curY);\n        const width = Math.abs(curX - sx);\n        const height = Math.abs(curY - sy);\n\n        setRect({ origin: { x: left, y: top }, size: { width, height } });\n      },\n      onPointerUp: (_, evt) => {\n        if (rect && zoom) {\n          const dragPx = Math.max(rect.size.width, rect.size.height) * scale;\n          if (dragPx > 5) {\n            // real drag → zoom to it\n            zoom.zoomToArea(pageIndex, rect);\n          } else {\n            // tiny drag → simple zoom-in\n            zoom.zoomIn();\n          }\n        }\n\n        startRef.current = null;\n        setRect(null);\n        (evt.target as HTMLElement)?.releasePointerCapture?.(evt.pointerId);\n      },\n      onPointerCancel: (_, evt) => {\n        startRef.current = null;\n        setRect(null);\n        (evt.target as HTMLElement)?.releasePointerCapture?.(evt.pointerId);\n      },\n    }),\n    [pageWidthPDF, pageWidthPDF, zoom, scale, rect, pageIndex],\n  );\n\n  /* register with the interaction-manager */\n  useEffect(() => {\n    if (!register) return;\n    return register(handlers);\n  }, [register, handlers]);\n\n  /* ------------------------------------------------------------------ */\n  /* render                                                              */\n  /* ------------------------------------------------------------------ */\n  if (!rect) return null; // nothing to draw\n\n  return (\n    <div\n      /* Each page wrapper is position:relative, so absolute is fine */\n      style={{\n        position: 'absolute',\n        pointerEvents: 'none', // ignore hits – underlying page still gets events\n        left: rect.origin.x * scale,\n        top: rect.origin.y * scale,\n        width: rect.size.width * scale,\n        height: rect.size.height * scale,\n        border: `1px solid ${stroke}`,\n        background: fill,\n        boxSizing: 'border-box',\n      }}\n      className={className}\n    />\n  );\n};\n"],"mappings":"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","names":["import_react","import_react","import_react","import_jsx_runtime"]}