"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const l=require("@embedpdf/core"),o="viewport",h={id:o,name:"Viewport Plugin",version:"1.0.0",provides:["viewport"],requires:[],optional:[],defaultConfig:{enabled:!0,viewportGap:10,scrollEndDelay:300}},n="SET_VIEWPORT_METRICS",d="SET_VIEWPORT_SCROLL_METRICS",y="SET_VIEWPORT_GAP",v="SET_SCROLL_ACTIVITY";function S(e){return{type:y,payload:e}}function E(e){return{type:n,payload:e}}function R(e){return{type:d,payload:e}}function f(e){return{type:v,payload:e}}const u={viewportGap:0,viewportMetrics:{width:0,height:0,scrollTop:0,scrollLeft:0,clientWidth:0,clientHeight:0,scrollWidth:0,scrollHeight:0,relativePosition:{x:0,y:0}},isScrolling:!1},P=(e=u,t)=>{switch(t.type){case y:return{...e,viewportGap:t.payload};case n:return{...e,viewportMetrics:{width:t.payload.width,height:t.payload.height,scrollTop:t.payload.scrollTop,scrollLeft:t.payload.scrollLeft,clientWidth:t.payload.clientWidth,clientHeight:t.payload.clientHeight,scrollWidth:t.payload.scrollWidth,scrollHeight:t.payload.scrollHeight,relativePosition:{x:t.payload.scrollWidth<=t.payload.clientWidth?0:t.payload.scrollLeft/(t.payload.scrollWidth-t.payload.clientWidth),y:t.payload.scrollHeight<=t.payload.clientHeight?0:t.payload.scrollTop/(t.payload.scrollHeight-t.payload.clientHeight)}}};case d:return{...e,viewportMetrics:{...e.viewportMetrics,scrollTop:t.payload.scrollTop,scrollLeft:t.payload.scrollLeft},isScrolling:!0};case v:return{...e,isScrolling:t.payload};default:return e}},c=class c extends l.BasePlugin{constructor(t,i,r){super(t,i),this.id=t,this.viewportResize$=l.createBehaviorEmitter(),this.viewportMetrics$=l.createBehaviorEmitter(),this.scrollMetrics$=l.createBehaviorEmitter(),this.scrollReq$=l.createEmitter(),this.scrollActivity$=l.createBehaviorEmitter(),this.rectProvider=null,r.viewportGap&&this.dispatch(S(r.viewportGap)),this.scrollEndDelay=r.scrollEndDelay||300}buildCapability(){return{getViewportGap:()=>this.state.viewportGap,getMetrics:()=>this.state.viewportMetrics,getBoundingRect:()=>{var t;return((t=this.rectProvider)==null?void 0:t.call(this))??{origin:{x:0,y:0},size:{width:0,height:0}}},scrollTo:t=>this.scrollTo(t),isScrolling:()=>this.state.isScrolling,onScrollChange:this.scrollMetrics$.on,onViewportChange:this.viewportMetrics$.on,onViewportResize:this.viewportResize$.on,onScrollActivity:this.scrollActivity$.on}}setViewportResizeMetrics(t){this.dispatch(E(t)),this.viewportResize$.emit(this.state.viewportMetrics)}setViewportScrollMetrics(t){(t.scrollTop!==this.state.viewportMetrics.scrollTop||t.scrollLeft!==this.state.viewportMetrics.scrollLeft)&&(this.dispatch(R(t)),this.bumpScrollActivity(),this.scrollMetrics$.emit({scrollTop:t.scrollTop,scrollLeft:t.scrollLeft}))}onScrollRequest(t){return this.scrollReq$.on(t)}registerBoundingRectProvider(t){this.rectProvider=t}bumpScrollActivity(){this.debouncedDispatch(f(!1),this.scrollEndDelay)}scrollTo(t){const{x:i,y:r,center:w,behavior:p="auto"}=t;if(w){const a=this.state.viewportMetrics,T=i-a.clientWidth/2,g=r-a.clientHeight/2;this.scrollReq$.emit({x:T,y:g,behavior:p})}else this.scrollReq$.emit({x:i,y:r,behavior:p})}onStoreUpdated(t,i){t!==i&&(this.viewportMetrics$.emit(i.viewportMetrics),t.isScrolling!==i.isScrolling&&this.scrollActivity$.emit(i.isScrolling))}async initialize(t){}async destroy(){super.destroy(),this.viewportMetrics$.clear(),this.viewportResize$.clear(),this.scrollMetrics$.clear(),this.scrollReq$.clear(),this.scrollActivity$.clear(),this.rectProvider=null,this.scrollEndTimer&&clearTimeout(this.scrollEndTimer)}};c.id="viewport";let s=c;const M={manifest:h,create:(e,t,i)=>new s(o,e,i),reducer:P,initialState:u};exports.VIEWPORT_PLUGIN_ID=o;exports.ViewportPlugin=s;exports.ViewportPluginPackage=M;exports.manifest=h;
//# sourceMappingURL=index.cjs.map
