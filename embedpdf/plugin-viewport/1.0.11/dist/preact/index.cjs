"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const w=require("preact"),s=require("preact/hooks"),c=require("../viewport-plugin-C6NBwaM2.cjs"),h=require("../jsxRuntime.module-BSRTsKji.cjs"),v=w.createContext({registry:null,isInitializing:!0,pluginsReady:!1});function y(){const t=s.useContext(v);if(t===void 0)throw new Error("useCapability must be used within a PDFContext.Provider");const{registry:i,isInitializing:e}=t;if(e)return t;if(i===null)throw new Error("PDF registry failed to initialize properly");return t}function p(t){const{registry:i}=y();if(i===null)return{plugin:null,isLoading:!0,ready:new Promise(()=>{})};const e=i.getPlugin(t);if(!e)throw new Error(`Plugin ${t} not found`);return{plugin:e,isLoading:!1,ready:e.ready()}}function P(t){const{plugin:i,isLoading:e,ready:o}=p(t);if(!i)return{provides:null,isLoading:e,ready:o};if(!i.provides)throw new Error(`Plugin ${t} does not provide a capability`);return{provides:i.provides(),isLoading:e,ready:o}}const d=()=>p(c.ViewportPlugin.id),g=()=>P(c.ViewportPlugin.id);function R(){const{plugin:t}=d(),i=s.useRef(null);return s.useLayoutEffect(()=>{if(!t)return;const e=i.current;if(!e)return;const o=()=>{const r=e.getBoundingClientRect();return{origin:{x:r.left,y:r.top},size:{width:r.width,height:r.height}}};t.registerBoundingRectProvider(o);const l=()=>{t.setViewportScrollMetrics({scrollTop:e.scrollTop,scrollLeft:e.scrollLeft})};e.addEventListener("scroll",l);const n=new ResizeObserver(()=>{t.setViewportResizeMetrics({width:e.offsetWidth,height:e.offsetHeight,clientWidth:e.clientWidth,clientHeight:e.clientHeight,scrollTop:e.scrollTop,scrollLeft:e.scrollLeft,scrollWidth:e.scrollWidth,scrollHeight:e.scrollHeight})});n.observe(e);const u=t.onScrollRequest(({x:r,y:a,behavior:f="auto"})=>{requestAnimationFrame(()=>{e.scrollTo({left:r,top:a,behavior:f})})});return()=>{t.registerBoundingRectProvider(null),e.removeEventListener("scroll",l),n.disconnect(),u()}},[t]),i}function b({children:t,...i}){const[e,o]=s.useState(0),l=R(),{provides:n}=g();s.useEffect(()=>{n&&o(n.getViewportGap())},[n]);const{style:u,...r}=i;return h.u("div",{...r,ref:l,style:{...typeof u=="object"?u:{},padding:`${e}px`},children:t})}exports.Viewport=b;exports.useViewportCapability=g;exports.useViewportPlugin=d;
//# sourceMappingURL=index.cjs.map
