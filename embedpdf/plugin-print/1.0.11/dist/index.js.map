{"version":3,"sources":["../src/lib/manifest.ts","../src/lib/print-plugin.ts","../../models/src/geometry.ts","../../models/src/logger.ts","../../models/src/task.ts","../../models/src/pdf.ts","../../models/src/color.ts","../../models/src/date.ts","../../models/src/index.ts","../src/lib/types.ts","../src/lib/index.ts"],"sourcesContent":["import { PluginManifest } from '@embedpdf/core';\nimport { PrintPluginConfig } from './types';\n\nexport const PRINT_PLUGIN_ID = 'print';\n\nexport const manifest: PluginManifest<PrintPluginConfig> = {\n  id: PRINT_PLUGIN_ID,\n  name: 'Print Plugin',\n  version: '1.0.0',\n  provides: ['print'],\n  requires: ['render'],\n  optional: [],\n  defaultConfig: {\n    enabled: true,\n  },\n};\n","import { BasePlugin, PluginRegistry } from '@embedpdf/core';\nimport { RenderCapability, RenderPlugin } from '@embedpdf/plugin-render';\n\nimport {\n  PageRangeType,\n  ParsedPageRange,\n  PrintOptions,\n  PrintPageResult,\n  PrintPluginConfig,\n  PrintProgress,\n  PrintQuality,\n} from './types';\nimport { PrintCapability } from './types';\nimport { Rotation } from '@embedpdf/models';\n\nexport class PrintPlugin extends BasePlugin<PrintPluginConfig, PrintCapability> {\n  static readonly id = 'print' as const;\n\n  private readonly renderCapability: RenderCapability;\n  private readonly config: PrintPluginConfig;\n\n  constructor(id: string, registry: PluginRegistry, config: PrintPluginConfig) {\n    super(id, registry);\n\n    this.config = config;\n    this.renderCapability = this.registry.getPlugin<RenderPlugin>(RenderPlugin.id)?.provides()!;\n  }\n\n  async initialize(_config: PrintPluginConfig): Promise<void> {}\n\n  protected buildCapability(): PrintCapability {\n    return {\n      preparePrint: this.preparePrint.bind(this),\n      parsePageRange: this.parsePageRange.bind(this),\n    };\n  }\n\n  private async preparePrint(\n    options: PrintOptions,\n    onProgress?: (progress: PrintProgress) => void,\n    onPageReady?: (result: PrintPageResult) => void,\n  ): Promise<void> {\n    const coreState = this.coreState.core;\n\n    if (!coreState.document) {\n      throw new Error('No document loaded');\n    }\n\n    const pagesToPrint = this.getPagesToPrint(options, coreState.document.pages.length);\n    const totalPages = pagesToPrint.length;\n    const batchSize = this.config?.batchSize || 3; // Render 3 pages concurrently by default\n\n    onProgress?.({\n      current: 0,\n      total: totalPages,\n      status: 'preparing',\n      message: `Preparing to render ${totalPages} page${totalPages !== 1 ? 's' : ''}...`,\n    });\n\n    const scaleFactor = this.getScaleFactor(options.quality);\n    const dpr = 1;\n\n    // Process pages in batches to avoid memory issues\n    for (let batchStart = 0; batchStart < pagesToPrint.length; batchStart += batchSize) {\n      const batchEnd = Math.min(batchStart + batchSize, pagesToPrint.length);\n      const batch = pagesToPrint.slice(batchStart, batchEnd);\n\n      // Render batch concurrently\n      const batchPromises = batch.map(async (pageIndex, batchIndex) => {\n        const overallIndex = batchStart + batchIndex;\n\n        onProgress?.({\n          current: overallIndex,\n          total: totalPages,\n          status: 'rendering',\n          message: `Rendering page ${pageIndex + 1}...`,\n        });\n\n        const blob = await this.renderPage(pageIndex, scaleFactor, dpr, options.includeAnnotations);\n\n        // Send page ready immediately after rendering\n        onPageReady?.({\n          pageIndex,\n          blob,\n        });\n\n        return;\n      });\n\n      // Wait for batch to complete\n      await Promise.all(batchPromises);\n    }\n\n    onProgress?.({\n      current: totalPages,\n      total: totalPages,\n      status: 'complete',\n      message: 'All pages rendered successfully',\n    });\n  }\n\n  private async renderPage(\n    pageIndex: number,\n    scaleFactor: number,\n    dpr: number,\n    withAnnotations: boolean,\n  ): Promise<Blob> {\n    return new Promise((resolve, reject) => {\n      const renderTask = this.renderCapability.renderPage({\n        pageIndex,\n        scaleFactor,\n        dpr,\n        rotation: Rotation.Degree0,\n        options: {\n          withAnnotations,\n        },\n      });\n\n      renderTask.wait(\n        (blob) => resolve(blob),\n        (error) =>\n          reject(\n            new Error(\n              `Failed to render page ${pageIndex + 1}: ${error.reason.message || 'Unknown error'}`,\n            ),\n          ),\n      );\n    });\n  }\n\n  private getScaleFactor(quality: PrintQuality): number {\n    switch (quality) {\n      case PrintQuality.High:\n        return 1.5; // Higher resolution for better print quality\n      case PrintQuality.Normal:\n      default:\n        return 1; // Standard print resolution\n    }\n  }\n\n  private getPagesToPrint(options: PrintOptions, totalPages: number): number[] {\n    const { pageRange } = options;\n\n    switch (pageRange.type) {\n      case PageRangeType.Current:\n        return pageRange.currentPage !== undefined ? [pageRange.currentPage] : [0];\n\n      case PageRangeType.All:\n        return Array.from({ length: totalPages }, (_, i) => i);\n\n      case PageRangeType.Custom:\n        if (!pageRange.pages) return [0];\n        return pageRange.pages\n          .filter((page) => page >= 0 && page < totalPages)\n          .sort((a, b) => a - b);\n\n      default:\n        return [0];\n    }\n  }\n\n  private parsePageRange(rangeString: string): ParsedPageRange {\n    try {\n      const totalPages = this.coreState.core.document?.pages.length || 0;\n      const pages: number[] = [];\n      const parts = rangeString.split(',').map((s) => s.trim());\n\n      for (const part of parts) {\n        if (part.includes('-')) {\n          // Handle range like \"5-10\"\n          const [start, end] = part.split('-').map((s) => parseInt(s.trim()));\n\n          if (isNaN(start) || isNaN(end)) {\n            return { pages: [], isValid: false, error: `Invalid range: ${part}` };\n          }\n\n          if (start > end) {\n            return { pages: [], isValid: false, error: `Invalid range: ${part} (start > end)` };\n          }\n\n          for (let i = start; i <= end; i++) {\n            if (i >= 1 && i <= totalPages) {\n              pages.push(i - 1); // Convert to 0-based index\n            }\n          }\n        } else {\n          // Handle single page\n          const pageNum = parseInt(part);\n\n          if (isNaN(pageNum)) {\n            return { pages: [], isValid: false, error: `Invalid page number: ${part}` };\n          }\n\n          if (pageNum >= 1 && pageNum <= totalPages) {\n            pages.push(pageNum - 1); // Convert to 0-based index\n          }\n        }\n      }\n\n      // Remove duplicates and sort\n      const uniquePages = [...new Set(pages)].sort((a, b) => a - b);\n\n      return {\n        pages: uniquePages,\n        isValid: true,\n      };\n    } catch (error) {\n      return {\n        pages: [],\n        isValid: false,\n        error: `Parsing error: ${error instanceof Error ? error.message : 'Unknown error'}`,\n      };\n    }\n  }\n}\n","/**\n * Clockwise direction\n * @public\n */\nexport enum Rotation {\n  Degree0 = 0,\n  Degree90 = 1,\n  Degree180 = 2,\n  Degree270 = 3,\n}\n\n/** Clamp a Position to device-pixel integers (floor) */\nexport function toIntPos(p: Position): Position {\n  return { x: Math.floor(p.x), y: Math.floor(p.y) };\n}\n\n/** Clamp a Size so it never truncates right / bottom (ceil) */\nexport function toIntSize(s: Size): Size {\n  return { width: Math.ceil(s.width), height: Math.ceil(s.height) };\n}\n\n/** Apply both rules to a Rect */\nexport function toIntRect(r: Rect): Rect {\n  return {\n    origin: toIntPos(r.origin),\n    size: toIntSize(r.size),\n  };\n}\n\n/**\n * Calculate degree that match the rotation type\n * @param rotation - type of rotation\n * @returns rotated degree\n *\n * @public\n */\nexport function calculateDegree(rotation: Rotation) {\n  switch (rotation) {\n    case Rotation.Degree0:\n      return 0;\n    case Rotation.Degree90:\n      return 90;\n    case Rotation.Degree180:\n      return 180;\n    case Rotation.Degree270:\n      return 270;\n  }\n}\n\n/**\n * Calculate angle that match the rotation type\n * @param rotation - type of rotation\n * @returns rotated angle\n *\n * @public\n */\nexport function calculateAngle(rotation: Rotation) {\n  return (calculateDegree(rotation) * Math.PI) / 180;\n}\n\n/**\n * Represent the size of object\n *\n * @public\n */\nexport interface Size {\n  /**\n   * width of the object\n   */\n  width: number;\n\n  /**\n   * height of the object\n   */\n  height: number;\n}\n\n/**\n * Represents a rectangle defined by its left, top, right, and bottom edges\n *\n * @public\n */\nexport interface Box {\n  /**\n   * The x-coordinate of the left edge\n   */\n  left: number;\n\n  /**\n   * The y-coordinate of the top edge\n   */\n  top: number;\n\n  /**\n   * The x-coordinate of the right edge\n   */\n  right: number;\n\n  /**\n   * The y-coordinate of the bottom edge\n   */\n  bottom: number;\n}\n\n/**\n * Swap the width and height of the size object\n * @param size - the original size\n * @returns swapped size\n *\n * @public\n */\nexport function swap(size: Size): Size {\n  const { width, height } = size;\n\n  return {\n    width: height,\n    height: width,\n  };\n}\n\n/**\n * Transform size with specified rotation angle and scale factor\n * @param size - orignal size of rect\n * @param rotation - rotation angle\n * @param scaleFactor - - scale factor\n * @returns size that has been transformed\n *\n * @public\n */\nexport function transformSize(size: Size, rotation: Rotation, scaleFactor: number): Size {\n  size = rotation % 2 === 0 ? size : swap(size);\n\n  return {\n    width: size.width * scaleFactor,\n    height: size.height * scaleFactor,\n  };\n}\n\n/**\n * position of point\n *\n * @public\n */\nexport interface Position {\n  /**\n   * x coordinate\n   */\n  x: number;\n\n  /**\n   * y coordinate\n   */\n  y: number;\n}\n\n/**\n * Quadrilateral\n *\n * @public\n */\nexport interface Quad {\n  p1: Position;\n  p2: Position;\n  p3: Position;\n  p4: Position;\n}\n\n/**\n * Convert quadrilateral to rectangle\n * @param q - quadrilateral\n * @returns rectangle\n *\n * @public\n */\nexport function quadToRect(q: Quad): Rect {\n  const xs = [q.p1.x, q.p2.x, q.p3.x, q.p4.x];\n  const ys = [q.p1.y, q.p2.y, q.p3.y, q.p4.y];\n\n  return {\n    origin: { x: Math.min(...xs), y: Math.min(...ys) },\n    size: {\n      width: Math.max(...xs) - Math.min(...xs),\n      height: Math.max(...ys) - Math.min(...ys),\n    },\n  };\n}\n\n/**\n * Convert rectangle to quadrilateral\n * @param r - rectangle\n * @returns quadrilateral\n *\n * @public\n */\nexport function rectToQuad(r: Rect): Quad {\n  return {\n    p1: { x: r.origin.x, y: r.origin.y },\n    p2: { x: r.origin.x + r.size.width, y: r.origin.y },\n    p3: { x: r.origin.x + r.size.width, y: r.origin.y + r.size.height },\n    p4: { x: r.origin.x, y: r.origin.y + r.size.height },\n  };\n}\n\n/**\n * Rotate the container and calculate the new position for a point\n * in specified position\n * @param containerSize - size of the container\n * @param position - position of the point\n * @param rotation - rotated angle\n * @returns new position of the point\n *\n * @public\n */\nexport function rotatePosition(\n  containerSize: Size,\n  position: Position,\n  rotation: Rotation,\n): Position {\n  let x = position.x;\n  let y = position.y;\n\n  switch (rotation) {\n    case Rotation.Degree0:\n      x = position.x;\n      y = position.y;\n      break;\n    case Rotation.Degree90:\n      x = containerSize.height - position.y;\n      y = position.x;\n      break;\n    case Rotation.Degree180:\n      x = containerSize.width - position.x;\n      y = containerSize.height - position.y;\n      break;\n    case Rotation.Degree270:\n      x = position.y;\n      y = containerSize.width - position.x;\n      break;\n  }\n\n  return {\n    x,\n    y,\n  };\n}\n\n/**\n * Calculate the position of point by scaling the container\n * @param position - position of the point\n * @param scaleFactor - factor of scaling\n * @returns new position of point\n *\n * @public\n */\nexport function scalePosition(position: Position, scaleFactor: number): Position {\n  return {\n    x: position.x * scaleFactor,\n    y: position.y * scaleFactor,\n  };\n}\n\n/**\n * Calculate the position of the point by applying the specified transformation\n * @param containerSize - size of container\n * @param position - position of the point\n * @param rotation - rotated angle\n * @param scaleFactor - factor of scaling\n * @returns new position of point\n *\n * @public\n */\nexport function transformPosition(\n  containerSize: Size,\n  position: Position,\n  rotation: Rotation,\n  scaleFactor: number,\n): Position {\n  return scalePosition(rotatePosition(containerSize, position, rotation), scaleFactor);\n}\n\n/**\n * Restore the position in a transformed cotainer\n * @param containerSize - size of the container\n * @param position - position of the point\n * @param rotation - rotated angle\n * @param scaleFactor - factor of scaling\n * @returns the original position of the point\n *\n * @public\n */\nexport function restorePosition(\n  containerSize: Size,\n  position: Position,\n  rotation: Rotation,\n  scaleFactor: number,\n): Position {\n  return scalePosition(\n    rotatePosition(containerSize, position, (4 - rotation) % 4),\n    1 / scaleFactor,\n  );\n}\n\n/**\n * representation of rectangle\n *\n * @public\n */\nexport interface Rect {\n  /**\n   * origin of the rectangle\n   */\n  origin: Position;\n\n  /**\n   * size of the rectangle\n   */\n  size: Size;\n}\n\n/**\n * Calculate the rect after rotated the container\n * @param containerSize - size of container\n * @param rect - target rect\n * @param rotation - rotation angle\n * @returns rotated rect\n *\n * @public\n */\nexport function rotateRect(containerSize: Size, rect: Rect, rotation: Rotation): Rect {\n  let x = rect.origin.x;\n  let y = rect.origin.y;\n  let size = rect.size;\n\n  switch (rotation) {\n    case Rotation.Degree0:\n      break;\n    case Rotation.Degree90:\n      x = containerSize.height - rect.origin.y - rect.size.height;\n      y = rect.origin.x;\n      size = swap(rect.size);\n      break;\n    case Rotation.Degree180:\n      x = containerSize.width - rect.origin.x - rect.size.width;\n      y = containerSize.height - rect.origin.y - rect.size.height;\n      break;\n    case Rotation.Degree270:\n      x = rect.origin.y;\n      y = containerSize.width - rect.origin.x - rect.size.width;\n      size = swap(rect.size);\n      break;\n  }\n\n  return {\n    origin: {\n      x,\n      y,\n    },\n    size: {\n      width: size.width,\n      height: size.height,\n    },\n  };\n}\n\n/**\n * Scale the rectangle\n * @param rect - rectangle\n * @param scaleFactor - factor of scaling\n * @returns new rectangle\n *\n * @public\n */\nexport function scaleRect(rect: Rect, scaleFactor: number): Rect {\n  return {\n    origin: {\n      x: rect.origin.x * scaleFactor,\n      y: rect.origin.y * scaleFactor,\n    },\n    size: {\n      width: rect.size.width * scaleFactor,\n      height: rect.size.height * scaleFactor,\n    },\n  };\n}\n\n/**\n * Calculate new rectangle after transforming the container\n * @param containerSize - size of the container\n * @param rect - the target rectangle\n * @param rotation - rotated angle\n * @param scaleFactor - factor of scaling\n * @returns new rectangle after transformation\n *\n * @public\n */\nexport function transformRect(\n  containerSize: Size,\n  rect: Rect,\n  rotation: Rotation,\n  scaleFactor: number,\n): Rect {\n  return scaleRect(rotateRect(containerSize, rect, rotation), scaleFactor);\n}\n\n/**\n * Calculate new rectangle before transforming the container\n * @param containerSize - size of the container\n * @param rect - the target rectangle\n * @param rotation - rotated angle\n * @param scaleFactor - factor of scaling\n * @returns original rectangle before transformation\n *\n * @public\n */\nexport function restoreRect(\n  containerSize: Size,\n  rect: Rect,\n  rotation: Rotation,\n  scaleFactor: number,\n): Rect {\n  return scaleRect(rotateRect(containerSize, rect, (4 - rotation) % 4), 1 / scaleFactor);\n}\n\n/**\n * Calculate the original offset in a transformed container\n * @param offset - position of the point\n * @param rotation - rotated angle\n * @param scaleFactor - factor of scaling\n * @returns original position of the point\n *\n * @public\n */\nexport function restoreOffset(offset: Position, rotation: Rotation, scaleFactor: number): Position {\n  let offsetX = offset.x;\n  let offsetY = offset.y;\n  switch (rotation) {\n    case Rotation.Degree0:\n      offsetX = offset.x / scaleFactor;\n      offsetY = offset.y / scaleFactor;\n      break;\n    case Rotation.Degree90:\n      offsetX = offset.y / scaleFactor;\n      offsetY = -offset.x / scaleFactor;\n      break;\n    case Rotation.Degree180:\n      offsetX = -offset.x / scaleFactor;\n      offsetY = -offset.y / scaleFactor;\n      break;\n    case Rotation.Degree270:\n      offsetX = -offset.y / scaleFactor;\n      offsetY = offset.x / scaleFactor;\n      break;\n  }\n\n  return {\n    x: offsetX,\n    y: offsetY,\n  };\n}\n\n/**\n * Return the smallest rectangle that encloses *all* `rects`.\n * If the array is empty, returns `null`.\n *\n * @param rects - array of rectangles\n * @returns smallest rectangle that encloses all the rectangles\n *\n * @public\n */\nexport function boundingRect(rects: Rect[]): Rect | null {\n  if (rects.length === 0) return null;\n\n  let minX = rects[0].origin.x,\n    minY = rects[0].origin.y,\n    maxX = rects[0].origin.x + rects[0].size.width,\n    maxY = rects[0].origin.y + rects[0].size.height;\n\n  for (const r of rects) {\n    minX = Math.min(minX, r.origin.x);\n    minY = Math.min(minY, r.origin.y);\n    maxX = Math.max(maxX, r.origin.x + r.size.width);\n    maxY = Math.max(maxY, r.origin.y + r.size.height);\n  }\n\n  return {\n    origin: {\n      x: minX,\n      y: minY,\n    },\n    size: {\n      width: maxX - minX,\n      height: maxY - minY,\n    },\n  };\n}\n\nexport interface Matrix {\n  a: number;\n  b: number;\n  c: number;\n  d: number;\n  e: number;\n  f: number;\n}\n\n/**\n * Build a CTM that maps *PDF-space* inside the annotation\n * → *device-space* inside the bitmap, honouring\n * zoom (scaleFactor × dpr) **and** page-rotation.\n */\n/** build the CTM for any page-rotation */\nexport const makeMatrix = (rectangle: Rect, rotation: Rotation, scaleFactor: number): Matrix => {\n  const { width, height } = rectangle.size;\n\n  switch (rotation) {\n    case Rotation.Degree0: // normal\n      return {\n        a: scaleFactor,\n        b: 0,\n        c: 0,\n        d: -scaleFactor,\n        e: 0,\n        f: height * scaleFactor,\n      };\n\n    case Rotation.Degree90: // +90° CW\n      //  matrix =   [ 0  s ]   after flip-Y → no extra translation needed\n      //              [ s  0 ]\n      return {\n        a: 0,\n        b: scaleFactor,\n        c: scaleFactor,\n        d: 0,\n        e: 0,\n        f: 0,\n      };\n\n    case Rotation.Degree180: // +180°\n      return {\n        a: -scaleFactor,\n        b: 0,\n        c: 0,\n        d: scaleFactor,\n        e: width * scaleFactor,\n        f: 0,\n      };\n\n    case Rotation.Degree270: // +270° CW  (= 90° CCW)\n      //  flips the other way, so we nudge it back inside the bitmap\n      return {\n        a: 0,\n        b: -scaleFactor,\n        c: -scaleFactor,\n        d: 0,\n        e: height * scaleFactor,\n        f: width * scaleFactor,\n      };\n  }\n};\n","/**\n * logger for logging\n *\n * @public\n */\nexport interface Logger {\n  /**\n   * Log debug message\n   * @param source - source of log\n   * @param category - category of log\n   * @param args - parameters of log\n   * @returns\n   *\n   * @public\n   */\n  debug: (source: string, category: string, ...args: any) => void;\n\n  /**\n   * Log infor message\n   * @param source - source of log\n   * @param category - category of log\n   * @param args - parameters of log\n   * @returns\n   *\n   * @public\n   */\n  info: (source: string, category: string, ...args: any) => void;\n\n  /**\n   * Log warning message\n   * @param source - source of log\n   * @param category - category of log\n   * @param args - parameters of log\n   * @returns\n   *\n   * @public\n   */\n  warn: (source: string, category: string, ...args: any) => void;\n  /**\n   * Log error message\n   * @param source - source of log\n   * @param category - category of log\n   * @param args - parameters of log\n   * @returns\n   *\n   * @public\n   */\n  error: (source: string, category: string, ...args: any) => void;\n\n  /**\n   * Log performance log\n   * @param source - source of log\n   * @param category - category of log\n   * @param event - event of log\n   * @param phase - event phase of log\n   * @param args - parameters of log\n   * @returns\n   *\n   * @public\n   */\n  perf: (\n    source: string,\n    category: string,\n    event: string,\n    phase: 'Begin' | 'End',\n    ...args: any\n  ) => void;\n}\n\n/**\n * Logger that log nothing, it will ignore all the logs\n *\n * @public\n */\nexport class NoopLogger implements Logger {\n  /** {@inheritDoc Logger.debug} */\n  debug() {}\n  /** {@inheritDoc Logger.info} */\n  info() {}\n  /** {@inheritDoc Logger.warn} */\n  warn() {}\n  /** {@inheritDoc Logger.error} */\n  error() {}\n  /** {@inheritDoc Logger.perf} */\n  perf() {}\n}\n\n/**\n * Logger that use console as the output\n *\n * @public\n */\nexport class ConsoleLogger implements Logger {\n  /** {@inheritDoc Logger.debug} */\n  debug(source: string, category: string, ...args: any) {\n    console.debug(`${source}.${category}`, ...args);\n  }\n\n  /** {@inheritDoc Logger.info} */\n  info(source: string, category: string, ...args: any) {\n    console.info(`${source}.${category}`, ...args);\n  }\n\n  /** {@inheritDoc Logger.warn} */\n  warn(source: string, category: string, ...args: any) {\n    console.warn(`${source}.${category}`, ...args);\n  }\n\n  /** {@inheritDoc Logger.error} */\n  error(source: string, category: string, ...args: any) {\n    console.error(`${source}.${category}`, ...args);\n  }\n\n  /** {@inheritDoc Logger.perf} */\n  perf(source: string, category: string, event: string, phase: 'Begin' | 'End', ...args: any) {\n    console.info(`${source}.${category}.${event}.${phase}`, ...args);\n  }\n}\n\n/**\n * Level of log\n *\n * @public\n */\nexport enum LogLevel {\n  Debug = 0,\n  Info,\n  Warn,\n  Error,\n}\n\n/**\n * Logger that support filtering by log level\n *\n * @public\n */\nexport class LevelLogger implements Logger {\n  /**\n   * create new LevelLogger\n   * @param logger - the original logger\n   * @param level - log level that used for filtering, all logs lower than this level will be filtered out\n   */\n  constructor(\n    private logger: Logger,\n    private level: LogLevel,\n  ) {}\n\n  /** {@inheritDoc Logger.debug} */\n  debug(source: string, category: string, ...args: any) {\n    if (this.level <= LogLevel.Debug) {\n      this.logger.debug(source, category, ...args);\n    }\n  }\n\n  /** {@inheritDoc Logger.info} */\n  info(source: string, category: string, ...args: any) {\n    if (this.level <= LogLevel.Info) {\n      this.logger.info(source, category, ...args);\n    }\n  }\n\n  /** {@inheritDoc Logger.warn} */\n  warn(source: string, category: string, ...args: any) {\n    if (this.level <= LogLevel.Warn) {\n      this.logger.warn(source, category, ...args);\n    }\n  }\n\n  /** {@inheritDoc Logger.error} */\n  error(source: string, category: string, ...args: any) {\n    if (this.level <= LogLevel.Error) {\n      this.logger.error(source, category, ...args);\n    }\n  }\n\n  /** {@inheritDoc Logger.perf} */\n  perf(source: string, category: string, event: string, phase: 'Begin' | 'End', ...args: any) {\n    this.logger.perf(source, category, event, phase, ...args);\n  }\n}\n\n/**\n * Logger for performance tracking\n *\n * @public\n */\nexport class PerfLogger implements Logger {\n  /**\n   * create new PerfLogger\n   */\n  constructor() {}\n\n  /** {@inheritDoc Logger.debug} */\n  debug(source: string, category: string, ...args: any) {}\n\n  /** {@inheritDoc Logger.info} */\n  info(source: string, category: string, ...args: any) {}\n\n  /** {@inheritDoc Logger.warn} */\n  warn(source: string, category: string, ...args: any) {}\n\n  /** {@inheritDoc Logger.error} */\n  error(source: string, category: string, ...args: any) {}\n\n  /** {@inheritDoc Logger.perf} */\n  perf(\n    source: string,\n    category: string,\n    event: string,\n    phase: 'Begin' | 'End',\n    identifier: string,\n    ...args: any\n  ) {\n    switch (phase) {\n      case 'Begin':\n        window.performance.mark(`${source}.${category}.${event}.${phase}.${identifier}`, {\n          detail: args,\n        });\n        break;\n      case 'End':\n        window.performance.mark(`${source}.${category}.${event}.${phase}.${identifier}`, {\n          detail: args,\n        });\n        window.performance.measure(\n          `${source}.${category}.${event}.Measure.${identifier}`,\n          `${source}.${category}.${event}.Begin.${identifier}`,\n          `${source}.${category}.${event}.End.${identifier}`,\n        );\n        break;\n    }\n  }\n}\n\n/**\n * Logger that will track and call child loggers\n *\n * @public\n */\nexport class AllLogger implements Logger {\n  /**\n   * create new PerfLogger\n   */\n  constructor(private loggers: Logger[]) {}\n\n  /** {@inheritDoc Logger.debug} */\n  debug(source: string, category: string, ...args: any) {\n    for (const logger of this.loggers) {\n      logger.debug(source, category, ...args);\n    }\n  }\n\n  /** {@inheritDoc Logger.info} */\n  info(source: string, category: string, ...args: any) {\n    for (const logger of this.loggers) {\n      logger.info(source, category, ...args);\n    }\n  }\n\n  /** {@inheritDoc Logger.warn} */\n  warn(source: string, category: string, ...args: any) {\n    for (const logger of this.loggers) {\n      logger.warn(source, category, ...args);\n    }\n  }\n\n  /** {@inheritDoc Logger.error} */\n  error(source: string, category: string, ...args: any) {\n    for (const logger of this.loggers) {\n      logger.error(source, category, ...args);\n    }\n  }\n\n  /** {@inheritDoc Logger.perf} */\n  perf(source: string, category: string, event: string, phase: 'Begin' | 'End', ...args: any) {\n    for (const logger of this.loggers) {\n      logger.perf(source, category, event, phase, ...args);\n    }\n  }\n}\n","/**\n * Stage of task\n *\n * @public\n */\nexport enum TaskStage {\n  /**\n   * Task is pending, means it just start executing\n   */\n  Pending = 0,\n  /**\n   * Task is succeed\n   */\n  Resolved = 1,\n  /**\n   * Task is failed\n   */\n  Rejected = 2,\n  /**\n   * Task is aborted\n   */\n  Aborted = 3,\n}\n\nexport interface TaskError<D> {\n  /**\n   * task error type\n   */\n  type: 'reject' | 'abort';\n  /**\n   * task error\n   */\n  reason: D;\n}\n\n/**\n * callback that will be called when task is resolved\n *\n * @public\n */\nexport type ResolvedCallback<R> = (r: R) => void;\n\n/**\n * callback that will be called when task is rejected\n *\n * @public\n */\nexport type RejectedCallback<D> = (e: TaskError<D>) => void;\n\n/**\n * Task state in different stage\n *\n * @public\n */\nexport type TaskState<R, D> =\n  | {\n      stage: TaskStage.Pending;\n    }\n  | {\n      stage: TaskStage.Resolved;\n      result: R;\n    }\n  | {\n      stage: TaskStage.Rejected;\n      reason: D;\n    }\n  | {\n      stage: TaskStage.Aborted;\n      reason: D;\n    };\n\n/**\n * Result type for allSettled\n *\n * @public\n */\nexport type TaskSettledResult<R, D> =\n  | { status: 'resolved'; value: R }\n  | { status: 'rejected'; reason: D }\n  | { status: 'aborted'; reason: D };\n\nexport class TaskAbortedError<D> extends Error {\n  constructor(reason: D) {\n    super(`Task aborted: ${JSON.stringify(reason)}`);\n    this.name = 'TaskAbortedError';\n  }\n}\n\nexport class TaskRejectedError<D> extends Error {\n  constructor(reason: D) {\n    super(`Task rejected: ${JSON.stringify(reason)}`);\n    this.name = 'TaskRejectedError';\n  }\n}\n\n/**\n * Base class of task\n *\n * @public\n */\nexport class Task<R, D> {\n  state: TaskState<R, D> = {\n    stage: TaskStage.Pending,\n  };\n  /**\n   * callbacks that will be executed when task is resolved\n   */\n  resolvedCallbacks: ResolvedCallback<R>[] = [];\n  /**\n   * callbacks that will be executed when task is rejected\n   */\n  rejectedCallbacks: RejectedCallback<D>[] = [];\n\n  /**\n   * Promise that will be resolved when task is settled\n   */\n  private _promise: Promise<R> | null = null;\n\n  /**\n   * Convert task to promise\n   * @returns promise that will be resolved when task is settled\n   */\n  toPromise(): Promise<R> {\n    if (!this._promise) {\n      this._promise = new Promise((resolve, reject) => {\n        this.wait(\n          (result) => resolve(result),\n          (error) => {\n            if (error.type === 'abort') {\n              reject(new TaskAbortedError(error.reason));\n            } else {\n              reject(new TaskRejectedError(error.reason));\n            }\n          },\n        );\n      });\n    }\n    return this._promise;\n  }\n\n  /**\n   * wait for task to be settled\n   * @param resolvedCallback - callback for resolved value\n   * @param rejectedCallback - callback for rejected value\n   */\n  wait(resolvedCallback: ResolvedCallback<R>, rejectedCallback: RejectedCallback<D>) {\n    switch (this.state.stage) {\n      case TaskStage.Pending:\n        this.resolvedCallbacks.push(resolvedCallback);\n        this.rejectedCallbacks.push(rejectedCallback);\n        break;\n      case TaskStage.Resolved:\n        resolvedCallback(this.state.result);\n        break;\n      case TaskStage.Rejected:\n        rejectedCallback({\n          type: 'reject',\n          reason: this.state.reason,\n        });\n        break;\n      case TaskStage.Aborted:\n        rejectedCallback({\n          type: 'abort',\n          reason: this.state.reason,\n        });\n        break;\n    }\n  }\n\n  /**\n   * resolve task with specific result\n   * @param result - result value\n   */\n  resolve(result: R) {\n    if (this.state.stage === TaskStage.Pending) {\n      this.state = {\n        stage: TaskStage.Resolved,\n        result,\n      };\n      for (const resolvedCallback of this.resolvedCallbacks) {\n        try {\n          resolvedCallback(result);\n        } catch (e) {\n          /* ignore */\n        }\n      }\n      this.resolvedCallbacks = [];\n      this.rejectedCallbacks = [];\n    }\n  }\n\n  /**\n   * reject task with specific reason\n   * @param reason - abort reason\n   *\n   */\n  reject(reason: D) {\n    if (this.state.stage === TaskStage.Pending) {\n      this.state = {\n        stage: TaskStage.Rejected,\n        reason,\n      };\n      for (const rejectedCallback of this.rejectedCallbacks) {\n        try {\n          rejectedCallback({\n            type: 'reject',\n            reason,\n          });\n        } catch (e) {\n          /*ignore */\n        }\n      }\n      this.resolvedCallbacks = [];\n      this.rejectedCallbacks = [];\n    }\n  }\n\n  /**\n   * abort task with specific reason\n   * @param reason - abort reason\n   */\n  abort(reason: D) {\n    if (this.state.stage === TaskStage.Pending) {\n      this.state = {\n        stage: TaskStage.Aborted,\n        reason,\n      };\n      for (const rejectedCallback of this.rejectedCallbacks) {\n        try {\n          rejectedCallback({\n            type: 'abort',\n            reason,\n          });\n        } catch (e) {\n          /* ignore */\n        }\n      }\n      this.resolvedCallbacks = [];\n      this.rejectedCallbacks = [];\n    }\n  }\n\n  /**\n   * fail task with a TaskError from another task\n   * This is a convenience method for error propagation between tasks\n   * @param error - TaskError from another task\n   */\n  fail(error: TaskError<D>) {\n    if (error.type === 'abort') {\n      this.abort(error.reason);\n    } else {\n      this.reject(error.reason);\n    }\n  }\n\n  /**\n   * Static method to wait for all tasks to resolve\n   * Returns a new task that resolves with an array of all results\n   * Rejects immediately if any task fails\n   *\n   * @param tasks - array of tasks to wait for\n   * @returns new task that resolves when all input tasks resolve\n   * @public\n   */\n  static all<R extends readonly Task<any, any>[]>(\n    tasks: R,\n  ): Task<{ [K in keyof R]: R[K] extends Task<infer U, any> ? U : never }, any> {\n    type ResultType = { [K in keyof R]: R[K] extends Task<infer U, any> ? U : never };\n\n    const combinedTask = new Task<ResultType, any>();\n\n    if (tasks.length === 0) {\n      combinedTask.resolve([] as any);\n      return combinedTask;\n    }\n\n    const results: any[] = new Array(tasks.length);\n    let resolvedCount = 0;\n    let isSettled = false;\n\n    tasks.forEach((task, index) => {\n      task.wait(\n        (result) => {\n          if (isSettled) return;\n\n          results[index] = result;\n          resolvedCount++;\n\n          if (resolvedCount === tasks.length) {\n            isSettled = true;\n            combinedTask.resolve(results as ResultType);\n          }\n        },\n        (error) => {\n          if (isSettled) return;\n\n          isSettled = true;\n          if (error.type === 'abort') {\n            combinedTask.abort(error.reason);\n          } else {\n            combinedTask.reject(error.reason);\n          }\n        },\n      );\n    });\n\n    return combinedTask;\n  }\n\n  /**\n   * Static method to wait for all tasks to settle (resolve, reject, or abort)\n   * Always resolves with an array of settlement results\n   *\n   * @param tasks - array of tasks to wait for\n   * @returns new task that resolves when all input tasks settle\n   * @public\n   */\n  static allSettled<R extends readonly Task<any, any>[]>(\n    tasks: R,\n  ): Task<\n    { [K in keyof R]: R[K] extends Task<infer U, infer E> ? TaskSettledResult<U, E> : never },\n    never\n  > {\n    type ResultType = {\n      [K in keyof R]: R[K] extends Task<infer U, infer E> ? TaskSettledResult<U, E> : never;\n    };\n\n    const combinedTask = new Task<ResultType, never>();\n\n    if (tasks.length === 0) {\n      combinedTask.resolve([] as any);\n      return combinedTask;\n    }\n\n    const results: any[] = new Array(tasks.length);\n    let settledCount = 0;\n\n    tasks.forEach((task, index) => {\n      task.wait(\n        (result) => {\n          results[index] = { status: 'resolved', value: result };\n          settledCount++;\n\n          if (settledCount === tasks.length) {\n            combinedTask.resolve(results as ResultType);\n          }\n        },\n        (error) => {\n          results[index] = {\n            status: error.type === 'abort' ? 'aborted' : 'rejected',\n            reason: error.reason,\n          };\n          settledCount++;\n\n          if (settledCount === tasks.length) {\n            combinedTask.resolve(results as ResultType);\n          }\n        },\n      );\n    });\n\n    return combinedTask;\n  }\n\n  /**\n   * Static method that resolves/rejects with the first task that settles\n   *\n   * @param tasks - array of tasks to race\n   * @returns new task that settles with the first input task that settles\n   * @public\n   */\n  static race<R extends readonly Task<any, any>[]>(\n    tasks: R,\n  ): Task<\n    R[number] extends Task<infer U, any> ? U : never,\n    R[number] extends Task<any, infer E> ? E : never\n  > {\n    type ResultType = R[number] extends Task<infer U, any> ? U : never;\n    type ErrorType = R[number] extends Task<any, infer E> ? E : never;\n\n    const combinedTask = new Task<ResultType, ErrorType>();\n\n    if (tasks.length === 0) {\n      combinedTask.reject('No tasks provided' as ErrorType);\n      return combinedTask;\n    }\n\n    let isSettled = false;\n\n    tasks.forEach((task) => {\n      task.wait(\n        (result) => {\n          if (isSettled) return;\n          isSettled = true;\n          combinedTask.resolve(result);\n        },\n        (error) => {\n          if (isSettled) return;\n          isSettled = true;\n          if (error.type === 'abort') {\n            combinedTask.abort(error.reason);\n          } else {\n            combinedTask.reject(error.reason);\n          }\n        },\n      );\n    });\n\n    return combinedTask;\n  }\n\n  /**\n   * Utility to track progress of multiple tasks\n   *\n   * @param tasks - array of tasks to track\n   * @param onProgress - callback called when any task completes\n   * @returns new task that resolves when all input tasks resolve\n   * @public\n   */\n  static withProgress<R extends readonly Task<any, any>[]>(\n    tasks: R,\n    onProgress?: (completed: number, total: number) => void,\n  ): Task<{ [K in keyof R]: R[K] extends Task<infer U, any> ? U : never }, any> {\n    const combinedTask = Task.all(tasks);\n\n    if (onProgress) {\n      let completedCount = 0;\n      tasks.forEach((task) => {\n        task.wait(\n          () => {\n            completedCount++;\n            onProgress(completedCount, tasks.length);\n          },\n          () => {\n            completedCount++;\n            onProgress(completedCount, tasks.length);\n          },\n        );\n      });\n    }\n\n    return combinedTask;\n  }\n}\n\n/**\n * Type that represent the result of executing task\n */\nexport type TaskReturn<T extends Task<any, any>> =\n  T extends Task<infer R, infer E>\n    ? { type: 'result'; value: R } | { type: 'error'; value: TaskError<E> }\n    : never;\n","import { WebAlphaColor } from './color';\nimport { Size, Rect, Position, Rotation, Quad } from './geometry';\nimport { Task, TaskError } from './task';\n\n/**\n * Representation of pdf page\n *\n * @public\n */\nexport interface PdfPageObject {\n  /**\n   * Index of this page, starts from 0\n   */\n  index: number;\n\n  /**\n   * Orignal size of this page\n   */\n  size: Size;\n}\n\n/**\n * Representation of pdf page with rotated size\n *\n * @public\n */\nexport interface PdfPageObjectWithRotatedSize extends PdfPageObject {\n  /**\n   * Rotated size of this page\n   */\n  rotatedSize: Size;\n}\n\n/**\n * Representation of pdf document\n *\n * @public\n */\nexport interface PdfDocumentObject {\n  /**\n   * Identity of document\n   */\n  id: string;\n\n  /**\n   * Count of pages in this document\n   */\n  pageCount: number;\n\n  /**\n   * Pages in this document\n   */\n  pages: PdfPageObject[];\n}\n\n/**\n * metadata of pdf document\n *\n * @public\n */\nexport interface PdfMetadataObject {\n  /**\n   * title of the document\n   */\n  title: string;\n  /**\n   * author of the document\n   */\n  author: string;\n  /**\n   * subject of the document\n   */\n  subject: string;\n  /**\n   * keywords of the document\n   */\n  keywords: string;\n  /**\n   * producer of the document\n   */\n  producer: string;\n  /**\n   * creator of the document\n   */\n  creator: string;\n  /**\n   * creation date of the document\n   */\n  creationDate: string;\n  /**\n   * modification date of the document\n   */\n  modificationDate: string;\n}\n\n/**\n * Unicode **soft-hyphen** marker (`U+00AD`).\n * Often embedded by PDF generators as discretionary hyphens.\n *\n * @public\n */\nexport const PdfSoftHyphenMarker = '\\u00AD';\n\n/**\n * Unicode **zero-width space** (`U+200B`).\n *\n * @public\n */\nexport const PdfZeroWidthSpace = '\\u200B';\n\n/**\n * Unicode **word-joiner** (`U+2060`) – zero-width no-break.\n *\n * @public\n */\nexport const PdfWordJoiner = '\\u2060';\n\n/**\n * Unicode **byte-order mark / zero-width&nbsp;no-break space** (`U+FEFF`).\n *\n * @public\n */\nexport const PdfBomOrZwnbsp = '\\uFEFF';\n\n/**\n * Unicode non-character `U+FFFE`.\n *\n * @public\n */\nexport const PdfNonCharacterFFFE = '\\uFFFE';\n\n/**\n * Unicode non-character `U+FFFF`.\n *\n * @public\n */\nexport const PdfNonCharacterFFFF = '\\uFFFF';\n\n/**\n * **Frozen list** of all unwanted markers in canonical order.\n *\n * @public\n */\nexport const PdfUnwantedTextMarkers = Object.freeze([\n  PdfSoftHyphenMarker,\n  PdfZeroWidthSpace,\n  PdfWordJoiner,\n  PdfBomOrZwnbsp,\n  PdfNonCharacterFFFE,\n  PdfNonCharacterFFFF,\n] as const);\n\n/**\n * Compiled regular expression that matches any unwanted marker.\n *\n * @public\n */\nexport const PdfUnwantedTextRegex = new RegExp(`[${PdfUnwantedTextMarkers.join('')}]`, 'g');\n\n/**\n * Remove all {@link PdfUnwantedTextMarkers | unwanted markers} from *text*.\n *\n * @param text - raw text extracted from PDF\n * @returns cleaned text\n *\n * @public\n */\nexport function stripPdfUnwantedMarkers(text: string): string {\n  return text.replace(PdfUnwantedTextRegex, '');\n}\n\n/**\n * zoom mode\n *\n * @public\n */\nexport enum PdfZoomMode {\n  Unknown = 0,\n  /**\n   * Zoom level with specified offset.\n   */\n  XYZ = 1,\n  /**\n   * Fit both the width and height of the page (whichever smaller).\n   */\n  FitPage = 2,\n  /**\n   * Fit the page width.\n   */\n  FitHorizontal = 3,\n  /**\n   * Fit the page height.\n   */\n  FitVertical = 4,\n  /**\n   * Fit a specific rectangle area within the window.\n   */\n  FitRectangle = 5,\n}\n\n/**\n * Blend mode\n *\n * @public\n */\nexport enum PdfBlendMode {\n  Normal = 0,\n  Multiply = 1,\n  Screen = 2,\n  Overlay = 3,\n  Darken = 4,\n  Lighten = 5,\n  ColorDodge = 6,\n  ColorBurn = 7,\n  HardLight = 8,\n  SoftLight = 9,\n  Difference = 10,\n  Exclusion = 11,\n  Hue = 12,\n  Saturation = 13,\n  Color = 14,\n  Luminosity = 15,\n}\n\n/** Extra UI sentinel for “multiple different values selected”. */\nexport const MixedBlendMode = Symbol('mixed');\nexport type UiBlendModeValue = PdfBlendMode | typeof MixedBlendMode;\n\ninterface BlendModeInfo {\n  /** Pdf enum value */\n  id: PdfBlendMode;\n  /** Human label for UI */\n  label: string;\n  /** CSS mix-blend-mode token */\n  css: string;\n}\n\n/** Canonical ordered descriptor list (matches enum numeric order). */\nconst BLEND_MODE_INFOS: readonly BlendModeInfo[] = Object.freeze([\n  { id: PdfBlendMode.Normal, label: 'Normal', css: 'normal' },\n  { id: PdfBlendMode.Multiply, label: 'Multiply', css: 'multiply' },\n  { id: PdfBlendMode.Screen, label: 'Screen', css: 'screen' },\n  { id: PdfBlendMode.Overlay, label: 'Overlay', css: 'overlay' },\n  { id: PdfBlendMode.Darken, label: 'Darken', css: 'darken' },\n  { id: PdfBlendMode.Lighten, label: 'Lighten', css: 'lighten' },\n  { id: PdfBlendMode.ColorDodge, label: 'Color Dodge', css: 'color-dodge' },\n  { id: PdfBlendMode.ColorBurn, label: 'Color Burn', css: 'color-burn' },\n  { id: PdfBlendMode.HardLight, label: 'Hard Light', css: 'hard-light' },\n  { id: PdfBlendMode.SoftLight, label: 'Soft Light', css: 'soft-light' },\n  { id: PdfBlendMode.Difference, label: 'Difference', css: 'difference' },\n  { id: PdfBlendMode.Exclusion, label: 'Exclusion', css: 'exclusion' },\n  { id: PdfBlendMode.Hue, label: 'Hue', css: 'hue' },\n  { id: PdfBlendMode.Saturation, label: 'Saturation', css: 'saturation' },\n  { id: PdfBlendMode.Color, label: 'Color', css: 'color' },\n  { id: PdfBlendMode.Luminosity, label: 'Luminosity', css: 'luminosity' },\n]);\n\n/* Build O(1) maps once */\nconst enumToInfo: Record<PdfBlendMode, BlendModeInfo> = BLEND_MODE_INFOS.reduce(\n  (m, info) => {\n    m[info.id] = info;\n    return m;\n  },\n  {} as Record<PdfBlendMode, BlendModeInfo>,\n);\n\nconst cssToEnum = BLEND_MODE_INFOS.reduce<Record<string, PdfBlendMode>>((m, info) => {\n  m[info.css] = info.id;\n  return m;\n}, {});\n\n/** Get descriptor (falls back to Normal if unknown number sneaks in).\n *\n * @public\n */\nexport function getBlendModeInfo(mode: PdfBlendMode): BlendModeInfo {\n  return enumToInfo[mode] ?? enumToInfo[PdfBlendMode.Normal];\n}\n\n/** Convert enum → CSS value for `mix-blend-mode`.\n *\n * @public\n */\nexport function blendModeToCss(mode: PdfBlendMode): string {\n  return getBlendModeInfo(mode).css;\n}\n\n/** Convert CSS token → enum (returns undefined if not recognized).\n *\n * @public\n */\nexport function cssToBlendMode(value: string): PdfBlendMode | undefined {\n  return cssToEnum[value as keyof typeof cssToEnum];\n}\n\n/** Enum → UI label.\n *\n * @public\n */\nexport function blendModeLabel(mode: PdfBlendMode): string {\n  return getBlendModeInfo(mode).label;\n}\n\n/**\n * For a selection of annotations: returns the common enum value, or Mixed sentinel.\n *\n * @public\n */\nexport function reduceBlendModes(modes: readonly PdfBlendMode[]): UiBlendModeValue {\n  if (!modes.length) return PdfBlendMode.Normal;\n  const first = modes[0];\n  return modes.every((m) => m === first) ? first : MixedBlendMode;\n}\n\n/** Options for a <select>.\n *\n * @public\n */\nexport const blendModeSelectOptions = BLEND_MODE_INFOS.map((info) => ({\n  value: info.id,\n  label: info.label,\n}));\n\n/** Provide a label when Mixed sentinel used (UI convenience).\n *\n * @public\n */\nexport function uiBlendModeDisplay(value: UiBlendModeValue): string {\n  return value === MixedBlendMode ? '(mixed)' : blendModeLabel(value);\n}\n\n/**\n * Representation of the linked destination\n *\n * @public\n */\nexport interface PdfDestinationObject {\n  /**\n   * Index of target page\n   */\n  pageIndex: number;\n  /**\n   * zoom config for target destination\n   */\n  zoom:\n    | {\n        mode: PdfZoomMode.Unknown;\n      }\n    | { mode: PdfZoomMode.XYZ; params: { x: number; y: number; zoom: number } }\n    | {\n        mode: PdfZoomMode.FitPage;\n      }\n    | {\n        mode: PdfZoomMode.FitHorizontal;\n      }\n    | {\n        mode: PdfZoomMode.FitVertical;\n      }\n    | {\n        mode: PdfZoomMode.FitRectangle;\n      };\n  view: number[];\n}\n\n/**\n * Type of pdf action\n *\n * @public\n */\nexport enum PdfActionType {\n  Unsupported = 0,\n  /**\n   * Goto specified position in this document\n   */\n  Goto = 1,\n  /**\n   * Goto specified position in another document\n   */\n  RemoteGoto = 2,\n  /**\n   * Goto specified URI\n   */\n  URI = 3,\n  /**\n   * Launch specifed application\n   */\n  LaunchAppOrOpenFile = 4,\n}\n\nexport type PdfImage = {\n  data: Uint8ClampedArray;\n  width: number;\n  height: number;\n};\n\n/**\n * Representation of pdf action\n *\n * @public\n */\nexport type PdfActionObject =\n  | {\n      type: PdfActionType.Unsupported;\n    }\n  | {\n      type: PdfActionType.Goto;\n      destination: PdfDestinationObject;\n    }\n  | {\n      type: PdfActionType.RemoteGoto;\n      destination: PdfDestinationObject;\n    }\n  | {\n      type: PdfActionType.URI;\n      uri: string;\n    }\n  | {\n      type: PdfActionType.LaunchAppOrOpenFile;\n      path: string;\n    };\n\n/**\n * target of pdf link\n *\n * @public\n */\nexport type PdfLinkTarget =\n  | {\n      type: 'action';\n      action: PdfActionObject;\n    }\n  | {\n      type: 'destination';\n      destination: PdfDestinationObject;\n    };\n\n/**\n * PDF bookmark\n *\n * @public\n */\nexport interface PdfBookmarkObject {\n  /**\n   * title of bookmark\n   */\n  title: string;\n\n  /**\n   * target of bookmark\n   */\n  target?: PdfLinkTarget | undefined;\n\n  /**\n   * bookmarks in the next level\n   */\n  children?: PdfBookmarkObject[];\n}\n\n/**\n * Pdf Signature\n *\n * @public\n */\nexport interface PdfSignatureObject {\n  /**\n   * contents of signature\n   */\n  contents: ArrayBuffer;\n\n  /**\n   * byte range of signature\n   */\n  byteRange: ArrayBuffer;\n\n  /**\n   * sub filters of signature\n   */\n  subFilter: ArrayBuffer;\n\n  /**\n   * reason of signature\n   */\n  reason: string;\n\n  /**\n   * creation time of signature\n   */\n  time: string;\n\n  /**\n   * MDP\n   */\n  docMDP: number;\n}\n\n/**\n * Bookmark tree of pdf\n *\n * @public\n */\nexport interface PdfBookmarksObject {\n  bookmarks: PdfBookmarkObject[];\n}\n\n/**\n * Text rectangle in pdf page\n *\n * @public\n */\nexport interface PdfTextRectObject {\n  /**\n   * Font of the text\n   */\n  font: {\n    /**\n     * font family\n     */\n    family: string;\n\n    /**\n     * font size\n     */\n    size: number;\n  };\n\n  /**\n   * content in this rectangle area\n   */\n  content: string;\n\n  /**\n   * rectangle of the text\n   */\n  rect: Rect;\n}\n\n/**\n * Color\n *\n * @public\n */\nexport interface PdfAlphaColor {\n  /**\n   * red\n   */\n  red: number;\n  /**\n   * green\n   */\n  green: number;\n  /**\n   * blue\n   */\n  blue: number;\n  /**\n   * alpha\n   */\n  alpha: number;\n}\n\n/**\n * Annotation type\n *\n * @public\n */\nexport enum PdfAnnotationSubtype {\n  UNKNOWN = 0,\n  TEXT,\n  LINK,\n  FREETEXT,\n  LINE,\n  SQUARE,\n  CIRCLE,\n  POLYGON,\n  POLYLINE,\n  HIGHLIGHT,\n  UNDERLINE,\n  SQUIGGLY,\n  STRIKEOUT,\n  STAMP,\n  CARET,\n  INK,\n  POPUP,\n  FILEATTACHMENT,\n  SOUND,\n  MOVIE,\n  WIDGET,\n  SCREEN,\n  PRINTERMARK,\n  TRAPNET,\n  WATERMARK,\n  THREED,\n  RICHMEDIA,\n  XFAWIDGET,\n  REDACT,\n}\n\n/**\n * Name of annotation type\n *\n * @public\n */\nexport const PdfAnnotationSubtypeName: Record<PdfAnnotationSubtype, string> = {\n  [PdfAnnotationSubtype.UNKNOWN]: 'unknow',\n  [PdfAnnotationSubtype.TEXT]: 'text',\n  [PdfAnnotationSubtype.LINK]: 'link',\n  [PdfAnnotationSubtype.FREETEXT]: 'freetext',\n  [PdfAnnotationSubtype.LINE]: 'line',\n  [PdfAnnotationSubtype.SQUARE]: 'square',\n  [PdfAnnotationSubtype.CIRCLE]: 'circle',\n  [PdfAnnotationSubtype.POLYGON]: 'polygon',\n  [PdfAnnotationSubtype.POLYLINE]: 'polyline',\n  [PdfAnnotationSubtype.HIGHLIGHT]: 'highlight',\n  [PdfAnnotationSubtype.UNDERLINE]: 'underline',\n  [PdfAnnotationSubtype.SQUIGGLY]: 'squiggly',\n  [PdfAnnotationSubtype.STRIKEOUT]: 'strikeout',\n  [PdfAnnotationSubtype.STAMP]: 'stamp',\n  [PdfAnnotationSubtype.CARET]: 'caret',\n  [PdfAnnotationSubtype.INK]: 'ink',\n  [PdfAnnotationSubtype.POPUP]: 'popup',\n  [PdfAnnotationSubtype.FILEATTACHMENT]: 'fileattachment',\n  [PdfAnnotationSubtype.SOUND]: 'sound',\n  [PdfAnnotationSubtype.MOVIE]: 'movie',\n  [PdfAnnotationSubtype.WIDGET]: 'widget',\n  [PdfAnnotationSubtype.SCREEN]: 'screen',\n  [PdfAnnotationSubtype.PRINTERMARK]: 'printermark',\n  [PdfAnnotationSubtype.TRAPNET]: 'trapnet',\n  [PdfAnnotationSubtype.WATERMARK]: 'watermark',\n  [PdfAnnotationSubtype.THREED]: 'threed',\n  [PdfAnnotationSubtype.RICHMEDIA]: 'richmedia',\n  [PdfAnnotationSubtype.XFAWIDGET]: 'xfawidget',\n  [PdfAnnotationSubtype.REDACT]: 'redact',\n};\n\n/**\n * Status of pdf annotation\n *\n * @public\n */\nexport enum PdfAnnotationObjectStatus {\n  /**\n   * Annotation is created\n   */\n  Created,\n  /**\n   * Annotation is committed to PDF file\n   */\n  Committed,\n}\n\n/**\n * Appearance mode\n *\n * @public\n */\nexport enum AppearanceMode {\n  Normal = 0,\n  Rollover = 1,\n  Down = 2,\n}\n\n/**\n * State of pdf annotation\n *\n * @public\n */\nexport enum PdfAnnotationState {\n  /**\n   * Annotation is active\n   */\n  Marked = 'Marked',\n  /**\n   * Annotation is unmarked\n   */\n  Unmarked = 'Unmarked',\n  /**\n   * Annotation is ink\n   */\n  Accepted = 'Accepted',\n  /**\n   * Annotation is rejected\n   */\n  Rejected = 'Rejected',\n  /**\n   * Annotation is complete\n   */\n  Complete = 'Complete',\n  /**\n   * Annotation is cancelled\n   */\n  Cancelled = 'Cancelled',\n  /**\n   * Annotation is none\n   */\n  None = 'None',\n}\n\n/**\n * State model of pdf annotation\n *\n * @public\n */\nexport enum PdfAnnotationStateModel {\n  /**\n   * Annotation is marked\n   */\n  Marked = 'Marked',\n  /**\n   * Annotation is reviewed\n   */\n  Reviewed = 'Reviewed',\n}\n\n/**\n * Basic information of pdf annotation\n *\n * @public\n */\nexport interface PdfAnnotationObjectBase {\n  /**\n   * Author of the annotation\n   */\n  author?: string;\n\n  /**\n   * Modified date of the annotation\n   */\n  modified?: Date;\n\n  /**\n   * blend mode of annotation\n   */\n  blendMode?: PdfBlendMode;\n\n  /**\n   * intent of annotation\n   */\n  intent?: string;\n\n  /**\n   * Sub type of annotation\n   */\n  type: PdfAnnotationSubtype;\n\n  /**\n   * The index of page that this annotation belong to\n   */\n  pageIndex: number;\n\n  /**\n   * id of the annotation\n   */\n  id: number;\n\n  /**\n   * Rectangle of the annotation\n   */\n  rect: Rect;\n}\n\n/**\n * Popup annotation\n *\n * @public\n */\nexport interface PdfPopupAnnoObject extends PdfAnnotationObjectBase {\n  /** {@inheritDoc PdfAnnotationObjectBase.type} */\n  type: PdfAnnotationSubtype.POPUP;\n  /**\n   * Contents of the popup\n   */\n  contents: string;\n\n  /**\n   * Whether the popup is opened or not\n   */\n  open: boolean;\n\n  /**\n   * In reply to id\n   */\n  inReplyToId?: number;\n}\n\n/**\n * Pdf Link annotation\n *\n * @public\n */\nexport interface PdfLinkAnnoObject extends PdfAnnotationObjectBase {\n  /** {@inheritDoc PdfAnnotationObjectBase.type} */\n  type: PdfAnnotationSubtype.LINK;\n  /**\n   * Text of the link\n   */\n  text: string;\n  /**\n   * target of the link\n   */\n  target: PdfLinkTarget | undefined;\n}\n\n/**\n * Pdf Text annotation\n *\n * @public\n */\nexport interface PdfTextAnnoObject extends PdfAnnotationObjectBase {\n  /** {@inheritDoc PdfAnnotationObjectBase.type} */\n  type: PdfAnnotationSubtype.TEXT;\n  /**\n   * Text contents of the annotation\n   */\n  contents: string;\n\n  /**\n   * color of text annotation\n   */\n  color?: string;\n\n  /**\n   * opacity of text annotation\n   */\n  opacity?: number;\n\n  /**\n   * In reply to id\n   */\n  inReplyToId?: number;\n\n  /**\n   * State of the text annotation\n   */\n  state?: PdfAnnotationState;\n\n  /**\n   * State model of the text annotation\n   */\n  stateModel?: PdfAnnotationStateModel;\n}\n\n/**\n * Type of form field\n *\n * @public\n */\nexport enum PDF_FORM_FIELD_TYPE {\n  /**\n   * Unknow\n   */\n  UNKNOWN = 0,\n  /**\n   * push button type\n   */\n  PUSHBUTTON = 1,\n  /**\n   * check box type.\n   */\n  CHECKBOX = 2,\n  /**\n   * radio button type.\n   */\n  RADIOBUTTON = 3,\n  /**\n   * combo box type.\n   */\n  COMBOBOX = 4,\n  /**\n   * list box type.\n   */\n  LISTBOX = 5,\n  /**\n   *  text field type\n   */\n  TEXTFIELD = 6,\n  /**\n   * signature field type.\n   */\n  SIGNATURE = 7,\n  /**\n   * Generic XFA type.\n   */\n  XFA = 8,\n  /**\n   * XFA check box type.\n   */\n  XFA_CHECKBOX = 9,\n  /**\n   * XFA combo box type.\n   */\n  XFA_COMBOBOX = 10,\n  /**\n   * XFA image field type.\n   */\n  XFA_IMAGEFIELD = 11,\n  /**\n   * XFA list box type.\n   */\n  XFA_LISTBOX = 12,\n  /**\n   * XFA push button type.\n   */\n  XFA_PUSHBUTTON = 13,\n  /**\n   * XFA signture field type.\n   */\n  XFA_SIGNATURE = 14,\n  /**\n   * XFA text field type.\n   */\n  XFA_TEXTFIELD = 15,\n}\n\nexport enum PdfAnnotationColorType {\n  Color = 0,\n  InteriorColor = 1,\n}\n\n/**\n * Border style of pdf annotation\n *\n * @public\n */\nexport enum PdfAnnotationBorderStyle {\n  UNKNOWN = 0,\n  SOLID = 1,\n  DASHED = 2,\n  BEVELED = 3,\n  INSET = 4,\n  UNDERLINE = 5,\n  CLOUDY = 6,\n}\n\n/**\n * Flag of pdf annotation\n *\n * @public\n */\nexport enum PdfAnnotationFlags {\n  NONE = 0,\n  INVISIBLE = 1 << 0,\n  HIDDEN = 1 << 1,\n  PRINT = 1 << 2,\n  NO_ZOOM = 1 << 3,\n  NO_ROTATE = 1 << 4,\n  NO_VIEW = 1 << 5,\n  READ_ONLY = 1 << 6,\n  LOCKED = 1 << 7,\n  TOGGLE_NOVIEW = 1 << 8,\n}\n\n/**\n * Flag of form field\n *\n * @public\n */\nexport enum PDF_FORM_FIELD_FLAG {\n  NONE = 0,\n  READONLY = 1 << 0,\n  REQUIRED = 1 << 1,\n  NOEXPORT = 1 << 2,\n  TEXT_MULTIPLINE = 1 << 12,\n  TEXT_PASSWORD = 1 << 13,\n  CHOICE_COMBO = 1 << 17,\n  CHOICE_EDIT = 1 << 18,\n  CHOICE_MULTL_SELECT = 1 << 21,\n}\n\n/**\n * Type of pdf object\n *\n * @public\n */\nexport enum PdfPageObjectType {\n  UNKNOWN = 0,\n  TEXT = 1,\n  PATH = 2,\n  IMAGE = 3,\n  SHADING = 4,\n  FORM = 5,\n}\n\n/**\n * Options of pdf widget annotation\n *\n * @public\n */\nexport interface PdfWidgetAnnoOption {\n  label: string;\n  isSelected: boolean;\n}\n\nexport type PdfAnnotationFlagName =\n  | 'invisible'\n  | 'hidden'\n  | 'print'\n  | 'noZoom'\n  | 'noRotate'\n  | 'noView'\n  | 'readOnly'\n  | 'locked'\n  | 'toggleNoView';\n\ntype FlagMap = Partial<\n  Record<Exclude<PdfAnnotationFlags, PdfAnnotationFlags.NONE>, PdfAnnotationFlagName>\n>;\n\nexport const PdfAnnotationFlagName: Readonly<FlagMap> = Object.freeze({\n  [PdfAnnotationFlags.INVISIBLE]: 'invisible',\n  [PdfAnnotationFlags.HIDDEN]: 'hidden',\n  [PdfAnnotationFlags.PRINT]: 'print',\n  [PdfAnnotationFlags.NO_ZOOM]: 'noZoom',\n  [PdfAnnotationFlags.NO_ROTATE]: 'noRotate',\n  [PdfAnnotationFlags.NO_VIEW]: 'noView',\n  [PdfAnnotationFlags.READ_ONLY]: 'readOnly',\n  [PdfAnnotationFlags.LOCKED]: 'locked',\n  [PdfAnnotationFlags.TOGGLE_NOVIEW]: 'toggleNoView',\n} as const);\n\n/** Build a reverse map once so look-ups are O(1)                      */\nconst PdfAnnotationFlagValue: Record<PdfAnnotationFlagName, PdfAnnotationFlags> = Object.entries(\n  PdfAnnotationFlagName,\n).reduce(\n  (acc, [bit, name]) => {\n    acc[name as PdfAnnotationFlagName] = Number(bit) as PdfAnnotationFlags;\n    return acc;\n  },\n  {} as Record<PdfAnnotationFlagName, PdfAnnotationFlags>,\n);\n\n/**\n * Convert the raw bit-mask coming from `FPDFAnnot_GetFlags()` into\n * an array of human-readable flag names (“invisible”, “print”…).\n */\nexport function flagsToNames(raw: number): PdfAnnotationFlagName[] {\n  return (\n    Object.keys(PdfAnnotationFlagName) as unknown as Exclude<\n      PdfAnnotationFlags,\n      PdfAnnotationFlags.NONE\n    >[]\n  )\n    .filter((flag) => (raw & flag) !== 0)\n    .map((flag) => PdfAnnotationFlagName[flag]!);\n}\n\n/**\n * Convert an array of flag-names back into the numeric mask that\n * PDFium expects for `FPDFAnnot_SetFlags()`.\n */\nexport function namesToFlags(names: readonly PdfAnnotationFlagName[]): PdfAnnotationFlags {\n  return names.reduce<PdfAnnotationFlags>(\n    (mask, name) => mask | PdfAnnotationFlagValue[name],\n    PdfAnnotationFlags.NONE,\n  );\n}\n\n/**\n * Field of PDF widget annotation\n *\n * @public\n */\nexport interface PdfWidgetAnnoField {\n  /**\n   * flag of field\n   */\n  flag: PDF_FORM_FIELD_FLAG;\n  /**\n   * name of field\n   */\n  name: string;\n  /**\n   * alternate name of field\n   */\n  alternateName: string;\n  /**\n   * type of field\n   */\n  type: PDF_FORM_FIELD_TYPE;\n  /**\n   * value of field\n   */\n  value: string;\n  /**\n   * whether field is checked\n   */\n  isChecked: boolean;\n  /**\n   * options of field\n   */\n  options: PdfWidgetAnnoOption[];\n}\n\n/**\n * PDF widget object\n *\n * @public\n */\nexport interface PdfWidgetAnnoObject extends PdfAnnotationObjectBase {\n  /** {@inheritDoc PdfAnnotationObjectBase.type} */\n  type: PdfAnnotationSubtype.WIDGET;\n  /**\n   * Field of pdf widget object\n   */\n  field: PdfWidgetAnnoField;\n}\n\n/**\n * Pdf file attachments annotation\n *\n * @public\n */\nexport interface PdfFileAttachmentAnnoObject extends PdfAnnotationObjectBase {\n  /** {@inheritDoc PdfAnnotationObjectBase.type} */\n  type: PdfAnnotationSubtype.FILEATTACHMENT;\n}\n\n/**\n * ink list in pdf ink annotation\n *\n * @public\n */\nexport interface PdfInkListObject {\n  points: Position[];\n}\n\n/**\n * Pdf ink annotation\n *\n * @public\n */\nexport interface PdfInkAnnoObject extends PdfAnnotationObjectBase {\n  /** {@inheritDoc PdfAnnotationObjectBase.type} */\n  type: PdfAnnotationSubtype.INK;\n  /**\n   * ink list of annotation\n   */\n  inkList: PdfInkListObject[];\n  /**\n   * color of ink annotation\n   */\n  color: string;\n\n  /**\n   * opacity of ink annotation\n   */\n  opacity: number;\n\n  /**\n   * stroke-width of ink annotation\n   */\n  strokeWidth: number;\n}\n\n/**\n * Pdf polygon annotation\n *\n * @public\n */\nexport interface PdfPolygonAnnoObject extends PdfAnnotationObjectBase {\n  /** {@inheritDoc PdfAnnotationObjectBase.type} */\n  type: PdfAnnotationSubtype.POLYGON;\n  /**\n   * vertices of annotation\n   */\n  vertices: Position[];\n}\n\n/**\n * PDF polyline annotation\n *\n * @public\n */\nexport interface PdfPolylineAnnoObject extends PdfAnnotationObjectBase {\n  /** {@inheritDoc PdfAnnotationObjectBase.type} */\n  type: PdfAnnotationSubtype.POLYLINE;\n  /**\n   * vertices of annotation\n   */\n  vertices: Position[];\n}\n\n/**\n * PDF line annotation\n *\n * @public\n */\nexport interface PdfLineAnnoObject extends PdfAnnotationObjectBase {\n  /** {@inheritDoc PdfAnnotationObjectBase.type} */\n  type: PdfAnnotationSubtype.LINE;\n  /**\n   * start point of line\n   */\n  startPoint: Position;\n  /**\n   * end point of line\n   */\n  endPoint: Position;\n}\n\n/**\n * PDF highlight annotation\n *\n * @public\n */\nexport interface PdfHighlightAnnoObject extends PdfAnnotationObjectBase {\n  /** {@inheritDoc PdfAnnotationObjectBase.type} */\n  type: PdfAnnotationSubtype.HIGHLIGHT;\n\n  /**\n   * Text contents of the highlight annotation\n   */\n  contents?: string;\n\n  /**\n   * color of highlight annotation\n   */\n  color: string;\n\n  /**\n   * opacity of highlight annotation\n   */\n  opacity: number;\n\n  /**\n   * quads of highlight area\n   */\n  segmentRects: Rect[];\n}\n\n/**\n * Matrix for transformation, in the form [a b c d e f], equivalent to:\n * | a  b  0 |\n * | c  d  0 |\n * | e  f  1 |\n *\n * Translation is performed with [1 0 0 1 tx ty].\n * Scaling is performed with [sx 0 0 sy 0 0].\n * See PDF Reference 1.7, 4.2.2 Common Transformations for more.\n */\nexport interface PdfTransformMatrix {\n  a: number;\n  b: number;\n  c: number;\n  d: number;\n  e: number;\n  f: number;\n}\n\n/**\n * type of segment type in pdf path object\n *\n * @public\n */\nexport enum PdfSegmentObjectType {\n  UNKNOWN = -1,\n  LINETO = 0,\n  BEZIERTO = 1,\n  MOVETO = 2,\n}\n\n/**\n * segment of path object\n *\n * @public\n */\nexport interface PdfSegmentObject {\n  type: PdfSegmentObjectType;\n  /**\n   * point of the segment\n   */\n  point: Position;\n  /**\n   * whether this segment close the path\n   */\n  isClosed: boolean;\n}\n\n/**\n * Pdf path object\n *\n * @public\n */\nexport interface PdfPathObject {\n  type: PdfPageObjectType.PATH;\n  /**\n   * bound that contains the path\n   */\n  bounds: { left: number; bottom: number; right: number; top: number };\n  /**\n   * segments of the path\n   */\n  segments: PdfSegmentObject[];\n  /**\n   * transform matrix\n   */\n  matrix: PdfTransformMatrix;\n}\n\n/**\n * Pdf image object\n *\n * @public\n */\nexport interface PdfImageObject {\n  type: PdfPageObjectType.IMAGE;\n  /**\n   * data of the image\n   */\n  imageData: ImageData;\n  /**\n   * transform matrix\n   */\n  matrix: PdfTransformMatrix;\n}\n\n/**\n * Pdf form object\n *\n * @public\n */\nexport interface PdfFormObject {\n  type: PdfPageObjectType.FORM;\n  /**\n   * objects that in this form object\n   */\n  objects: (PdfImageObject | PdfPathObject | PdfFormObject)[];\n  /**\n   * transform matrix\n   */\n  matrix: PdfTransformMatrix;\n}\n\n/**\n * Contents type of pdf stamp annotation\n *\n * @public\n */\nexport type PdfStampAnnoObjectContents = Array<PdfPathObject | PdfImageObject | PdfFormObject>;\n\n/**\n * Pdf stamp annotation\n *\n * @public\n */\nexport interface PdfStampAnnoObject extends PdfAnnotationObjectBase {\n  /** {@inheritDoc PdfAnnotationObjectBase.type} */\n  type: PdfAnnotationSubtype.STAMP;\n  /**\n   * contents in this stamp annotation\n   */\n  contents: PdfStampAnnoObjectContents;\n}\n\n/**\n * Pdf circle annotation\n *\n * @public\n */\nexport interface PdfCircleAnnoObject extends PdfAnnotationObjectBase {\n  /** {@inheritDoc PdfAnnotationObjectBase.type} */\n  type: PdfAnnotationSubtype.CIRCLE;\n  /**\n   * flags of circle annotation\n   */\n  flags: PdfAnnotationFlagName[];\n  /**\n   * color of circle annotation\n   */\n  color: string;\n  /**\n   * opacity of circle annotation\n   */\n  opacity: number;\n  /**\n   * stroke-width of circle annotation\n   */\n  strokeWidth: number;\n  /**\n   * stroke color of circle annotation\n   */\n  strokeColor: string;\n  /**\n   * stroke style of circle annotation\n   */\n  strokeStyle: PdfAnnotationBorderStyle;\n  /**\n   * stroke dash array of circle annotation\n   */\n  strokeDashArray?: number[];\n  /**\n   * cloudy border intensity of circle annotation\n   */\n  cloudyBorderIntensity?: number;\n  /**\n   * cloudy border inset of circle annotation\n   */\n  cloudyBorderInset?: number[];\n}\n\n/**\n * Pdf square annotation\n *\n * @public\n */\nexport interface PdfSquareAnnoObject extends PdfAnnotationObjectBase {\n  /** {@inheritDoc PdfAnnotationObjectBase.type} */\n  type: PdfAnnotationSubtype.SQUARE;\n  /**\n   * flags of square annotation\n   */\n  flags: PdfAnnotationFlagName[];\n  /**\n   * color of square annotation\n   */\n  color: string;\n  /**\n   * opacity of square annotation\n   */\n  opacity: number;\n  /**\n   * stroke-width of square annotation\n   */\n  strokeWidth: number;\n  /**\n   * stroke color of square annotation\n   */\n  strokeColor: string;\n  /**\n   * stroke style of square annotation\n   */\n  strokeStyle: PdfAnnotationBorderStyle;\n  /**\n   * stroke dash array of square annotation\n   */\n  strokeDashArray?: number[];\n  /**\n   * cloudy border intensity of circle annotation\n   */\n  cloudyBorderIntensity?: number;\n  /**\n   * cloudy border inset of circle annotation\n   */\n  cloudyBorderInset?: number[];\n}\n\n/**\n * Pdf squiggly annotation\n *\n * @public\n */\nexport interface PdfSquigglyAnnoObject extends PdfAnnotationObjectBase {\n  /** {@inheritDoc PdfAnnotationObjectBase.type} */\n  type: PdfAnnotationSubtype.SQUIGGLY;\n  /**\n   * Text contents of the highlight annotation\n   */\n  contents?: string;\n  /**\n   * color of strike out annotation\n   */\n  color: string;\n\n  /**\n   * opacity of strike out annotation\n   */\n  opacity: number;\n  /**\n   * quads of highlight area\n   */\n  segmentRects: Rect[];\n}\n\n/**\n * Pdf underline annotation\n *\n * @public\n */\nexport interface PdfUnderlineAnnoObject extends PdfAnnotationObjectBase {\n  /** {@inheritDoc PdfAnnotationObjectBase.type} */\n  type: PdfAnnotationSubtype.UNDERLINE;\n  /**\n   * Text contents of the highlight annotation\n   */\n  contents?: string;\n  /**\n   * color of strike out annotation\n   */\n  color: string;\n\n  /**\n   * opacity of strike out annotation\n   */\n  opacity: number;\n  /**\n   * quads of highlight area\n   */\n  segmentRects: Rect[];\n}\n\n/**\n * Pdf strike out annotation\n *\n * @public\n */\nexport interface PdfStrikeOutAnnoObject extends PdfAnnotationObjectBase {\n  /** {@inheritDoc PdfAnnotationObjectBase.type} */\n  type: PdfAnnotationSubtype.STRIKEOUT;\n  /**\n   * Text contents of the strike out annotation\n   */\n  contents?: string;\n\n  /**\n   * color of strike out annotation\n   */\n  color: string;\n\n  /**\n   * opacity of strike out annotation\n   */\n  opacity: number;\n\n  /**\n   * quads of highlight area\n   */\n  segmentRects: Rect[];\n}\n\n/**\n * Pdf caret annotation\n *\n * @public\n */\nexport interface PdfCaretAnnoObject extends PdfAnnotationObjectBase {\n  /** {@inheritDoc PdfAnnotationObjectBase.type} */\n  type: PdfAnnotationSubtype.CARET;\n}\n\n/**\n * Pdf free text annotation\n *\n * @public\n */\nexport interface PdfFreeTextAnnoObject extends PdfAnnotationObjectBase {\n  /** {@inheritDoc PdfAnnotationObjectBase.type} */\n  type: PdfAnnotationSubtype.FREETEXT;\n  contents: string;\n  richContent?: string;\n}\n\n/**\n * All annotation that support\n *\n * @public\n */\nexport type PdfSupportedAnnoObject =\n  | PdfInkAnnoObject\n  | PdfTextAnnoObject\n  | PdfLinkAnnoObject\n  | PdfPolygonAnnoObject\n  | PdfPolylineAnnoObject\n  | PdfHighlightAnnoObject\n  | PdfLineAnnoObject\n  | PdfWidgetAnnoObject\n  | PdfFileAttachmentAnnoObject\n  | PdfStampAnnoObject\n  | PdfSquareAnnoObject\n  | PdfCircleAnnoObject\n  | PdfSquigglyAnnoObject\n  | PdfUnderlineAnnoObject\n  | PdfStrikeOutAnnoObject\n  | PdfCaretAnnoObject\n  | PdfFreeTextAnnoObject;\n\n/**\n * Pdf annotation that does not support\n *\n * @public\n */\nexport interface PdfUnsupportedAnnoObject extends PdfAnnotationObjectBase {\n  type: Exclude<PdfAnnotationSubtype, PdfSupportedAnnoObject['type']>;\n}\n\n/**\n * all annotations\n *\n * @public\n */\nexport type PdfAnnotationObject = PdfSupportedAnnoObject | PdfUnsupportedAnnoObject;\n\n/**\n * Pdf attachment\n *\n * @public\n */\nexport interface PdfAttachmentObject {\n  index: number;\n  name: string;\n  creationDate: string;\n  checksum: string;\n}\n\n/**\n * Pdf engine features\n *\n * @public\n */\nexport enum PdfEngineFeature {\n  RenderPage,\n  RenderPageRect,\n  Thumbnails,\n  Bookmarks,\n  Annotations,\n}\n\n/**\n * All operations for this engine\n *\n * @public\n */\nexport enum PdfEngineOperation {\n  Create,\n  Read,\n  Update,\n  Delete,\n}\n\n/**\n * flags to match the text during searching\n *\n * @public\n */\nexport enum MatchFlag {\n  None = 0,\n  MatchCase = 1,\n  MatchWholeWord = 2,\n  MatchConsecutive = 4,\n}\n\n/**\n * Union all the flags\n * @param flags - all the flags\n * @returns union of flags\n *\n * @public\n */\nexport function unionFlags(flags: MatchFlag[]) {\n  return flags.reduce((flag, currFlag) => {\n    return flag | currFlag;\n  }, MatchFlag.None);\n}\n\n/**\n * Image conversion types\n *\n * @public\n */\nexport type ImageConversionTypes = 'image/webp' | 'image/png' | 'image/jpeg';\n\n/**\n * Targe for searching\n *\n * @public\n */\nexport interface SearchTarget {\n  keyword: string;\n  flags: MatchFlag[];\n}\n\n/**\n * compare 2 search target\n * @param targetA - first target for search\n * @param targetB - second target for search\n * @returns whether 2 search target are the same\n *\n * @public\n */\nexport function compareSearchTarget(targetA: SearchTarget, targetB: SearchTarget) {\n  const flagA = unionFlags(targetA.flags);\n  const flagB = unionFlags(targetB.flags);\n\n  return flagA === flagB && targetA.keyword === targetB.keyword;\n}\n\n/** Context of one hit */\nexport interface TextContext {\n  /** Complete words that come *before* the hit (no ellipsis)            */\n  before: string;\n  /** Exactly the text that matched (case-preserved)                      */\n  match: string;\n  /** Complete words that come *after* the hit (no ellipsis)             */\n  after: string;\n  /** `true` ⇢ there were more words on the left that we cut off         */\n  truncatedLeft: boolean;\n  /** `true` ⇢ there were more words on the right that we cut off        */\n  truncatedRight: boolean;\n}\n\n/**\n * Text slice\n *\n * @public\n */\nexport interface PageTextSlice {\n  /**\n   * Index of the pdf page\n   */\n  pageIndex: number;\n  /**\n   * Index of the first character\n   */\n  charIndex: number;\n  /**\n   * Count of the characters\n   */\n  charCount: number;\n}\n\n/**\n * search result\n *\n * @public\n */\nexport interface SearchResult {\n  /**\n   * Index of the pdf page\n   */\n  pageIndex: number;\n  /**\n   * index of the first character\n   */\n  charIndex: number;\n  /**\n   * count of the characters\n   */\n  charCount: number;\n  /**\n   * highlight rects\n   */\n  rects: Rect[];\n  /**\n   * context of the hit\n   */\n  context: TextContext;\n}\n\n/**\n * Results of searching through the entire document\n */\nexport interface SearchAllPagesResult {\n  /**\n   * Array of all search results across all pages\n   */\n  results: SearchResult[];\n\n  /**\n   * Total number of results found\n   */\n  total: number;\n}\n\n/**\n * Glyph object\n *\n * @public\n */\nexport interface PdfGlyphObject {\n  /**\n   * Origin of the glyph\n   */\n  origin: { x: number; y: number };\n  /**\n   * Size of the glyph\n   */\n  size: { width: number; height: number };\n  /**\n   * Whether the glyph is a space\n   */\n  isSpace?: boolean;\n  /**\n   * Whether the glyph is a empty\n   */\n  isEmpty?: boolean;\n}\n\n/**\n * Glyph object\n *\n * @public\n */\nexport interface PdfGlyphSlim {\n  /**\n   * X coordinate of the glyph\n   */\n  x: number;\n  /**\n   * Y coordinate of the glyph\n   */\n  y: number;\n  /**\n   * Width of the glyph\n   */\n  width: number;\n  /**\n   * Height of the glyph\n   */\n  height: number;\n  /**\n   * Flags of the glyph\n   */\n  flags: number;\n}\n\n/**\n * Run object\n *\n * @public\n */\nexport interface PdfRun {\n  /**\n   * Rectangle of the run\n   */\n  rect: { x: number; y: number; width: number; height: number };\n  /**\n   * Start index of the run\n   */\n  charStart: number;\n  /**\n   * Glyphs of the run\n   */\n  glyphs: PdfGlyphSlim[];\n}\n\n/**\n * Page geometry\n *\n * @public\n */\nexport interface PdfPageGeometry {\n  /**\n   * Runs of the page\n   */\n  runs: PdfRun[];\n}\n\n/**\n * form field value\n * @public\n */\nexport type FormFieldValue =\n  | { kind: 'text'; text: string }\n  | { kind: 'selection'; index: number; isSelected: boolean }\n  | { kind: 'checked'; isChecked: boolean };\n\n/**\n * Transformation that will be applied to annotation\n *\n * @public\n */\nexport interface PdfAnnotationTransformation {\n  /**\n   * Translated offset\n   */\n  offset: Position;\n  /**\n   * Scaled factors\n   */\n  scale: Size;\n}\n\n/**\n * Render options\n *\n * @public\n */\nexport interface PdfRenderOptions {\n  /**\n   * Whether needs to render the page with annotations\n   */\n  withAnnotations: boolean;\n}\n\n/**\n * source can be byte array contains pdf content\n *\n * @public\n */\nexport type PdfFileContent = ArrayBuffer;\n\nexport enum PdfPermission {\n  PrintDocument = 2 ** 3,\n  ModifyContent = 2 ** 4,\n  CopyOrExtract = 2 ** 5,\n  AddOrModifyTextAnnot = 2 ** 6,\n  FillInExistingForm = 2 ** 9,\n  ExtractTextOrGraphics = 2 ** 10,\n  AssembleDocument = 2 ** 11,\n  PrintHighQuality = 2 ** 12,\n}\n\nexport enum PdfPageFlattenFlag {\n  Display = 0,\n  Print = 1,\n}\n\nexport enum PdfPageFlattenResult {\n  Fail = 0,\n  Success = 1,\n  NothingToDo = 2,\n}\n\n/**\n * Pdf File without content\n *\n * @public\n */\nexport interface PdfFileWithoutContent {\n  /**\n   * id of file\n   */\n  id: string;\n}\n\nexport interface PdfFileLoader extends PdfFileWithoutContent {\n  /**\n   * length of file\n   */\n  fileLength: number;\n  /**\n   * read block of file\n   * @param offset - offset of file\n   * @param length - length of file\n   * @returns block of file\n   */\n  callback: (offset: number, length: number) => Uint8Array;\n}\n\n/**\n * Pdf File\n *\n * @public\n */\nexport interface PdfFile extends PdfFileWithoutContent {\n  /**\n   * content of file\n   */\n  content: PdfFileContent;\n}\n\nexport interface PdfFileUrl extends PdfFileWithoutContent {\n  url: string;\n}\n\nexport interface PdfUrlOptions {\n  mode?: 'auto' | 'range-request' | 'full-fetch';\n  password?: string;\n}\n\nexport enum PdfErrorCode {\n  Ok, //  #define FPDF_ERR_SUCCESS 0    // No error.\n  Unknown, // #define FPDF_ERR_UNKNOWN 1    // Unknown error.\n  NotFound, // #define FPDF_ERR_FILE 2       // File not found or could not be opened.\n  WrongFormat, // #define FPDF_ERR_FORMAT 3     // File not in PDF format or corrupted.\n  Password, // #define FPDF_ERR_PASSWORD 4   // Password required or incorrect password.\n  Security, // #define FPDF_ERR_SECURITY 5   // Unsupported security scheme.\n  PageError, // #define FPDF_ERR_PAGE 6       // Page not found or content error.\n  XFALoad, // #ifdef PDF_ENABLE_XFA\n  XFALayout, //\n  Cancelled,\n  Initialization,\n  NotReady,\n  NotSupport,\n  LoadDoc,\n  DocNotOpen,\n  CantCloseDoc,\n  CantCreateNewDoc,\n  CantImportPages,\n  CantCreateAnnot,\n  CantSetAnnotRect,\n  CantSetAnnotContent,\n  CantRemoveInkList,\n  CantAddInkStoke,\n  CantReadAttachmentSize,\n  CantReadAttachmentContent,\n  CantFocusAnnot,\n  CantSelectText,\n  CantSelectOption,\n  CantCheckField,\n}\n\nexport interface PdfErrorReason {\n  code: PdfErrorCode;\n  message: string;\n}\n\nexport type PdfEngineError = TaskError<PdfErrorReason>;\n\nexport type PdfTask<R> = Task<R, PdfErrorReason>;\n\nexport class PdfTaskHelper {\n  /**\n   * Create a task\n   * @returns new task\n   */\n  static create<R>(): Task<R, PdfErrorReason> {\n    return new Task<R, PdfErrorReason>();\n  }\n\n  /**\n   * Create a task that has been resolved with value\n   * @param result - resolved value\n   * @returns resolved task\n   */\n  static resolve<R>(result: R): Task<R, PdfErrorReason> {\n    const task = new Task<R, PdfErrorReason>();\n    task.resolve(result);\n\n    return task;\n  }\n\n  /**\n   * Create a task that has been rejected with error\n   * @param reason - rejected error\n   * @returns rejected task\n   */\n  static reject<T = any>(reason: PdfErrorReason): Task<T, PdfErrorReason> {\n    const task = new Task<T, PdfErrorReason>();\n    task.reject(reason);\n\n    return task;\n  }\n\n  /**\n   * Create a task that has been aborted with error\n   * @param reason - aborted error\n   * @returns aborted task\n   */\n  static abort<T = any>(reason: PdfErrorReason): Task<T, PdfErrorReason> {\n    const task = new Task<T, PdfErrorReason>();\n    task.reject(reason);\n\n    return task;\n  }\n}\n\n/**\n * Pdf engine\n *\n * @public\n */\nexport interface PdfEngine<T = Blob> {\n  /**\n   * Check whether pdf engine supports this feature\n   * @param feature - which feature want to check\n   * @returns support or not\n   */\n  isSupport?: (feature: PdfEngineFeature) => PdfTask<PdfEngineOperation[]>;\n  /**\n   * Initialize the engine\n   * @returns task that indicate whether initialization is successful\n   */\n  initialize?: () => PdfTask<boolean>;\n  /**\n   * Destroy the engine\n   * @returns task that indicate whether destroy is successful\n   */\n  destroy?: () => PdfTask<boolean>;\n  /**\n   * Open a PDF from a URL with specified mode\n   * @param url - The PDF file URL\n   * @param options - Additional options including mode (auto, range-request, full-fetch) and password\n   * @returns Task that resolves with the PdfDocumentObject or an error\n   */\n  openDocumentUrl: (file: PdfFileUrl, options?: PdfUrlOptions) => PdfTask<PdfDocumentObject>;\n  /**\n   * Open pdf document from buffer\n   * @param file - pdf file\n   * @param password - protected password for this file\n   * @returns task that contains the file or error\n   */\n  openDocumentFromBuffer: (file: PdfFile, password: string) => PdfTask<PdfDocumentObject>;\n  /**\n   * Open pdf document from loader\n   * @param file - pdf file\n   * @param password - protected password for this file\n   * @returns task that contains the file or error\n   */\n  openDocumentFromLoader: (file: PdfFileLoader, password: string) => PdfTask<PdfDocumentObject>;\n  /**\n   * Get the metadata of the file\n   * @param doc - pdf document\n   * @returns task that contains the metadata or error\n   */\n  getMetadata: (doc: PdfDocumentObject) => PdfTask<PdfMetadataObject>;\n  /**\n   * Get permissions of the file\n   * @param doc - pdf document\n   * @returns task that contains a 32-bit integer indicating permission flags\n   */\n  getDocPermissions: (doc: PdfDocumentObject) => PdfTask<number>;\n  /**\n   * Get the user permissions of the file\n   * @param doc - pdf document\n   * @returns task that contains a 32-bit integer indicating permission flags\n   */\n  getDocUserPermissions: (doc: PdfDocumentObject) => PdfTask<number>;\n  /**\n   * Get the signatures of the file\n   * @param doc - pdf document\n   * @returns task that contains the signatures or error\n   */\n  getSignatures: (doc: PdfDocumentObject) => PdfTask<PdfSignatureObject[]>;\n  /**\n   * Get the bookmarks of the file\n   * @param doc - pdf document\n   * @returns task that contains the bookmarks or error\n   */\n  getBookmarks: (doc: PdfDocumentObject) => PdfTask<PdfBookmarksObject>;\n  /**\n   * Render the specified pdf page\n   * @param doc - pdf document\n   * @param page - pdf page\n   * @param scaleFactor - factor of scaling\n   * @param rotation - rotated angle\n   * @param dpr - devicePixelRatio\n   * @param options - render options\n   * @returns task contains the rendered image or error\n   */\n  renderPage: (\n    doc: PdfDocumentObject,\n    page: PdfPageObject,\n    scaleFactor: number,\n    rotation: Rotation,\n    dpr: number,\n    options: PdfRenderOptions,\n    imageType?: ImageConversionTypes,\n  ) => PdfTask<T>;\n  /**\n   * Render the specified rect of pdf page\n   * @param doc - pdf document\n   * @param page - pdf page\n   * @param scaleFactor - factor of scaling\n   * @param rotation - rotated angle\n   * @param dpr - devicePixelRatio\n   * @param rect - target rect\n   * @param options - render options\n   * @returns task contains the rendered image or error\n   */\n  renderPageRect: (\n    doc: PdfDocumentObject,\n    page: PdfPageObject,\n    scaleFactor: number,\n    rotation: Rotation,\n    dpr: number,\n    rect: Rect,\n    options: PdfRenderOptions,\n    imageType?: ImageConversionTypes,\n  ) => PdfTask<T>;\n  /**\n   * Render a single annotation into an ImageData blob.\n   *\n   * Note:  • honours Display-Matrix, page rotation & DPR\n   *        • you decide whether to include the page background\n   * @param doc - pdf document\n   * @param page - pdf page\n   * @param annotation - the annotation to render\n   * @param scaleFactor - factor of scaling\n   * @param rotation - rotated angle\n   * @param dpr - devicePixelRatio\n   * @param mode - appearance mode\n   */\n  renderAnnotation(\n    doc: PdfDocumentObject,\n    page: PdfPageObject,\n    annotation: PdfAnnotationObject,\n    scaleFactor: number,\n    rotation: Rotation,\n    dpr: number,\n    mode: AppearanceMode,\n    imageType: ImageConversionTypes,\n  ): PdfTask<T>;\n  /**\n   * Get annotations of pdf page\n   * @param doc - pdf document\n   * @param page - pdf page\n   * @param scaleFactor - factor of scaling\n   * @param rotation - rotated angle\n   * @returns task contains the annotations or error\n   */\n  getPageAnnotations: (\n    doc: PdfDocumentObject,\n    page: PdfPageObject,\n  ) => PdfTask<PdfAnnotationObject[]>;\n\n  /**\n   * Change the visible colour (and opacity) of an existing annotation.\n   * @param doc - pdf document\n   * @param page - pdf page\n   * @param annotation - the annotation to recolour\n   * @param colour - RGBA color values (0-255 per channel)\n   * @param which - 0 = stroke/fill colour (PDFium's \"colourType\" param)\n   * @returns task that indicates whether the operation succeeded\n   */\n  updateAnnotationColor: (\n    doc: PdfDocumentObject,\n    page: PdfPageObject,\n    annotation: PdfAnnotationObjectBase,\n    color: WebAlphaColor,\n    which?: number,\n  ) => PdfTask<boolean>;\n\n  /**\n   * Create a annotation on specified page\n   * @param doc - pdf document\n   * @param page - pdf page\n   * @param annotation - new annotations\n   * @returns task whether the annotations is created successfully\n   */\n  createPageAnnotation: (\n    doc: PdfDocumentObject,\n    page: PdfPageObject,\n    annotation: PdfAnnotationObject,\n  ) => PdfTask<number>;\n  /**\n   * Update a annotation on specified page\n   * @param doc - pdf document\n   * @param page - pdf page\n   * @param annotation - new annotations\n   * @returns task that indicates whether the operation succeeded\n   */\n  updatePageAnnotation: (\n    doc: PdfDocumentObject,\n    page: PdfPageObject,\n    annotation: PdfAnnotationObject,\n  ) => PdfTask<boolean>;\n  /**\n   * Remove a annotation on specified page\n   * @param doc - pdf document\n   * @param page - pdf page\n   * @param annotation - new annotations\n   * @returns task whether the annotations is removed successfully\n   */\n  removePageAnnotation: (\n    doc: PdfDocumentObject,\n    page: PdfPageObject,\n    annotation: PdfAnnotationObject,\n  ) => PdfTask<boolean>;\n  /**\n   * get all text rects in pdf page\n   * @param doc - pdf document\n   * @param page - pdf page\n   * @param scaleFactor - factor of scaling\n   * @param rotation - rotated angle\n   * @returns task contains the text rects or error\n   */\n  getPageTextRects: (\n    doc: PdfDocumentObject,\n    page: PdfPageObject,\n    scaleFactor: number,\n    rotation: Rotation,\n  ) => PdfTask<PdfTextRectObject[]>;\n  /**\n   * Render the thumbnail of specified pdf page\n   * @param doc - pdf document\n   * @param page - pdf page\n   * @param scaleFactor - factor of scaling\n   * @param rotation - rotated angle\n   * @param dpr - devicePixelRatio\n   * @param options - render options\n   * @returns task contains the rendered image or error\n   */\n  renderThumbnail: (\n    doc: PdfDocumentObject,\n    page: PdfPageObject,\n    scaleFactor: number,\n    rotation: Rotation,\n    dpr: number,\n  ) => PdfTask<T>;\n  /**\n   * Search across all pages in the document\n   * @param doc - pdf document\n   * @param keyword - search keyword\n   * @param flags - match flags for search\n   * @returns Task contains all search results throughout the document\n   */\n  searchAllPages: (\n    doc: PdfDocumentObject,\n    keyword: string,\n    flags?: MatchFlag[],\n  ) => PdfTask<SearchAllPagesResult>;\n  /**\n   * Get all annotations in this file\n   * @param doc - pdf document\n   * @returns task that contains the annotations or error\n   */\n  getAllAnnotations: (doc: PdfDocumentObject) => PdfTask<Record<number, PdfAnnotationObject[]>>;\n  /**\n   * Get all attachments in this file\n   * @param doc - pdf document\n   * @returns task that contains the attachments or error\n   */\n  getAttachments: (doc: PdfDocumentObject) => PdfTask<PdfAttachmentObject[]>;\n  /**\n   * Read content of pdf attachment\n   * @param doc - pdf document\n   * @param attachment - pdf attachments\n   * @returns task that contains the content of specified attachment or error\n   */\n  readAttachmentContent: (\n    doc: PdfDocumentObject,\n    attachment: PdfAttachmentObject,\n  ) => PdfTask<ArrayBuffer>;\n  /**\n   * Set form field value\n   * @param doc - pdf document\n   * @param page - pdf page\n   * @param annotation - pdf annotation\n   * @param text - text value\n   */\n  setFormFieldValue: (\n    doc: PdfDocumentObject,\n    page: PdfPageObject,\n    annotation: PdfWidgetAnnoObject,\n    value: FormFieldValue,\n  ) => PdfTask<boolean>;\n  /**\n   * Flatten annotations and form fields into the page contents.\n   * @param doc - pdf document\n   * @param page - pdf page\n   * @param flag - flatten flag\n   */\n  flattenPage: (\n    doc: PdfDocumentObject,\n    page: PdfPageObject,\n    flag: PdfPageFlattenFlag,\n  ) => PdfTask<PdfPageFlattenResult>;\n  /**\n   * Extract pdf pages to a new file\n   * @param doc - pdf document\n   * @param pageIndexes - indexes of pdf pages\n   * @returns task contains the new pdf file content\n   */\n  extractPages: (doc: PdfDocumentObject, pageIndexes: number[]) => PdfTask<ArrayBuffer>;\n  /**\n   * Extract text on specified pdf pages\n   * @param doc - pdf document\n   * @param pageIndexes - indexes of pdf pages\n   * @returns task contains the text\n   */\n  extractText: (doc: PdfDocumentObject, pageIndexes: number[]) => PdfTask<string>;\n  /**\n   * Extract text on specified pdf pages\n   * @param doc - pdf document\n   * @param pageIndexes - indexes of pdf pages\n   * @returns task contains the text\n   */\n  getTextSlices: (doc: PdfDocumentObject, slices: PageTextSlice[]) => PdfTask<string[]>;\n  /**\n   * Get all glyphs in the specified pdf page\n   * @param doc - pdf document\n   * @param page - pdf page\n   * @returns task contains the glyphs\n   */\n  getPageGlyphs: (doc: PdfDocumentObject, page: PdfPageObject) => PdfTask<PdfGlyphObject[]>;\n  /**\n   * Get the geometry of the specified pdf page\n   * @param doc - pdf document\n   * @param page - pdf page\n   * @returns task contains the geometry\n   */\n  getPageGeometry: (doc: PdfDocumentObject, page: PdfPageObject) => PdfTask<PdfPageGeometry>;\n  /**\n   * Merge multiple pdf documents\n   * @param files - all the pdf files\n   * @returns task contains the merged pdf file\n   */\n  merge: (files: PdfFile[]) => PdfTask<PdfFile>;\n  /**\n   * Merge specific pages from multiple PDF documents in a custom order\n   * @param mergeConfigs Array of configurations specifying which pages to merge from which documents\n   * @returns A PdfTask that resolves with the merged PDF file\n   * @public\n   */\n  mergePages: (mergeConfigs: Array<{ docId: string; pageIndices: number[] }>) => PdfTask<PdfFile>;\n  /**\n   * Save a copy of pdf document\n   * @param doc - pdf document\n   * @returns task contains the new pdf file content\n   */\n  saveAsCopy: (doc: PdfDocumentObject) => PdfTask<ArrayBuffer>;\n  /**\n   * Close pdf document\n   * @param doc - pdf document\n   * @returns task that file is closed or not\n   */\n  closeDocument: (doc: PdfDocumentObject) => PdfTask<boolean>;\n}\n\n/**\n * Method name of PdfEngine interface\n *\n * @public\n */\nexport type PdfEngineMethodName = keyof Required<PdfEngine>;\n\n/**\n * Arguments of PdfEngine method\n *\n * @public\n */\nexport type PdfEngineMethodArgs<P extends PdfEngineMethodName> = Readonly<\n  Parameters<Required<PdfEngine>[P]>\n>;\n\n/**\n * Return type of PdfEngine method\n *\n * @public\n */\nexport type PdfEngineMethodReturnType<P extends PdfEngineMethodName> = ReturnType<\n  Required<PdfEngine>[P]\n>;\n","import { PdfAlphaColor } from './pdf';\n\nexport interface WebAlphaColor {\n  color: string;\n  opacity: number;\n}\n\n/**\n * Convert a {@link PdfAlphaColor} to a CSS-style colour definition.\n *\n * @param c - the colour coming from PDFium (0-255 per channel)\n * @returns\n *   hex   – #RRGGBB (no alpha channel)\n *   opacity – 0-1 float suitable for CSS `opacity`/`rgba()`\n */\nexport function pdfAlphaColorToWebAlphaColor(c: PdfAlphaColor): WebAlphaColor {\n  const clamp = (n: number) => Math.max(0, Math.min(255, n));\n  const toHex = (n: number) => clamp(n).toString(16).padStart(2, '0');\n\n  const color = `#${toHex(c.red)}${toHex(c.green)}${toHex(c.blue)}` as const;\n  const opacity = clamp(c.alpha) / 255;\n\n  return { color, opacity };\n}\n\n/**\n * Convert a CSS hex colour + opacity back into {@link PdfAlphaColor}\n *\n * @param hex      - #RGB, #RRGGBB, or #rrggbb\n * @param opacity  - 0-1 float (values outside clamp automatically)\n */\nexport function webAlphaColorToPdfAlphaColor({ color, opacity }: WebAlphaColor): PdfAlphaColor {\n  // Normalise: #abc → #aabbcc\n  if (/^#?[0-9a-f]{3}$/i.test(color)) {\n    color = color.replace(/^#?([0-9a-f])([0-9a-f])([0-9a-f])$/i, '#$1$1$2$2$3$3').toLowerCase();\n  }\n\n  const [, r, g, b] =\n    /^#?([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$/i.exec(color) ??\n    (() => {\n      throw new Error(`Invalid hex colour: “${color}”`);\n    })();\n\n  const clamp = (n: number, hi = 255) => Math.max(0, Math.min(hi, n));\n\n  return {\n    red: parseInt(r, 16),\n    green: parseInt(g, 16),\n    blue: parseInt(b, 16),\n    alpha: clamp(Math.round(opacity * 255)),\n  };\n}\n","/**\n * Parse a PDF date string **D:YYYYMMDDHHmmSSOHH'mm'** to ISO-8601.\n *\n * Returns `undefined` if the input is malformed.\n *\n * @public\n */\nexport function pdfDateToDate(pdf?: string): Date | undefined {\n  if (!pdf?.startsWith('D:') || pdf.length < 16) return;\n\n  const y = +pdf.slice(2, 6);\n  const mo = +pdf.slice(6, 8) - 1; // JS months: 0-based\n  const d = +pdf.slice(8, 10);\n  const H = +pdf.slice(10, 12);\n  const M = +pdf.slice(12, 14);\n  const S = +pdf.slice(14, 16);\n\n  return new Date(Date.UTC(y, mo, d, H, M, S));\n}\n\n/**\n * Convert a date to a PDF date string\n * @param date - date to convert\n * @returns PDF date string\n *\n * @public\n */\nexport function dateToPdfDate(date: Date = new Date()): string {\n  const z = (n: number, len = 2) => n.toString().padStart(len, '0');\n\n  const YYYY = date.getUTCFullYear();\n  const MM = z(date.getUTCMonth() + 1);\n  const DD = z(date.getUTCDate());\n  const HH = z(date.getUTCHours());\n  const mm = z(date.getUTCMinutes());\n  const SS = z(date.getUTCSeconds());\n\n  return `D:${YYYY}${MM}${DD}${HH}${mm}${SS}`;\n}\n","/**\n * Library contains the common definitions of data types and logic\n *\n * @remarks\n * The `@embedpdf/models` defines the interface and classes which are used to\n * handling PDF files.\n *\n * @packageDocumentation\n */\nexport * from './geometry';\nexport * from './logger';\nexport * from './pdf';\nexport * from './task';\nexport * from './color';\nexport * from './date';\n\n/**\n * ignore will do nothing when called.\n *\n * @public\n */\nexport function ignore() {}\n","import { BasePluginConfig } from '@embedpdf/core';\n\nexport interface PrintPluginConfig extends BasePluginConfig {\n  defaultQuality?: PrintQuality;\n  defaultIncludeAnnotations?: boolean;\n  batchSize?: number;\n}\n\nexport enum PrintQuality {\n  Normal = 'normal',\n  High = 'high',\n}\n\nexport enum PageRangeType {\n  Current = 'current',\n  All = 'all',\n  Custom = 'custom',\n}\n\nexport interface PageRangeCurrent {\n  type: PageRangeType.Current;\n  currentPage: number;\n}\n\nexport interface PageRangeAll {\n  type: PageRangeType.All;\n}\n\nexport interface PageRangeCustom {\n  type: PageRangeType.Custom;\n  pages: number[];\n}\n\nexport type PageRange = PageRangeCurrent | PageRangeAll | PageRangeCustom;\n\nexport interface PrintOptions {\n  pageRange: PageRange;\n  includeAnnotations: boolean;\n  quality: PrintQuality;\n}\n\nexport interface PrintProgress {\n  current: number;\n  total: number;\n  status: 'preparing' | 'rendering' | 'complete' | 'error';\n  message?: string;\n}\n\nexport interface PrintData {\n  blobs: Blob[];\n  options: PrintOptions;\n  totalPages: number;\n}\n\nexport interface ParsedPageRange {\n  pages: number[];\n  isValid: boolean;\n  error?: string;\n}\n\nexport interface PrintPageResult {\n  pageIndex: number;\n  blob: Blob;\n}\n\nexport interface PrintCapability {\n  preparePrint: (\n    options: PrintOptions,\n    onProgress?: (progress: PrintProgress) => void,\n    onPageReady?: (result: PrintPageResult) => void,\n  ) => Promise<void>;\n  parsePageRange: (rangeString: string) => ParsedPageRange;\n}\n","import { PluginPackage } from '@embedpdf/core';\nimport { manifest, PRINT_PLUGIN_ID } from './manifest';\nimport { PrintPluginConfig } from './types';\nimport { PrintPlugin } from './print-plugin';\n\nexport const PrintPluginPackage: PluginPackage<PrintPlugin, PrintPluginConfig> = {\n  manifest,\n  create: (registry, _engine, config) => new PrintPlugin(PRINT_PLUGIN_ID, registry, config),\n  reducer: () => {},\n  initialState: {},\n};\n\nexport * from './print-plugin';\nexport * from './types';\nexport * from './manifest';\n"],"mappings":"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","names":["Rotation","_RenderPlugin","BasePlugin","id","registry","engine","_config","pageIndex","scaleFactor","dpr","rotation","Rotation","options","imageType","coreState","page","rect","RenderPlugin","PrintQuality","PageRangeType"]}