{"version":3,"file":"index.cjs","sources":["../src/lib/manifest.ts","../src/lib/actions.ts","../src/lib/reducer.ts","../src/lib/utils.ts","../src/lib/tiling-plugin.ts","../src/lib/index.ts"],"sourcesContent":["import { PluginManifest } from '@embedpdf/core';\n\nimport { TilingPluginConfig } from './types';\n\nexport const TILING_PLUGIN_ID = 'tiling';\n\nexport const manifest: PluginManifest<TilingPluginConfig> = {\n  id: TILING_PLUGIN_ID,\n  name: 'Tiling Plugin',\n  version: '1.0.0',\n  provides: ['tiling'],\n  requires: ['render', 'scroll', 'viewport'],\n  optional: [],\n  defaultConfig: {\n    enabled: true,\n    tileSize: 768,\n    overlapPx: 2.5,\n    extraRings: 0,\n  },\n};\n","import { Tile, TileStatus } from './types';\n\nexport const UPDATE_VISIBLE_TILES = 'UPDATE_VISIBLE_TILES';\nexport const MARK_TILE_STATUS = 'MARK_TILE_STATUS';\n\nexport type UpdateVisibleTilesAction = {\n  type: typeof UPDATE_VISIBLE_TILES;\n  payload: Record<number, Tile[]>;\n};\n\nexport type MarkTileStatusAction = {\n  type: typeof MARK_TILE_STATUS;\n  payload: { pageIndex: number; tileId: string; status: TileStatus };\n};\n\nexport type TilingAction = UpdateVisibleTilesAction | MarkTileStatusAction;\n\nexport const updateVisibleTiles = (tiles: Record<number, Tile[]>): UpdateVisibleTilesAction => ({\n  type: UPDATE_VISIBLE_TILES,\n  payload: tiles,\n});\n\nexport const markTileStatus = (\n  pageIndex: number,\n  tileId: string,\n  status: TileStatus,\n): MarkTileStatusAction => ({ type: MARK_TILE_STATUS, payload: { pageIndex, tileId, status } });\n","import { Reducer } from '@embedpdf/core';\n\nimport { UPDATE_VISIBLE_TILES, MARK_TILE_STATUS, TilingAction } from './actions';\nimport { Tile, TilingState } from './types';\n\nexport const initialState: TilingState = {\n  visibleTiles: {},\n};\n\nexport const tilingReducer: Reducer<TilingState, TilingAction> = (state, action) => {\n  switch (action.type) {\n    case UPDATE_VISIBLE_TILES: {\n      const incoming = action.payload; // Record<number, Tile[]>\n      const nextPages = { ...state.visibleTiles };\n\n      for (const key in incoming) {\n        const pageIndex = Number(key);\n        const newTiles = incoming[pageIndex]; // all isFallback=false\n        const prevTiles = nextPages[pageIndex] ?? [];\n\n        const prevScale = prevTiles.find((t) => !t.isFallback)?.srcScale;\n        const newScale = newTiles[0].srcScale;\n        const zoomChanged = prevScale !== undefined && prevScale !== newScale;\n\n        if (zoomChanged) {\n          /* 1️⃣  ready tiles from the old zoom → new fallback */\n          const promoted = prevTiles\n            .filter((t) => !t.isFallback && t.status === 'ready')\n            .map((t) => ({ ...t, isFallback: true }));\n\n          /* 2️⃣  decide which fallback tiles to keep           */\n          const fallbackToCarry = promoted.length > 0 ? [] : prevTiles.filter((t) => t.isFallback);\n\n          /* 3️⃣  final list = (maybe-kept fallback) + promoted + newTiles */\n          nextPages[pageIndex] = [...fallbackToCarry, ...promoted, ...newTiles];\n        } else {\n          /* same zoom → keep current fallback, replace visible */\n          const newIds = new Set(newTiles.map((t) => t.id));\n          const keepers: Tile[] = []; // where we’ll collect surviving tiles\n          const seenIds = new Set<string>();\n\n          /* 2️⃣  loop prevTiles once */\n          for (const t of prevTiles) {\n            if (t.isFallback) {\n              keepers.push(t); // always keep fallback\n              seenIds.add(t.id);\n            } else if (newIds.has(t.id)) {\n              keepers.push(t); // keep old visible tile (preserves status)\n              seenIds.add(t.id);\n            }\n          }\n\n          /* 3️⃣  append *brand-new* tiles (not yet kept) */\n          for (const t of newTiles) {\n            if (!seenIds.has(t.id)) keepers.push(t);\n          }\n\n          /* 4️⃣  store result */\n          nextPages[pageIndex] = keepers;\n        }\n      }\n\n      return { ...state, visibleTiles: nextPages };\n    }\n\n    case MARK_TILE_STATUS: {\n      const { pageIndex, tileId, status } = action.payload;\n      const tiles =\n        state.visibleTiles[pageIndex]?.map((t) =>\n          t.id === tileId ? ({ ...t, status } as Tile) : t,\n        ) ?? [];\n\n      const newTiles = tiles.filter((t) => !t.isFallback);\n      const allReady = newTiles.every((t) => t.status === 'ready');\n      const finalTiles = allReady ? newTiles : tiles;\n\n      return {\n        ...state,\n        visibleTiles: { ...state.visibleTiles, [pageIndex]: finalTiles },\n      };\n    }\n\n    default:\n      return state;\n  }\n};\n","import { Rect, restoreRect, transformSize } from '@embedpdf/models';\nimport { CalculateTilesForPageOptions, Tile } from './types';\n\n/**\n * Build a grid where neighbouring tiles overlap by `overlapPx`\n * (screen pixels). Inner tiles keep the full `tileSize`, edge\n * tiles are clipped to the page bounds. All screen-space values\n * are rounded to **integers** to avoid sub-pixel seams.\n */\nexport function calculateTilesForPage({\n  tileSize = 768,\n  overlapPx = 2.5,\n  extraRings = 0,\n  scale,\n  rotation,\n  page,\n  metric,\n}: CalculateTilesForPageOptions): Tile[] {\n  /* ---- work in screen-pixel space -------------------------------- */\n  const pageW = page.size.width * scale; // px\n  const pageH = page.size.height * scale; // px\n\n  const step = tileSize - overlapPx; // shift between tiles\n\n  const containerSize = transformSize(page.size, rotation, scale);\n  const rotatedVisRect: Rect = {\n    origin: { x: metric.scaled.pageX, y: metric.scaled.pageY },\n    size: { width: metric.scaled.visibleWidth, height: metric.scaled.visibleHeight },\n  };\n  const unrotatedVisRect = restoreRect(containerSize, rotatedVisRect, rotation, 1);\n\n  const visLeft = unrotatedVisRect.origin.x;\n  const visTop = unrotatedVisRect.origin.y;\n  const visRight = visLeft + unrotatedVisRect.size.width;\n  const visBottom = visTop + unrotatedVisRect.size.height;\n\n  const maxCol = Math.floor((pageW - 1) / step);\n  const maxRow = Math.floor((pageH - 1) / step);\n\n  const startCol = Math.max(0, Math.floor(visLeft / step) - extraRings);\n  const endCol = Math.min(maxCol, Math.floor((visRight - 1) / step) + extraRings);\n  const startRow = Math.max(0, Math.floor(visTop / step) - extraRings);\n  const endRow = Math.min(maxRow, Math.floor((visBottom - 1) / step) + extraRings);\n\n  /* ---- build tiles ---------------------------------------------- */\n  const tiles: Tile[] = [];\n\n  for (let col = startCol; col <= endCol; col++) {\n    const xScreen = col * step; // px (integer)\n    const wScreen = Math.min(tileSize, pageW - xScreen); // px (≤  tileSize)\n\n    const xPage = xScreen / scale; // pt (may be frac.)\n    const wPage = wScreen / scale; // pt\n\n    for (let row = startRow; row <= endRow; row++) {\n      const yScreen = row * step;\n      const hScreen = Math.min(tileSize, pageH - yScreen);\n\n      const yPage = yScreen / scale;\n      const hPage = hScreen / scale;\n\n      tiles.push({\n        id: `p${page.index}-${scale}-x${xScreen}-y${yScreen}-w${wScreen}-h${hScreen}`,\n        col,\n        row,\n        pageRect: { origin: { x: xPage, y: yPage }, size: { width: wPage, height: hPage } },\n        screenRect: {\n          origin: { x: xScreen, y: yScreen },\n          size: { width: wScreen, height: hScreen },\n        },\n        status: 'queued',\n        srcScale: scale,\n        isFallback: false,\n      });\n    }\n  }\n\n  return tiles;\n}\n","import {\n  BasePlugin,\n  CoreState,\n  createBehaviorEmitter,\n  PluginRegistry,\n  StoreState,\n} from '@embedpdf/core';\nimport { ignore } from '@embedpdf/models';\nimport { RenderCapability, RenderPlugin } from '@embedpdf/plugin-render';\nimport { ScrollCapability, ScrollMetrics, ScrollPlugin } from '@embedpdf/plugin-scroll';\nimport { ViewportCapability, ViewportPlugin } from '@embedpdf/plugin-viewport';\n\nimport { markTileStatus, updateVisibleTiles } from './actions';\nimport {\n  TilingPluginConfig,\n  TilingCapability,\n  Tile,\n  RenderTileOptions,\n  TilingState,\n} from './types';\nimport { calculateTilesForPage } from './utils';\n\nexport class TilingPlugin extends BasePlugin<TilingPluginConfig, TilingCapability> {\n  static readonly id = 'tiling' as const;\n\n  private readonly tileRendering$ = createBehaviorEmitter<Record<number, Tile[]>>();\n\n  private config: TilingPluginConfig;\n  private renderCapability: RenderCapability;\n  private scrollCapability: ScrollCapability;\n  private viewportCapability: ViewportCapability;\n\n  constructor(id: string, registry: PluginRegistry, config: TilingPluginConfig) {\n    super(id, registry);\n\n    this.config = config;\n\n    this.renderCapability = this.registry.getPlugin<RenderPlugin>('render')!.provides();\n    this.scrollCapability = this.registry.getPlugin<ScrollPlugin>('scroll')!.provides();\n    this.viewportCapability = this.registry.getPlugin<ViewportPlugin>('viewport')!.provides();\n\n    this.scrollCapability.onScroll((scrollMetrics) => this.calculateVisibleTiles(scrollMetrics), {\n      mode: 'throttle',\n      wait: 500,\n      throttleMode: 'trailing',\n    });\n  }\n\n  async initialize(): Promise<void> {\n    // Fetch dependencies from the registry if needed\n  }\n\n  protected onCoreStoreUpdated(\n    oldState: StoreState<CoreState>,\n    newState: StoreState<CoreState>,\n  ): void {\n    if (oldState.core.scale !== newState.core.scale) {\n      this.calculateVisibleTiles(\n        this.scrollCapability.getMetrics(this.viewportCapability.getMetrics()),\n      );\n    }\n  }\n\n  private calculateVisibleTiles(scrollMetrics: ScrollMetrics): void {\n    if (!this.config.enabled) {\n      this.dispatch(updateVisibleTiles([]));\n      return;\n    }\n\n    const scale = this.coreState.core.scale;\n    const rotation = this.coreState.core.rotation;\n    const visibleTiles: { [pageIndex: number]: Tile[] } = {};\n\n    for (const scrollMetric of scrollMetrics.pageVisibilityMetrics) {\n      const pageIndex = scrollMetric.pageNumber - 1; // Convert to 0-based index\n      const page = this.coreState.core.document?.pages[pageIndex];\n      if (!page) continue;\n\n      // Calculate tiles for the page using the utility function\n      const tiles = calculateTilesForPage({\n        page,\n        metric: scrollMetric,\n        scale,\n        rotation,\n        tileSize: this.config.tileSize,\n        overlapPx: this.config.overlapPx,\n        extraRings: this.config.extraRings,\n      });\n\n      visibleTiles[pageIndex] = tiles;\n    }\n\n    this.dispatch(updateVisibleTiles(visibleTiles));\n  }\n\n  override onStoreUpdated(_prevState: TilingState, newState: TilingState): void {\n    this.tileRendering$.emit(newState.visibleTiles);\n  }\n\n  protected buildCapability(): TilingCapability {\n    return {\n      renderTile: this.renderTile.bind(this),\n      onTileRendering: this.tileRendering$.on,\n    };\n  }\n\n  private renderTile(options: RenderTileOptions) {\n    if (!this.renderCapability) {\n      throw new Error('Render capability not available.');\n    }\n\n    this.dispatch(markTileStatus(options.pageIndex, options.tile.id, 'rendering'));\n\n    const task = this.renderCapability.renderPageRect({\n      pageIndex: options.pageIndex,\n      rect: options.tile.pageRect,\n      scaleFactor: options.tile.srcScale,\n      dpr: options.dpr,\n    });\n\n    task.wait(() => {\n      this.dispatch(markTileStatus(options.pageIndex, options.tile.id, 'ready'));\n    }, ignore);\n\n    return task;\n  }\n}\n","import { PluginPackage } from '@embedpdf/core';\n\nimport { TilingAction } from './actions';\nimport { manifest, TILING_PLUGIN_ID } from './manifest';\nimport { initialState, tilingReducer } from './reducer';\nimport { TilingPlugin } from './tiling-plugin';\nimport { TilingPluginConfig, TilingState } from './types';\n\nexport const TilingPluginPackage: PluginPackage<\n  TilingPlugin,\n  TilingPluginConfig,\n  TilingState,\n  TilingAction\n> = {\n  manifest,\n  create: (registry, _engine, config) => new TilingPlugin(TILING_PLUGIN_ID, registry, config),\n  reducer: (state, action) => tilingReducer(state, action),\n  initialState,\n};\n\nexport * from './tiling-plugin';\nexport * from './types';\nexport * from './manifest';\n"],"names":["TILING_PLUGIN_ID","manifest","UPDATE_VISIBLE_TILES","MARK_TILE_STATUS","updateVisibleTiles","tiles","markTileStatus","pageIndex","tileId","status","initialState","tilingReducer","state","action","incoming","nextPages","key","newTiles","prevTiles","prevScale","_a","t","newScale","promoted","fallbackToCarry","newIds","keepers","seenIds","_b","finalTiles","calculateTilesForPage","tileSize","overlapPx","extraRings","scale","rotation","page","metric","pageW","pageH","step","containerSize","transformSize","rotatedVisRect","unrotatedVisRect","restoreRect","visLeft","visTop","visRight","visBottom","maxCol","maxRow","startCol","endCol","startRow","endRow","col","xScreen","wScreen","xPage","wPage","row","yScreen","hScreen","yPage","hPage","_TilingPlugin","BasePlugin","id","registry","config","createBehaviorEmitter","scrollMetrics","oldState","newState","visibleTiles","scrollMetric","_prevState","options","task","ignore","TilingPlugin","TilingPluginPackage","_engine"],"mappings":"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"}