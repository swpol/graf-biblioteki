{"version":3,"file":"index.js","sources":["../src/lib/manifest.ts","../src/lib/actions.ts","../src/lib/reducer.ts","../src/lib/utils.ts","../src/lib/tiling-plugin.ts","../src/lib/index.ts"],"sourcesContent":["import { PluginManifest } from '@embedpdf/core';\n\nimport { TilingPluginConfig } from './types';\n\nexport const TILING_PLUGIN_ID = 'tiling';\n\nexport const manifest: PluginManifest<TilingPluginConfig> = {\n  id: TILING_PLUGIN_ID,\n  name: 'Tiling Plugin',\n  version: '1.0.0',\n  provides: ['tiling'],\n  requires: ['render', 'scroll', 'viewport'],\n  optional: [],\n  defaultConfig: {\n    enabled: true,\n    tileSize: 768,\n    overlapPx: 2.5,\n    extraRings: 0,\n  },\n};\n","import { Tile, TileStatus } from './types';\n\nexport const UPDATE_VISIBLE_TILES = 'UPDATE_VISIBLE_TILES';\nexport const MARK_TILE_STATUS = 'MARK_TILE_STATUS';\n\nexport type UpdateVisibleTilesAction = {\n  type: typeof UPDATE_VISIBLE_TILES;\n  payload: Record<number, Tile[]>;\n};\n\nexport type MarkTileStatusAction = {\n  type: typeof MARK_TILE_STATUS;\n  payload: { pageIndex: number; tileId: string; status: TileStatus };\n};\n\nexport type TilingAction = UpdateVisibleTilesAction | MarkTileStatusAction;\n\nexport const updateVisibleTiles = (tiles: Record<number, Tile[]>): UpdateVisibleTilesAction => ({\n  type: UPDATE_VISIBLE_TILES,\n  payload: tiles,\n});\n\nexport const markTileStatus = (\n  pageIndex: number,\n  tileId: string,\n  status: TileStatus,\n): MarkTileStatusAction => ({ type: MARK_TILE_STATUS, payload: { pageIndex, tileId, status } });\n","import { Reducer } from '@embedpdf/core';\n\nimport { UPDATE_VISIBLE_TILES, MARK_TILE_STATUS, TilingAction } from './actions';\nimport { Tile, TilingState } from './types';\n\nexport const initialState: TilingState = {\n  visibleTiles: {},\n};\n\nexport const tilingReducer: Reducer<TilingState, TilingAction> = (state, action) => {\n  switch (action.type) {\n    case UPDATE_VISIBLE_TILES: {\n      const incoming = action.payload; // Record<number, Tile[]>\n      const nextPages = { ...state.visibleTiles };\n\n      for (const key in incoming) {\n        const pageIndex = Number(key);\n        const newTiles = incoming[pageIndex]; // all isFallback=false\n        const prevTiles = nextPages[pageIndex] ?? [];\n\n        const prevScale = prevTiles.find((t) => !t.isFallback)?.srcScale;\n        const newScale = newTiles[0].srcScale;\n        const zoomChanged = prevScale !== undefined && prevScale !== newScale;\n\n        if (zoomChanged) {\n          /* 1️⃣  ready tiles from the old zoom → new fallback */\n          const promoted = prevTiles\n            .filter((t) => !t.isFallback && t.status === 'ready')\n            .map((t) => ({ ...t, isFallback: true }));\n\n          /* 2️⃣  decide which fallback tiles to keep           */\n          const fallbackToCarry = promoted.length > 0 ? [] : prevTiles.filter((t) => t.isFallback);\n\n          /* 3️⃣  final list = (maybe-kept fallback) + promoted + newTiles */\n          nextPages[pageIndex] = [...fallbackToCarry, ...promoted, ...newTiles];\n        } else {\n          /* same zoom → keep current fallback, replace visible */\n          const newIds = new Set(newTiles.map((t) => t.id));\n          const keepers: Tile[] = []; // where we’ll collect surviving tiles\n          const seenIds = new Set<string>();\n\n          /* 2️⃣  loop prevTiles once */\n          for (const t of prevTiles) {\n            if (t.isFallback) {\n              keepers.push(t); // always keep fallback\n              seenIds.add(t.id);\n            } else if (newIds.has(t.id)) {\n              keepers.push(t); // keep old visible tile (preserves status)\n              seenIds.add(t.id);\n            }\n          }\n\n          /* 3️⃣  append *brand-new* tiles (not yet kept) */\n          for (const t of newTiles) {\n            if (!seenIds.has(t.id)) keepers.push(t);\n          }\n\n          /* 4️⃣  store result */\n          nextPages[pageIndex] = keepers;\n        }\n      }\n\n      return { ...state, visibleTiles: nextPages };\n    }\n\n    case MARK_TILE_STATUS: {\n      const { pageIndex, tileId, status } = action.payload;\n      const tiles =\n        state.visibleTiles[pageIndex]?.map((t) =>\n          t.id === tileId ? ({ ...t, status } as Tile) : t,\n        ) ?? [];\n\n      const newTiles = tiles.filter((t) => !t.isFallback);\n      const allReady = newTiles.every((t) => t.status === 'ready');\n      const finalTiles = allReady ? newTiles : tiles;\n\n      return {\n        ...state,\n        visibleTiles: { ...state.visibleTiles, [pageIndex]: finalTiles },\n      };\n    }\n\n    default:\n      return state;\n  }\n};\n","import { Rect, restoreRect, transformSize } from '@embedpdf/models';\nimport { CalculateTilesForPageOptions, Tile } from './types';\n\n/**\n * Build a grid where neighbouring tiles overlap by `overlapPx`\n * (screen pixels). Inner tiles keep the full `tileSize`, edge\n * tiles are clipped to the page bounds. All screen-space values\n * are rounded to **integers** to avoid sub-pixel seams.\n */\nexport function calculateTilesForPage({\n  tileSize = 768,\n  overlapPx = 2.5,\n  extraRings = 0,\n  scale,\n  rotation,\n  page,\n  metric,\n}: CalculateTilesForPageOptions): Tile[] {\n  /* ---- work in screen-pixel space -------------------------------- */\n  const pageW = page.size.width * scale; // px\n  const pageH = page.size.height * scale; // px\n\n  const step = tileSize - overlapPx; // shift between tiles\n\n  const containerSize = transformSize(page.size, rotation, scale);\n  const rotatedVisRect: Rect = {\n    origin: { x: metric.scaled.pageX, y: metric.scaled.pageY },\n    size: { width: metric.scaled.visibleWidth, height: metric.scaled.visibleHeight },\n  };\n  const unrotatedVisRect = restoreRect(containerSize, rotatedVisRect, rotation, 1);\n\n  const visLeft = unrotatedVisRect.origin.x;\n  const visTop = unrotatedVisRect.origin.y;\n  const visRight = visLeft + unrotatedVisRect.size.width;\n  const visBottom = visTop + unrotatedVisRect.size.height;\n\n  const maxCol = Math.floor((pageW - 1) / step);\n  const maxRow = Math.floor((pageH - 1) / step);\n\n  const startCol = Math.max(0, Math.floor(visLeft / step) - extraRings);\n  const endCol = Math.min(maxCol, Math.floor((visRight - 1) / step) + extraRings);\n  const startRow = Math.max(0, Math.floor(visTop / step) - extraRings);\n  const endRow = Math.min(maxRow, Math.floor((visBottom - 1) / step) + extraRings);\n\n  /* ---- build tiles ---------------------------------------------- */\n  const tiles: Tile[] = [];\n\n  for (let col = startCol; col <= endCol; col++) {\n    const xScreen = col * step; // px (integer)\n    const wScreen = Math.min(tileSize, pageW - xScreen); // px (≤  tileSize)\n\n    const xPage = xScreen / scale; // pt (may be frac.)\n    const wPage = wScreen / scale; // pt\n\n    for (let row = startRow; row <= endRow; row++) {\n      const yScreen = row * step;\n      const hScreen = Math.min(tileSize, pageH - yScreen);\n\n      const yPage = yScreen / scale;\n      const hPage = hScreen / scale;\n\n      tiles.push({\n        id: `p${page.index}-${scale}-x${xScreen}-y${yScreen}-w${wScreen}-h${hScreen}`,\n        col,\n        row,\n        pageRect: { origin: { x: xPage, y: yPage }, size: { width: wPage, height: hPage } },\n        screenRect: {\n          origin: { x: xScreen, y: yScreen },\n          size: { width: wScreen, height: hScreen },\n        },\n        status: 'queued',\n        srcScale: scale,\n        isFallback: false,\n      });\n    }\n  }\n\n  return tiles;\n}\n","import {\n  BasePlugin,\n  CoreState,\n  createBehaviorEmitter,\n  PluginRegistry,\n  StoreState,\n} from '@embedpdf/core';\nimport { ignore } from '@embedpdf/models';\nimport { RenderCapability, RenderPlugin } from '@embedpdf/plugin-render';\nimport { ScrollCapability, ScrollMetrics, ScrollPlugin } from '@embedpdf/plugin-scroll';\nimport { ViewportCapability, ViewportPlugin } from '@embedpdf/plugin-viewport';\n\nimport { markTileStatus, updateVisibleTiles } from './actions';\nimport {\n  TilingPluginConfig,\n  TilingCapability,\n  Tile,\n  RenderTileOptions,\n  TilingState,\n} from './types';\nimport { calculateTilesForPage } from './utils';\n\nexport class TilingPlugin extends BasePlugin<TilingPluginConfig, TilingCapability> {\n  static readonly id = 'tiling' as const;\n\n  private readonly tileRendering$ = createBehaviorEmitter<Record<number, Tile[]>>();\n\n  private config: TilingPluginConfig;\n  private renderCapability: RenderCapability;\n  private scrollCapability: ScrollCapability;\n  private viewportCapability: ViewportCapability;\n\n  constructor(id: string, registry: PluginRegistry, config: TilingPluginConfig) {\n    super(id, registry);\n\n    this.config = config;\n\n    this.renderCapability = this.registry.getPlugin<RenderPlugin>('render')!.provides();\n    this.scrollCapability = this.registry.getPlugin<ScrollPlugin>('scroll')!.provides();\n    this.viewportCapability = this.registry.getPlugin<ViewportPlugin>('viewport')!.provides();\n\n    this.scrollCapability.onScroll((scrollMetrics) => this.calculateVisibleTiles(scrollMetrics), {\n      mode: 'throttle',\n      wait: 500,\n      throttleMode: 'trailing',\n    });\n  }\n\n  async initialize(): Promise<void> {\n    // Fetch dependencies from the registry if needed\n  }\n\n  protected onCoreStoreUpdated(\n    oldState: StoreState<CoreState>,\n    newState: StoreState<CoreState>,\n  ): void {\n    if (oldState.core.scale !== newState.core.scale) {\n      this.calculateVisibleTiles(\n        this.scrollCapability.getMetrics(this.viewportCapability.getMetrics()),\n      );\n    }\n  }\n\n  private calculateVisibleTiles(scrollMetrics: ScrollMetrics): void {\n    if (!this.config.enabled) {\n      this.dispatch(updateVisibleTiles([]));\n      return;\n    }\n\n    const scale = this.coreState.core.scale;\n    const rotation = this.coreState.core.rotation;\n    const visibleTiles: { [pageIndex: number]: Tile[] } = {};\n\n    for (const scrollMetric of scrollMetrics.pageVisibilityMetrics) {\n      const pageIndex = scrollMetric.pageNumber - 1; // Convert to 0-based index\n      const page = this.coreState.core.document?.pages[pageIndex];\n      if (!page) continue;\n\n      // Calculate tiles for the page using the utility function\n      const tiles = calculateTilesForPage({\n        page,\n        metric: scrollMetric,\n        scale,\n        rotation,\n        tileSize: this.config.tileSize,\n        overlapPx: this.config.overlapPx,\n        extraRings: this.config.extraRings,\n      });\n\n      visibleTiles[pageIndex] = tiles;\n    }\n\n    this.dispatch(updateVisibleTiles(visibleTiles));\n  }\n\n  override onStoreUpdated(_prevState: TilingState, newState: TilingState): void {\n    this.tileRendering$.emit(newState.visibleTiles);\n  }\n\n  protected buildCapability(): TilingCapability {\n    return {\n      renderTile: this.renderTile.bind(this),\n      onTileRendering: this.tileRendering$.on,\n    };\n  }\n\n  private renderTile(options: RenderTileOptions) {\n    if (!this.renderCapability) {\n      throw new Error('Render capability not available.');\n    }\n\n    this.dispatch(markTileStatus(options.pageIndex, options.tile.id, 'rendering'));\n\n    const task = this.renderCapability.renderPageRect({\n      pageIndex: options.pageIndex,\n      rect: options.tile.pageRect,\n      scaleFactor: options.tile.srcScale,\n      dpr: options.dpr,\n    });\n\n    task.wait(() => {\n      this.dispatch(markTileStatus(options.pageIndex, options.tile.id, 'ready'));\n    }, ignore);\n\n    return task;\n  }\n}\n","import { PluginPackage } from '@embedpdf/core';\n\nimport { TilingAction } from './actions';\nimport { manifest, TILING_PLUGIN_ID } from './manifest';\nimport { initialState, tilingReducer } from './reducer';\nimport { TilingPlugin } from './tiling-plugin';\nimport { TilingPluginConfig, TilingState } from './types';\n\nexport const TilingPluginPackage: PluginPackage<\n  TilingPlugin,\n  TilingPluginConfig,\n  TilingState,\n  TilingAction\n> = {\n  manifest,\n  create: (registry, _engine, config) => new TilingPlugin(TILING_PLUGIN_ID, registry, config),\n  reducer: (state, action) => tilingReducer(state, action),\n  initialState,\n};\n\nexport * from './tiling-plugin';\nexport * from './types';\nexport * from './manifest';\n"],"names":["TILING_PLUGIN_ID","manifest","UPDATE_VISIBLE_TILES","MARK_TILE_STATUS","updateVisibleTiles","tiles","markTileStatus","pageIndex","tileId","status","initialState","tilingReducer","state","action","incoming","nextPages","key","newTiles","prevTiles","prevScale","_a","t","newScale","promoted","fallbackToCarry","newIds","keepers","seenIds","_b","finalTiles","calculateTilesForPage","tileSize","overlapPx","extraRings","scale","rotation","page","metric","pageW","pageH","step","containerSize","transformSize","rotatedVisRect","unrotatedVisRect","restoreRect","visLeft","visTop","visRight","visBottom","maxCol","maxRow","startCol","endCol","startRow","endRow","col","xScreen","wScreen","xPage","wPage","row","yScreen","hScreen","yPage","hPage","_TilingPlugin","BasePlugin","id","registry","config","createBehaviorEmitter","scrollMetrics","oldState","newState","visibleTiles","scrollMetric","_prevState","options","task","ignore","TilingPlugin","TilingPluginPackage","_engine"],"mappings":"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"}