{"version":3,"sources":["../../../core/src/lib/utils/dependency-resolver.ts","../../../core/src/lib/types/errors.ts","../../../core/src/lib/store/plugin-store.ts","../../../core/src/lib/store/actions.ts","../../../core/src/lib/store/store.ts","../../../models/dist/index.js","../../../core/src/lib/store/initial-state.ts","../../../core/src/lib/store/reducer.ts","../../../core/src/lib/registry/plugin-registry.ts","../../../core/src/lib/utils/math.ts","../../../../node_modules/.pnpm/preact@10.26.9/node_modules/preact/compat/dist/compat.module.js","../../../core/src/react/context.ts","../../../core/src/react/components/embed-pdf.tsx","../../../core/src/react/hooks/use-registry.ts","../../../core/src/react/hooks/use-plugin.ts","../../../core/src/react/hooks/use-capability.ts","../../../core/src/react/hooks/use-store-state.ts","../../../core/src/react/hooks/use-core-state.ts","../../src/lib/manifest.ts","../../../core/src/lib/utils/dependency-resolver.ts","../../../core/src/lib/types/errors.ts","../../../core/src/lib/store/plugin-store.ts","../../../core/src/lib/store/actions.ts","../../../core/src/lib/store/store.ts","../../../models/dist/index.js","../../../core/src/lib/store/initial-state.ts","../../../core/src/lib/store/reducer.ts","../../../core/src/lib/registry/plugin-registry.ts","../../../core/src/lib/utils/math.ts","../../../core/src/lib/store/selectors.ts","../../../core/src/lib/utils/plugin-helpers.ts","../../../core/src/lib/base/base-plugin.ts","../../../core/src/lib/utils/event-control.ts","../../../core/src/lib/utils/eventing.ts","../../../core/src/lib/utils/typed-object.ts","../../src/lib/actions.ts","../../src/lib/fullscreen-plugin.ts","../../src/lib/reducer.ts","../../src/lib/index.ts","../../src/react/hooks/use-fullscreen.ts","../../src/react/components/fullscreen.tsx"],"sourcesContent":["export class DependencyResolver {\n  private dependencyGraph = new Map<string, Set<string>>();\n\n  addNode(id: string, dependencies: string[] = []) {\n    this.dependencyGraph.set(id, new Set(dependencies));\n  }\n\n  private hasCircularDependencies(): boolean {\n    const visited = new Set<string>();\n    const recursionStack = new Set<string>();\n\n    const dfs = (id: string): boolean => {\n      visited.add(id);\n      recursionStack.add(id);\n\n      const dependencies = this.dependencyGraph.get(id) || new Set();\n      for (const dep of dependencies) {\n        if (!visited.has(dep)) {\n          if (dfs(dep)) return true;\n        } else if (recursionStack.has(dep)) {\n          return true; // Circular dependency found\n        }\n      }\n\n      recursionStack.delete(id);\n      return false;\n    };\n\n    for (const id of this.dependencyGraph.keys()) {\n      if (!visited.has(id)) {\n        if (dfs(id)) return true;\n      }\n    }\n\n    return false;\n  }\n\n  resolveLoadOrder(): string[] {\n    if (this.hasCircularDependencies()) {\n      throw new Error('Circular dependencies detected');\n    }\n\n    const result: string[] = [];\n    const visited = new Set<string>();\n    const temp = new Set<string>();\n\n    const visit = (id: string) => {\n      if (temp.has(id)) throw new Error('Circular dependency');\n      if (visited.has(id)) return;\n\n      temp.add(id);\n\n      const dependencies = this.dependencyGraph.get(id) || new Set();\n      for (const dep of dependencies) {\n        visit(dep);\n      }\n\n      temp.delete(id);\n      visited.add(id);\n      result.push(id);\n    };\n\n    for (const id of this.dependencyGraph.keys()) {\n      if (!visited.has(id)) {\n        visit(id);\n      }\n    }\n\n    return result;\n  }\n}\n","export class PluginRegistrationError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'PluginRegistrationError';\n  }\n}\n\nexport class PluginNotFoundError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'PluginNotFoundError';\n  }\n}\n\nexport class CircularDependencyError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'CircularDependencyError';\n  }\n}\n\nexport class CapabilityNotFoundError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'CapabilityNotFoundError';\n  }\n}\n\n// You might also want to add:\nexport class CapabilityConflictError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'CapabilityConflictError';\n  }\n}\n\nexport class PluginInitializationError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'PluginInitializationError';\n  }\n}\n\nexport class PluginConfigurationError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'PluginConfigurationError';\n  }\n}\n","import { Store } from './store';\nimport { Action } from './types';\n\n/**\n * A type-safe store handle for plugins, providing access to plugin-specific state and actions.\n */\nexport class PluginStore<PluginState, PluginAction extends Action> {\n  private store: Store<any, any>;\n  private pluginId: string;\n\n  /**\n   * Initializes the PluginStore with the main store and plugin ID.\n   * @param store The main store instance.\n   * @param pluginId The unique identifier for the plugin.\n   */\n  constructor(store: Store<any, any>, pluginId: string) {\n    this.store = store;\n    this.pluginId = pluginId;\n  }\n\n  /**\n   * Gets the current state of the plugin.\n   * @returns The plugin's state.\n   */\n  getState(): PluginState {\n    return this.store.getState().plugins[this.pluginId] as PluginState;\n  }\n\n  /**\n   * Dispatches an action for the plugin and returns the *new* global state.\n   * If you only need the plugin’s updated state, call `getState()` afterward.\n   * @param action The action to dispatch.\n   * @returns The updated global store state (after plugin reducer).\n   */\n  dispatch(action: PluginAction): PluginState {\n    return this.store.dispatchToPlugin(this.pluginId, action);\n  }\n\n  /**\n   * Subscribes to state changes only for this specific plugin.\n   * You now receive (action, newPluginState, oldPluginState) in the callback.\n   *\n   * @param listener The callback to invoke when plugin state changes.\n   * @returns A function to unsubscribe the listener.\n   */\n  subscribeToState(\n    listener: (action: PluginAction, newState: PluginState, oldState: PluginState) => void,\n  ) {\n    return this.store.subscribeToPlugin(this.pluginId, (action, newPluginState, oldPluginState) => {\n      listener(\n        action as PluginAction,\n        newPluginState as PluginState,\n        oldPluginState as PluginState,\n      );\n    });\n  }\n\n  /**\n   * Subscribes to a specific action type for the plugin.\n   * This still uses the main store's `onAction`, so you get the *global*\n   * old/new store states there. If you specifically want old/new plugin state,\n   * use `subscribeToState` instead.\n   *\n   * @param type The action type to listen for.\n   * @param handler The callback to invoke when the action occurs.\n   * @returns A function to unsubscribe the handler.\n   */\n  onAction<T extends PluginAction['type']>(\n    type: T,\n    handler: (\n      action: Extract<PluginAction, { type: T }>,\n      state: PluginState,\n      oldState: PluginState,\n    ) => void,\n  ) {\n    return this.store.onAction(type, (action, state, oldState) => {\n      handler(\n        action as Extract<PluginAction, { type: T }>,\n        state.plugins[this.pluginId] as PluginState,\n        oldState.plugins[this.pluginId] as PluginState,\n      );\n    });\n  }\n}\n","import { PdfDocumentObject, PdfPageObject, Rotation } from '@embedpdf/models';\n\nexport const LOAD_DOCUMENT = 'LOAD_DOCUMENT';\nexport const SET_DOCUMENT = 'SET_DOCUMENT';\nexport const SET_DOCUMENT_ERROR = 'SET_DOCUMENT_ERROR';\nexport const SET_SCALE = 'SET_SCALE';\nexport const SET_ROTATION = 'SET_ROTATION';\nexport const SET_PAGES = 'SET_PAGES';\n\nexport const CORE_ACTION_TYPES = [\n  LOAD_DOCUMENT,\n  SET_DOCUMENT,\n  SET_DOCUMENT_ERROR,\n  SET_SCALE,\n  SET_ROTATION,\n  SET_PAGES,\n] as const;\n\n// Action Type Interfaces\nexport interface LoadDocumentAction {\n  type: typeof LOAD_DOCUMENT;\n}\n\nexport interface SetDocumentAction {\n  type: typeof SET_DOCUMENT;\n  payload: PdfDocumentObject;\n}\n\nexport interface SetDocumentErrorAction {\n  type: typeof SET_DOCUMENT_ERROR;\n  payload: string;\n}\n\nexport interface SetScaleAction {\n  type: typeof SET_SCALE;\n  payload: number;\n}\n\nexport interface SetRotationAction {\n  type: typeof SET_ROTATION;\n  payload: Rotation;\n}\n\nexport interface SetPagesAction {\n  type: typeof SET_PAGES;\n  payload: PdfPageObject[][];\n}\n\nexport type DocumentAction =\n  | LoadDocumentAction\n  | SetDocumentAction\n  | SetDocumentErrorAction\n  | SetScaleAction\n  | SetRotationAction\n  | SetPagesAction;\n\n// Core actions\nexport type CoreAction = DocumentAction;\n\nexport const loadDocument = (): CoreAction => ({ type: LOAD_DOCUMENT });\nexport const setDocument = (document: PdfDocumentObject): CoreAction => ({\n  type: SET_DOCUMENT,\n  payload: document,\n});\nexport const setDocumentError = (error: string): CoreAction => ({\n  type: SET_DOCUMENT_ERROR,\n  payload: error,\n});\nexport const setScale = (scale: number): CoreAction => ({ type: SET_SCALE, payload: scale });\nexport const setRotation = (rotation: Rotation): CoreAction => ({\n  type: SET_ROTATION,\n  payload: rotation,\n});\nexport const setPages = (pages: PdfPageObject[][]): CoreAction => ({\n  type: SET_PAGES,\n  payload: pages,\n});\n","import { Reducer, Action, StoreState, StoreListener, PluginListener } from './types';\nimport { PluginStore } from './plugin-store';\nimport { CORE_ACTION_TYPES } from './actions';\n\n/**\n * A generic, type-safe store class managing core and plugin states, reducers, and subscriptions.\n * @template CoreState The type of the core state.\n * @template CoreAction The type of actions handled by core reducers (extends Action).\n */\nexport class Store<CoreState, CoreAction extends Action = Action> {\n  private state: StoreState<CoreState>;\n  private coreReducer: Reducer<CoreState, CoreAction>;\n  private pluginReducers: Record<string, Reducer<any, Action>> = {};\n\n  private listeners: StoreListener<CoreState>[] = [];\n  private pluginListeners: Record<string, PluginListener[]> = {};\n\n  /**\n   * Initializes the store with the provided core state.\n   * @param reducer          The core reducer function\n   * @param initialCoreState The initial core state\n   */\n  constructor(\n    reducer: Reducer<CoreState, CoreAction>,\n    public initialCoreState: CoreState,\n  ) {\n    this.state = { core: initialCoreState, plugins: {} };\n    this.coreReducer = reducer;\n  }\n\n  /**\n   * Adds a reducer for a plugin-specific state.\n   * @param pluginId The unique identifier for the plugin.\n   * @param reducer The reducer function for the plugin state.\n   * @param initialState The initial state for the plugin.\n   */\n  addPluginReducer<PluginState>(\n    pluginId: string,\n    reducer: Reducer<PluginState, Action>,\n    initialState: PluginState,\n  ) {\n    this.state.plugins[pluginId] = initialState;\n    this.pluginReducers[pluginId] = reducer;\n  }\n\n  /**\n   * Dispatches an action *only* to the core reducer.\n   * Notifies the global store listeners with (action, newState, oldState).\n   *\n   * @param action The action to dispatch, typed as CoreAction\n   * @returns The updated *global* store state\n   */\n  dispatchToCore(action: CoreAction): StoreState<CoreState> {\n    if (!this.coreReducer) {\n      return this.getState();\n    }\n\n    const oldState = this.getState();\n    // Update core state via its reducer\n    this.state.core = this.coreReducer(this.state.core, action);\n\n    const newState = this.getState();\n    // Notify all main-store subscribers\n    this.listeners.forEach((listener) => listener(action, newState, oldState));\n\n    return newState;\n  }\n\n  /**\n   * Dispatches an action *only* to a specific plugin.\n   * Optionally notifies global store listeners if `notifyGlobal` is true.\n   * Always notifies plugin-specific listeners with (action, newPluginState, oldPluginState).\n   *\n   * @param pluginId   The plugin identifier\n   * @param action     The plugin action to dispatch\n   * @param notifyGlobal Whether to also notify global store listeners\n   * @returns The updated *global* store state\n   */\n  dispatchToPlugin<PluginAction extends Action>(\n    pluginId: string,\n    action: PluginAction,\n    notifyGlobal: boolean = true,\n  ): any {\n    const oldGlobalState = this.getState();\n\n    const reducer = this.pluginReducers[pluginId];\n    if (!reducer) {\n      // No plugin found, just return the old state\n      return oldGlobalState;\n    }\n\n    // Grab the old plugin state\n    const oldPluginState = oldGlobalState.plugins[pluginId];\n    // Reduce to new plugin state\n    const newPluginState = reducer(oldPluginState, action);\n    // Update the store's plugin slice\n    this.state.plugins[pluginId] = newPluginState;\n\n    const newGlobalState = this.getState();\n\n    // If we are notifying the main store subscribers about plugin changes\n    if (notifyGlobal) {\n      this.listeners.forEach((listener) => listener(action, newGlobalState, oldGlobalState));\n    }\n\n    // Notify plugin-specific listeners\n    if (this.pluginListeners[pluginId]) {\n      this.pluginListeners[pluginId].forEach((listener) => {\n        listener(action, newPluginState, oldPluginState);\n      });\n    }\n\n    return newPluginState;\n  }\n\n  /**\n   * Dispatches an action to update the state using:\n   * - the core reducer (if it's a CoreAction)\n   * - *all* plugin reducers (regardless of action type), with no global notify for each plugin\n   *\n   * Returns the new *global* store state after all reducers have processed the action.\n   *\n   * @param action The action to dispatch (can be CoreAction or any Action).\n   */\n  dispatch(action: CoreAction | Action): StoreState<CoreState> {\n    // Keep old state to notify global listeners *once*, after all reducers run.\n    const oldState = this.getState();\n    // 1) Apply core reducer (only if action is a CoreAction)\n    if (this.isCoreAction(action)) {\n      this.state.core = this.coreReducer(this.state.core, action);\n    }\n\n    // 2) Apply plugin reducers (without globally notifying after each plugin)\n    for (const pluginId in this.pluginReducers) {\n      const reducer = this.pluginReducers[pluginId];\n      const oldPluginState = oldState.plugins[pluginId];\n      if (reducer) {\n        this.state.plugins[pluginId] = reducer(oldPluginState, action);\n      }\n      // We do *not* notify global listeners or plugin listeners here,\n      // as that might be undesired \"fan-out\". If you want per-plugin subscription\n      // triggered on every dispatch, you can do so here, but that’s up to you.\n    }\n\n    // 3) Notify global listeners *once* with the final new state\n    const newState = this.getState();\n    this.listeners.forEach((listener) => listener(action, newState, oldState));\n\n    // 4) Return the new global store state\n    return newState;\n  }\n\n  /**\n   * Returns a shallow copy of the current state.\n   * @returns The current store state.\n   */\n  getState(): StoreState<CoreState> {\n    return {\n      core: { ...this.state.core },\n      plugins: { ...this.state.plugins },\n    };\n  }\n\n  /**\n   * Subscribes a listener to *global* state changes.\n   * The callback signature is now (action, newState, oldState).\n   *\n   * @param listener The callback to invoke on state changes\n   * @returns A function to unsubscribe the listener\n   */\n  subscribe(listener: StoreListener<CoreState>) {\n    this.listeners.push(listener);\n    return () => {\n      this.listeners = this.listeners.filter((l) => l !== listener);\n    };\n  }\n\n  /**\n   * Subscribes a listener to *plugin-specific* state changes.\n   * The callback signature is now (action, newPluginState, oldPluginState).\n   *\n   * @param pluginId The unique identifier for the plugin.\n   * @param listener The callback to invoke on plugin state changes.\n   * @returns A function to unsubscribe the listener.\n   */\n  subscribeToPlugin(pluginId: string, listener: PluginListener) {\n    if (!(pluginId in this.state.plugins)) {\n      throw new Error(\n        `Plugin state not found for plugin \"${pluginId}\". Did you forget to call addPluginReducer?`,\n      );\n    }\n\n    if (!this.pluginListeners[pluginId]) {\n      this.pluginListeners[pluginId] = [];\n    }\n    this.pluginListeners[pluginId].push(listener);\n\n    return () => {\n      this.pluginListeners[pluginId] = this.pluginListeners[pluginId].filter((l) => l !== listener);\n      if (this.pluginListeners[pluginId].length === 0) {\n        delete this.pluginListeners[pluginId];\n      }\n    };\n  }\n\n  /**\n   * Subscribes to a specific action type (only from the core's action union).\n   * The callback signature is (action, newState, oldState).\n   *\n   * @param type The action type to listen for.\n   * @param handler The callback to invoke when the action occurs.\n   * @returns A function to unsubscribe the handler.\n   */\n  onAction<T extends CoreAction['type']>(\n    type: T,\n    handler: (\n      action: Extract<CoreAction, { type: T }>,\n      state: StoreState<CoreState>,\n      oldState: StoreState<CoreState>,\n    ) => void,\n  ) {\n    return this.subscribe((action, newState, oldState) => {\n      if (action.type === type) {\n        handler(action as Extract<CoreAction, { type: T }>, newState, oldState);\n      }\n    });\n  }\n\n  /**\n   * Gets a PluginStore handle for a specific plugin.\n   * @param pluginId The unique identifier for the plugin.\n   * @returns A PluginStore instance for the plugin.\n   */\n  getPluginStore<PluginState, PluginAction extends Action>(\n    pluginId: string,\n  ): PluginStore<PluginState, PluginAction> {\n    if (!(pluginId in this.state.plugins)) {\n      throw new Error(\n        `Plugin state not found for plugin \"${pluginId}\". Did you forget to call addPluginReducer?`,\n      );\n    }\n    return new PluginStore<PluginState, PluginAction>(this, pluginId);\n  }\n\n  /**\n   * Helper method to check if an action is a CoreAction.\n   * Adjust if you have a more refined way to differentiate CoreAction vs. any other Action.\n   */\n  public isCoreAction(action: Action): action is CoreAction {\n    // In many codebases you'd do something more robust here\n    // or rely on TypeScript's narrowing logic if possible.\n    return CORE_ACTION_TYPES.includes(action.type as (typeof CORE_ACTION_TYPES)[number]);\n  }\n\n  /**\n   * Destroy the store: drop every listener and plugin reducer\n   */\n  public destroy(): void {\n    // 1. empty listener collections\n    this.listeners.length = 0;\n    for (const id in this.pluginListeners) {\n      this.pluginListeners[id]?.splice?.(0);\n    }\n    this.pluginListeners = {};\n\n    // 2. wipe plugin reducers and states\n    this.pluginReducers = {};\n    this.state.plugins = {};\n\n    // 3. reset core state to initial\n    this.state.core = { ...this.initialCoreState };\n  }\n}\n","// src/geometry.ts\nvar Rotation = /* @__PURE__ */ ((Rotation2) => {\n  Rotation2[Rotation2[\"Degree0\"] = 0] = \"Degree0\";\n  Rotation2[Rotation2[\"Degree90\"] = 1] = \"Degree90\";\n  Rotation2[Rotation2[\"Degree180\"] = 2] = \"Degree180\";\n  Rotation2[Rotation2[\"Degree270\"] = 3] = \"Degree270\";\n  return Rotation2;\n})(Rotation || {});\nfunction toIntPos(p) {\n  return { x: Math.floor(p.x), y: Math.floor(p.y) };\n}\nfunction toIntSize(s) {\n  return { width: Math.ceil(s.width), height: Math.ceil(s.height) };\n}\nfunction toIntRect(r) {\n  return {\n    origin: toIntPos(r.origin),\n    size: toIntSize(r.size)\n  };\n}\nfunction calculateDegree(rotation) {\n  switch (rotation) {\n    case 0 /* Degree0 */:\n      return 0;\n    case 1 /* Degree90 */:\n      return 90;\n    case 2 /* Degree180 */:\n      return 180;\n    case 3 /* Degree270 */:\n      return 270;\n  }\n}\nfunction calculateAngle(rotation) {\n  return calculateDegree(rotation) * Math.PI / 180;\n}\nfunction swap(size) {\n  const { width, height } = size;\n  return {\n    width: height,\n    height: width\n  };\n}\nfunction transformSize(size, rotation, scaleFactor) {\n  size = rotation % 2 === 0 ? size : swap(size);\n  return {\n    width: size.width * scaleFactor,\n    height: size.height * scaleFactor\n  };\n}\nfunction quadToRect(q) {\n  const xs = [q.p1.x, q.p2.x, q.p3.x, q.p4.x];\n  const ys = [q.p1.y, q.p2.y, q.p3.y, q.p4.y];\n  return {\n    origin: { x: Math.min(...xs), y: Math.min(...ys) },\n    size: {\n      width: Math.max(...xs) - Math.min(...xs),\n      height: Math.max(...ys) - Math.min(...ys)\n    }\n  };\n}\nfunction rectToQuad(r) {\n  return {\n    p1: { x: r.origin.x, y: r.origin.y },\n    p2: { x: r.origin.x + r.size.width, y: r.origin.y },\n    p3: { x: r.origin.x + r.size.width, y: r.origin.y + r.size.height },\n    p4: { x: r.origin.x, y: r.origin.y + r.size.height }\n  };\n}\nfunction rotatePosition(containerSize, position, rotation) {\n  let x = position.x;\n  let y = position.y;\n  switch (rotation) {\n    case 0 /* Degree0 */:\n      x = position.x;\n      y = position.y;\n      break;\n    case 1 /* Degree90 */:\n      x = containerSize.height - position.y;\n      y = position.x;\n      break;\n    case 2 /* Degree180 */:\n      x = containerSize.width - position.x;\n      y = containerSize.height - position.y;\n      break;\n    case 3 /* Degree270 */:\n      x = position.y;\n      y = containerSize.width - position.x;\n      break;\n  }\n  return {\n    x,\n    y\n  };\n}\nfunction scalePosition(position, scaleFactor) {\n  return {\n    x: position.x * scaleFactor,\n    y: position.y * scaleFactor\n  };\n}\nfunction transformPosition(containerSize, position, rotation, scaleFactor) {\n  return scalePosition(rotatePosition(containerSize, position, rotation), scaleFactor);\n}\nfunction restorePosition(containerSize, position, rotation, scaleFactor) {\n  return scalePosition(\n    rotatePosition(containerSize, position, (4 - rotation) % 4),\n    1 / scaleFactor\n  );\n}\nfunction rotateRect(containerSize, rect, rotation) {\n  let x = rect.origin.x;\n  let y = rect.origin.y;\n  let size = rect.size;\n  switch (rotation) {\n    case 0 /* Degree0 */:\n      break;\n    case 1 /* Degree90 */:\n      x = containerSize.height - rect.origin.y - rect.size.height;\n      y = rect.origin.x;\n      size = swap(rect.size);\n      break;\n    case 2 /* Degree180 */:\n      x = containerSize.width - rect.origin.x - rect.size.width;\n      y = containerSize.height - rect.origin.y - rect.size.height;\n      break;\n    case 3 /* Degree270 */:\n      x = rect.origin.y;\n      y = containerSize.width - rect.origin.x - rect.size.width;\n      size = swap(rect.size);\n      break;\n  }\n  return {\n    origin: {\n      x,\n      y\n    },\n    size: {\n      width: size.width,\n      height: size.height\n    }\n  };\n}\nfunction scaleRect(rect, scaleFactor) {\n  return {\n    origin: {\n      x: rect.origin.x * scaleFactor,\n      y: rect.origin.y * scaleFactor\n    },\n    size: {\n      width: rect.size.width * scaleFactor,\n      height: rect.size.height * scaleFactor\n    }\n  };\n}\nfunction transformRect(containerSize, rect, rotation, scaleFactor) {\n  return scaleRect(rotateRect(containerSize, rect, rotation), scaleFactor);\n}\nfunction restoreRect(containerSize, rect, rotation, scaleFactor) {\n  return scaleRect(rotateRect(containerSize, rect, (4 - rotation) % 4), 1 / scaleFactor);\n}\nfunction restoreOffset(offset, rotation, scaleFactor) {\n  let offsetX = offset.x;\n  let offsetY = offset.y;\n  switch (rotation) {\n    case 0 /* Degree0 */:\n      offsetX = offset.x / scaleFactor;\n      offsetY = offset.y / scaleFactor;\n      break;\n    case 1 /* Degree90 */:\n      offsetX = offset.y / scaleFactor;\n      offsetY = -offset.x / scaleFactor;\n      break;\n    case 2 /* Degree180 */:\n      offsetX = -offset.x / scaleFactor;\n      offsetY = -offset.y / scaleFactor;\n      break;\n    case 3 /* Degree270 */:\n      offsetX = -offset.y / scaleFactor;\n      offsetY = offset.x / scaleFactor;\n      break;\n  }\n  return {\n    x: offsetX,\n    y: offsetY\n  };\n}\nfunction boundingRect(rects) {\n  if (rects.length === 0) return null;\n  let minX = rects[0].origin.x, minY = rects[0].origin.y, maxX = rects[0].origin.x + rects[0].size.width, maxY = rects[0].origin.y + rects[0].size.height;\n  for (const r of rects) {\n    minX = Math.min(minX, r.origin.x);\n    minY = Math.min(minY, r.origin.y);\n    maxX = Math.max(maxX, r.origin.x + r.size.width);\n    maxY = Math.max(maxY, r.origin.y + r.size.height);\n  }\n  return {\n    origin: {\n      x: minX,\n      y: minY\n    },\n    size: {\n      width: maxX - minX,\n      height: maxY - minY\n    }\n  };\n}\nvar makeMatrix = (rectangle, rotation, scaleFactor) => {\n  const { width, height } = rectangle.size;\n  switch (rotation) {\n    case 0 /* Degree0 */:\n      return {\n        a: scaleFactor,\n        b: 0,\n        c: 0,\n        d: -scaleFactor,\n        e: 0,\n        f: height * scaleFactor\n      };\n    case 1 /* Degree90 */:\n      return {\n        a: 0,\n        b: scaleFactor,\n        c: scaleFactor,\n        d: 0,\n        e: 0,\n        f: 0\n      };\n    case 2 /* Degree180 */:\n      return {\n        a: -scaleFactor,\n        b: 0,\n        c: 0,\n        d: scaleFactor,\n        e: width * scaleFactor,\n        f: 0\n      };\n    case 3 /* Degree270 */:\n      return {\n        a: 0,\n        b: -scaleFactor,\n        c: -scaleFactor,\n        d: 0,\n        e: height * scaleFactor,\n        f: width * scaleFactor\n      };\n  }\n};\n\n// src/logger.ts\nvar NoopLogger = class {\n  /** {@inheritDoc Logger.debug} */\n  debug() {\n  }\n  /** {@inheritDoc Logger.info} */\n  info() {\n  }\n  /** {@inheritDoc Logger.warn} */\n  warn() {\n  }\n  /** {@inheritDoc Logger.error} */\n  error() {\n  }\n  /** {@inheritDoc Logger.perf} */\n  perf() {\n  }\n};\nvar ConsoleLogger = class {\n  /** {@inheritDoc Logger.debug} */\n  debug(source, category, ...args) {\n    console.debug(`${source}.${category}`, ...args);\n  }\n  /** {@inheritDoc Logger.info} */\n  info(source, category, ...args) {\n    console.info(`${source}.${category}`, ...args);\n  }\n  /** {@inheritDoc Logger.warn} */\n  warn(source, category, ...args) {\n    console.warn(`${source}.${category}`, ...args);\n  }\n  /** {@inheritDoc Logger.error} */\n  error(source, category, ...args) {\n    console.error(`${source}.${category}`, ...args);\n  }\n  /** {@inheritDoc Logger.perf} */\n  perf(source, category, event, phase, ...args) {\n    console.info(`${source}.${category}.${event}.${phase}`, ...args);\n  }\n};\nvar LogLevel = /* @__PURE__ */ ((LogLevel2) => {\n  LogLevel2[LogLevel2[\"Debug\"] = 0] = \"Debug\";\n  LogLevel2[LogLevel2[\"Info\"] = 1] = \"Info\";\n  LogLevel2[LogLevel2[\"Warn\"] = 2] = \"Warn\";\n  LogLevel2[LogLevel2[\"Error\"] = 3] = \"Error\";\n  return LogLevel2;\n})(LogLevel || {});\nvar LevelLogger = class {\n  /**\n   * create new LevelLogger\n   * @param logger - the original logger\n   * @param level - log level that used for filtering, all logs lower than this level will be filtered out\n   */\n  constructor(logger, level) {\n    this.logger = logger;\n    this.level = level;\n  }\n  /** {@inheritDoc Logger.debug} */\n  debug(source, category, ...args) {\n    if (this.level <= 0 /* Debug */) {\n      this.logger.debug(source, category, ...args);\n    }\n  }\n  /** {@inheritDoc Logger.info} */\n  info(source, category, ...args) {\n    if (this.level <= 1 /* Info */) {\n      this.logger.info(source, category, ...args);\n    }\n  }\n  /** {@inheritDoc Logger.warn} */\n  warn(source, category, ...args) {\n    if (this.level <= 2 /* Warn */) {\n      this.logger.warn(source, category, ...args);\n    }\n  }\n  /** {@inheritDoc Logger.error} */\n  error(source, category, ...args) {\n    if (this.level <= 3 /* Error */) {\n      this.logger.error(source, category, ...args);\n    }\n  }\n  /** {@inheritDoc Logger.perf} */\n  perf(source, category, event, phase, ...args) {\n    this.logger.perf(source, category, event, phase, ...args);\n  }\n};\nvar PerfLogger = class {\n  /**\n   * create new PerfLogger\n   */\n  constructor() {\n  }\n  /** {@inheritDoc Logger.debug} */\n  debug(source, category, ...args) {\n  }\n  /** {@inheritDoc Logger.info} */\n  info(source, category, ...args) {\n  }\n  /** {@inheritDoc Logger.warn} */\n  warn(source, category, ...args) {\n  }\n  /** {@inheritDoc Logger.error} */\n  error(source, category, ...args) {\n  }\n  /** {@inheritDoc Logger.perf} */\n  perf(source, category, event, phase, identifier, ...args) {\n    switch (phase) {\n      case \"Begin\":\n        window.performance.mark(`${source}.${category}.${event}.${phase}.${identifier}`, {\n          detail: args\n        });\n        break;\n      case \"End\":\n        window.performance.mark(`${source}.${category}.${event}.${phase}.${identifier}`, {\n          detail: args\n        });\n        window.performance.measure(\n          `${source}.${category}.${event}.Measure.${identifier}`,\n          `${source}.${category}.${event}.Begin.${identifier}`,\n          `${source}.${category}.${event}.End.${identifier}`\n        );\n        break;\n    }\n  }\n};\nvar AllLogger = class {\n  /**\n   * create new PerfLogger\n   */\n  constructor(loggers) {\n    this.loggers = loggers;\n  }\n  /** {@inheritDoc Logger.debug} */\n  debug(source, category, ...args) {\n    for (const logger of this.loggers) {\n      logger.debug(source, category, ...args);\n    }\n  }\n  /** {@inheritDoc Logger.info} */\n  info(source, category, ...args) {\n    for (const logger of this.loggers) {\n      logger.info(source, category, ...args);\n    }\n  }\n  /** {@inheritDoc Logger.warn} */\n  warn(source, category, ...args) {\n    for (const logger of this.loggers) {\n      logger.warn(source, category, ...args);\n    }\n  }\n  /** {@inheritDoc Logger.error} */\n  error(source, category, ...args) {\n    for (const logger of this.loggers) {\n      logger.error(source, category, ...args);\n    }\n  }\n  /** {@inheritDoc Logger.perf} */\n  perf(source, category, event, phase, ...args) {\n    for (const logger of this.loggers) {\n      logger.perf(source, category, event, phase, ...args);\n    }\n  }\n};\n\n// src/task.ts\nvar TaskStage = /* @__PURE__ */ ((TaskStage2) => {\n  TaskStage2[TaskStage2[\"Pending\"] = 0] = \"Pending\";\n  TaskStage2[TaskStage2[\"Resolved\"] = 1] = \"Resolved\";\n  TaskStage2[TaskStage2[\"Rejected\"] = 2] = \"Rejected\";\n  TaskStage2[TaskStage2[\"Aborted\"] = 3] = \"Aborted\";\n  return TaskStage2;\n})(TaskStage || {});\nvar TaskAbortedError = class extends Error {\n  constructor(reason) {\n    super(`Task aborted: ${JSON.stringify(reason)}`);\n    this.name = \"TaskAbortedError\";\n  }\n};\nvar TaskRejectedError = class extends Error {\n  constructor(reason) {\n    super(`Task rejected: ${JSON.stringify(reason)}`);\n    this.name = \"TaskRejectedError\";\n  }\n};\nvar Task = class _Task {\n  constructor() {\n    this.state = {\n      stage: 0 /* Pending */\n    };\n    /**\n     * callbacks that will be executed when task is resolved\n     */\n    this.resolvedCallbacks = [];\n    /**\n     * callbacks that will be executed when task is rejected\n     */\n    this.rejectedCallbacks = [];\n    /**\n     * Promise that will be resolved when task is settled\n     */\n    this._promise = null;\n  }\n  /**\n   * Convert task to promise\n   * @returns promise that will be resolved when task is settled\n   */\n  toPromise() {\n    if (!this._promise) {\n      this._promise = new Promise((resolve, reject) => {\n        this.wait(\n          (result) => resolve(result),\n          (error) => {\n            if (error.type === \"abort\") {\n              reject(new TaskAbortedError(error.reason));\n            } else {\n              reject(new TaskRejectedError(error.reason));\n            }\n          }\n        );\n      });\n    }\n    return this._promise;\n  }\n  /**\n   * wait for task to be settled\n   * @param resolvedCallback - callback for resolved value\n   * @param rejectedCallback - callback for rejected value\n   */\n  wait(resolvedCallback, rejectedCallback) {\n    switch (this.state.stage) {\n      case 0 /* Pending */:\n        this.resolvedCallbacks.push(resolvedCallback);\n        this.rejectedCallbacks.push(rejectedCallback);\n        break;\n      case 1 /* Resolved */:\n        resolvedCallback(this.state.result);\n        break;\n      case 2 /* Rejected */:\n        rejectedCallback({\n          type: \"reject\",\n          reason: this.state.reason\n        });\n        break;\n      case 3 /* Aborted */:\n        rejectedCallback({\n          type: \"abort\",\n          reason: this.state.reason\n        });\n        break;\n    }\n  }\n  /**\n   * resolve task with specific result\n   * @param result - result value\n   */\n  resolve(result) {\n    if (this.state.stage === 0 /* Pending */) {\n      this.state = {\n        stage: 1 /* Resolved */,\n        result\n      };\n      for (const resolvedCallback of this.resolvedCallbacks) {\n        try {\n          resolvedCallback(result);\n        } catch (e) {\n        }\n      }\n      this.resolvedCallbacks = [];\n      this.rejectedCallbacks = [];\n    }\n  }\n  /**\n   * reject task with specific reason\n   * @param reason - abort reason\n   *\n   */\n  reject(reason) {\n    if (this.state.stage === 0 /* Pending */) {\n      this.state = {\n        stage: 2 /* Rejected */,\n        reason\n      };\n      for (const rejectedCallback of this.rejectedCallbacks) {\n        try {\n          rejectedCallback({\n            type: \"reject\",\n            reason\n          });\n        } catch (e) {\n        }\n      }\n      this.resolvedCallbacks = [];\n      this.rejectedCallbacks = [];\n    }\n  }\n  /**\n   * abort task with specific reason\n   * @param reason - abort reason\n   */\n  abort(reason) {\n    if (this.state.stage === 0 /* Pending */) {\n      this.state = {\n        stage: 3 /* Aborted */,\n        reason\n      };\n      for (const rejectedCallback of this.rejectedCallbacks) {\n        try {\n          rejectedCallback({\n            type: \"abort\",\n            reason\n          });\n        } catch (e) {\n        }\n      }\n      this.resolvedCallbacks = [];\n      this.rejectedCallbacks = [];\n    }\n  }\n  /**\n   * fail task with a TaskError from another task\n   * This is a convenience method for error propagation between tasks\n   * @param error - TaskError from another task\n   */\n  fail(error) {\n    if (error.type === \"abort\") {\n      this.abort(error.reason);\n    } else {\n      this.reject(error.reason);\n    }\n  }\n  /**\n   * Static method to wait for all tasks to resolve\n   * Returns a new task that resolves with an array of all results\n   * Rejects immediately if any task fails\n   *\n   * @param tasks - array of tasks to wait for\n   * @returns new task that resolves when all input tasks resolve\n   * @public\n   */\n  static all(tasks) {\n    const combinedTask = new _Task();\n    if (tasks.length === 0) {\n      combinedTask.resolve([]);\n      return combinedTask;\n    }\n    const results = new Array(tasks.length);\n    let resolvedCount = 0;\n    let isSettled = false;\n    tasks.forEach((task, index) => {\n      task.wait(\n        (result) => {\n          if (isSettled) return;\n          results[index] = result;\n          resolvedCount++;\n          if (resolvedCount === tasks.length) {\n            isSettled = true;\n            combinedTask.resolve(results);\n          }\n        },\n        (error) => {\n          if (isSettled) return;\n          isSettled = true;\n          if (error.type === \"abort\") {\n            combinedTask.abort(error.reason);\n          } else {\n            combinedTask.reject(error.reason);\n          }\n        }\n      );\n    });\n    return combinedTask;\n  }\n  /**\n   * Static method to wait for all tasks to settle (resolve, reject, or abort)\n   * Always resolves with an array of settlement results\n   *\n   * @param tasks - array of tasks to wait for\n   * @returns new task that resolves when all input tasks settle\n   * @public\n   */\n  static allSettled(tasks) {\n    const combinedTask = new _Task();\n    if (tasks.length === 0) {\n      combinedTask.resolve([]);\n      return combinedTask;\n    }\n    const results = new Array(tasks.length);\n    let settledCount = 0;\n    tasks.forEach((task, index) => {\n      task.wait(\n        (result) => {\n          results[index] = { status: \"resolved\", value: result };\n          settledCount++;\n          if (settledCount === tasks.length) {\n            combinedTask.resolve(results);\n          }\n        },\n        (error) => {\n          results[index] = {\n            status: error.type === \"abort\" ? \"aborted\" : \"rejected\",\n            reason: error.reason\n          };\n          settledCount++;\n          if (settledCount === tasks.length) {\n            combinedTask.resolve(results);\n          }\n        }\n      );\n    });\n    return combinedTask;\n  }\n  /**\n   * Static method that resolves/rejects with the first task that settles\n   *\n   * @param tasks - array of tasks to race\n   * @returns new task that settles with the first input task that settles\n   * @public\n   */\n  static race(tasks) {\n    const combinedTask = new _Task();\n    if (tasks.length === 0) {\n      combinedTask.reject(\"No tasks provided\");\n      return combinedTask;\n    }\n    let isSettled = false;\n    tasks.forEach((task) => {\n      task.wait(\n        (result) => {\n          if (isSettled) return;\n          isSettled = true;\n          combinedTask.resolve(result);\n        },\n        (error) => {\n          if (isSettled) return;\n          isSettled = true;\n          if (error.type === \"abort\") {\n            combinedTask.abort(error.reason);\n          } else {\n            combinedTask.reject(error.reason);\n          }\n        }\n      );\n    });\n    return combinedTask;\n  }\n  /**\n   * Utility to track progress of multiple tasks\n   *\n   * @param tasks - array of tasks to track\n   * @param onProgress - callback called when any task completes\n   * @returns new task that resolves when all input tasks resolve\n   * @public\n   */\n  static withProgress(tasks, onProgress) {\n    const combinedTask = _Task.all(tasks);\n    if (onProgress) {\n      let completedCount = 0;\n      tasks.forEach((task) => {\n        task.wait(\n          () => {\n            completedCount++;\n            onProgress(completedCount, tasks.length);\n          },\n          () => {\n            completedCount++;\n            onProgress(completedCount, tasks.length);\n          }\n        );\n      });\n    }\n    return combinedTask;\n  }\n};\n\n// src/pdf.ts\nvar PdfSoftHyphenMarker = \"\\xAD\";\nvar PdfZeroWidthSpace = \"\\u200B\";\nvar PdfWordJoiner = \"\\u2060\";\nvar PdfBomOrZwnbsp = \"\\uFEFF\";\nvar PdfNonCharacterFFFE = \"\\uFFFE\";\nvar PdfNonCharacterFFFF = \"\\uFFFF\";\nvar PdfUnwantedTextMarkers = Object.freeze([\n  PdfSoftHyphenMarker,\n  PdfZeroWidthSpace,\n  PdfWordJoiner,\n  PdfBomOrZwnbsp,\n  PdfNonCharacterFFFE,\n  PdfNonCharacterFFFF\n]);\nvar PdfUnwantedTextRegex = new RegExp(`[${PdfUnwantedTextMarkers.join(\"\")}]`, \"g\");\nfunction stripPdfUnwantedMarkers(text) {\n  return text.replace(PdfUnwantedTextRegex, \"\");\n}\nvar PdfZoomMode = /* @__PURE__ */ ((PdfZoomMode2) => {\n  PdfZoomMode2[PdfZoomMode2[\"Unknown\"] = 0] = \"Unknown\";\n  PdfZoomMode2[PdfZoomMode2[\"XYZ\"] = 1] = \"XYZ\";\n  PdfZoomMode2[PdfZoomMode2[\"FitPage\"] = 2] = \"FitPage\";\n  PdfZoomMode2[PdfZoomMode2[\"FitHorizontal\"] = 3] = \"FitHorizontal\";\n  PdfZoomMode2[PdfZoomMode2[\"FitVertical\"] = 4] = \"FitVertical\";\n  PdfZoomMode2[PdfZoomMode2[\"FitRectangle\"] = 5] = \"FitRectangle\";\n  return PdfZoomMode2;\n})(PdfZoomMode || {});\nvar PdfBlendMode = /* @__PURE__ */ ((PdfBlendMode2) => {\n  PdfBlendMode2[PdfBlendMode2[\"Normal\"] = 0] = \"Normal\";\n  PdfBlendMode2[PdfBlendMode2[\"Multiply\"] = 1] = \"Multiply\";\n  PdfBlendMode2[PdfBlendMode2[\"Screen\"] = 2] = \"Screen\";\n  PdfBlendMode2[PdfBlendMode2[\"Overlay\"] = 3] = \"Overlay\";\n  PdfBlendMode2[PdfBlendMode2[\"Darken\"] = 4] = \"Darken\";\n  PdfBlendMode2[PdfBlendMode2[\"Lighten\"] = 5] = \"Lighten\";\n  PdfBlendMode2[PdfBlendMode2[\"ColorDodge\"] = 6] = \"ColorDodge\";\n  PdfBlendMode2[PdfBlendMode2[\"ColorBurn\"] = 7] = \"ColorBurn\";\n  PdfBlendMode2[PdfBlendMode2[\"HardLight\"] = 8] = \"HardLight\";\n  PdfBlendMode2[PdfBlendMode2[\"SoftLight\"] = 9] = \"SoftLight\";\n  PdfBlendMode2[PdfBlendMode2[\"Difference\"] = 10] = \"Difference\";\n  PdfBlendMode2[PdfBlendMode2[\"Exclusion\"] = 11] = \"Exclusion\";\n  PdfBlendMode2[PdfBlendMode2[\"Hue\"] = 12] = \"Hue\";\n  PdfBlendMode2[PdfBlendMode2[\"Saturation\"] = 13] = \"Saturation\";\n  PdfBlendMode2[PdfBlendMode2[\"Color\"] = 14] = \"Color\";\n  PdfBlendMode2[PdfBlendMode2[\"Luminosity\"] = 15] = \"Luminosity\";\n  return PdfBlendMode2;\n})(PdfBlendMode || {});\nvar MixedBlendMode = Symbol(\"mixed\");\nvar BLEND_MODE_INFOS = Object.freeze([\n  { id: 0 /* Normal */, label: \"Normal\", css: \"normal\" },\n  { id: 1 /* Multiply */, label: \"Multiply\", css: \"multiply\" },\n  { id: 2 /* Screen */, label: \"Screen\", css: \"screen\" },\n  { id: 3 /* Overlay */, label: \"Overlay\", css: \"overlay\" },\n  { id: 4 /* Darken */, label: \"Darken\", css: \"darken\" },\n  { id: 5 /* Lighten */, label: \"Lighten\", css: \"lighten\" },\n  { id: 6 /* ColorDodge */, label: \"Color Dodge\", css: \"color-dodge\" },\n  { id: 7 /* ColorBurn */, label: \"Color Burn\", css: \"color-burn\" },\n  { id: 8 /* HardLight */, label: \"Hard Light\", css: \"hard-light\" },\n  { id: 9 /* SoftLight */, label: \"Soft Light\", css: \"soft-light\" },\n  { id: 10 /* Difference */, label: \"Difference\", css: \"difference\" },\n  { id: 11 /* Exclusion */, label: \"Exclusion\", css: \"exclusion\" },\n  { id: 12 /* Hue */, label: \"Hue\", css: \"hue\" },\n  { id: 13 /* Saturation */, label: \"Saturation\", css: \"saturation\" },\n  { id: 14 /* Color */, label: \"Color\", css: \"color\" },\n  { id: 15 /* Luminosity */, label: \"Luminosity\", css: \"luminosity\" }\n]);\nvar enumToInfo = BLEND_MODE_INFOS.reduce(\n  (m, info) => {\n    m[info.id] = info;\n    return m;\n  },\n  {}\n);\nvar cssToEnum = BLEND_MODE_INFOS.reduce((m, info) => {\n  m[info.css] = info.id;\n  return m;\n}, {});\nfunction getBlendModeInfo(mode) {\n  return enumToInfo[mode] ?? enumToInfo[0 /* Normal */];\n}\nfunction blendModeToCss(mode) {\n  return getBlendModeInfo(mode).css;\n}\nfunction cssToBlendMode(value) {\n  return cssToEnum[value];\n}\nfunction blendModeLabel(mode) {\n  return getBlendModeInfo(mode).label;\n}\nfunction reduceBlendModes(modes) {\n  if (!modes.length) return 0 /* Normal */;\n  const first = modes[0];\n  return modes.every((m) => m === first) ? first : MixedBlendMode;\n}\nvar blendModeSelectOptions = BLEND_MODE_INFOS.map((info) => ({\n  value: info.id,\n  label: info.label\n}));\nfunction uiBlendModeDisplay(value) {\n  return value === MixedBlendMode ? \"(mixed)\" : blendModeLabel(value);\n}\nvar PdfActionType = /* @__PURE__ */ ((PdfActionType2) => {\n  PdfActionType2[PdfActionType2[\"Unsupported\"] = 0] = \"Unsupported\";\n  PdfActionType2[PdfActionType2[\"Goto\"] = 1] = \"Goto\";\n  PdfActionType2[PdfActionType2[\"RemoteGoto\"] = 2] = \"RemoteGoto\";\n  PdfActionType2[PdfActionType2[\"URI\"] = 3] = \"URI\";\n  PdfActionType2[PdfActionType2[\"LaunchAppOrOpenFile\"] = 4] = \"LaunchAppOrOpenFile\";\n  return PdfActionType2;\n})(PdfActionType || {});\nvar PdfAnnotationSubtype = /* @__PURE__ */ ((PdfAnnotationSubtype2) => {\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"TEXT\"] = 1] = \"TEXT\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"LINK\"] = 2] = \"LINK\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"FREETEXT\"] = 3] = \"FREETEXT\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"LINE\"] = 4] = \"LINE\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"SQUARE\"] = 5] = \"SQUARE\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"CIRCLE\"] = 6] = \"CIRCLE\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"POLYGON\"] = 7] = \"POLYGON\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"POLYLINE\"] = 8] = \"POLYLINE\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"HIGHLIGHT\"] = 9] = \"HIGHLIGHT\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"UNDERLINE\"] = 10] = \"UNDERLINE\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"SQUIGGLY\"] = 11] = \"SQUIGGLY\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"STRIKEOUT\"] = 12] = \"STRIKEOUT\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"STAMP\"] = 13] = \"STAMP\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"CARET\"] = 14] = \"CARET\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"INK\"] = 15] = \"INK\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"POPUP\"] = 16] = \"POPUP\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"FILEATTACHMENT\"] = 17] = \"FILEATTACHMENT\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"SOUND\"] = 18] = \"SOUND\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"MOVIE\"] = 19] = \"MOVIE\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"WIDGET\"] = 20] = \"WIDGET\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"SCREEN\"] = 21] = \"SCREEN\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"PRINTERMARK\"] = 22] = \"PRINTERMARK\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"TRAPNET\"] = 23] = \"TRAPNET\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"WATERMARK\"] = 24] = \"WATERMARK\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"THREED\"] = 25] = \"THREED\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"RICHMEDIA\"] = 26] = \"RICHMEDIA\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"XFAWIDGET\"] = 27] = \"XFAWIDGET\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"REDACT\"] = 28] = \"REDACT\";\n  return PdfAnnotationSubtype2;\n})(PdfAnnotationSubtype || {});\nvar PdfAnnotationSubtypeName = {\n  [0 /* UNKNOWN */]: \"unknow\",\n  [1 /* TEXT */]: \"text\",\n  [2 /* LINK */]: \"link\",\n  [3 /* FREETEXT */]: \"freetext\",\n  [4 /* LINE */]: \"line\",\n  [5 /* SQUARE */]: \"square\",\n  [6 /* CIRCLE */]: \"circle\",\n  [7 /* POLYGON */]: \"polygon\",\n  [8 /* POLYLINE */]: \"polyline\",\n  [9 /* HIGHLIGHT */]: \"highlight\",\n  [10 /* UNDERLINE */]: \"underline\",\n  [11 /* SQUIGGLY */]: \"squiggly\",\n  [12 /* STRIKEOUT */]: \"strikeout\",\n  [13 /* STAMP */]: \"stamp\",\n  [14 /* CARET */]: \"caret\",\n  [15 /* INK */]: \"ink\",\n  [16 /* POPUP */]: \"popup\",\n  [17 /* FILEATTACHMENT */]: \"fileattachment\",\n  [18 /* SOUND */]: \"sound\",\n  [19 /* MOVIE */]: \"movie\",\n  [20 /* WIDGET */]: \"widget\",\n  [21 /* SCREEN */]: \"screen\",\n  [22 /* PRINTERMARK */]: \"printermark\",\n  [23 /* TRAPNET */]: \"trapnet\",\n  [24 /* WATERMARK */]: \"watermark\",\n  [25 /* THREED */]: \"threed\",\n  [26 /* RICHMEDIA */]: \"richmedia\",\n  [27 /* XFAWIDGET */]: \"xfawidget\",\n  [28 /* REDACT */]: \"redact\"\n};\nvar PdfAnnotationObjectStatus = /* @__PURE__ */ ((PdfAnnotationObjectStatus2) => {\n  PdfAnnotationObjectStatus2[PdfAnnotationObjectStatus2[\"Created\"] = 0] = \"Created\";\n  PdfAnnotationObjectStatus2[PdfAnnotationObjectStatus2[\"Committed\"] = 1] = \"Committed\";\n  return PdfAnnotationObjectStatus2;\n})(PdfAnnotationObjectStatus || {});\nvar AppearanceMode = /* @__PURE__ */ ((AppearanceMode2) => {\n  AppearanceMode2[AppearanceMode2[\"Normal\"] = 0] = \"Normal\";\n  AppearanceMode2[AppearanceMode2[\"Rollover\"] = 1] = \"Rollover\";\n  AppearanceMode2[AppearanceMode2[\"Down\"] = 2] = \"Down\";\n  return AppearanceMode2;\n})(AppearanceMode || {});\nvar PdfAnnotationState = /* @__PURE__ */ ((PdfAnnotationState2) => {\n  PdfAnnotationState2[\"Marked\"] = \"Marked\";\n  PdfAnnotationState2[\"Unmarked\"] = \"Unmarked\";\n  PdfAnnotationState2[\"Accepted\"] = \"Accepted\";\n  PdfAnnotationState2[\"Rejected\"] = \"Rejected\";\n  PdfAnnotationState2[\"Complete\"] = \"Complete\";\n  PdfAnnotationState2[\"Cancelled\"] = \"Cancelled\";\n  PdfAnnotationState2[\"None\"] = \"None\";\n  return PdfAnnotationState2;\n})(PdfAnnotationState || {});\nvar PdfAnnotationStateModel = /* @__PURE__ */ ((PdfAnnotationStateModel2) => {\n  PdfAnnotationStateModel2[\"Marked\"] = \"Marked\";\n  PdfAnnotationStateModel2[\"Reviewed\"] = \"Reviewed\";\n  return PdfAnnotationStateModel2;\n})(PdfAnnotationStateModel || {});\nvar PDF_FORM_FIELD_TYPE = /* @__PURE__ */ ((PDF_FORM_FIELD_TYPE2) => {\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"PUSHBUTTON\"] = 1] = \"PUSHBUTTON\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"CHECKBOX\"] = 2] = \"CHECKBOX\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"RADIOBUTTON\"] = 3] = \"RADIOBUTTON\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"COMBOBOX\"] = 4] = \"COMBOBOX\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"LISTBOX\"] = 5] = \"LISTBOX\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"TEXTFIELD\"] = 6] = \"TEXTFIELD\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"SIGNATURE\"] = 7] = \"SIGNATURE\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"XFA\"] = 8] = \"XFA\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"XFA_CHECKBOX\"] = 9] = \"XFA_CHECKBOX\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"XFA_COMBOBOX\"] = 10] = \"XFA_COMBOBOX\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"XFA_IMAGEFIELD\"] = 11] = \"XFA_IMAGEFIELD\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"XFA_LISTBOX\"] = 12] = \"XFA_LISTBOX\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"XFA_PUSHBUTTON\"] = 13] = \"XFA_PUSHBUTTON\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"XFA_SIGNATURE\"] = 14] = \"XFA_SIGNATURE\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"XFA_TEXTFIELD\"] = 15] = \"XFA_TEXTFIELD\";\n  return PDF_FORM_FIELD_TYPE2;\n})(PDF_FORM_FIELD_TYPE || {});\nvar PdfAnnotationColorType = /* @__PURE__ */ ((PdfAnnotationColorType2) => {\n  PdfAnnotationColorType2[PdfAnnotationColorType2[\"Color\"] = 0] = \"Color\";\n  PdfAnnotationColorType2[PdfAnnotationColorType2[\"InteriorColor\"] = 1] = \"InteriorColor\";\n  return PdfAnnotationColorType2;\n})(PdfAnnotationColorType || {});\nvar PdfAnnotationBorderStyle = /* @__PURE__ */ ((PdfAnnotationBorderStyle2) => {\n  PdfAnnotationBorderStyle2[PdfAnnotationBorderStyle2[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n  PdfAnnotationBorderStyle2[PdfAnnotationBorderStyle2[\"SOLID\"] = 1] = \"SOLID\";\n  PdfAnnotationBorderStyle2[PdfAnnotationBorderStyle2[\"DASHED\"] = 2] = \"DASHED\";\n  PdfAnnotationBorderStyle2[PdfAnnotationBorderStyle2[\"BEVELED\"] = 3] = \"BEVELED\";\n  PdfAnnotationBorderStyle2[PdfAnnotationBorderStyle2[\"INSET\"] = 4] = \"INSET\";\n  PdfAnnotationBorderStyle2[PdfAnnotationBorderStyle2[\"UNDERLINE\"] = 5] = \"UNDERLINE\";\n  PdfAnnotationBorderStyle2[PdfAnnotationBorderStyle2[\"CLOUDY\"] = 6] = \"CLOUDY\";\n  return PdfAnnotationBorderStyle2;\n})(PdfAnnotationBorderStyle || {});\nvar PdfAnnotationFlags = /* @__PURE__ */ ((PdfAnnotationFlags2) => {\n  PdfAnnotationFlags2[PdfAnnotationFlags2[\"NONE\"] = 0] = \"NONE\";\n  PdfAnnotationFlags2[PdfAnnotationFlags2[\"INVISIBLE\"] = 1] = \"INVISIBLE\";\n  PdfAnnotationFlags2[PdfAnnotationFlags2[\"HIDDEN\"] = 2] = \"HIDDEN\";\n  PdfAnnotationFlags2[PdfAnnotationFlags2[\"PRINT\"] = 4] = \"PRINT\";\n  PdfAnnotationFlags2[PdfAnnotationFlags2[\"NO_ZOOM\"] = 8] = \"NO_ZOOM\";\n  PdfAnnotationFlags2[PdfAnnotationFlags2[\"NO_ROTATE\"] = 16] = \"NO_ROTATE\";\n  PdfAnnotationFlags2[PdfAnnotationFlags2[\"NO_VIEW\"] = 32] = \"NO_VIEW\";\n  PdfAnnotationFlags2[PdfAnnotationFlags2[\"READ_ONLY\"] = 64] = \"READ_ONLY\";\n  PdfAnnotationFlags2[PdfAnnotationFlags2[\"LOCKED\"] = 128] = \"LOCKED\";\n  PdfAnnotationFlags2[PdfAnnotationFlags2[\"TOGGLE_NOVIEW\"] = 256] = \"TOGGLE_NOVIEW\";\n  return PdfAnnotationFlags2;\n})(PdfAnnotationFlags || {});\nvar PDF_FORM_FIELD_FLAG = /* @__PURE__ */ ((PDF_FORM_FIELD_FLAG2) => {\n  PDF_FORM_FIELD_FLAG2[PDF_FORM_FIELD_FLAG2[\"NONE\"] = 0] = \"NONE\";\n  PDF_FORM_FIELD_FLAG2[PDF_FORM_FIELD_FLAG2[\"READONLY\"] = 1] = \"READONLY\";\n  PDF_FORM_FIELD_FLAG2[PDF_FORM_FIELD_FLAG2[\"REQUIRED\"] = 2] = \"REQUIRED\";\n  PDF_FORM_FIELD_FLAG2[PDF_FORM_FIELD_FLAG2[\"NOEXPORT\"] = 4] = \"NOEXPORT\";\n  PDF_FORM_FIELD_FLAG2[PDF_FORM_FIELD_FLAG2[\"TEXT_MULTIPLINE\"] = 4096] = \"TEXT_MULTIPLINE\";\n  PDF_FORM_FIELD_FLAG2[PDF_FORM_FIELD_FLAG2[\"TEXT_PASSWORD\"] = 8192] = \"TEXT_PASSWORD\";\n  PDF_FORM_FIELD_FLAG2[PDF_FORM_FIELD_FLAG2[\"CHOICE_COMBO\"] = 131072] = \"CHOICE_COMBO\";\n  PDF_FORM_FIELD_FLAG2[PDF_FORM_FIELD_FLAG2[\"CHOICE_EDIT\"] = 262144] = \"CHOICE_EDIT\";\n  PDF_FORM_FIELD_FLAG2[PDF_FORM_FIELD_FLAG2[\"CHOICE_MULTL_SELECT\"] = 2097152] = \"CHOICE_MULTL_SELECT\";\n  return PDF_FORM_FIELD_FLAG2;\n})(PDF_FORM_FIELD_FLAG || {});\nvar PdfPageObjectType = /* @__PURE__ */ ((PdfPageObjectType2) => {\n  PdfPageObjectType2[PdfPageObjectType2[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n  PdfPageObjectType2[PdfPageObjectType2[\"TEXT\"] = 1] = \"TEXT\";\n  PdfPageObjectType2[PdfPageObjectType2[\"PATH\"] = 2] = \"PATH\";\n  PdfPageObjectType2[PdfPageObjectType2[\"IMAGE\"] = 3] = \"IMAGE\";\n  PdfPageObjectType2[PdfPageObjectType2[\"SHADING\"] = 4] = \"SHADING\";\n  PdfPageObjectType2[PdfPageObjectType2[\"FORM\"] = 5] = \"FORM\";\n  return PdfPageObjectType2;\n})(PdfPageObjectType || {});\nvar PdfAnnotationFlagName = Object.freeze({\n  [1 /* INVISIBLE */]: \"invisible\",\n  [2 /* HIDDEN */]: \"hidden\",\n  [4 /* PRINT */]: \"print\",\n  [8 /* NO_ZOOM */]: \"noZoom\",\n  [16 /* NO_ROTATE */]: \"noRotate\",\n  [32 /* NO_VIEW */]: \"noView\",\n  [64 /* READ_ONLY */]: \"readOnly\",\n  [128 /* LOCKED */]: \"locked\",\n  [256 /* TOGGLE_NOVIEW */]: \"toggleNoView\"\n});\nvar PdfAnnotationFlagValue = Object.entries(\n  PdfAnnotationFlagName\n).reduce(\n  (acc, [bit, name]) => {\n    acc[name] = Number(bit);\n    return acc;\n  },\n  {}\n);\nfunction flagsToNames(raw) {\n  return Object.keys(PdfAnnotationFlagName).filter((flag) => (raw & flag) !== 0).map((flag) => PdfAnnotationFlagName[flag]);\n}\nfunction namesToFlags(names) {\n  return names.reduce(\n    (mask, name) => mask | PdfAnnotationFlagValue[name],\n    0 /* NONE */\n  );\n}\nvar PdfSegmentObjectType = /* @__PURE__ */ ((PdfSegmentObjectType2) => {\n  PdfSegmentObjectType2[PdfSegmentObjectType2[\"UNKNOWN\"] = -1] = \"UNKNOWN\";\n  PdfSegmentObjectType2[PdfSegmentObjectType2[\"LINETO\"] = 0] = \"LINETO\";\n  PdfSegmentObjectType2[PdfSegmentObjectType2[\"BEZIERTO\"] = 1] = \"BEZIERTO\";\n  PdfSegmentObjectType2[PdfSegmentObjectType2[\"MOVETO\"] = 2] = \"MOVETO\";\n  return PdfSegmentObjectType2;\n})(PdfSegmentObjectType || {});\nvar PdfEngineFeature = /* @__PURE__ */ ((PdfEngineFeature2) => {\n  PdfEngineFeature2[PdfEngineFeature2[\"RenderPage\"] = 0] = \"RenderPage\";\n  PdfEngineFeature2[PdfEngineFeature2[\"RenderPageRect\"] = 1] = \"RenderPageRect\";\n  PdfEngineFeature2[PdfEngineFeature2[\"Thumbnails\"] = 2] = \"Thumbnails\";\n  PdfEngineFeature2[PdfEngineFeature2[\"Bookmarks\"] = 3] = \"Bookmarks\";\n  PdfEngineFeature2[PdfEngineFeature2[\"Annotations\"] = 4] = \"Annotations\";\n  return PdfEngineFeature2;\n})(PdfEngineFeature || {});\nvar PdfEngineOperation = /* @__PURE__ */ ((PdfEngineOperation2) => {\n  PdfEngineOperation2[PdfEngineOperation2[\"Create\"] = 0] = \"Create\";\n  PdfEngineOperation2[PdfEngineOperation2[\"Read\"] = 1] = \"Read\";\n  PdfEngineOperation2[PdfEngineOperation2[\"Update\"] = 2] = \"Update\";\n  PdfEngineOperation2[PdfEngineOperation2[\"Delete\"] = 3] = \"Delete\";\n  return PdfEngineOperation2;\n})(PdfEngineOperation || {});\nvar MatchFlag = /* @__PURE__ */ ((MatchFlag2) => {\n  MatchFlag2[MatchFlag2[\"None\"] = 0] = \"None\";\n  MatchFlag2[MatchFlag2[\"MatchCase\"] = 1] = \"MatchCase\";\n  MatchFlag2[MatchFlag2[\"MatchWholeWord\"] = 2] = \"MatchWholeWord\";\n  MatchFlag2[MatchFlag2[\"MatchConsecutive\"] = 4] = \"MatchConsecutive\";\n  return MatchFlag2;\n})(MatchFlag || {});\nfunction unionFlags(flags) {\n  return flags.reduce((flag, currFlag) => {\n    return flag | currFlag;\n  }, 0 /* None */);\n}\nfunction compareSearchTarget(targetA, targetB) {\n  const flagA = unionFlags(targetA.flags);\n  const flagB = unionFlags(targetB.flags);\n  return flagA === flagB && targetA.keyword === targetB.keyword;\n}\nvar PdfPermission = /* @__PURE__ */ ((PdfPermission2) => {\n  PdfPermission2[PdfPermission2[\"PrintDocument\"] = 8] = \"PrintDocument\";\n  PdfPermission2[PdfPermission2[\"ModifyContent\"] = 16] = \"ModifyContent\";\n  PdfPermission2[PdfPermission2[\"CopyOrExtract\"] = 32] = \"CopyOrExtract\";\n  PdfPermission2[PdfPermission2[\"AddOrModifyTextAnnot\"] = 64] = \"AddOrModifyTextAnnot\";\n  PdfPermission2[PdfPermission2[\"FillInExistingForm\"] = 512] = \"FillInExistingForm\";\n  PdfPermission2[PdfPermission2[\"ExtractTextOrGraphics\"] = 1024] = \"ExtractTextOrGraphics\";\n  PdfPermission2[PdfPermission2[\"AssembleDocument\"] = 2048] = \"AssembleDocument\";\n  PdfPermission2[PdfPermission2[\"PrintHighQuality\"] = 4096] = \"PrintHighQuality\";\n  return PdfPermission2;\n})(PdfPermission || {});\nvar PdfPageFlattenFlag = /* @__PURE__ */ ((PdfPageFlattenFlag2) => {\n  PdfPageFlattenFlag2[PdfPageFlattenFlag2[\"Display\"] = 0] = \"Display\";\n  PdfPageFlattenFlag2[PdfPageFlattenFlag2[\"Print\"] = 1] = \"Print\";\n  return PdfPageFlattenFlag2;\n})(PdfPageFlattenFlag || {});\nvar PdfPageFlattenResult = /* @__PURE__ */ ((PdfPageFlattenResult2) => {\n  PdfPageFlattenResult2[PdfPageFlattenResult2[\"Fail\"] = 0] = \"Fail\";\n  PdfPageFlattenResult2[PdfPageFlattenResult2[\"Success\"] = 1] = \"Success\";\n  PdfPageFlattenResult2[PdfPageFlattenResult2[\"NothingToDo\"] = 2] = \"NothingToDo\";\n  return PdfPageFlattenResult2;\n})(PdfPageFlattenResult || {});\nvar PdfErrorCode = /* @__PURE__ */ ((PdfErrorCode2) => {\n  PdfErrorCode2[PdfErrorCode2[\"Ok\"] = 0] = \"Ok\";\n  PdfErrorCode2[PdfErrorCode2[\"Unknown\"] = 1] = \"Unknown\";\n  PdfErrorCode2[PdfErrorCode2[\"NotFound\"] = 2] = \"NotFound\";\n  PdfErrorCode2[PdfErrorCode2[\"WrongFormat\"] = 3] = \"WrongFormat\";\n  PdfErrorCode2[PdfErrorCode2[\"Password\"] = 4] = \"Password\";\n  PdfErrorCode2[PdfErrorCode2[\"Security\"] = 5] = \"Security\";\n  PdfErrorCode2[PdfErrorCode2[\"PageError\"] = 6] = \"PageError\";\n  PdfErrorCode2[PdfErrorCode2[\"XFALoad\"] = 7] = \"XFALoad\";\n  PdfErrorCode2[PdfErrorCode2[\"XFALayout\"] = 8] = \"XFALayout\";\n  PdfErrorCode2[PdfErrorCode2[\"Cancelled\"] = 9] = \"Cancelled\";\n  PdfErrorCode2[PdfErrorCode2[\"Initialization\"] = 10] = \"Initialization\";\n  PdfErrorCode2[PdfErrorCode2[\"NotReady\"] = 11] = \"NotReady\";\n  PdfErrorCode2[PdfErrorCode2[\"NotSupport\"] = 12] = \"NotSupport\";\n  PdfErrorCode2[PdfErrorCode2[\"LoadDoc\"] = 13] = \"LoadDoc\";\n  PdfErrorCode2[PdfErrorCode2[\"DocNotOpen\"] = 14] = \"DocNotOpen\";\n  PdfErrorCode2[PdfErrorCode2[\"CantCloseDoc\"] = 15] = \"CantCloseDoc\";\n  PdfErrorCode2[PdfErrorCode2[\"CantCreateNewDoc\"] = 16] = \"CantCreateNewDoc\";\n  PdfErrorCode2[PdfErrorCode2[\"CantImportPages\"] = 17] = \"CantImportPages\";\n  PdfErrorCode2[PdfErrorCode2[\"CantCreateAnnot\"] = 18] = \"CantCreateAnnot\";\n  PdfErrorCode2[PdfErrorCode2[\"CantSetAnnotRect\"] = 19] = \"CantSetAnnotRect\";\n  PdfErrorCode2[PdfErrorCode2[\"CantSetAnnotContent\"] = 20] = \"CantSetAnnotContent\";\n  PdfErrorCode2[PdfErrorCode2[\"CantRemoveInkList\"] = 21] = \"CantRemoveInkList\";\n  PdfErrorCode2[PdfErrorCode2[\"CantAddInkStoke\"] = 22] = \"CantAddInkStoke\";\n  PdfErrorCode2[PdfErrorCode2[\"CantReadAttachmentSize\"] = 23] = \"CantReadAttachmentSize\";\n  PdfErrorCode2[PdfErrorCode2[\"CantReadAttachmentContent\"] = 24] = \"CantReadAttachmentContent\";\n  PdfErrorCode2[PdfErrorCode2[\"CantFocusAnnot\"] = 25] = \"CantFocusAnnot\";\n  PdfErrorCode2[PdfErrorCode2[\"CantSelectText\"] = 26] = \"CantSelectText\";\n  PdfErrorCode2[PdfErrorCode2[\"CantSelectOption\"] = 27] = \"CantSelectOption\";\n  PdfErrorCode2[PdfErrorCode2[\"CantCheckField\"] = 28] = \"CantCheckField\";\n  return PdfErrorCode2;\n})(PdfErrorCode || {});\nvar PdfTaskHelper = class {\n  /**\n   * Create a task\n   * @returns new task\n   */\n  static create() {\n    return new Task();\n  }\n  /**\n   * Create a task that has been resolved with value\n   * @param result - resolved value\n   * @returns resolved task\n   */\n  static resolve(result) {\n    const task = new Task();\n    task.resolve(result);\n    return task;\n  }\n  /**\n   * Create a task that has been rejected with error\n   * @param reason - rejected error\n   * @returns rejected task\n   */\n  static reject(reason) {\n    const task = new Task();\n    task.reject(reason);\n    return task;\n  }\n  /**\n   * Create a task that has been aborted with error\n   * @param reason - aborted error\n   * @returns aborted task\n   */\n  static abort(reason) {\n    const task = new Task();\n    task.reject(reason);\n    return task;\n  }\n};\n\n// src/color.ts\nfunction pdfAlphaColorToWebAlphaColor(c) {\n  const clamp = (n) => Math.max(0, Math.min(255, n));\n  const toHex = (n) => clamp(n).toString(16).padStart(2, \"0\");\n  const color = `#${toHex(c.red)}${toHex(c.green)}${toHex(c.blue)}`;\n  const opacity = clamp(c.alpha) / 255;\n  return { color, opacity };\n}\nfunction webAlphaColorToPdfAlphaColor({ color, opacity }) {\n  if (/^#?[0-9a-f]{3}$/i.test(color)) {\n    color = color.replace(/^#?([0-9a-f])([0-9a-f])([0-9a-f])$/i, \"#$1$1$2$2$3$3\").toLowerCase();\n  }\n  const [, r, g, b] = /^#?([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$/i.exec(color) ?? (() => {\n    throw new Error(`Invalid hex colour: \\u201C${color}\\u201D`);\n  })();\n  const clamp = (n, hi = 255) => Math.max(0, Math.min(hi, n));\n  return {\n    red: parseInt(r, 16),\n    green: parseInt(g, 16),\n    blue: parseInt(b, 16),\n    alpha: clamp(Math.round(opacity * 255))\n  };\n}\n\n// src/date.ts\nfunction pdfDateToDate(pdf) {\n  if (!pdf?.startsWith(\"D:\") || pdf.length < 16) return;\n  const y = +pdf.slice(2, 6);\n  const mo = +pdf.slice(6, 8) - 1;\n  const d = +pdf.slice(8, 10);\n  const H = +pdf.slice(10, 12);\n  const M = +pdf.slice(12, 14);\n  const S = +pdf.slice(14, 16);\n  return new Date(Date.UTC(y, mo, d, H, M, S));\n}\nfunction dateToPdfDate(date = /* @__PURE__ */ new Date()) {\n  const z = (n, len = 2) => n.toString().padStart(len, \"0\");\n  const YYYY = date.getUTCFullYear();\n  const MM = z(date.getUTCMonth() + 1);\n  const DD = z(date.getUTCDate());\n  const HH = z(date.getUTCHours());\n  const mm = z(date.getUTCMinutes());\n  const SS = z(date.getUTCSeconds());\n  return `D:${YYYY}${MM}${DD}${HH}${mm}${SS}`;\n}\n\n// src/index.ts\nfunction ignore() {\n}\nexport {\n  AllLogger,\n  AppearanceMode,\n  ConsoleLogger,\n  LevelLogger,\n  LogLevel,\n  MatchFlag,\n  MixedBlendMode,\n  NoopLogger,\n  PDF_FORM_FIELD_FLAG,\n  PDF_FORM_FIELD_TYPE,\n  PdfActionType,\n  PdfAnnotationBorderStyle,\n  PdfAnnotationColorType,\n  PdfAnnotationFlagName,\n  PdfAnnotationFlags,\n  PdfAnnotationObjectStatus,\n  PdfAnnotationState,\n  PdfAnnotationStateModel,\n  PdfAnnotationSubtype,\n  PdfAnnotationSubtypeName,\n  PdfBlendMode,\n  PdfBomOrZwnbsp,\n  PdfEngineFeature,\n  PdfEngineOperation,\n  PdfErrorCode,\n  PdfNonCharacterFFFE,\n  PdfNonCharacterFFFF,\n  PdfPageFlattenFlag,\n  PdfPageFlattenResult,\n  PdfPageObjectType,\n  PdfPermission,\n  PdfSegmentObjectType,\n  PdfSoftHyphenMarker,\n  PdfTaskHelper,\n  PdfUnwantedTextMarkers,\n  PdfUnwantedTextRegex,\n  PdfWordJoiner,\n  PdfZeroWidthSpace,\n  PdfZoomMode,\n  PerfLogger,\n  Rotation,\n  Task,\n  TaskAbortedError,\n  TaskRejectedError,\n  TaskStage,\n  blendModeLabel,\n  blendModeSelectOptions,\n  blendModeToCss,\n  boundingRect,\n  calculateAngle,\n  calculateDegree,\n  compareSearchTarget,\n  cssToBlendMode,\n  dateToPdfDate,\n  flagsToNames,\n  getBlendModeInfo,\n  ignore,\n  makeMatrix,\n  namesToFlags,\n  pdfAlphaColorToWebAlphaColor,\n  pdfDateToDate,\n  quadToRect,\n  rectToQuad,\n  reduceBlendModes,\n  restoreOffset,\n  restorePosition,\n  restoreRect,\n  rotatePosition,\n  rotateRect,\n  scalePosition,\n  scaleRect,\n  stripPdfUnwantedMarkers,\n  swap,\n  toIntPos,\n  toIntRect,\n  toIntSize,\n  transformPosition,\n  transformRect,\n  transformSize,\n  uiBlendModeDisplay,\n  unionFlags,\n  webAlphaColorToPdfAlphaColor\n};\n//# sourceMappingURL=index.js.map","import { PdfDocumentObject, PdfPageObject, Rotation } from '@embedpdf/models';\nimport { PluginRegistryConfig } from '../types/plugin';\n\nexport interface CoreState {\n  scale: number;\n  rotation: Rotation;\n  document: PdfDocumentObject | null;\n  pages: PdfPageObject[][];\n  loading: boolean;\n  error: string | null;\n}\n\nexport const initialCoreState: (config?: PluginRegistryConfig) => CoreState = (config) => ({\n  scale: config?.scale ?? 1,\n  rotation: config?.rotation ?? Rotation.Degree0,\n  document: null,\n  pages: [],\n  loading: false,\n  error: null,\n});\n","import { Reducer } from './types';\nimport { CoreState } from './initial-state';\nimport {\n  CoreAction,\n  LOAD_DOCUMENT,\n  SET_DOCUMENT,\n  SET_DOCUMENT_ERROR,\n  SET_PAGES,\n  SET_ROTATION,\n  SET_SCALE,\n} from './actions';\n\nexport const coreReducer: Reducer<CoreState, CoreAction> = (state, action): CoreState => {\n  switch (action.type) {\n    case LOAD_DOCUMENT:\n      return {\n        ...state,\n        loading: true,\n        error: null,\n      };\n\n    case SET_DOCUMENT:\n      return {\n        ...state,\n        document: action.payload,\n        pages: action.payload.pages.map((page) => [page]),\n        loading: false,\n        error: null,\n      };\n\n    case SET_ROTATION:\n      return {\n        ...state,\n        rotation: action.payload,\n      };\n\n    case SET_PAGES:\n      return {\n        ...state,\n        pages: action.payload,\n      };\n\n    case SET_DOCUMENT_ERROR:\n      return {\n        ...state,\n        loading: false,\n        error: action.payload,\n      };\n\n    case SET_SCALE:\n      return {\n        ...state,\n        scale: action.payload,\n      };\n\n    default:\n      return state;\n  }\n};\n","import { DependencyResolver } from '../utils/dependency-resolver';\nimport {\n  IPlugin,\n  PluginBatchRegistration,\n  PluginManifest,\n  PluginStatus,\n  PluginPackage,\n  PluginRegistryConfig,\n} from '../types/plugin';\nimport {\n  PluginRegistrationError,\n  PluginNotFoundError,\n  CircularDependencyError,\n  CapabilityNotFoundError,\n  PluginConfigurationError,\n} from '../types/errors';\nimport { ignore, PdfEngine, Rotation } from '@embedpdf/models';\nimport { Action, CoreState, Store, initialCoreState, Reducer } from '../store';\nimport { CoreAction } from '../store/actions';\nimport { coreReducer } from '../store/reducer';\n\n// Define a more flexible generic type for plugin registrations\ninterface PluginRegistration {\n  // Use existential types for the plugin package to allow accepting any plugin type\n  package: PluginPackage<any, any, any, any>;\n  config?: any;\n}\n\nexport class PluginRegistry {\n  private plugins: Map<string, IPlugin> = new Map();\n  private manifests: Map<string, PluginManifest> = new Map();\n  private capabilities: Map<string, string> = new Map(); // capability -> pluginId\n  private status: Map<string, PluginStatus> = new Map();\n  private resolver: DependencyResolver;\n  private configurations: Map<string, unknown> = new Map();\n  private engine: PdfEngine;\n  private engineInitialized = false;\n  private store: Store<CoreState, CoreAction>;\n  private initPromise: Promise<void> | null = null;\n\n  private pendingRegistrations: PluginRegistration[] = [];\n  private processingRegistrations: PluginRegistration[] = [];\n  private initialized = false;\n  private isInitializing = false;\n  private initialCoreState: CoreState;\n  private pluginsReadyPromise: Promise<void> | null = null;\n  private destroyed = false;\n\n  constructor(engine: PdfEngine, config?: PluginRegistryConfig) {\n    this.resolver = new DependencyResolver();\n    this.engine = engine;\n    this.initialCoreState = initialCoreState(config);\n    this.store = new Store<CoreState, CoreAction>(coreReducer, this.initialCoreState);\n  }\n\n  /**\n   * Ensure engine is initialized before proceeding\n   */\n  private async ensureEngineInitialized(): Promise<void> {\n    if (this.engineInitialized) {\n      return;\n    }\n\n    if (this.engine.initialize) {\n      const task = this.engine.initialize();\n      await task.toPromise();\n      this.engineInitialized = true;\n    } else {\n      this.engineInitialized = true;\n    }\n  }\n\n  /**\n   * Register a plugin without initializing it\n   */\n  registerPlugin<\n    TPlugin extends IPlugin<TConfig>,\n    TConfig = unknown,\n    TState = unknown,\n    TAction extends Action = Action,\n  >(\n    pluginPackage: PluginPackage<TPlugin, TConfig, TState, TAction>,\n    config?: Partial<TConfig>,\n  ): void {\n    if (this.initialized && !this.isInitializing) {\n      throw new PluginRegistrationError('Cannot register plugins after initialization');\n    }\n\n    this.validateManifest(pluginPackage.manifest);\n\n    // Use appropriate typing for store methods\n    this.store.addPluginReducer(\n      pluginPackage.manifest.id,\n      // We need one type assertion here since we can't fully reconcile TAction with Action\n      // due to TypeScript's type system limitations with generic variance\n      pluginPackage.reducer as Reducer<TState, Action>,\n      'function' === typeof pluginPackage.initialState\n        ? (pluginPackage.initialState as (coreState: CoreState, config: TConfig) => TState)(\n            this.initialCoreState,\n            {\n              ...pluginPackage.manifest.defaultConfig,\n              ...config,\n            },\n          )\n        : pluginPackage.initialState,\n    );\n\n    this.pendingRegistrations.push({\n      package: pluginPackage,\n      config,\n    });\n  }\n\n  /**\n   * Get the central store instance\n   */\n  getStore(): Store<CoreState, CoreAction> {\n    return this.store;\n  }\n\n  /**\n   * Get the engine instance\n   */\n  getEngine(): PdfEngine {\n    return this.engine;\n  }\n\n  /**\n   * Get a promise that resolves when all plugins are ready\n   */\n  public pluginsReady(): Promise<void> {\n    // Re-use the same promise every time it’s asked for\n    if (this.pluginsReadyPromise) {\n      return this.pluginsReadyPromise;\n    }\n\n    // Build the promise the *first* time it’s requested\n    this.pluginsReadyPromise = (async () => {\n      // 1. Wait until the registry itself has finished initialising\n      if (!this.initialized) {\n        await this.initialize();\n      }\n\n      // 2. Wait for every plugin’s ready() promise (if it has one)\n      const readyPromises = Array.from(this.plugins.values()).map((p) =>\n        typeof p.ready === 'function' ? p.ready() : Promise.resolve(),\n      );\n\n      await Promise.all(readyPromises); // resolves when the slowest is done\n    })();\n\n    return this.pluginsReadyPromise;\n  }\n\n  /**\n   * INITIALISE THE REGISTRY – runs once no-matter-how-many calls   *\n   */\n  async initialize(): Promise<void> {\n    if (this.destroyed) {\n      throw new PluginRegistrationError('Registry has been destroyed');\n    }\n\n    // If an initialisation is already in-flight (or finished)\n    // return the very same promise so callers can await it.\n    if (this.initPromise) {\n      return this.initPromise;\n    }\n\n    // Wrap your existing body in a single promise and cache it\n    this.initPromise = (async () => {\n      if (this.initialized) {\n        throw new PluginRegistrationError('Registry is already initialized');\n      }\n\n      this.isInitializing = true;\n\n      try {\n        /* ---------------- original body starts ------------------ */\n        await this.ensureEngineInitialized();\n        // Check if destroyed after engine initialization\n        if (this.destroyed) {\n          return;\n        }\n\n        while (this.pendingRegistrations.length > 0) {\n          // Check if destroyed before processing each batch\n          if (this.destroyed) {\n            return;\n          }\n          this.processingRegistrations = [...this.pendingRegistrations];\n          this.pendingRegistrations = [];\n\n          for (const reg of this.processingRegistrations) {\n            const dependsOn = new Set<string>();\n            const allDeps = [...reg.package.manifest.requires, ...reg.package.manifest.optional];\n            for (const cap of allDeps) {\n              const provider = this.processingRegistrations.find((r) =>\n                r.package.manifest.provides.includes(cap),\n              );\n              if (provider) dependsOn.add(provider.package.manifest.id);\n            }\n            this.resolver.addNode(reg.package.manifest.id, [...dependsOn]);\n          }\n\n          const loadOrder = this.resolver.resolveLoadOrder();\n          for (const id of loadOrder) {\n            const reg = this.processingRegistrations.find((r) => r.package.manifest.id === id)!;\n            await this.initializePlugin(reg.package.manifest, reg.package.create, reg.config);\n          }\n\n          this.processingRegistrations = [];\n          this.resolver = new DependencyResolver();\n        }\n\n        for (const plugin of this.plugins.values()) {\n          await plugin.postInitialize?.().catch((e) => {\n            console.error(`Error in postInitialize for plugin ${plugin.id}`, e);\n            this.status.set(plugin.id, 'error');\n          });\n        }\n\n        this.initialized = true;\n        /* ----------------- original body ends ------------------- */\n      } catch (err) {\n        if (err instanceof Error) {\n          throw new CircularDependencyError(\n            `Failed to resolve plugin dependencies: ${err.message}`,\n          );\n        }\n        throw err;\n      } finally {\n        this.isInitializing = false;\n      }\n    })();\n\n    return this.initPromise;\n  }\n\n  /**\n   * Initialize a single plugin with all necessary checks\n   */\n  private async initializePlugin<TConfig>(\n    manifest: PluginManifest<TConfig>,\n    packageCreator: (\n      registry: PluginRegistry,\n      engine: PdfEngine,\n      config?: TConfig,\n    ) => IPlugin<TConfig>,\n    config?: Partial<TConfig>,\n  ): Promise<void> {\n    const finalConfig = {\n      ...manifest.defaultConfig,\n      ...config,\n    };\n\n    this.validateConfig(manifest.id, finalConfig, manifest.defaultConfig);\n\n    // Create plugin instance during initialization\n    const plugin = packageCreator(this, this.engine, finalConfig);\n    this.validatePlugin(plugin);\n\n    // Verify all required capabilities are available\n    for (const capability of manifest.requires) {\n      if (!this.capabilities.has(capability)) {\n        throw new PluginRegistrationError(\n          `Missing required capability: ${capability} for plugin ${manifest.id}`,\n        );\n      }\n    }\n\n    // Optional capabilities can be null, so we don't throw errors for them\n    for (const capability of manifest.optional) {\n      if (this.capabilities.has(capability)) {\n        // Optional capability is available, but we don't require it\n        console.debug(`Optional capability ${capability} is available for plugin ${manifest.id}`);\n      }\n    }\n\n    console.log('initializePlugin', manifest.id, manifest.provides);\n\n    // Register provided capabilities\n    for (const capability of manifest.provides) {\n      if (this.capabilities.has(capability)) {\n        throw new PluginRegistrationError(\n          `Capability ${capability} is already provided by plugin ${this.capabilities.get(capability)}`,\n        );\n      }\n      this.capabilities.set(capability, manifest.id);\n    }\n\n    // Store plugin and manifest\n    this.plugins.set(manifest.id, plugin);\n    this.manifests.set(manifest.id, manifest);\n    this.status.set(manifest.id, 'registered');\n    this.configurations.set(manifest.id, finalConfig);\n\n    try {\n      if (plugin.initialize) {\n        await plugin.initialize(finalConfig);\n      }\n      this.status.set(manifest.id, 'active');\n    } catch (error) {\n      // Cleanup on initialization failure\n      this.plugins.delete(manifest.id);\n      this.manifests.delete(manifest.id);\n      console.log('initializePlugin failed', manifest.id, manifest.provides);\n      manifest.provides.forEach((cap) => this.capabilities.delete(cap));\n      throw error;\n    }\n  }\n\n  getPluginConfig<TConfig>(pluginId: string): TConfig {\n    const config = this.configurations.get(pluginId);\n    if (!config) {\n      throw new PluginNotFoundError(`Configuration for plugin ${pluginId} not found`);\n    }\n    return config as TConfig;\n  }\n\n  private validateConfig(pluginId: string, config: unknown, defaultConfig: unknown): void {\n    // Check all required fields exist\n    const requiredKeys = Object.keys(defaultConfig as object);\n    const missingKeys = requiredKeys.filter((key) => !(config as object).hasOwnProperty(key));\n\n    if (missingKeys.length > 0) {\n      throw new PluginConfigurationError(\n        `Missing required configuration keys for plugin ${pluginId}: ${missingKeys.join(', ')}`,\n      );\n    }\n\n    // You could add more validation here:\n    // - Type checking\n    // - Value range validation\n    // - Format validation\n    // etc.\n  }\n\n  async updatePluginConfig<TConfig>(pluginId: string, config: Partial<TConfig>): Promise<void> {\n    const plugin = this.getPlugin(pluginId);\n\n    if (!plugin) {\n      throw new PluginNotFoundError(`Plugin ${pluginId} not found`);\n    }\n\n    const manifest = this.manifests.get(pluginId);\n    const currentConfig = this.configurations.get(pluginId);\n\n    if (!manifest || !currentConfig) {\n      throw new PluginNotFoundError(`Plugin ${pluginId} not found`);\n    }\n\n    // Merge new config with current\n    const newConfig = {\n      ...currentConfig,\n      ...config,\n    };\n\n    // Validate new configuration\n    this.validateConfig(pluginId, newConfig, manifest.defaultConfig);\n\n    // Store new configuration\n    this.configurations.set(pluginId, newConfig);\n\n    // Reinitialize plugin if needed\n    if (plugin.initialize) {\n      await plugin.initialize(newConfig);\n    }\n  }\n\n  /**\n   * Register multiple plugins at once\n   */\n  registerPluginBatch(registrations: PluginBatchRegistration<IPlugin<any>, any, any, any>[]): void {\n    for (const reg of registrations) {\n      this.registerPlugin(reg.package, reg.config);\n    }\n  }\n\n  /**\n   * Unregister a plugin\n   */\n  async unregisterPlugin(pluginId: string): Promise<void> {\n    const plugin = this.plugins.get(pluginId);\n    if (!plugin) {\n      throw new PluginNotFoundError(`Plugin ${pluginId} is not registered`);\n    }\n\n    const manifest = this.manifests.get(pluginId);\n    if (!manifest) {\n      throw new PluginNotFoundError(`Manifest for plugin ${pluginId} not found`);\n    }\n\n    // Check if any other plugins depend on this one\n    for (const [otherId, otherManifest] of this.manifests.entries()) {\n      if (otherId === pluginId) continue;\n\n      const dependsOnThis = [...otherManifest.requires, ...otherManifest.optional].some((cap) =>\n        manifest.provides.includes(cap),\n      );\n\n      if (dependsOnThis) {\n        throw new PluginRegistrationError(\n          `Cannot unregister plugin ${pluginId}: plugin ${otherId} depends on it`,\n        );\n      }\n    }\n\n    // Cleanup plugin\n    try {\n      if (plugin.destroy) {\n        await plugin.destroy();\n      }\n\n      // Remove capabilities\n      for (const capability of manifest.provides) {\n        this.capabilities.delete(capability);\n      }\n\n      // Remove plugin and manifest\n      this.plugins.delete(pluginId);\n      this.manifests.delete(pluginId);\n      this.status.delete(pluginId);\n    } catch (error) {\n      if (error instanceof Error) {\n        throw new Error(`Failed to unregister plugin ${pluginId}: ${error.message}`);\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Get a plugin instance\n   * @param pluginId The ID of the plugin to get\n   * @returns The plugin instance or null if not found\n   */\n  getPlugin<T extends IPlugin>(pluginId: string): T | null {\n    const plugin = this.plugins.get(pluginId);\n    if (!plugin) {\n      return null;\n    }\n    return plugin as T;\n  }\n\n  /**\n   * Get a plugin that provides a specific capability\n   * @param capability The capability to get a provider for\n   * @returns The plugin providing the capability or null if not found\n   */\n  getCapabilityProvider(capability: string): IPlugin | null {\n    const pluginId = this.capabilities.get(capability);\n    if (!pluginId) {\n      return null;\n    }\n    return this.getPlugin(pluginId);\n  }\n\n  /**\n   * Check if a capability is available\n   */\n  hasCapability(capability: string): boolean {\n    return this.capabilities.has(capability);\n  }\n\n  /**\n   * Get all registered plugins\n   */\n  getAllPlugins(): IPlugin[] {\n    return Array.from(this.plugins.values());\n  }\n\n  /**\n   * Get plugin status\n   */\n  getPluginStatus(pluginId: string): PluginStatus {\n    const status = this.status.get(pluginId);\n    if (!status) {\n      throw new PluginNotFoundError(`Plugin ${pluginId} not found`);\n    }\n    return status;\n  }\n\n  /**\n   * Validate plugin object\n   */\n  private validatePlugin(plugin: IPlugin): void {\n    if (!plugin.id) {\n      throw new PluginRegistrationError('Plugin must have an id');\n    }\n  }\n\n  /**\n   * Validate plugin manifest\n   */\n  private validateManifest(manifest: PluginManifest): void {\n    if (!manifest.id) {\n      throw new PluginRegistrationError('Manifest must have an id');\n    }\n    if (!manifest.name) {\n      throw new PluginRegistrationError('Manifest must have a name');\n    }\n    if (!manifest.version) {\n      throw new PluginRegistrationError('Manifest must have a version');\n    }\n    if (!Array.isArray(manifest.provides)) {\n      throw new PluginRegistrationError('Manifest must have a provides array');\n    }\n    if (!Array.isArray(manifest.requires)) {\n      throw new PluginRegistrationError('Manifest must have a requires array');\n    }\n    if (!Array.isArray(manifest.optional)) {\n      throw new PluginRegistrationError('Manifest must have an optional array');\n    }\n  }\n\n  isDestroyed(): boolean {\n    return this.destroyed;\n  }\n\n  /**\n   * DESTROY EVERYTHING – waits for any ongoing initialise(), once  *\n   */\n  async destroy(): Promise<void> {\n    if (this.destroyed) throw new PluginRegistrationError('Registry has already been destroyed');\n    this.destroyed = true;\n\n    // If initialisation is still underway, wait (success OR failure)\n    try {\n      await this.initPromise;\n    } catch {\n      /* ignore – still need to clean up */\n    }\n\n    /* ------- original teardown, unchanged except the guard ------ */\n    for (const plugin of Array.from(this.plugins.values()).reverse()) {\n      await plugin.destroy?.();\n    }\n\n    this.store.destroy();\n\n    this.plugins.clear();\n    this.manifests.clear();\n    this.capabilities.clear();\n    this.status.clear();\n    this.pendingRegistrations.length = 0;\n    this.processingRegistrations.length = 0;\n  }\n}\n","/**\n * Restrict a numeric value to the inclusive range [min, max].\n *\n * @example\n *   clamp( 5, 0, 10)  // 5\n *   clamp(-3, 0, 10)  // 0\n *   clamp(17, 0, 10)  // 10\n */\nexport function clamp(value: number, min: number, max: number): number {\n  return value < min ? min : value > max ? max : value;\n}\n\n/**\n * Deeply compares two values (objects, arrays, primitives)\n * with the following rules:\n *  - Objects are compared ignoring property order.\n *  - Arrays are compared ignoring element order (multiset comparison).\n *  - Primitives are compared by strict equality.\n *  - null/undefined are treated as normal primitives.\n *\n * @param a First value\n * @param b Second value\n * @param visited Used internally to detect cycles\n */\nexport function arePropsEqual(a: any, b: any, visited?: Set<any>): boolean {\n  // Quick path for reference equality or same primitive\n  if (a === b) {\n    return true;\n  }\n\n  // Handle null/undefined mismatch\n  if (a == null || b == null) {\n    // If one is null/undefined and the other isn't, no match\n    return a === b;\n  }\n\n  // Check types\n  const aType = typeof a;\n  const bType = typeof b;\n  if (aType !== bType) return false;\n\n  // If they are both objects or arrays, handle recursively\n  if (aType === 'object') {\n    // Optionally handle cyclical references\n    if (!visited) visited = new Set();\n    const pairId = getPairId(a, b);\n    if (visited.has(pairId)) {\n      // Already compared these two objects => assume true to avoid infinite recursion\n      // or return false if you want to treat cycles as inequality\n      return true;\n    }\n    visited.add(pairId);\n\n    const aIsArray = Array.isArray(a);\n    const bIsArray = Array.isArray(b);\n    if (aIsArray && bIsArray) {\n      // Compare as arrays ignoring order\n      return arraysEqualUnordered(a, b, visited);\n    } else if (!aIsArray && !bIsArray) {\n      // Compare as plain objects (order of properties doesn't matter)\n      return objectsEqual(a, b, visited);\n    } else {\n      // One is array, the other is object => not equal\n      return false;\n    }\n  }\n\n  // If both are function, symbol, etc. - typically we might say false\n  // But you can decide your own logic for function or symbol equality\n  return false;\n}\n\nfunction getPairId(a: any, b: any) {\n  // Could do something more advanced. This is a cheap approach:\n  // e.g. use the memory reference or an object identity approach\n  return `${objectId(a)}__${objectId(b)}`;\n}\n\n/**\n * If you want stable object IDs, you'd need a WeakMap to store them.\n * This simplistic approach just calls toString on the object.\n */\nlet objectIdCounter = 0;\nconst objectIds = new WeakMap<object, number>();\n\nfunction objectId(obj: object): number {\n  if (!objectIds.has(obj)) {\n    objectIds.set(obj, ++objectIdCounter);\n  }\n  return objectIds.get(obj)!;\n}\n\nfunction arraysEqualUnordered(a: any[], b: any[], visited?: Set<any>): boolean {\n  if (a.length !== b.length) return false;\n\n  const used = new Array<boolean>(b.length).fill(false);\n\n  // For each element in a, find an unused matching element in b\n  outer: for (let i = 0; i < a.length; i++) {\n    const elemA = a[i];\n    for (let j = 0; j < b.length; j++) {\n      if (used[j]) continue; // already used that slot\n      if (arePropsEqual(elemA, b[j], visited)) {\n        used[j] = true;\n        continue outer; // found match for a[i], proceed\n      }\n    }\n    // If we never found a match\n    return false;\n  }\n\n  return true;\n}\n\nfunction objectsEqual(a: object, b: object, visited?: Set<any>): boolean {\n  // Get all prop keys\n  const aKeys = Object.keys(a).sort();\n  const bKeys = Object.keys(b).sort();\n  if (aKeys.length !== bKeys.length) return false;\n\n  // Compare each property name\n  for (let i = 0; i < aKeys.length; i++) {\n    if (aKeys[i] !== bKeys[i]) return false;\n  }\n\n  // Compare each property value\n  for (const key of aKeys) {\n    // @ts-ignore\n    const valA = a[key];\n    // @ts-ignore\n    const valB = b[key];\n    if (!arePropsEqual(valA, valB, visited)) {\n      return false;\n    }\n  }\n  return true;\n}\n","import{Component as n,createElement as t,options as e,toChildArray as r,Fragment as u,render as o,hydrate as i,createContext as l,createRef as c,cloneElement as f}from\"preact\";export{Component,Fragment,createContext,createElement,createRef}from\"preact\";import{useState as a,useLayoutEffect as s,useEffect as h,useCallback as v,useContext as d,useDebugValue as m,useId as p,useImperativeHandle as y,useMemo as _,useReducer as b,useRef as S}from\"preact/hooks\";export*from\"preact/hooks\";function g(n,t){for(var e in t)n[e]=t[e];return n}function E(n,t){for(var e in n)if(\"__source\"!==e&&!(e in t))return!0;for(var r in t)if(\"__source\"!==r&&n[r]!==t[r])return!0;return!1}function C(n,t){var e=t(),r=a({t:{__:e,u:t}}),u=r[0].t,o=r[1];return s(function(){u.__=e,u.u=t,x(u)&&o({t:u})},[n,e,t]),h(function(){return x(u)&&o({t:u}),n(function(){x(u)&&o({t:u})})},[n]),e}function x(n){var t,e,r=n.u,u=n.__;try{var o=r();return!((t=u)===(e=o)&&(0!==t||1/t==1/e)||t!=t&&e!=e)}catch(n){return!0}}function R(n){n()}function w(n){return n}function k(){return[!1,R]}var I=s;function N(n,t){this.props=n,this.context=t}function M(n,e){function r(n){var t=this.props.ref,r=t==n.ref;return!r&&t&&(t.call?t(null):t.current=null),e?!e(this.props,n)||!r:E(this.props,n)}function u(e){return this.shouldComponentUpdate=r,t(n,e)}return u.displayName=\"Memo(\"+(n.displayName||n.name)+\")\",u.prototype.isReactComponent=!0,u.__f=!0,u}(N.prototype=new n).isPureReactComponent=!0,N.prototype.shouldComponentUpdate=function(n,t){return E(this.props,n)||E(this.state,t)};var T=e.__b;e.__b=function(n){n.type&&n.type.__f&&n.ref&&(n.props.ref=n.ref,n.ref=null),T&&T(n)};var A=\"undefined\"!=typeof Symbol&&Symbol.for&&Symbol.for(\"react.forward_ref\")||3911;function D(n){function t(t){var e=g({},t);return delete e.ref,n(e,t.ref||null)}return t.$$typeof=A,t.render=t,t.prototype.isReactComponent=t.__f=!0,t.displayName=\"ForwardRef(\"+(n.displayName||n.name)+\")\",t}var L=function(n,t){return null==n?null:r(r(n).map(t))},O={map:L,forEach:L,count:function(n){return n?r(n).length:0},only:function(n){var t=r(n);if(1!==t.length)throw\"Children.only\";return t[0]},toArray:r},F=e.__e;e.__e=function(n,t,e,r){if(n.then)for(var u,o=t;o=o.__;)if((u=o.__c)&&u.__c)return null==t.__e&&(t.__e=e.__e,t.__k=e.__k),u.__c(n,t);F(n,t,e,r)};var U=e.unmount;function V(n,t,e){return n&&(n.__c&&n.__c.__H&&(n.__c.__H.__.forEach(function(n){\"function\"==typeof n.__c&&n.__c()}),n.__c.__H=null),null!=(n=g({},n)).__c&&(n.__c.__P===e&&(n.__c.__P=t),n.__c.__e=!0,n.__c=null),n.__k=n.__k&&n.__k.map(function(n){return V(n,t,e)})),n}function W(n,t,e){return n&&e&&(n.__v=null,n.__k=n.__k&&n.__k.map(function(n){return W(n,t,e)}),n.__c&&n.__c.__P===t&&(n.__e&&e.appendChild(n.__e),n.__c.__e=!0,n.__c.__P=e)),n}function P(){this.__u=0,this.o=null,this.__b=null}function j(n){var t=n.__.__c;return t&&t.__a&&t.__a(n)}function z(n){var e,r,u;function o(o){if(e||(e=n()).then(function(n){r=n.default||n},function(n){u=n}),u)throw u;if(!r)throw e;return t(r,o)}return o.displayName=\"Lazy\",o.__f=!0,o}function B(){this.i=null,this.l=null}e.unmount=function(n){var t=n.__c;t&&t.__R&&t.__R(),t&&32&n.__u&&(n.type=null),U&&U(n)},(P.prototype=new n).__c=function(n,t){var e=t.__c,r=this;null==r.o&&(r.o=[]),r.o.push(e);var u=j(r.__v),o=!1,i=function(){o||(o=!0,e.__R=null,u?u(l):l())};e.__R=i;var l=function(){if(!--r.__u){if(r.state.__a){var n=r.state.__a;r.__v.__k[0]=W(n,n.__c.__P,n.__c.__O)}var t;for(r.setState({__a:r.__b=null});t=r.o.pop();)t.forceUpdate()}};r.__u++||32&t.__u||r.setState({__a:r.__b=r.__v.__k[0]}),n.then(i,i)},P.prototype.componentWillUnmount=function(){this.o=[]},P.prototype.render=function(n,e){if(this.__b){if(this.__v.__k){var r=document.createElement(\"div\"),o=this.__v.__k[0].__c;this.__v.__k[0]=V(this.__b,r,o.__O=o.__P)}this.__b=null}var i=e.__a&&t(u,null,n.fallback);return i&&(i.__u&=-33),[t(u,null,e.__a?null:n.children),i]};var H=function(n,t,e){if(++e[1]===e[0]&&n.l.delete(t),n.props.revealOrder&&(\"t\"!==n.props.revealOrder[0]||!n.l.size))for(e=n.i;e;){for(;e.length>3;)e.pop()();if(e[1]<e[0])break;n.i=e=e[2]}};function Z(n){return this.getChildContext=function(){return n.context},n.children}function Y(n){var e=this,r=n.h;if(e.componentWillUnmount=function(){o(null,e.v),e.v=null,e.h=null},e.h&&e.h!==r&&e.componentWillUnmount(),!e.v){for(var u=e.__v;null!==u&&!u.__m&&null!==u.__;)u=u.__;e.h=r,e.v={nodeType:1,parentNode:r,childNodes:[],__k:{__m:u.__m},contains:function(){return!0},insertBefore:function(n,t){this.childNodes.push(n),e.h.insertBefore(n,t)},removeChild:function(n){this.childNodes.splice(this.childNodes.indexOf(n)>>>1,1),e.h.removeChild(n)}}}o(t(Z,{context:e.context},n.__v),e.v)}function $(n,e){var r=t(Y,{__v:n,h:e});return r.containerInfo=e,r}(B.prototype=new n).__a=function(n){var t=this,e=j(t.__v),r=t.l.get(n);return r[0]++,function(u){var o=function(){t.props.revealOrder?(r.push(u),H(t,n,r)):u()};e?e(o):o()}},B.prototype.render=function(n){this.i=null,this.l=new Map;var t=r(n.children);n.revealOrder&&\"b\"===n.revealOrder[0]&&t.reverse();for(var e=t.length;e--;)this.l.set(t[e],this.i=[1,0,this.i]);return n.children},B.prototype.componentDidUpdate=B.prototype.componentDidMount=function(){var n=this;this.l.forEach(function(t,e){H(n,e,t)})};var q=\"undefined\"!=typeof Symbol&&Symbol.for&&Symbol.for(\"react.element\")||60103,G=/^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|image(!S)|letter|lighting|marker(?!H|W|U)|overline|paint|pointer|shape|stop|strikethrough|stroke|text(?!L)|transform|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/,J=/^on(Ani|Tra|Tou|BeforeInp|Compo)/,K=/[A-Z0-9]/g,Q=\"undefined\"!=typeof document,X=function(n){return(\"undefined\"!=typeof Symbol&&\"symbol\"==typeof Symbol()?/fil|che|rad/:/fil|che|ra/).test(n)};function nn(n,t,e){return null==t.__k&&(t.textContent=\"\"),o(n,t),\"function\"==typeof e&&e(),n?n.__c:null}function tn(n,t,e){return i(n,t),\"function\"==typeof e&&e(),n?n.__c:null}n.prototype.isReactComponent={},[\"componentWillMount\",\"componentWillReceiveProps\",\"componentWillUpdate\"].forEach(function(t){Object.defineProperty(n.prototype,t,{configurable:!0,get:function(){return this[\"UNSAFE_\"+t]},set:function(n){Object.defineProperty(this,t,{configurable:!0,writable:!0,value:n})}})});var en=e.event;function rn(){}function un(){return this.cancelBubble}function on(){return this.defaultPrevented}e.event=function(n){return en&&(n=en(n)),n.persist=rn,n.isPropagationStopped=un,n.isDefaultPrevented=on,n.nativeEvent=n};var ln,cn={enumerable:!1,configurable:!0,get:function(){return this.class}},fn=e.vnode;e.vnode=function(n){\"string\"==typeof n.type&&function(n){var t=n.props,e=n.type,u={},o=-1===e.indexOf(\"-\");for(var i in t){var l=t[i];if(!(\"value\"===i&&\"defaultValue\"in t&&null==l||Q&&\"children\"===i&&\"noscript\"===e||\"class\"===i||\"className\"===i)){var c=i.toLowerCase();\"defaultValue\"===i&&\"value\"in t&&null==t.value?i=\"value\":\"download\"===i&&!0===l?l=\"\":\"translate\"===c&&\"no\"===l?l=!1:\"o\"===c[0]&&\"n\"===c[1]?\"ondoubleclick\"===c?i=\"ondblclick\":\"onchange\"!==c||\"input\"!==e&&\"textarea\"!==e||X(t.type)?\"onfocus\"===c?i=\"onfocusin\":\"onblur\"===c?i=\"onfocusout\":J.test(i)&&(i=c):c=i=\"oninput\":o&&G.test(i)?i=i.replace(K,\"-$&\").toLowerCase():null===l&&(l=void 0),\"oninput\"===c&&u[i=c]&&(i=\"oninputCapture\"),u[i]=l}}\"select\"==e&&u.multiple&&Array.isArray(u.value)&&(u.value=r(t.children).forEach(function(n){n.props.selected=-1!=u.value.indexOf(n.props.value)})),\"select\"==e&&null!=u.defaultValue&&(u.value=r(t.children).forEach(function(n){n.props.selected=u.multiple?-1!=u.defaultValue.indexOf(n.props.value):u.defaultValue==n.props.value})),t.class&&!t.className?(u.class=t.class,Object.defineProperty(u,\"className\",cn)):(t.className&&!t.class||t.class&&t.className)&&(u.class=u.className=t.className),n.props=u}(n),n.$$typeof=q,fn&&fn(n)};var an=e.__r;e.__r=function(n){an&&an(n),ln=n.__c};var sn=e.diffed;e.diffed=function(n){sn&&sn(n);var t=n.props,e=n.__e;null!=e&&\"textarea\"===n.type&&\"value\"in t&&t.value!==e.value&&(e.value=null==t.value?\"\":t.value),ln=null};var hn={ReactCurrentDispatcher:{current:{readContext:function(n){return ln.__n[n.__c].props.value},useCallback:v,useContext:d,useDebugValue:m,useDeferredValue:w,useEffect:h,useId:p,useImperativeHandle:y,useInsertionEffect:I,useLayoutEffect:s,useMemo:_,useReducer:b,useRef:S,useState:a,useSyncExternalStore:C,useTransition:k}}},vn=\"18.3.1\";function dn(n){return t.bind(null,n)}function mn(n){return!!n&&n.$$typeof===q}function pn(n){return mn(n)&&n.type===u}function yn(n){return!!n&&!!n.displayName&&(\"string\"==typeof n.displayName||n.displayName instanceof String)&&n.displayName.startsWith(\"Memo(\")}function _n(n){return mn(n)?f.apply(null,arguments):n}function bn(n){return!!n.__k&&(o(null,n),!0)}function Sn(n){return n&&(n.base||1===n.nodeType&&n)||null}var gn=function(n,t){return n(t)},En=function(n,t){return n(t)},Cn=u,xn=mn,Rn={useState:a,useId:p,useReducer:b,useEffect:h,useLayoutEffect:s,useInsertionEffect:I,useTransition:k,useDeferredValue:w,useSyncExternalStore:C,startTransition:R,useRef:S,useImperativeHandle:y,useMemo:_,useCallback:v,useContext:d,useDebugValue:m,version:\"18.3.1\",Children:O,render:nn,hydrate:tn,unmountComponentAtNode:bn,createPortal:$,createElement:t,createContext:l,createFactory:dn,cloneElement:_n,createRef:c,Fragment:u,isValidElement:mn,isElement:xn,isFragment:pn,isMemo:yn,findDOMNode:Sn,Component:n,PureComponent:N,memo:M,forwardRef:D,flushSync:En,unstable_batchedUpdates:gn,StrictMode:Cn,Suspense:P,SuspenseList:B,lazy:z,__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED:hn};export{O as Children,N as PureComponent,Cn as StrictMode,P as Suspense,B as SuspenseList,hn as __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,_n as cloneElement,dn as createFactory,$ as createPortal,Rn as default,Sn as findDOMNode,En as flushSync,D as forwardRef,tn as hydrate,xn as isElement,pn as isFragment,yn as isMemo,mn as isValidElement,z as lazy,M as memo,nn as render,R as startTransition,bn as unmountComponentAtNode,gn as unstable_batchedUpdates,w as useDeferredValue,I as useInsertionEffect,C as useSyncExternalStore,k as useTransition,vn as version};\n//# sourceMappingURL=compat.module.js.map\n","import { createContext } from 'react';\nimport type { PluginRegistry } from '@embedpdf/core';\n\nexport interface PDFContextState {\n  registry: PluginRegistry | null;\n  isInitializing: boolean;\n  pluginsReady: boolean;\n}\n\nexport const PDFContext = createContext<PDFContextState>({\n  registry: null,\n  isInitializing: true,\n  pluginsReady: false,\n});\n","import React, { useState, useEffect, useRef } from 'react';\nimport { PdfEngine } from '@embedpdf/models';\nimport { PluginRegistry } from '@embedpdf/core';\nimport type { IPlugin, PluginBatchRegistration } from '@embedpdf/core';\n\nimport { PDFContext, PDFContextState } from '../context';\n\ninterface EmbedPDFProps {\n  engine: PdfEngine;\n  onInitialized?: (registry: PluginRegistry) => Promise<void>;\n  plugins: PluginBatchRegistration<IPlugin<any>, any>[];\n  children: React.ReactNode | ((state: PDFContextState) => React.ReactNode);\n}\n\nexport function EmbedPDF({ engine, onInitialized, plugins, children }: EmbedPDFProps) {\n  const [registry, setRegistry] = useState<PluginRegistry | null>(null);\n  const [isInitializing, setIsInitializing] = useState<boolean>(true);\n  const [pluginsReady, setPluginsReady] = useState<boolean>(false);\n  const initRef = useRef<EmbedPDFProps['onInitialized']>(onInitialized);\n\n  useEffect(() => {\n    initRef.current = onInitialized; // update without triggering re-runs\n  }, [onInitialized]);\n\n  useEffect(() => {\n    const pdfViewer = new PluginRegistry(engine);\n    pdfViewer.registerPluginBatch(plugins);\n\n    const initialize = async () => {\n      await pdfViewer.initialize();\n      // if the registry is destroyed, don't do anything\n      if (pdfViewer.isDestroyed()) {\n        return;\n      }\n\n      /* always call the *latest* callback */\n      await initRef.current?.(pdfViewer);\n\n      // if the registry is destroyed, don't do anything\n      if (pdfViewer.isDestroyed()) {\n        return;\n      }\n\n      pdfViewer.pluginsReady().then(() => {\n        if (!pdfViewer.isDestroyed()) {\n          setPluginsReady(true);\n        }\n      });\n\n      // Provide the registry to children via context\n      setRegistry(pdfViewer);\n      setIsInitializing(false);\n    };\n\n    initialize().catch(console.error);\n\n    return () => {\n      pdfViewer.destroy();\n      setRegistry(null);\n      setIsInitializing(true);\n      setPluginsReady(false);\n    };\n  }, [engine, plugins]);\n\n  return (\n    <PDFContext.Provider value={{ registry, isInitializing, pluginsReady }}>\n      {typeof children === 'function'\n        ? children({ registry, isInitializing, pluginsReady })\n        : children}\n    </PDFContext.Provider>\n  );\n}\n","import { useContext } from 'react';\nimport { PDFContext, PDFContextState } from '../context';\n\n/**\n * Hook to access the PDF registry.\n * @returns The PDF registry or null during initialization\n */\nexport function useRegistry(): PDFContextState {\n  const contextValue = useContext(PDFContext);\n\n  // Error if used outside of context\n  if (contextValue === undefined) {\n    throw new Error('useCapability must be used within a PDFContext.Provider');\n  }\n\n  const { registry, isInitializing } = contextValue;\n\n  // During initialization, return null instead of throwing an error\n  if (isInitializing) {\n    return contextValue;\n  }\n\n  // At this point, initialization is complete but registry is still null, which is unexpected\n  if (registry === null) {\n    throw new Error('PDF registry failed to initialize properly');\n  }\n\n  return contextValue;\n}\n","import type { BasePlugin } from '@embedpdf/core';\nimport { useRegistry } from './use-registry';\n\ntype PluginState<T extends BasePlugin> = {\n  plugin: T | null;\n  isLoading: boolean;\n  ready: Promise<void>;\n};\n\n/**\n * Hook to access a plugin.\n * @param pluginId The ID of the plugin to access\n * @returns The plugin or null during initialization\n * @example\n * // Get zoom plugin\n * const zoom = usePlugin<ZoomPlugin>(ZoomPlugin.id);\n */\nexport function usePlugin<T extends BasePlugin>(pluginId: T['id']): PluginState<T> {\n  const { registry } = useRegistry();\n\n  if (registry === null) {\n    return {\n      plugin: null,\n      isLoading: true,\n      ready: new Promise(() => {}),\n    };\n  }\n\n  const plugin = registry.getPlugin<T>(pluginId);\n\n  if (!plugin) {\n    throw new Error(`Plugin ${pluginId} not found`);\n  }\n\n  return {\n    plugin,\n    isLoading: false,\n    ready: plugin.ready(),\n  };\n}\n","import type { BasePlugin } from '@embedpdf/core';\nimport { usePlugin } from './use-plugin';\n\ntype CapabilityState<T extends BasePlugin> = {\n  provides: ReturnType<NonNullable<T['provides']>> | null;\n  isLoading: boolean;\n  ready: Promise<void>;\n};\n\n/**\n * Hook to access a plugin's capability.\n * @param pluginId The ID of the plugin to access\n * @returns The capability provided by the plugin or null during initialization\n * @example\n * // Get zoom capability\n * const zoom = useCapability<ZoomPlugin>(ZoomPlugin.id);\n */\nexport function useCapability<T extends BasePlugin>(pluginId: T['id']): CapabilityState<T> {\n  const { plugin, isLoading, ready } = usePlugin<T>(pluginId);\n\n  if (!plugin) {\n    return {\n      provides: null,\n      isLoading,\n      ready,\n    };\n  }\n\n  if (!plugin.provides) {\n    throw new Error(`Plugin ${pluginId} does not provide a capability`);\n  }\n\n  return {\n    provides: plugin.provides() as ReturnType<NonNullable<T['provides']>>,\n    isLoading,\n    ready,\n  };\n}\n","import { useState, useEffect } from 'react';\nimport { CoreState, StoreState } from '@embedpdf/core';\nimport { useRegistry } from './use-registry';\n\n/**\n * Hook that provides access to the current global store state\n * and re-renders the component when the state changes\n */\nexport function useStoreState<T = CoreState>(): StoreState<T> | null {\n  const { registry } = useRegistry();\n  const [state, setState] = useState<StoreState<T> | null>(null);\n\n  useEffect(() => {\n    if (!registry) return;\n\n    // Get initial state\n    setState(registry.getStore().getState() as StoreState<T>);\n\n    // Subscribe to store changes\n    const unsubscribe = registry.getStore().subscribe((_action, newState) => {\n      setState(newState as StoreState<T>);\n    });\n\n    return () => unsubscribe();\n  }, [registry]);\n\n  return state;\n}\n","import { useState, useEffect } from 'react';\nimport { CoreState, arePropsEqual } from '@embedpdf/core';\nimport { useRegistry } from './use-registry';\n\n/**\n * Hook that provides access to the current core state\n * and re-renders the component only when the core state changes\n */\nexport function useCoreState(): CoreState | null {\n  const { registry } = useRegistry();\n  const [coreState, setCoreState] = useState<CoreState | null>(null);\n\n  useEffect(() => {\n    if (!registry) return;\n\n    const store = registry.getStore();\n\n    // Get initial core state\n    setCoreState(store.getState().core);\n\n    // Create a single subscription that handles all core actions\n    const unsubscribe = store.subscribe((action, newState, oldState) => {\n      // Only update if it's a core action and the core state changed\n      if (store.isCoreAction(action) && !arePropsEqual(newState.core, oldState.core)) {\n        setCoreState(newState.core);\n      }\n    });\n\n    return () => unsubscribe();\n  }, [registry]);\n\n  return coreState;\n}\n","import { PluginManifest } from '@embedpdf/core';\nimport { FullscreenPluginConfig } from './types';\n\nexport const FULLSCREEN_PLUGIN_ID = 'fullscreen';\n\nexport const manifest: PluginManifest<FullscreenPluginConfig> = {\n  id: FULLSCREEN_PLUGIN_ID,\n  name: 'Fullscreen Plugin',\n  version: '1.0.0',\n  provides: ['fullscreen'],\n  requires: [],\n  optional: [],\n  defaultConfig: {\n    enabled: true,\n  },\n};\n","export class DependencyResolver {\n  private dependencyGraph = new Map<string, Set<string>>();\n\n  addNode(id: string, dependencies: string[] = []) {\n    this.dependencyGraph.set(id, new Set(dependencies));\n  }\n\n  private hasCircularDependencies(): boolean {\n    const visited = new Set<string>();\n    const recursionStack = new Set<string>();\n\n    const dfs = (id: string): boolean => {\n      visited.add(id);\n      recursionStack.add(id);\n\n      const dependencies = this.dependencyGraph.get(id) || new Set();\n      for (const dep of dependencies) {\n        if (!visited.has(dep)) {\n          if (dfs(dep)) return true;\n        } else if (recursionStack.has(dep)) {\n          return true; // Circular dependency found\n        }\n      }\n\n      recursionStack.delete(id);\n      return false;\n    };\n\n    for (const id of this.dependencyGraph.keys()) {\n      if (!visited.has(id)) {\n        if (dfs(id)) return true;\n      }\n    }\n\n    return false;\n  }\n\n  resolveLoadOrder(): string[] {\n    if (this.hasCircularDependencies()) {\n      throw new Error('Circular dependencies detected');\n    }\n\n    const result: string[] = [];\n    const visited = new Set<string>();\n    const temp = new Set<string>();\n\n    const visit = (id: string) => {\n      if (temp.has(id)) throw new Error('Circular dependency');\n      if (visited.has(id)) return;\n\n      temp.add(id);\n\n      const dependencies = this.dependencyGraph.get(id) || new Set();\n      for (const dep of dependencies) {\n        visit(dep);\n      }\n\n      temp.delete(id);\n      visited.add(id);\n      result.push(id);\n    };\n\n    for (const id of this.dependencyGraph.keys()) {\n      if (!visited.has(id)) {\n        visit(id);\n      }\n    }\n\n    return result;\n  }\n}\n","export class PluginRegistrationError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'PluginRegistrationError';\n  }\n}\n\nexport class PluginNotFoundError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'PluginNotFoundError';\n  }\n}\n\nexport class CircularDependencyError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'CircularDependencyError';\n  }\n}\n\nexport class CapabilityNotFoundError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'CapabilityNotFoundError';\n  }\n}\n\n// You might also want to add:\nexport class CapabilityConflictError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'CapabilityConflictError';\n  }\n}\n\nexport class PluginInitializationError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'PluginInitializationError';\n  }\n}\n\nexport class PluginConfigurationError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'PluginConfigurationError';\n  }\n}\n","import { Store } from './store';\nimport { Action } from './types';\n\n/**\n * A type-safe store handle for plugins, providing access to plugin-specific state and actions.\n */\nexport class PluginStore<PluginState, PluginAction extends Action> {\n  private store: Store<any, any>;\n  private pluginId: string;\n\n  /**\n   * Initializes the PluginStore with the main store and plugin ID.\n   * @param store The main store instance.\n   * @param pluginId The unique identifier for the plugin.\n   */\n  constructor(store: Store<any, any>, pluginId: string) {\n    this.store = store;\n    this.pluginId = pluginId;\n  }\n\n  /**\n   * Gets the current state of the plugin.\n   * @returns The plugin's state.\n   */\n  getState(): PluginState {\n    return this.store.getState().plugins[this.pluginId] as PluginState;\n  }\n\n  /**\n   * Dispatches an action for the plugin and returns the *new* global state.\n   * If you only need the plugin’s updated state, call `getState()` afterward.\n   * @param action The action to dispatch.\n   * @returns The updated global store state (after plugin reducer).\n   */\n  dispatch(action: PluginAction): PluginState {\n    return this.store.dispatchToPlugin(this.pluginId, action);\n  }\n\n  /**\n   * Subscribes to state changes only for this specific plugin.\n   * You now receive (action, newPluginState, oldPluginState) in the callback.\n   *\n   * @param listener The callback to invoke when plugin state changes.\n   * @returns A function to unsubscribe the listener.\n   */\n  subscribeToState(\n    listener: (action: PluginAction, newState: PluginState, oldState: PluginState) => void,\n  ) {\n    return this.store.subscribeToPlugin(this.pluginId, (action, newPluginState, oldPluginState) => {\n      listener(\n        action as PluginAction,\n        newPluginState as PluginState,\n        oldPluginState as PluginState,\n      );\n    });\n  }\n\n  /**\n   * Subscribes to a specific action type for the plugin.\n   * This still uses the main store's `onAction`, so you get the *global*\n   * old/new store states there. If you specifically want old/new plugin state,\n   * use `subscribeToState` instead.\n   *\n   * @param type The action type to listen for.\n   * @param handler The callback to invoke when the action occurs.\n   * @returns A function to unsubscribe the handler.\n   */\n  onAction<T extends PluginAction['type']>(\n    type: T,\n    handler: (\n      action: Extract<PluginAction, { type: T }>,\n      state: PluginState,\n      oldState: PluginState,\n    ) => void,\n  ) {\n    return this.store.onAction(type, (action, state, oldState) => {\n      handler(\n        action as Extract<PluginAction, { type: T }>,\n        state.plugins[this.pluginId] as PluginState,\n        oldState.plugins[this.pluginId] as PluginState,\n      );\n    });\n  }\n}\n","import { PdfDocumentObject, PdfPageObject, Rotation } from '@embedpdf/models';\n\nexport const LOAD_DOCUMENT = 'LOAD_DOCUMENT';\nexport const SET_DOCUMENT = 'SET_DOCUMENT';\nexport const SET_DOCUMENT_ERROR = 'SET_DOCUMENT_ERROR';\nexport const SET_SCALE = 'SET_SCALE';\nexport const SET_ROTATION = 'SET_ROTATION';\nexport const SET_PAGES = 'SET_PAGES';\n\nexport const CORE_ACTION_TYPES = [\n  LOAD_DOCUMENT,\n  SET_DOCUMENT,\n  SET_DOCUMENT_ERROR,\n  SET_SCALE,\n  SET_ROTATION,\n  SET_PAGES,\n] as const;\n\n// Action Type Interfaces\nexport interface LoadDocumentAction {\n  type: typeof LOAD_DOCUMENT;\n}\n\nexport interface SetDocumentAction {\n  type: typeof SET_DOCUMENT;\n  payload: PdfDocumentObject;\n}\n\nexport interface SetDocumentErrorAction {\n  type: typeof SET_DOCUMENT_ERROR;\n  payload: string;\n}\n\nexport interface SetScaleAction {\n  type: typeof SET_SCALE;\n  payload: number;\n}\n\nexport interface SetRotationAction {\n  type: typeof SET_ROTATION;\n  payload: Rotation;\n}\n\nexport interface SetPagesAction {\n  type: typeof SET_PAGES;\n  payload: PdfPageObject[][];\n}\n\nexport type DocumentAction =\n  | LoadDocumentAction\n  | SetDocumentAction\n  | SetDocumentErrorAction\n  | SetScaleAction\n  | SetRotationAction\n  | SetPagesAction;\n\n// Core actions\nexport type CoreAction = DocumentAction;\n\nexport const loadDocument = (): CoreAction => ({ type: LOAD_DOCUMENT });\nexport const setDocument = (document: PdfDocumentObject): CoreAction => ({\n  type: SET_DOCUMENT,\n  payload: document,\n});\nexport const setDocumentError = (error: string): CoreAction => ({\n  type: SET_DOCUMENT_ERROR,\n  payload: error,\n});\nexport const setScale = (scale: number): CoreAction => ({ type: SET_SCALE, payload: scale });\nexport const setRotation = (rotation: Rotation): CoreAction => ({\n  type: SET_ROTATION,\n  payload: rotation,\n});\nexport const setPages = (pages: PdfPageObject[][]): CoreAction => ({\n  type: SET_PAGES,\n  payload: pages,\n});\n","import { Reducer, Action, StoreState, StoreListener, PluginListener } from './types';\nimport { PluginStore } from './plugin-store';\nimport { CORE_ACTION_TYPES } from './actions';\n\n/**\n * A generic, type-safe store class managing core and plugin states, reducers, and subscriptions.\n * @template CoreState The type of the core state.\n * @template CoreAction The type of actions handled by core reducers (extends Action).\n */\nexport class Store<CoreState, CoreAction extends Action = Action> {\n  private state: StoreState<CoreState>;\n  private coreReducer: Reducer<CoreState, CoreAction>;\n  private pluginReducers: Record<string, Reducer<any, Action>> = {};\n\n  private listeners: StoreListener<CoreState>[] = [];\n  private pluginListeners: Record<string, PluginListener[]> = {};\n\n  /**\n   * Initializes the store with the provided core state.\n   * @param reducer          The core reducer function\n   * @param initialCoreState The initial core state\n   */\n  constructor(\n    reducer: Reducer<CoreState, CoreAction>,\n    public initialCoreState: CoreState,\n  ) {\n    this.state = { core: initialCoreState, plugins: {} };\n    this.coreReducer = reducer;\n  }\n\n  /**\n   * Adds a reducer for a plugin-specific state.\n   * @param pluginId The unique identifier for the plugin.\n   * @param reducer The reducer function for the plugin state.\n   * @param initialState The initial state for the plugin.\n   */\n  addPluginReducer<PluginState>(\n    pluginId: string,\n    reducer: Reducer<PluginState, Action>,\n    initialState: PluginState,\n  ) {\n    this.state.plugins[pluginId] = initialState;\n    this.pluginReducers[pluginId] = reducer;\n  }\n\n  /**\n   * Dispatches an action *only* to the core reducer.\n   * Notifies the global store listeners with (action, newState, oldState).\n   *\n   * @param action The action to dispatch, typed as CoreAction\n   * @returns The updated *global* store state\n   */\n  dispatchToCore(action: CoreAction): StoreState<CoreState> {\n    if (!this.coreReducer) {\n      return this.getState();\n    }\n\n    const oldState = this.getState();\n    // Update core state via its reducer\n    this.state.core = this.coreReducer(this.state.core, action);\n\n    const newState = this.getState();\n    // Notify all main-store subscribers\n    this.listeners.forEach((listener) => listener(action, newState, oldState));\n\n    return newState;\n  }\n\n  /**\n   * Dispatches an action *only* to a specific plugin.\n   * Optionally notifies global store listeners if `notifyGlobal` is true.\n   * Always notifies plugin-specific listeners with (action, newPluginState, oldPluginState).\n   *\n   * @param pluginId   The plugin identifier\n   * @param action     The plugin action to dispatch\n   * @param notifyGlobal Whether to also notify global store listeners\n   * @returns The updated *global* store state\n   */\n  dispatchToPlugin<PluginAction extends Action>(\n    pluginId: string,\n    action: PluginAction,\n    notifyGlobal: boolean = true,\n  ): any {\n    const oldGlobalState = this.getState();\n\n    const reducer = this.pluginReducers[pluginId];\n    if (!reducer) {\n      // No plugin found, just return the old state\n      return oldGlobalState;\n    }\n\n    // Grab the old plugin state\n    const oldPluginState = oldGlobalState.plugins[pluginId];\n    // Reduce to new plugin state\n    const newPluginState = reducer(oldPluginState, action);\n    // Update the store's plugin slice\n    this.state.plugins[pluginId] = newPluginState;\n\n    const newGlobalState = this.getState();\n\n    // If we are notifying the main store subscribers about plugin changes\n    if (notifyGlobal) {\n      this.listeners.forEach((listener) => listener(action, newGlobalState, oldGlobalState));\n    }\n\n    // Notify plugin-specific listeners\n    if (this.pluginListeners[pluginId]) {\n      this.pluginListeners[pluginId].forEach((listener) => {\n        listener(action, newPluginState, oldPluginState);\n      });\n    }\n\n    return newPluginState;\n  }\n\n  /**\n   * Dispatches an action to update the state using:\n   * - the core reducer (if it's a CoreAction)\n   * - *all* plugin reducers (regardless of action type), with no global notify for each plugin\n   *\n   * Returns the new *global* store state after all reducers have processed the action.\n   *\n   * @param action The action to dispatch (can be CoreAction or any Action).\n   */\n  dispatch(action: CoreAction | Action): StoreState<CoreState> {\n    // Keep old state to notify global listeners *once*, after all reducers run.\n    const oldState = this.getState();\n    // 1) Apply core reducer (only if action is a CoreAction)\n    if (this.isCoreAction(action)) {\n      this.state.core = this.coreReducer(this.state.core, action);\n    }\n\n    // 2) Apply plugin reducers (without globally notifying after each plugin)\n    for (const pluginId in this.pluginReducers) {\n      const reducer = this.pluginReducers[pluginId];\n      const oldPluginState = oldState.plugins[pluginId];\n      if (reducer) {\n        this.state.plugins[pluginId] = reducer(oldPluginState, action);\n      }\n      // We do *not* notify global listeners or plugin listeners here,\n      // as that might be undesired \"fan-out\". If you want per-plugin subscription\n      // triggered on every dispatch, you can do so here, but that’s up to you.\n    }\n\n    // 3) Notify global listeners *once* with the final new state\n    const newState = this.getState();\n    this.listeners.forEach((listener) => listener(action, newState, oldState));\n\n    // 4) Return the new global store state\n    return newState;\n  }\n\n  /**\n   * Returns a shallow copy of the current state.\n   * @returns The current store state.\n   */\n  getState(): StoreState<CoreState> {\n    return {\n      core: { ...this.state.core },\n      plugins: { ...this.state.plugins },\n    };\n  }\n\n  /**\n   * Subscribes a listener to *global* state changes.\n   * The callback signature is now (action, newState, oldState).\n   *\n   * @param listener The callback to invoke on state changes\n   * @returns A function to unsubscribe the listener\n   */\n  subscribe(listener: StoreListener<CoreState>) {\n    this.listeners.push(listener);\n    return () => {\n      this.listeners = this.listeners.filter((l) => l !== listener);\n    };\n  }\n\n  /**\n   * Subscribes a listener to *plugin-specific* state changes.\n   * The callback signature is now (action, newPluginState, oldPluginState).\n   *\n   * @param pluginId The unique identifier for the plugin.\n   * @param listener The callback to invoke on plugin state changes.\n   * @returns A function to unsubscribe the listener.\n   */\n  subscribeToPlugin(pluginId: string, listener: PluginListener) {\n    if (!(pluginId in this.state.plugins)) {\n      throw new Error(\n        `Plugin state not found for plugin \"${pluginId}\". Did you forget to call addPluginReducer?`,\n      );\n    }\n\n    if (!this.pluginListeners[pluginId]) {\n      this.pluginListeners[pluginId] = [];\n    }\n    this.pluginListeners[pluginId].push(listener);\n\n    return () => {\n      this.pluginListeners[pluginId] = this.pluginListeners[pluginId].filter((l) => l !== listener);\n      if (this.pluginListeners[pluginId].length === 0) {\n        delete this.pluginListeners[pluginId];\n      }\n    };\n  }\n\n  /**\n   * Subscribes to a specific action type (only from the core's action union).\n   * The callback signature is (action, newState, oldState).\n   *\n   * @param type The action type to listen for.\n   * @param handler The callback to invoke when the action occurs.\n   * @returns A function to unsubscribe the handler.\n   */\n  onAction<T extends CoreAction['type']>(\n    type: T,\n    handler: (\n      action: Extract<CoreAction, { type: T }>,\n      state: StoreState<CoreState>,\n      oldState: StoreState<CoreState>,\n    ) => void,\n  ) {\n    return this.subscribe((action, newState, oldState) => {\n      if (action.type === type) {\n        handler(action as Extract<CoreAction, { type: T }>, newState, oldState);\n      }\n    });\n  }\n\n  /**\n   * Gets a PluginStore handle for a specific plugin.\n   * @param pluginId The unique identifier for the plugin.\n   * @returns A PluginStore instance for the plugin.\n   */\n  getPluginStore<PluginState, PluginAction extends Action>(\n    pluginId: string,\n  ): PluginStore<PluginState, PluginAction> {\n    if (!(pluginId in this.state.plugins)) {\n      throw new Error(\n        `Plugin state not found for plugin \"${pluginId}\". Did you forget to call addPluginReducer?`,\n      );\n    }\n    return new PluginStore<PluginState, PluginAction>(this, pluginId);\n  }\n\n  /**\n   * Helper method to check if an action is a CoreAction.\n   * Adjust if you have a more refined way to differentiate CoreAction vs. any other Action.\n   */\n  public isCoreAction(action: Action): action is CoreAction {\n    // In many codebases you'd do something more robust here\n    // or rely on TypeScript's narrowing logic if possible.\n    return CORE_ACTION_TYPES.includes(action.type as (typeof CORE_ACTION_TYPES)[number]);\n  }\n\n  /**\n   * Destroy the store: drop every listener and plugin reducer\n   */\n  public destroy(): void {\n    // 1. empty listener collections\n    this.listeners.length = 0;\n    for (const id in this.pluginListeners) {\n      this.pluginListeners[id]?.splice?.(0);\n    }\n    this.pluginListeners = {};\n\n    // 2. wipe plugin reducers and states\n    this.pluginReducers = {};\n    this.state.plugins = {};\n\n    // 3. reset core state to initial\n    this.state.core = { ...this.initialCoreState };\n  }\n}\n","// src/geometry.ts\nvar Rotation = /* @__PURE__ */ ((Rotation2) => {\n  Rotation2[Rotation2[\"Degree0\"] = 0] = \"Degree0\";\n  Rotation2[Rotation2[\"Degree90\"] = 1] = \"Degree90\";\n  Rotation2[Rotation2[\"Degree180\"] = 2] = \"Degree180\";\n  Rotation2[Rotation2[\"Degree270\"] = 3] = \"Degree270\";\n  return Rotation2;\n})(Rotation || {});\nfunction toIntPos(p) {\n  return { x: Math.floor(p.x), y: Math.floor(p.y) };\n}\nfunction toIntSize(s) {\n  return { width: Math.ceil(s.width), height: Math.ceil(s.height) };\n}\nfunction toIntRect(r) {\n  return {\n    origin: toIntPos(r.origin),\n    size: toIntSize(r.size)\n  };\n}\nfunction calculateDegree(rotation) {\n  switch (rotation) {\n    case 0 /* Degree0 */:\n      return 0;\n    case 1 /* Degree90 */:\n      return 90;\n    case 2 /* Degree180 */:\n      return 180;\n    case 3 /* Degree270 */:\n      return 270;\n  }\n}\nfunction calculateAngle(rotation) {\n  return calculateDegree(rotation) * Math.PI / 180;\n}\nfunction swap(size) {\n  const { width, height } = size;\n  return {\n    width: height,\n    height: width\n  };\n}\nfunction transformSize(size, rotation, scaleFactor) {\n  size = rotation % 2 === 0 ? size : swap(size);\n  return {\n    width: size.width * scaleFactor,\n    height: size.height * scaleFactor\n  };\n}\nfunction quadToRect(q) {\n  const xs = [q.p1.x, q.p2.x, q.p3.x, q.p4.x];\n  const ys = [q.p1.y, q.p2.y, q.p3.y, q.p4.y];\n  return {\n    origin: { x: Math.min(...xs), y: Math.min(...ys) },\n    size: {\n      width: Math.max(...xs) - Math.min(...xs),\n      height: Math.max(...ys) - Math.min(...ys)\n    }\n  };\n}\nfunction rectToQuad(r) {\n  return {\n    p1: { x: r.origin.x, y: r.origin.y },\n    p2: { x: r.origin.x + r.size.width, y: r.origin.y },\n    p3: { x: r.origin.x + r.size.width, y: r.origin.y + r.size.height },\n    p4: { x: r.origin.x, y: r.origin.y + r.size.height }\n  };\n}\nfunction rotatePosition(containerSize, position, rotation) {\n  let x = position.x;\n  let y = position.y;\n  switch (rotation) {\n    case 0 /* Degree0 */:\n      x = position.x;\n      y = position.y;\n      break;\n    case 1 /* Degree90 */:\n      x = containerSize.height - position.y;\n      y = position.x;\n      break;\n    case 2 /* Degree180 */:\n      x = containerSize.width - position.x;\n      y = containerSize.height - position.y;\n      break;\n    case 3 /* Degree270 */:\n      x = position.y;\n      y = containerSize.width - position.x;\n      break;\n  }\n  return {\n    x,\n    y\n  };\n}\nfunction scalePosition(position, scaleFactor) {\n  return {\n    x: position.x * scaleFactor,\n    y: position.y * scaleFactor\n  };\n}\nfunction transformPosition(containerSize, position, rotation, scaleFactor) {\n  return scalePosition(rotatePosition(containerSize, position, rotation), scaleFactor);\n}\nfunction restorePosition(containerSize, position, rotation, scaleFactor) {\n  return scalePosition(\n    rotatePosition(containerSize, position, (4 - rotation) % 4),\n    1 / scaleFactor\n  );\n}\nfunction rotateRect(containerSize, rect, rotation) {\n  let x = rect.origin.x;\n  let y = rect.origin.y;\n  let size = rect.size;\n  switch (rotation) {\n    case 0 /* Degree0 */:\n      break;\n    case 1 /* Degree90 */:\n      x = containerSize.height - rect.origin.y - rect.size.height;\n      y = rect.origin.x;\n      size = swap(rect.size);\n      break;\n    case 2 /* Degree180 */:\n      x = containerSize.width - rect.origin.x - rect.size.width;\n      y = containerSize.height - rect.origin.y - rect.size.height;\n      break;\n    case 3 /* Degree270 */:\n      x = rect.origin.y;\n      y = containerSize.width - rect.origin.x - rect.size.width;\n      size = swap(rect.size);\n      break;\n  }\n  return {\n    origin: {\n      x,\n      y\n    },\n    size: {\n      width: size.width,\n      height: size.height\n    }\n  };\n}\nfunction scaleRect(rect, scaleFactor) {\n  return {\n    origin: {\n      x: rect.origin.x * scaleFactor,\n      y: rect.origin.y * scaleFactor\n    },\n    size: {\n      width: rect.size.width * scaleFactor,\n      height: rect.size.height * scaleFactor\n    }\n  };\n}\nfunction transformRect(containerSize, rect, rotation, scaleFactor) {\n  return scaleRect(rotateRect(containerSize, rect, rotation), scaleFactor);\n}\nfunction restoreRect(containerSize, rect, rotation, scaleFactor) {\n  return scaleRect(rotateRect(containerSize, rect, (4 - rotation) % 4), 1 / scaleFactor);\n}\nfunction restoreOffset(offset, rotation, scaleFactor) {\n  let offsetX = offset.x;\n  let offsetY = offset.y;\n  switch (rotation) {\n    case 0 /* Degree0 */:\n      offsetX = offset.x / scaleFactor;\n      offsetY = offset.y / scaleFactor;\n      break;\n    case 1 /* Degree90 */:\n      offsetX = offset.y / scaleFactor;\n      offsetY = -offset.x / scaleFactor;\n      break;\n    case 2 /* Degree180 */:\n      offsetX = -offset.x / scaleFactor;\n      offsetY = -offset.y / scaleFactor;\n      break;\n    case 3 /* Degree270 */:\n      offsetX = -offset.y / scaleFactor;\n      offsetY = offset.x / scaleFactor;\n      break;\n  }\n  return {\n    x: offsetX,\n    y: offsetY\n  };\n}\nfunction boundingRect(rects) {\n  if (rects.length === 0) return null;\n  let minX = rects[0].origin.x, minY = rects[0].origin.y, maxX = rects[0].origin.x + rects[0].size.width, maxY = rects[0].origin.y + rects[0].size.height;\n  for (const r of rects) {\n    minX = Math.min(minX, r.origin.x);\n    minY = Math.min(minY, r.origin.y);\n    maxX = Math.max(maxX, r.origin.x + r.size.width);\n    maxY = Math.max(maxY, r.origin.y + r.size.height);\n  }\n  return {\n    origin: {\n      x: minX,\n      y: minY\n    },\n    size: {\n      width: maxX - minX,\n      height: maxY - minY\n    }\n  };\n}\nvar makeMatrix = (rectangle, rotation, scaleFactor) => {\n  const { width, height } = rectangle.size;\n  switch (rotation) {\n    case 0 /* Degree0 */:\n      return {\n        a: scaleFactor,\n        b: 0,\n        c: 0,\n        d: -scaleFactor,\n        e: 0,\n        f: height * scaleFactor\n      };\n    case 1 /* Degree90 */:\n      return {\n        a: 0,\n        b: scaleFactor,\n        c: scaleFactor,\n        d: 0,\n        e: 0,\n        f: 0\n      };\n    case 2 /* Degree180 */:\n      return {\n        a: -scaleFactor,\n        b: 0,\n        c: 0,\n        d: scaleFactor,\n        e: width * scaleFactor,\n        f: 0\n      };\n    case 3 /* Degree270 */:\n      return {\n        a: 0,\n        b: -scaleFactor,\n        c: -scaleFactor,\n        d: 0,\n        e: height * scaleFactor,\n        f: width * scaleFactor\n      };\n  }\n};\n\n// src/logger.ts\nvar NoopLogger = class {\n  /** {@inheritDoc Logger.debug} */\n  debug() {\n  }\n  /** {@inheritDoc Logger.info} */\n  info() {\n  }\n  /** {@inheritDoc Logger.warn} */\n  warn() {\n  }\n  /** {@inheritDoc Logger.error} */\n  error() {\n  }\n  /** {@inheritDoc Logger.perf} */\n  perf() {\n  }\n};\nvar ConsoleLogger = class {\n  /** {@inheritDoc Logger.debug} */\n  debug(source, category, ...args) {\n    console.debug(`${source}.${category}`, ...args);\n  }\n  /** {@inheritDoc Logger.info} */\n  info(source, category, ...args) {\n    console.info(`${source}.${category}`, ...args);\n  }\n  /** {@inheritDoc Logger.warn} */\n  warn(source, category, ...args) {\n    console.warn(`${source}.${category}`, ...args);\n  }\n  /** {@inheritDoc Logger.error} */\n  error(source, category, ...args) {\n    console.error(`${source}.${category}`, ...args);\n  }\n  /** {@inheritDoc Logger.perf} */\n  perf(source, category, event, phase, ...args) {\n    console.info(`${source}.${category}.${event}.${phase}`, ...args);\n  }\n};\nvar LogLevel = /* @__PURE__ */ ((LogLevel2) => {\n  LogLevel2[LogLevel2[\"Debug\"] = 0] = \"Debug\";\n  LogLevel2[LogLevel2[\"Info\"] = 1] = \"Info\";\n  LogLevel2[LogLevel2[\"Warn\"] = 2] = \"Warn\";\n  LogLevel2[LogLevel2[\"Error\"] = 3] = \"Error\";\n  return LogLevel2;\n})(LogLevel || {});\nvar LevelLogger = class {\n  /**\n   * create new LevelLogger\n   * @param logger - the original logger\n   * @param level - log level that used for filtering, all logs lower than this level will be filtered out\n   */\n  constructor(logger, level) {\n    this.logger = logger;\n    this.level = level;\n  }\n  /** {@inheritDoc Logger.debug} */\n  debug(source, category, ...args) {\n    if (this.level <= 0 /* Debug */) {\n      this.logger.debug(source, category, ...args);\n    }\n  }\n  /** {@inheritDoc Logger.info} */\n  info(source, category, ...args) {\n    if (this.level <= 1 /* Info */) {\n      this.logger.info(source, category, ...args);\n    }\n  }\n  /** {@inheritDoc Logger.warn} */\n  warn(source, category, ...args) {\n    if (this.level <= 2 /* Warn */) {\n      this.logger.warn(source, category, ...args);\n    }\n  }\n  /** {@inheritDoc Logger.error} */\n  error(source, category, ...args) {\n    if (this.level <= 3 /* Error */) {\n      this.logger.error(source, category, ...args);\n    }\n  }\n  /** {@inheritDoc Logger.perf} */\n  perf(source, category, event, phase, ...args) {\n    this.logger.perf(source, category, event, phase, ...args);\n  }\n};\nvar PerfLogger = class {\n  /**\n   * create new PerfLogger\n   */\n  constructor() {\n  }\n  /** {@inheritDoc Logger.debug} */\n  debug(source, category, ...args) {\n  }\n  /** {@inheritDoc Logger.info} */\n  info(source, category, ...args) {\n  }\n  /** {@inheritDoc Logger.warn} */\n  warn(source, category, ...args) {\n  }\n  /** {@inheritDoc Logger.error} */\n  error(source, category, ...args) {\n  }\n  /** {@inheritDoc Logger.perf} */\n  perf(source, category, event, phase, identifier, ...args) {\n    switch (phase) {\n      case \"Begin\":\n        window.performance.mark(`${source}.${category}.${event}.${phase}.${identifier}`, {\n          detail: args\n        });\n        break;\n      case \"End\":\n        window.performance.mark(`${source}.${category}.${event}.${phase}.${identifier}`, {\n          detail: args\n        });\n        window.performance.measure(\n          `${source}.${category}.${event}.Measure.${identifier}`,\n          `${source}.${category}.${event}.Begin.${identifier}`,\n          `${source}.${category}.${event}.End.${identifier}`\n        );\n        break;\n    }\n  }\n};\nvar AllLogger = class {\n  /**\n   * create new PerfLogger\n   */\n  constructor(loggers) {\n    this.loggers = loggers;\n  }\n  /** {@inheritDoc Logger.debug} */\n  debug(source, category, ...args) {\n    for (const logger of this.loggers) {\n      logger.debug(source, category, ...args);\n    }\n  }\n  /** {@inheritDoc Logger.info} */\n  info(source, category, ...args) {\n    for (const logger of this.loggers) {\n      logger.info(source, category, ...args);\n    }\n  }\n  /** {@inheritDoc Logger.warn} */\n  warn(source, category, ...args) {\n    for (const logger of this.loggers) {\n      logger.warn(source, category, ...args);\n    }\n  }\n  /** {@inheritDoc Logger.error} */\n  error(source, category, ...args) {\n    for (const logger of this.loggers) {\n      logger.error(source, category, ...args);\n    }\n  }\n  /** {@inheritDoc Logger.perf} */\n  perf(source, category, event, phase, ...args) {\n    for (const logger of this.loggers) {\n      logger.perf(source, category, event, phase, ...args);\n    }\n  }\n};\n\n// src/task.ts\nvar TaskStage = /* @__PURE__ */ ((TaskStage2) => {\n  TaskStage2[TaskStage2[\"Pending\"] = 0] = \"Pending\";\n  TaskStage2[TaskStage2[\"Resolved\"] = 1] = \"Resolved\";\n  TaskStage2[TaskStage2[\"Rejected\"] = 2] = \"Rejected\";\n  TaskStage2[TaskStage2[\"Aborted\"] = 3] = \"Aborted\";\n  return TaskStage2;\n})(TaskStage || {});\nvar TaskAbortedError = class extends Error {\n  constructor(reason) {\n    super(`Task aborted: ${JSON.stringify(reason)}`);\n    this.name = \"TaskAbortedError\";\n  }\n};\nvar TaskRejectedError = class extends Error {\n  constructor(reason) {\n    super(`Task rejected: ${JSON.stringify(reason)}`);\n    this.name = \"TaskRejectedError\";\n  }\n};\nvar Task = class _Task {\n  constructor() {\n    this.state = {\n      stage: 0 /* Pending */\n    };\n    /**\n     * callbacks that will be executed when task is resolved\n     */\n    this.resolvedCallbacks = [];\n    /**\n     * callbacks that will be executed when task is rejected\n     */\n    this.rejectedCallbacks = [];\n    /**\n     * Promise that will be resolved when task is settled\n     */\n    this._promise = null;\n  }\n  /**\n   * Convert task to promise\n   * @returns promise that will be resolved when task is settled\n   */\n  toPromise() {\n    if (!this._promise) {\n      this._promise = new Promise((resolve, reject) => {\n        this.wait(\n          (result) => resolve(result),\n          (error) => {\n            if (error.type === \"abort\") {\n              reject(new TaskAbortedError(error.reason));\n            } else {\n              reject(new TaskRejectedError(error.reason));\n            }\n          }\n        );\n      });\n    }\n    return this._promise;\n  }\n  /**\n   * wait for task to be settled\n   * @param resolvedCallback - callback for resolved value\n   * @param rejectedCallback - callback for rejected value\n   */\n  wait(resolvedCallback, rejectedCallback) {\n    switch (this.state.stage) {\n      case 0 /* Pending */:\n        this.resolvedCallbacks.push(resolvedCallback);\n        this.rejectedCallbacks.push(rejectedCallback);\n        break;\n      case 1 /* Resolved */:\n        resolvedCallback(this.state.result);\n        break;\n      case 2 /* Rejected */:\n        rejectedCallback({\n          type: \"reject\",\n          reason: this.state.reason\n        });\n        break;\n      case 3 /* Aborted */:\n        rejectedCallback({\n          type: \"abort\",\n          reason: this.state.reason\n        });\n        break;\n    }\n  }\n  /**\n   * resolve task with specific result\n   * @param result - result value\n   */\n  resolve(result) {\n    if (this.state.stage === 0 /* Pending */) {\n      this.state = {\n        stage: 1 /* Resolved */,\n        result\n      };\n      for (const resolvedCallback of this.resolvedCallbacks) {\n        try {\n          resolvedCallback(result);\n        } catch (e) {\n        }\n      }\n      this.resolvedCallbacks = [];\n      this.rejectedCallbacks = [];\n    }\n  }\n  /**\n   * reject task with specific reason\n   * @param reason - abort reason\n   *\n   */\n  reject(reason) {\n    if (this.state.stage === 0 /* Pending */) {\n      this.state = {\n        stage: 2 /* Rejected */,\n        reason\n      };\n      for (const rejectedCallback of this.rejectedCallbacks) {\n        try {\n          rejectedCallback({\n            type: \"reject\",\n            reason\n          });\n        } catch (e) {\n        }\n      }\n      this.resolvedCallbacks = [];\n      this.rejectedCallbacks = [];\n    }\n  }\n  /**\n   * abort task with specific reason\n   * @param reason - abort reason\n   */\n  abort(reason) {\n    if (this.state.stage === 0 /* Pending */) {\n      this.state = {\n        stage: 3 /* Aborted */,\n        reason\n      };\n      for (const rejectedCallback of this.rejectedCallbacks) {\n        try {\n          rejectedCallback({\n            type: \"abort\",\n            reason\n          });\n        } catch (e) {\n        }\n      }\n      this.resolvedCallbacks = [];\n      this.rejectedCallbacks = [];\n    }\n  }\n  /**\n   * fail task with a TaskError from another task\n   * This is a convenience method for error propagation between tasks\n   * @param error - TaskError from another task\n   */\n  fail(error) {\n    if (error.type === \"abort\") {\n      this.abort(error.reason);\n    } else {\n      this.reject(error.reason);\n    }\n  }\n  /**\n   * Static method to wait for all tasks to resolve\n   * Returns a new task that resolves with an array of all results\n   * Rejects immediately if any task fails\n   *\n   * @param tasks - array of tasks to wait for\n   * @returns new task that resolves when all input tasks resolve\n   * @public\n   */\n  static all(tasks) {\n    const combinedTask = new _Task();\n    if (tasks.length === 0) {\n      combinedTask.resolve([]);\n      return combinedTask;\n    }\n    const results = new Array(tasks.length);\n    let resolvedCount = 0;\n    let isSettled = false;\n    tasks.forEach((task, index) => {\n      task.wait(\n        (result) => {\n          if (isSettled) return;\n          results[index] = result;\n          resolvedCount++;\n          if (resolvedCount === tasks.length) {\n            isSettled = true;\n            combinedTask.resolve(results);\n          }\n        },\n        (error) => {\n          if (isSettled) return;\n          isSettled = true;\n          if (error.type === \"abort\") {\n            combinedTask.abort(error.reason);\n          } else {\n            combinedTask.reject(error.reason);\n          }\n        }\n      );\n    });\n    return combinedTask;\n  }\n  /**\n   * Static method to wait for all tasks to settle (resolve, reject, or abort)\n   * Always resolves with an array of settlement results\n   *\n   * @param tasks - array of tasks to wait for\n   * @returns new task that resolves when all input tasks settle\n   * @public\n   */\n  static allSettled(tasks) {\n    const combinedTask = new _Task();\n    if (tasks.length === 0) {\n      combinedTask.resolve([]);\n      return combinedTask;\n    }\n    const results = new Array(tasks.length);\n    let settledCount = 0;\n    tasks.forEach((task, index) => {\n      task.wait(\n        (result) => {\n          results[index] = { status: \"resolved\", value: result };\n          settledCount++;\n          if (settledCount === tasks.length) {\n            combinedTask.resolve(results);\n          }\n        },\n        (error) => {\n          results[index] = {\n            status: error.type === \"abort\" ? \"aborted\" : \"rejected\",\n            reason: error.reason\n          };\n          settledCount++;\n          if (settledCount === tasks.length) {\n            combinedTask.resolve(results);\n          }\n        }\n      );\n    });\n    return combinedTask;\n  }\n  /**\n   * Static method that resolves/rejects with the first task that settles\n   *\n   * @param tasks - array of tasks to race\n   * @returns new task that settles with the first input task that settles\n   * @public\n   */\n  static race(tasks) {\n    const combinedTask = new _Task();\n    if (tasks.length === 0) {\n      combinedTask.reject(\"No tasks provided\");\n      return combinedTask;\n    }\n    let isSettled = false;\n    tasks.forEach((task) => {\n      task.wait(\n        (result) => {\n          if (isSettled) return;\n          isSettled = true;\n          combinedTask.resolve(result);\n        },\n        (error) => {\n          if (isSettled) return;\n          isSettled = true;\n          if (error.type === \"abort\") {\n            combinedTask.abort(error.reason);\n          } else {\n            combinedTask.reject(error.reason);\n          }\n        }\n      );\n    });\n    return combinedTask;\n  }\n  /**\n   * Utility to track progress of multiple tasks\n   *\n   * @param tasks - array of tasks to track\n   * @param onProgress - callback called when any task completes\n   * @returns new task that resolves when all input tasks resolve\n   * @public\n   */\n  static withProgress(tasks, onProgress) {\n    const combinedTask = _Task.all(tasks);\n    if (onProgress) {\n      let completedCount = 0;\n      tasks.forEach((task) => {\n        task.wait(\n          () => {\n            completedCount++;\n            onProgress(completedCount, tasks.length);\n          },\n          () => {\n            completedCount++;\n            onProgress(completedCount, tasks.length);\n          }\n        );\n      });\n    }\n    return combinedTask;\n  }\n};\n\n// src/pdf.ts\nvar PdfSoftHyphenMarker = \"\\xAD\";\nvar PdfZeroWidthSpace = \"\\u200B\";\nvar PdfWordJoiner = \"\\u2060\";\nvar PdfBomOrZwnbsp = \"\\uFEFF\";\nvar PdfNonCharacterFFFE = \"\\uFFFE\";\nvar PdfNonCharacterFFFF = \"\\uFFFF\";\nvar PdfUnwantedTextMarkers = Object.freeze([\n  PdfSoftHyphenMarker,\n  PdfZeroWidthSpace,\n  PdfWordJoiner,\n  PdfBomOrZwnbsp,\n  PdfNonCharacterFFFE,\n  PdfNonCharacterFFFF\n]);\nvar PdfUnwantedTextRegex = new RegExp(`[${PdfUnwantedTextMarkers.join(\"\")}]`, \"g\");\nfunction stripPdfUnwantedMarkers(text) {\n  return text.replace(PdfUnwantedTextRegex, \"\");\n}\nvar PdfZoomMode = /* @__PURE__ */ ((PdfZoomMode2) => {\n  PdfZoomMode2[PdfZoomMode2[\"Unknown\"] = 0] = \"Unknown\";\n  PdfZoomMode2[PdfZoomMode2[\"XYZ\"] = 1] = \"XYZ\";\n  PdfZoomMode2[PdfZoomMode2[\"FitPage\"] = 2] = \"FitPage\";\n  PdfZoomMode2[PdfZoomMode2[\"FitHorizontal\"] = 3] = \"FitHorizontal\";\n  PdfZoomMode2[PdfZoomMode2[\"FitVertical\"] = 4] = \"FitVertical\";\n  PdfZoomMode2[PdfZoomMode2[\"FitRectangle\"] = 5] = \"FitRectangle\";\n  return PdfZoomMode2;\n})(PdfZoomMode || {});\nvar PdfBlendMode = /* @__PURE__ */ ((PdfBlendMode2) => {\n  PdfBlendMode2[PdfBlendMode2[\"Normal\"] = 0] = \"Normal\";\n  PdfBlendMode2[PdfBlendMode2[\"Multiply\"] = 1] = \"Multiply\";\n  PdfBlendMode2[PdfBlendMode2[\"Screen\"] = 2] = \"Screen\";\n  PdfBlendMode2[PdfBlendMode2[\"Overlay\"] = 3] = \"Overlay\";\n  PdfBlendMode2[PdfBlendMode2[\"Darken\"] = 4] = \"Darken\";\n  PdfBlendMode2[PdfBlendMode2[\"Lighten\"] = 5] = \"Lighten\";\n  PdfBlendMode2[PdfBlendMode2[\"ColorDodge\"] = 6] = \"ColorDodge\";\n  PdfBlendMode2[PdfBlendMode2[\"ColorBurn\"] = 7] = \"ColorBurn\";\n  PdfBlendMode2[PdfBlendMode2[\"HardLight\"] = 8] = \"HardLight\";\n  PdfBlendMode2[PdfBlendMode2[\"SoftLight\"] = 9] = \"SoftLight\";\n  PdfBlendMode2[PdfBlendMode2[\"Difference\"] = 10] = \"Difference\";\n  PdfBlendMode2[PdfBlendMode2[\"Exclusion\"] = 11] = \"Exclusion\";\n  PdfBlendMode2[PdfBlendMode2[\"Hue\"] = 12] = \"Hue\";\n  PdfBlendMode2[PdfBlendMode2[\"Saturation\"] = 13] = \"Saturation\";\n  PdfBlendMode2[PdfBlendMode2[\"Color\"] = 14] = \"Color\";\n  PdfBlendMode2[PdfBlendMode2[\"Luminosity\"] = 15] = \"Luminosity\";\n  return PdfBlendMode2;\n})(PdfBlendMode || {});\nvar MixedBlendMode = Symbol(\"mixed\");\nvar BLEND_MODE_INFOS = Object.freeze([\n  { id: 0 /* Normal */, label: \"Normal\", css: \"normal\" },\n  { id: 1 /* Multiply */, label: \"Multiply\", css: \"multiply\" },\n  { id: 2 /* Screen */, label: \"Screen\", css: \"screen\" },\n  { id: 3 /* Overlay */, label: \"Overlay\", css: \"overlay\" },\n  { id: 4 /* Darken */, label: \"Darken\", css: \"darken\" },\n  { id: 5 /* Lighten */, label: \"Lighten\", css: \"lighten\" },\n  { id: 6 /* ColorDodge */, label: \"Color Dodge\", css: \"color-dodge\" },\n  { id: 7 /* ColorBurn */, label: \"Color Burn\", css: \"color-burn\" },\n  { id: 8 /* HardLight */, label: \"Hard Light\", css: \"hard-light\" },\n  { id: 9 /* SoftLight */, label: \"Soft Light\", css: \"soft-light\" },\n  { id: 10 /* Difference */, label: \"Difference\", css: \"difference\" },\n  { id: 11 /* Exclusion */, label: \"Exclusion\", css: \"exclusion\" },\n  { id: 12 /* Hue */, label: \"Hue\", css: \"hue\" },\n  { id: 13 /* Saturation */, label: \"Saturation\", css: \"saturation\" },\n  { id: 14 /* Color */, label: \"Color\", css: \"color\" },\n  { id: 15 /* Luminosity */, label: \"Luminosity\", css: \"luminosity\" }\n]);\nvar enumToInfo = BLEND_MODE_INFOS.reduce(\n  (m, info) => {\n    m[info.id] = info;\n    return m;\n  },\n  {}\n);\nvar cssToEnum = BLEND_MODE_INFOS.reduce((m, info) => {\n  m[info.css] = info.id;\n  return m;\n}, {});\nfunction getBlendModeInfo(mode) {\n  return enumToInfo[mode] ?? enumToInfo[0 /* Normal */];\n}\nfunction blendModeToCss(mode) {\n  return getBlendModeInfo(mode).css;\n}\nfunction cssToBlendMode(value) {\n  return cssToEnum[value];\n}\nfunction blendModeLabel(mode) {\n  return getBlendModeInfo(mode).label;\n}\nfunction reduceBlendModes(modes) {\n  if (!modes.length) return 0 /* Normal */;\n  const first = modes[0];\n  return modes.every((m) => m === first) ? first : MixedBlendMode;\n}\nvar blendModeSelectOptions = BLEND_MODE_INFOS.map((info) => ({\n  value: info.id,\n  label: info.label\n}));\nfunction uiBlendModeDisplay(value) {\n  return value === MixedBlendMode ? \"(mixed)\" : blendModeLabel(value);\n}\nvar PdfActionType = /* @__PURE__ */ ((PdfActionType2) => {\n  PdfActionType2[PdfActionType2[\"Unsupported\"] = 0] = \"Unsupported\";\n  PdfActionType2[PdfActionType2[\"Goto\"] = 1] = \"Goto\";\n  PdfActionType2[PdfActionType2[\"RemoteGoto\"] = 2] = \"RemoteGoto\";\n  PdfActionType2[PdfActionType2[\"URI\"] = 3] = \"URI\";\n  PdfActionType2[PdfActionType2[\"LaunchAppOrOpenFile\"] = 4] = \"LaunchAppOrOpenFile\";\n  return PdfActionType2;\n})(PdfActionType || {});\nvar PdfAnnotationSubtype = /* @__PURE__ */ ((PdfAnnotationSubtype2) => {\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"TEXT\"] = 1] = \"TEXT\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"LINK\"] = 2] = \"LINK\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"FREETEXT\"] = 3] = \"FREETEXT\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"LINE\"] = 4] = \"LINE\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"SQUARE\"] = 5] = \"SQUARE\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"CIRCLE\"] = 6] = \"CIRCLE\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"POLYGON\"] = 7] = \"POLYGON\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"POLYLINE\"] = 8] = \"POLYLINE\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"HIGHLIGHT\"] = 9] = \"HIGHLIGHT\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"UNDERLINE\"] = 10] = \"UNDERLINE\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"SQUIGGLY\"] = 11] = \"SQUIGGLY\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"STRIKEOUT\"] = 12] = \"STRIKEOUT\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"STAMP\"] = 13] = \"STAMP\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"CARET\"] = 14] = \"CARET\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"INK\"] = 15] = \"INK\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"POPUP\"] = 16] = \"POPUP\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"FILEATTACHMENT\"] = 17] = \"FILEATTACHMENT\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"SOUND\"] = 18] = \"SOUND\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"MOVIE\"] = 19] = \"MOVIE\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"WIDGET\"] = 20] = \"WIDGET\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"SCREEN\"] = 21] = \"SCREEN\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"PRINTERMARK\"] = 22] = \"PRINTERMARK\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"TRAPNET\"] = 23] = \"TRAPNET\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"WATERMARK\"] = 24] = \"WATERMARK\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"THREED\"] = 25] = \"THREED\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"RICHMEDIA\"] = 26] = \"RICHMEDIA\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"XFAWIDGET\"] = 27] = \"XFAWIDGET\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"REDACT\"] = 28] = \"REDACT\";\n  return PdfAnnotationSubtype2;\n})(PdfAnnotationSubtype || {});\nvar PdfAnnotationSubtypeName = {\n  [0 /* UNKNOWN */]: \"unknow\",\n  [1 /* TEXT */]: \"text\",\n  [2 /* LINK */]: \"link\",\n  [3 /* FREETEXT */]: \"freetext\",\n  [4 /* LINE */]: \"line\",\n  [5 /* SQUARE */]: \"square\",\n  [6 /* CIRCLE */]: \"circle\",\n  [7 /* POLYGON */]: \"polygon\",\n  [8 /* POLYLINE */]: \"polyline\",\n  [9 /* HIGHLIGHT */]: \"highlight\",\n  [10 /* UNDERLINE */]: \"underline\",\n  [11 /* SQUIGGLY */]: \"squiggly\",\n  [12 /* STRIKEOUT */]: \"strikeout\",\n  [13 /* STAMP */]: \"stamp\",\n  [14 /* CARET */]: \"caret\",\n  [15 /* INK */]: \"ink\",\n  [16 /* POPUP */]: \"popup\",\n  [17 /* FILEATTACHMENT */]: \"fileattachment\",\n  [18 /* SOUND */]: \"sound\",\n  [19 /* MOVIE */]: \"movie\",\n  [20 /* WIDGET */]: \"widget\",\n  [21 /* SCREEN */]: \"screen\",\n  [22 /* PRINTERMARK */]: \"printermark\",\n  [23 /* TRAPNET */]: \"trapnet\",\n  [24 /* WATERMARK */]: \"watermark\",\n  [25 /* THREED */]: \"threed\",\n  [26 /* RICHMEDIA */]: \"richmedia\",\n  [27 /* XFAWIDGET */]: \"xfawidget\",\n  [28 /* REDACT */]: \"redact\"\n};\nvar PdfAnnotationObjectStatus = /* @__PURE__ */ ((PdfAnnotationObjectStatus2) => {\n  PdfAnnotationObjectStatus2[PdfAnnotationObjectStatus2[\"Created\"] = 0] = \"Created\";\n  PdfAnnotationObjectStatus2[PdfAnnotationObjectStatus2[\"Committed\"] = 1] = \"Committed\";\n  return PdfAnnotationObjectStatus2;\n})(PdfAnnotationObjectStatus || {});\nvar AppearanceMode = /* @__PURE__ */ ((AppearanceMode2) => {\n  AppearanceMode2[AppearanceMode2[\"Normal\"] = 0] = \"Normal\";\n  AppearanceMode2[AppearanceMode2[\"Rollover\"] = 1] = \"Rollover\";\n  AppearanceMode2[AppearanceMode2[\"Down\"] = 2] = \"Down\";\n  return AppearanceMode2;\n})(AppearanceMode || {});\nvar PdfAnnotationState = /* @__PURE__ */ ((PdfAnnotationState2) => {\n  PdfAnnotationState2[\"Marked\"] = \"Marked\";\n  PdfAnnotationState2[\"Unmarked\"] = \"Unmarked\";\n  PdfAnnotationState2[\"Accepted\"] = \"Accepted\";\n  PdfAnnotationState2[\"Rejected\"] = \"Rejected\";\n  PdfAnnotationState2[\"Complete\"] = \"Complete\";\n  PdfAnnotationState2[\"Cancelled\"] = \"Cancelled\";\n  PdfAnnotationState2[\"None\"] = \"None\";\n  return PdfAnnotationState2;\n})(PdfAnnotationState || {});\nvar PdfAnnotationStateModel = /* @__PURE__ */ ((PdfAnnotationStateModel2) => {\n  PdfAnnotationStateModel2[\"Marked\"] = \"Marked\";\n  PdfAnnotationStateModel2[\"Reviewed\"] = \"Reviewed\";\n  return PdfAnnotationStateModel2;\n})(PdfAnnotationStateModel || {});\nvar PDF_FORM_FIELD_TYPE = /* @__PURE__ */ ((PDF_FORM_FIELD_TYPE2) => {\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"PUSHBUTTON\"] = 1] = \"PUSHBUTTON\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"CHECKBOX\"] = 2] = \"CHECKBOX\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"RADIOBUTTON\"] = 3] = \"RADIOBUTTON\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"COMBOBOX\"] = 4] = \"COMBOBOX\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"LISTBOX\"] = 5] = \"LISTBOX\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"TEXTFIELD\"] = 6] = \"TEXTFIELD\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"SIGNATURE\"] = 7] = \"SIGNATURE\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"XFA\"] = 8] = \"XFA\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"XFA_CHECKBOX\"] = 9] = \"XFA_CHECKBOX\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"XFA_COMBOBOX\"] = 10] = \"XFA_COMBOBOX\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"XFA_IMAGEFIELD\"] = 11] = \"XFA_IMAGEFIELD\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"XFA_LISTBOX\"] = 12] = \"XFA_LISTBOX\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"XFA_PUSHBUTTON\"] = 13] = \"XFA_PUSHBUTTON\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"XFA_SIGNATURE\"] = 14] = \"XFA_SIGNATURE\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"XFA_TEXTFIELD\"] = 15] = \"XFA_TEXTFIELD\";\n  return PDF_FORM_FIELD_TYPE2;\n})(PDF_FORM_FIELD_TYPE || {});\nvar PdfAnnotationColorType = /* @__PURE__ */ ((PdfAnnotationColorType2) => {\n  PdfAnnotationColorType2[PdfAnnotationColorType2[\"Color\"] = 0] = \"Color\";\n  PdfAnnotationColorType2[PdfAnnotationColorType2[\"InteriorColor\"] = 1] = \"InteriorColor\";\n  return PdfAnnotationColorType2;\n})(PdfAnnotationColorType || {});\nvar PdfAnnotationBorderStyle = /* @__PURE__ */ ((PdfAnnotationBorderStyle2) => {\n  PdfAnnotationBorderStyle2[PdfAnnotationBorderStyle2[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n  PdfAnnotationBorderStyle2[PdfAnnotationBorderStyle2[\"SOLID\"] = 1] = \"SOLID\";\n  PdfAnnotationBorderStyle2[PdfAnnotationBorderStyle2[\"DASHED\"] = 2] = \"DASHED\";\n  PdfAnnotationBorderStyle2[PdfAnnotationBorderStyle2[\"BEVELED\"] = 3] = \"BEVELED\";\n  PdfAnnotationBorderStyle2[PdfAnnotationBorderStyle2[\"INSET\"] = 4] = \"INSET\";\n  PdfAnnotationBorderStyle2[PdfAnnotationBorderStyle2[\"UNDERLINE\"] = 5] = \"UNDERLINE\";\n  PdfAnnotationBorderStyle2[PdfAnnotationBorderStyle2[\"CLOUDY\"] = 6] = \"CLOUDY\";\n  return PdfAnnotationBorderStyle2;\n})(PdfAnnotationBorderStyle || {});\nvar PdfAnnotationFlags = /* @__PURE__ */ ((PdfAnnotationFlags2) => {\n  PdfAnnotationFlags2[PdfAnnotationFlags2[\"NONE\"] = 0] = \"NONE\";\n  PdfAnnotationFlags2[PdfAnnotationFlags2[\"INVISIBLE\"] = 1] = \"INVISIBLE\";\n  PdfAnnotationFlags2[PdfAnnotationFlags2[\"HIDDEN\"] = 2] = \"HIDDEN\";\n  PdfAnnotationFlags2[PdfAnnotationFlags2[\"PRINT\"] = 4] = \"PRINT\";\n  PdfAnnotationFlags2[PdfAnnotationFlags2[\"NO_ZOOM\"] = 8] = \"NO_ZOOM\";\n  PdfAnnotationFlags2[PdfAnnotationFlags2[\"NO_ROTATE\"] = 16] = \"NO_ROTATE\";\n  PdfAnnotationFlags2[PdfAnnotationFlags2[\"NO_VIEW\"] = 32] = \"NO_VIEW\";\n  PdfAnnotationFlags2[PdfAnnotationFlags2[\"READ_ONLY\"] = 64] = \"READ_ONLY\";\n  PdfAnnotationFlags2[PdfAnnotationFlags2[\"LOCKED\"] = 128] = \"LOCKED\";\n  PdfAnnotationFlags2[PdfAnnotationFlags2[\"TOGGLE_NOVIEW\"] = 256] = \"TOGGLE_NOVIEW\";\n  return PdfAnnotationFlags2;\n})(PdfAnnotationFlags || {});\nvar PDF_FORM_FIELD_FLAG = /* @__PURE__ */ ((PDF_FORM_FIELD_FLAG2) => {\n  PDF_FORM_FIELD_FLAG2[PDF_FORM_FIELD_FLAG2[\"NONE\"] = 0] = \"NONE\";\n  PDF_FORM_FIELD_FLAG2[PDF_FORM_FIELD_FLAG2[\"READONLY\"] = 1] = \"READONLY\";\n  PDF_FORM_FIELD_FLAG2[PDF_FORM_FIELD_FLAG2[\"REQUIRED\"] = 2] = \"REQUIRED\";\n  PDF_FORM_FIELD_FLAG2[PDF_FORM_FIELD_FLAG2[\"NOEXPORT\"] = 4] = \"NOEXPORT\";\n  PDF_FORM_FIELD_FLAG2[PDF_FORM_FIELD_FLAG2[\"TEXT_MULTIPLINE\"] = 4096] = \"TEXT_MULTIPLINE\";\n  PDF_FORM_FIELD_FLAG2[PDF_FORM_FIELD_FLAG2[\"TEXT_PASSWORD\"] = 8192] = \"TEXT_PASSWORD\";\n  PDF_FORM_FIELD_FLAG2[PDF_FORM_FIELD_FLAG2[\"CHOICE_COMBO\"] = 131072] = \"CHOICE_COMBO\";\n  PDF_FORM_FIELD_FLAG2[PDF_FORM_FIELD_FLAG2[\"CHOICE_EDIT\"] = 262144] = \"CHOICE_EDIT\";\n  PDF_FORM_FIELD_FLAG2[PDF_FORM_FIELD_FLAG2[\"CHOICE_MULTL_SELECT\"] = 2097152] = \"CHOICE_MULTL_SELECT\";\n  return PDF_FORM_FIELD_FLAG2;\n})(PDF_FORM_FIELD_FLAG || {});\nvar PdfPageObjectType = /* @__PURE__ */ ((PdfPageObjectType2) => {\n  PdfPageObjectType2[PdfPageObjectType2[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n  PdfPageObjectType2[PdfPageObjectType2[\"TEXT\"] = 1] = \"TEXT\";\n  PdfPageObjectType2[PdfPageObjectType2[\"PATH\"] = 2] = \"PATH\";\n  PdfPageObjectType2[PdfPageObjectType2[\"IMAGE\"] = 3] = \"IMAGE\";\n  PdfPageObjectType2[PdfPageObjectType2[\"SHADING\"] = 4] = \"SHADING\";\n  PdfPageObjectType2[PdfPageObjectType2[\"FORM\"] = 5] = \"FORM\";\n  return PdfPageObjectType2;\n})(PdfPageObjectType || {});\nvar PdfAnnotationFlagName = Object.freeze({\n  [1 /* INVISIBLE */]: \"invisible\",\n  [2 /* HIDDEN */]: \"hidden\",\n  [4 /* PRINT */]: \"print\",\n  [8 /* NO_ZOOM */]: \"noZoom\",\n  [16 /* NO_ROTATE */]: \"noRotate\",\n  [32 /* NO_VIEW */]: \"noView\",\n  [64 /* READ_ONLY */]: \"readOnly\",\n  [128 /* LOCKED */]: \"locked\",\n  [256 /* TOGGLE_NOVIEW */]: \"toggleNoView\"\n});\nvar PdfAnnotationFlagValue = Object.entries(\n  PdfAnnotationFlagName\n).reduce(\n  (acc, [bit, name]) => {\n    acc[name] = Number(bit);\n    return acc;\n  },\n  {}\n);\nfunction flagsToNames(raw) {\n  return Object.keys(PdfAnnotationFlagName).filter((flag) => (raw & flag) !== 0).map((flag) => PdfAnnotationFlagName[flag]);\n}\nfunction namesToFlags(names) {\n  return names.reduce(\n    (mask, name) => mask | PdfAnnotationFlagValue[name],\n    0 /* NONE */\n  );\n}\nvar PdfSegmentObjectType = /* @__PURE__ */ ((PdfSegmentObjectType2) => {\n  PdfSegmentObjectType2[PdfSegmentObjectType2[\"UNKNOWN\"] = -1] = \"UNKNOWN\";\n  PdfSegmentObjectType2[PdfSegmentObjectType2[\"LINETO\"] = 0] = \"LINETO\";\n  PdfSegmentObjectType2[PdfSegmentObjectType2[\"BEZIERTO\"] = 1] = \"BEZIERTO\";\n  PdfSegmentObjectType2[PdfSegmentObjectType2[\"MOVETO\"] = 2] = \"MOVETO\";\n  return PdfSegmentObjectType2;\n})(PdfSegmentObjectType || {});\nvar PdfEngineFeature = /* @__PURE__ */ ((PdfEngineFeature2) => {\n  PdfEngineFeature2[PdfEngineFeature2[\"RenderPage\"] = 0] = \"RenderPage\";\n  PdfEngineFeature2[PdfEngineFeature2[\"RenderPageRect\"] = 1] = \"RenderPageRect\";\n  PdfEngineFeature2[PdfEngineFeature2[\"Thumbnails\"] = 2] = \"Thumbnails\";\n  PdfEngineFeature2[PdfEngineFeature2[\"Bookmarks\"] = 3] = \"Bookmarks\";\n  PdfEngineFeature2[PdfEngineFeature2[\"Annotations\"] = 4] = \"Annotations\";\n  return PdfEngineFeature2;\n})(PdfEngineFeature || {});\nvar PdfEngineOperation = /* @__PURE__ */ ((PdfEngineOperation2) => {\n  PdfEngineOperation2[PdfEngineOperation2[\"Create\"] = 0] = \"Create\";\n  PdfEngineOperation2[PdfEngineOperation2[\"Read\"] = 1] = \"Read\";\n  PdfEngineOperation2[PdfEngineOperation2[\"Update\"] = 2] = \"Update\";\n  PdfEngineOperation2[PdfEngineOperation2[\"Delete\"] = 3] = \"Delete\";\n  return PdfEngineOperation2;\n})(PdfEngineOperation || {});\nvar MatchFlag = /* @__PURE__ */ ((MatchFlag2) => {\n  MatchFlag2[MatchFlag2[\"None\"] = 0] = \"None\";\n  MatchFlag2[MatchFlag2[\"MatchCase\"] = 1] = \"MatchCase\";\n  MatchFlag2[MatchFlag2[\"MatchWholeWord\"] = 2] = \"MatchWholeWord\";\n  MatchFlag2[MatchFlag2[\"MatchConsecutive\"] = 4] = \"MatchConsecutive\";\n  return MatchFlag2;\n})(MatchFlag || {});\nfunction unionFlags(flags) {\n  return flags.reduce((flag, currFlag) => {\n    return flag | currFlag;\n  }, 0 /* None */);\n}\nfunction compareSearchTarget(targetA, targetB) {\n  const flagA = unionFlags(targetA.flags);\n  const flagB = unionFlags(targetB.flags);\n  return flagA === flagB && targetA.keyword === targetB.keyword;\n}\nvar PdfPermission = /* @__PURE__ */ ((PdfPermission2) => {\n  PdfPermission2[PdfPermission2[\"PrintDocument\"] = 8] = \"PrintDocument\";\n  PdfPermission2[PdfPermission2[\"ModifyContent\"] = 16] = \"ModifyContent\";\n  PdfPermission2[PdfPermission2[\"CopyOrExtract\"] = 32] = \"CopyOrExtract\";\n  PdfPermission2[PdfPermission2[\"AddOrModifyTextAnnot\"] = 64] = \"AddOrModifyTextAnnot\";\n  PdfPermission2[PdfPermission2[\"FillInExistingForm\"] = 512] = \"FillInExistingForm\";\n  PdfPermission2[PdfPermission2[\"ExtractTextOrGraphics\"] = 1024] = \"ExtractTextOrGraphics\";\n  PdfPermission2[PdfPermission2[\"AssembleDocument\"] = 2048] = \"AssembleDocument\";\n  PdfPermission2[PdfPermission2[\"PrintHighQuality\"] = 4096] = \"PrintHighQuality\";\n  return PdfPermission2;\n})(PdfPermission || {});\nvar PdfPageFlattenFlag = /* @__PURE__ */ ((PdfPageFlattenFlag2) => {\n  PdfPageFlattenFlag2[PdfPageFlattenFlag2[\"Display\"] = 0] = \"Display\";\n  PdfPageFlattenFlag2[PdfPageFlattenFlag2[\"Print\"] = 1] = \"Print\";\n  return PdfPageFlattenFlag2;\n})(PdfPageFlattenFlag || {});\nvar PdfPageFlattenResult = /* @__PURE__ */ ((PdfPageFlattenResult2) => {\n  PdfPageFlattenResult2[PdfPageFlattenResult2[\"Fail\"] = 0] = \"Fail\";\n  PdfPageFlattenResult2[PdfPageFlattenResult2[\"Success\"] = 1] = \"Success\";\n  PdfPageFlattenResult2[PdfPageFlattenResult2[\"NothingToDo\"] = 2] = \"NothingToDo\";\n  return PdfPageFlattenResult2;\n})(PdfPageFlattenResult || {});\nvar PdfErrorCode = /* @__PURE__ */ ((PdfErrorCode2) => {\n  PdfErrorCode2[PdfErrorCode2[\"Ok\"] = 0] = \"Ok\";\n  PdfErrorCode2[PdfErrorCode2[\"Unknown\"] = 1] = \"Unknown\";\n  PdfErrorCode2[PdfErrorCode2[\"NotFound\"] = 2] = \"NotFound\";\n  PdfErrorCode2[PdfErrorCode2[\"WrongFormat\"] = 3] = \"WrongFormat\";\n  PdfErrorCode2[PdfErrorCode2[\"Password\"] = 4] = \"Password\";\n  PdfErrorCode2[PdfErrorCode2[\"Security\"] = 5] = \"Security\";\n  PdfErrorCode2[PdfErrorCode2[\"PageError\"] = 6] = \"PageError\";\n  PdfErrorCode2[PdfErrorCode2[\"XFALoad\"] = 7] = \"XFALoad\";\n  PdfErrorCode2[PdfErrorCode2[\"XFALayout\"] = 8] = \"XFALayout\";\n  PdfErrorCode2[PdfErrorCode2[\"Cancelled\"] = 9] = \"Cancelled\";\n  PdfErrorCode2[PdfErrorCode2[\"Initialization\"] = 10] = \"Initialization\";\n  PdfErrorCode2[PdfErrorCode2[\"NotReady\"] = 11] = \"NotReady\";\n  PdfErrorCode2[PdfErrorCode2[\"NotSupport\"] = 12] = \"NotSupport\";\n  PdfErrorCode2[PdfErrorCode2[\"LoadDoc\"] = 13] = \"LoadDoc\";\n  PdfErrorCode2[PdfErrorCode2[\"DocNotOpen\"] = 14] = \"DocNotOpen\";\n  PdfErrorCode2[PdfErrorCode2[\"CantCloseDoc\"] = 15] = \"CantCloseDoc\";\n  PdfErrorCode2[PdfErrorCode2[\"CantCreateNewDoc\"] = 16] = \"CantCreateNewDoc\";\n  PdfErrorCode2[PdfErrorCode2[\"CantImportPages\"] = 17] = \"CantImportPages\";\n  PdfErrorCode2[PdfErrorCode2[\"CantCreateAnnot\"] = 18] = \"CantCreateAnnot\";\n  PdfErrorCode2[PdfErrorCode2[\"CantSetAnnotRect\"] = 19] = \"CantSetAnnotRect\";\n  PdfErrorCode2[PdfErrorCode2[\"CantSetAnnotContent\"] = 20] = \"CantSetAnnotContent\";\n  PdfErrorCode2[PdfErrorCode2[\"CantRemoveInkList\"] = 21] = \"CantRemoveInkList\";\n  PdfErrorCode2[PdfErrorCode2[\"CantAddInkStoke\"] = 22] = \"CantAddInkStoke\";\n  PdfErrorCode2[PdfErrorCode2[\"CantReadAttachmentSize\"] = 23] = \"CantReadAttachmentSize\";\n  PdfErrorCode2[PdfErrorCode2[\"CantReadAttachmentContent\"] = 24] = \"CantReadAttachmentContent\";\n  PdfErrorCode2[PdfErrorCode2[\"CantFocusAnnot\"] = 25] = \"CantFocusAnnot\";\n  PdfErrorCode2[PdfErrorCode2[\"CantSelectText\"] = 26] = \"CantSelectText\";\n  PdfErrorCode2[PdfErrorCode2[\"CantSelectOption\"] = 27] = \"CantSelectOption\";\n  PdfErrorCode2[PdfErrorCode2[\"CantCheckField\"] = 28] = \"CantCheckField\";\n  return PdfErrorCode2;\n})(PdfErrorCode || {});\nvar PdfTaskHelper = class {\n  /**\n   * Create a task\n   * @returns new task\n   */\n  static create() {\n    return new Task();\n  }\n  /**\n   * Create a task that has been resolved with value\n   * @param result - resolved value\n   * @returns resolved task\n   */\n  static resolve(result) {\n    const task = new Task();\n    task.resolve(result);\n    return task;\n  }\n  /**\n   * Create a task that has been rejected with error\n   * @param reason - rejected error\n   * @returns rejected task\n   */\n  static reject(reason) {\n    const task = new Task();\n    task.reject(reason);\n    return task;\n  }\n  /**\n   * Create a task that has been aborted with error\n   * @param reason - aborted error\n   * @returns aborted task\n   */\n  static abort(reason) {\n    const task = new Task();\n    task.reject(reason);\n    return task;\n  }\n};\n\n// src/color.ts\nfunction pdfAlphaColorToWebAlphaColor(c) {\n  const clamp = (n) => Math.max(0, Math.min(255, n));\n  const toHex = (n) => clamp(n).toString(16).padStart(2, \"0\");\n  const color = `#${toHex(c.red)}${toHex(c.green)}${toHex(c.blue)}`;\n  const opacity = clamp(c.alpha) / 255;\n  return { color, opacity };\n}\nfunction webAlphaColorToPdfAlphaColor({ color, opacity }) {\n  if (/^#?[0-9a-f]{3}$/i.test(color)) {\n    color = color.replace(/^#?([0-9a-f])([0-9a-f])([0-9a-f])$/i, \"#$1$1$2$2$3$3\").toLowerCase();\n  }\n  const [, r, g, b] = /^#?([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$/i.exec(color) ?? (() => {\n    throw new Error(`Invalid hex colour: \\u201C${color}\\u201D`);\n  })();\n  const clamp = (n, hi = 255) => Math.max(0, Math.min(hi, n));\n  return {\n    red: parseInt(r, 16),\n    green: parseInt(g, 16),\n    blue: parseInt(b, 16),\n    alpha: clamp(Math.round(opacity * 255))\n  };\n}\n\n// src/date.ts\nfunction pdfDateToDate(pdf) {\n  if (!pdf?.startsWith(\"D:\") || pdf.length < 16) return;\n  const y = +pdf.slice(2, 6);\n  const mo = +pdf.slice(6, 8) - 1;\n  const d = +pdf.slice(8, 10);\n  const H = +pdf.slice(10, 12);\n  const M = +pdf.slice(12, 14);\n  const S = +pdf.slice(14, 16);\n  return new Date(Date.UTC(y, mo, d, H, M, S));\n}\nfunction dateToPdfDate(date = /* @__PURE__ */ new Date()) {\n  const z = (n, len = 2) => n.toString().padStart(len, \"0\");\n  const YYYY = date.getUTCFullYear();\n  const MM = z(date.getUTCMonth() + 1);\n  const DD = z(date.getUTCDate());\n  const HH = z(date.getUTCHours());\n  const mm = z(date.getUTCMinutes());\n  const SS = z(date.getUTCSeconds());\n  return `D:${YYYY}${MM}${DD}${HH}${mm}${SS}`;\n}\n\n// src/index.ts\nfunction ignore() {\n}\nexport {\n  AllLogger,\n  AppearanceMode,\n  ConsoleLogger,\n  LevelLogger,\n  LogLevel,\n  MatchFlag,\n  MixedBlendMode,\n  NoopLogger,\n  PDF_FORM_FIELD_FLAG,\n  PDF_FORM_FIELD_TYPE,\n  PdfActionType,\n  PdfAnnotationBorderStyle,\n  PdfAnnotationColorType,\n  PdfAnnotationFlagName,\n  PdfAnnotationFlags,\n  PdfAnnotationObjectStatus,\n  PdfAnnotationState,\n  PdfAnnotationStateModel,\n  PdfAnnotationSubtype,\n  PdfAnnotationSubtypeName,\n  PdfBlendMode,\n  PdfBomOrZwnbsp,\n  PdfEngineFeature,\n  PdfEngineOperation,\n  PdfErrorCode,\n  PdfNonCharacterFFFE,\n  PdfNonCharacterFFFF,\n  PdfPageFlattenFlag,\n  PdfPageFlattenResult,\n  PdfPageObjectType,\n  PdfPermission,\n  PdfSegmentObjectType,\n  PdfSoftHyphenMarker,\n  PdfTaskHelper,\n  PdfUnwantedTextMarkers,\n  PdfUnwantedTextRegex,\n  PdfWordJoiner,\n  PdfZeroWidthSpace,\n  PdfZoomMode,\n  PerfLogger,\n  Rotation,\n  Task,\n  TaskAbortedError,\n  TaskRejectedError,\n  TaskStage,\n  blendModeLabel,\n  blendModeSelectOptions,\n  blendModeToCss,\n  boundingRect,\n  calculateAngle,\n  calculateDegree,\n  compareSearchTarget,\n  cssToBlendMode,\n  dateToPdfDate,\n  flagsToNames,\n  getBlendModeInfo,\n  ignore,\n  makeMatrix,\n  namesToFlags,\n  pdfAlphaColorToWebAlphaColor,\n  pdfDateToDate,\n  quadToRect,\n  rectToQuad,\n  reduceBlendModes,\n  restoreOffset,\n  restorePosition,\n  restoreRect,\n  rotatePosition,\n  rotateRect,\n  scalePosition,\n  scaleRect,\n  stripPdfUnwantedMarkers,\n  swap,\n  toIntPos,\n  toIntRect,\n  toIntSize,\n  transformPosition,\n  transformRect,\n  transformSize,\n  uiBlendModeDisplay,\n  unionFlags,\n  webAlphaColorToPdfAlphaColor\n};\n//# sourceMappingURL=index.js.map","import { PdfDocumentObject, PdfPageObject, Rotation } from '@embedpdf/models';\nimport { PluginRegistryConfig } from '../types/plugin';\n\nexport interface CoreState {\n  scale: number;\n  rotation: Rotation;\n  document: PdfDocumentObject | null;\n  pages: PdfPageObject[][];\n  loading: boolean;\n  error: string | null;\n}\n\nexport const initialCoreState: (config?: PluginRegistryConfig) => CoreState = (config) => ({\n  scale: config?.scale ?? 1,\n  rotation: config?.rotation ?? Rotation.Degree0,\n  document: null,\n  pages: [],\n  loading: false,\n  error: null,\n});\n","import { Reducer } from './types';\nimport { CoreState } from './initial-state';\nimport {\n  CoreAction,\n  LOAD_DOCUMENT,\n  SET_DOCUMENT,\n  SET_DOCUMENT_ERROR,\n  SET_PAGES,\n  SET_ROTATION,\n  SET_SCALE,\n} from './actions';\n\nexport const coreReducer: Reducer<CoreState, CoreAction> = (state, action): CoreState => {\n  switch (action.type) {\n    case LOAD_DOCUMENT:\n      return {\n        ...state,\n        loading: true,\n        error: null,\n      };\n\n    case SET_DOCUMENT:\n      return {\n        ...state,\n        document: action.payload,\n        pages: action.payload.pages.map((page) => [page]),\n        loading: false,\n        error: null,\n      };\n\n    case SET_ROTATION:\n      return {\n        ...state,\n        rotation: action.payload,\n      };\n\n    case SET_PAGES:\n      return {\n        ...state,\n        pages: action.payload,\n      };\n\n    case SET_DOCUMENT_ERROR:\n      return {\n        ...state,\n        loading: false,\n        error: action.payload,\n      };\n\n    case SET_SCALE:\n      return {\n        ...state,\n        scale: action.payload,\n      };\n\n    default:\n      return state;\n  }\n};\n","import { DependencyResolver } from '../utils/dependency-resolver';\nimport {\n  IPlugin,\n  PluginBatchRegistration,\n  PluginManifest,\n  PluginStatus,\n  PluginPackage,\n  PluginRegistryConfig,\n} from '../types/plugin';\nimport {\n  PluginRegistrationError,\n  PluginNotFoundError,\n  CircularDependencyError,\n  CapabilityNotFoundError,\n  PluginConfigurationError,\n} from '../types/errors';\nimport { ignore, PdfEngine, Rotation } from '@embedpdf/models';\nimport { Action, CoreState, Store, initialCoreState, Reducer } from '../store';\nimport { CoreAction } from '../store/actions';\nimport { coreReducer } from '../store/reducer';\n\n// Define a more flexible generic type for plugin registrations\ninterface PluginRegistration {\n  // Use existential types for the plugin package to allow accepting any plugin type\n  package: PluginPackage<any, any, any, any>;\n  config?: any;\n}\n\nexport class PluginRegistry {\n  private plugins: Map<string, IPlugin> = new Map();\n  private manifests: Map<string, PluginManifest> = new Map();\n  private capabilities: Map<string, string> = new Map(); // capability -> pluginId\n  private status: Map<string, PluginStatus> = new Map();\n  private resolver: DependencyResolver;\n  private configurations: Map<string, unknown> = new Map();\n  private engine: PdfEngine;\n  private engineInitialized = false;\n  private store: Store<CoreState, CoreAction>;\n  private initPromise: Promise<void> | null = null;\n\n  private pendingRegistrations: PluginRegistration[] = [];\n  private processingRegistrations: PluginRegistration[] = [];\n  private initialized = false;\n  private isInitializing = false;\n  private initialCoreState: CoreState;\n  private pluginsReadyPromise: Promise<void> | null = null;\n  private destroyed = false;\n\n  constructor(engine: PdfEngine, config?: PluginRegistryConfig) {\n    this.resolver = new DependencyResolver();\n    this.engine = engine;\n    this.initialCoreState = initialCoreState(config);\n    this.store = new Store<CoreState, CoreAction>(coreReducer, this.initialCoreState);\n  }\n\n  /**\n   * Ensure engine is initialized before proceeding\n   */\n  private async ensureEngineInitialized(): Promise<void> {\n    if (this.engineInitialized) {\n      return;\n    }\n\n    if (this.engine.initialize) {\n      const task = this.engine.initialize();\n      await task.toPromise();\n      this.engineInitialized = true;\n    } else {\n      this.engineInitialized = true;\n    }\n  }\n\n  /**\n   * Register a plugin without initializing it\n   */\n  registerPlugin<\n    TPlugin extends IPlugin<TConfig>,\n    TConfig = unknown,\n    TState = unknown,\n    TAction extends Action = Action,\n  >(\n    pluginPackage: PluginPackage<TPlugin, TConfig, TState, TAction>,\n    config?: Partial<TConfig>,\n  ): void {\n    if (this.initialized && !this.isInitializing) {\n      throw new PluginRegistrationError('Cannot register plugins after initialization');\n    }\n\n    this.validateManifest(pluginPackage.manifest);\n\n    // Use appropriate typing for store methods\n    this.store.addPluginReducer(\n      pluginPackage.manifest.id,\n      // We need one type assertion here since we can't fully reconcile TAction with Action\n      // due to TypeScript's type system limitations with generic variance\n      pluginPackage.reducer as Reducer<TState, Action>,\n      'function' === typeof pluginPackage.initialState\n        ? (pluginPackage.initialState as (coreState: CoreState, config: TConfig) => TState)(\n            this.initialCoreState,\n            {\n              ...pluginPackage.manifest.defaultConfig,\n              ...config,\n            },\n          )\n        : pluginPackage.initialState,\n    );\n\n    this.pendingRegistrations.push({\n      package: pluginPackage,\n      config,\n    });\n  }\n\n  /**\n   * Get the central store instance\n   */\n  getStore(): Store<CoreState, CoreAction> {\n    return this.store;\n  }\n\n  /**\n   * Get the engine instance\n   */\n  getEngine(): PdfEngine {\n    return this.engine;\n  }\n\n  /**\n   * Get a promise that resolves when all plugins are ready\n   */\n  public pluginsReady(): Promise<void> {\n    // Re-use the same promise every time it’s asked for\n    if (this.pluginsReadyPromise) {\n      return this.pluginsReadyPromise;\n    }\n\n    // Build the promise the *first* time it’s requested\n    this.pluginsReadyPromise = (async () => {\n      // 1. Wait until the registry itself has finished initialising\n      if (!this.initialized) {\n        await this.initialize();\n      }\n\n      // 2. Wait for every plugin’s ready() promise (if it has one)\n      const readyPromises = Array.from(this.plugins.values()).map((p) =>\n        typeof p.ready === 'function' ? p.ready() : Promise.resolve(),\n      );\n\n      await Promise.all(readyPromises); // resolves when the slowest is done\n    })();\n\n    return this.pluginsReadyPromise;\n  }\n\n  /**\n   * INITIALISE THE REGISTRY – runs once no-matter-how-many calls   *\n   */\n  async initialize(): Promise<void> {\n    if (this.destroyed) {\n      throw new PluginRegistrationError('Registry has been destroyed');\n    }\n\n    // If an initialisation is already in-flight (or finished)\n    // return the very same promise so callers can await it.\n    if (this.initPromise) {\n      return this.initPromise;\n    }\n\n    // Wrap your existing body in a single promise and cache it\n    this.initPromise = (async () => {\n      if (this.initialized) {\n        throw new PluginRegistrationError('Registry is already initialized');\n      }\n\n      this.isInitializing = true;\n\n      try {\n        /* ---------------- original body starts ------------------ */\n        await this.ensureEngineInitialized();\n        // Check if destroyed after engine initialization\n        if (this.destroyed) {\n          return;\n        }\n\n        while (this.pendingRegistrations.length > 0) {\n          // Check if destroyed before processing each batch\n          if (this.destroyed) {\n            return;\n          }\n          this.processingRegistrations = [...this.pendingRegistrations];\n          this.pendingRegistrations = [];\n\n          for (const reg of this.processingRegistrations) {\n            const dependsOn = new Set<string>();\n            const allDeps = [...reg.package.manifest.requires, ...reg.package.manifest.optional];\n            for (const cap of allDeps) {\n              const provider = this.processingRegistrations.find((r) =>\n                r.package.manifest.provides.includes(cap),\n              );\n              if (provider) dependsOn.add(provider.package.manifest.id);\n            }\n            this.resolver.addNode(reg.package.manifest.id, [...dependsOn]);\n          }\n\n          const loadOrder = this.resolver.resolveLoadOrder();\n          for (const id of loadOrder) {\n            const reg = this.processingRegistrations.find((r) => r.package.manifest.id === id)!;\n            await this.initializePlugin(reg.package.manifest, reg.package.create, reg.config);\n          }\n\n          this.processingRegistrations = [];\n          this.resolver = new DependencyResolver();\n        }\n\n        for (const plugin of this.plugins.values()) {\n          await plugin.postInitialize?.().catch((e) => {\n            console.error(`Error in postInitialize for plugin ${plugin.id}`, e);\n            this.status.set(plugin.id, 'error');\n          });\n        }\n\n        this.initialized = true;\n        /* ----------------- original body ends ------------------- */\n      } catch (err) {\n        if (err instanceof Error) {\n          throw new CircularDependencyError(\n            `Failed to resolve plugin dependencies: ${err.message}`,\n          );\n        }\n        throw err;\n      } finally {\n        this.isInitializing = false;\n      }\n    })();\n\n    return this.initPromise;\n  }\n\n  /**\n   * Initialize a single plugin with all necessary checks\n   */\n  private async initializePlugin<TConfig>(\n    manifest: PluginManifest<TConfig>,\n    packageCreator: (\n      registry: PluginRegistry,\n      engine: PdfEngine,\n      config?: TConfig,\n    ) => IPlugin<TConfig>,\n    config?: Partial<TConfig>,\n  ): Promise<void> {\n    const finalConfig = {\n      ...manifest.defaultConfig,\n      ...config,\n    };\n\n    this.validateConfig(manifest.id, finalConfig, manifest.defaultConfig);\n\n    // Create plugin instance during initialization\n    const plugin = packageCreator(this, this.engine, finalConfig);\n    this.validatePlugin(plugin);\n\n    // Verify all required capabilities are available\n    for (const capability of manifest.requires) {\n      if (!this.capabilities.has(capability)) {\n        throw new PluginRegistrationError(\n          `Missing required capability: ${capability} for plugin ${manifest.id}`,\n        );\n      }\n    }\n\n    // Optional capabilities can be null, so we don't throw errors for them\n    for (const capability of manifest.optional) {\n      if (this.capabilities.has(capability)) {\n        // Optional capability is available, but we don't require it\n        console.debug(`Optional capability ${capability} is available for plugin ${manifest.id}`);\n      }\n    }\n\n    console.log('initializePlugin', manifest.id, manifest.provides);\n\n    // Register provided capabilities\n    for (const capability of manifest.provides) {\n      if (this.capabilities.has(capability)) {\n        throw new PluginRegistrationError(\n          `Capability ${capability} is already provided by plugin ${this.capabilities.get(capability)}`,\n        );\n      }\n      this.capabilities.set(capability, manifest.id);\n    }\n\n    // Store plugin and manifest\n    this.plugins.set(manifest.id, plugin);\n    this.manifests.set(manifest.id, manifest);\n    this.status.set(manifest.id, 'registered');\n    this.configurations.set(manifest.id, finalConfig);\n\n    try {\n      if (plugin.initialize) {\n        await plugin.initialize(finalConfig);\n      }\n      this.status.set(manifest.id, 'active');\n    } catch (error) {\n      // Cleanup on initialization failure\n      this.plugins.delete(manifest.id);\n      this.manifests.delete(manifest.id);\n      console.log('initializePlugin failed', manifest.id, manifest.provides);\n      manifest.provides.forEach((cap) => this.capabilities.delete(cap));\n      throw error;\n    }\n  }\n\n  getPluginConfig<TConfig>(pluginId: string): TConfig {\n    const config = this.configurations.get(pluginId);\n    if (!config) {\n      throw new PluginNotFoundError(`Configuration for plugin ${pluginId} not found`);\n    }\n    return config as TConfig;\n  }\n\n  private validateConfig(pluginId: string, config: unknown, defaultConfig: unknown): void {\n    // Check all required fields exist\n    const requiredKeys = Object.keys(defaultConfig as object);\n    const missingKeys = requiredKeys.filter((key) => !(config as object).hasOwnProperty(key));\n\n    if (missingKeys.length > 0) {\n      throw new PluginConfigurationError(\n        `Missing required configuration keys for plugin ${pluginId}: ${missingKeys.join(', ')}`,\n      );\n    }\n\n    // You could add more validation here:\n    // - Type checking\n    // - Value range validation\n    // - Format validation\n    // etc.\n  }\n\n  async updatePluginConfig<TConfig>(pluginId: string, config: Partial<TConfig>): Promise<void> {\n    const plugin = this.getPlugin(pluginId);\n\n    if (!plugin) {\n      throw new PluginNotFoundError(`Plugin ${pluginId} not found`);\n    }\n\n    const manifest = this.manifests.get(pluginId);\n    const currentConfig = this.configurations.get(pluginId);\n\n    if (!manifest || !currentConfig) {\n      throw new PluginNotFoundError(`Plugin ${pluginId} not found`);\n    }\n\n    // Merge new config with current\n    const newConfig = {\n      ...currentConfig,\n      ...config,\n    };\n\n    // Validate new configuration\n    this.validateConfig(pluginId, newConfig, manifest.defaultConfig);\n\n    // Store new configuration\n    this.configurations.set(pluginId, newConfig);\n\n    // Reinitialize plugin if needed\n    if (plugin.initialize) {\n      await plugin.initialize(newConfig);\n    }\n  }\n\n  /**\n   * Register multiple plugins at once\n   */\n  registerPluginBatch(registrations: PluginBatchRegistration<IPlugin<any>, any, any, any>[]): void {\n    for (const reg of registrations) {\n      this.registerPlugin(reg.package, reg.config);\n    }\n  }\n\n  /**\n   * Unregister a plugin\n   */\n  async unregisterPlugin(pluginId: string): Promise<void> {\n    const plugin = this.plugins.get(pluginId);\n    if (!plugin) {\n      throw new PluginNotFoundError(`Plugin ${pluginId} is not registered`);\n    }\n\n    const manifest = this.manifests.get(pluginId);\n    if (!manifest) {\n      throw new PluginNotFoundError(`Manifest for plugin ${pluginId} not found`);\n    }\n\n    // Check if any other plugins depend on this one\n    for (const [otherId, otherManifest] of this.manifests.entries()) {\n      if (otherId === pluginId) continue;\n\n      const dependsOnThis = [...otherManifest.requires, ...otherManifest.optional].some((cap) =>\n        manifest.provides.includes(cap),\n      );\n\n      if (dependsOnThis) {\n        throw new PluginRegistrationError(\n          `Cannot unregister plugin ${pluginId}: plugin ${otherId} depends on it`,\n        );\n      }\n    }\n\n    // Cleanup plugin\n    try {\n      if (plugin.destroy) {\n        await plugin.destroy();\n      }\n\n      // Remove capabilities\n      for (const capability of manifest.provides) {\n        this.capabilities.delete(capability);\n      }\n\n      // Remove plugin and manifest\n      this.plugins.delete(pluginId);\n      this.manifests.delete(pluginId);\n      this.status.delete(pluginId);\n    } catch (error) {\n      if (error instanceof Error) {\n        throw new Error(`Failed to unregister plugin ${pluginId}: ${error.message}`);\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Get a plugin instance\n   * @param pluginId The ID of the plugin to get\n   * @returns The plugin instance or null if not found\n   */\n  getPlugin<T extends IPlugin>(pluginId: string): T | null {\n    const plugin = this.plugins.get(pluginId);\n    if (!plugin) {\n      return null;\n    }\n    return plugin as T;\n  }\n\n  /**\n   * Get a plugin that provides a specific capability\n   * @param capability The capability to get a provider for\n   * @returns The plugin providing the capability or null if not found\n   */\n  getCapabilityProvider(capability: string): IPlugin | null {\n    const pluginId = this.capabilities.get(capability);\n    if (!pluginId) {\n      return null;\n    }\n    return this.getPlugin(pluginId);\n  }\n\n  /**\n   * Check if a capability is available\n   */\n  hasCapability(capability: string): boolean {\n    return this.capabilities.has(capability);\n  }\n\n  /**\n   * Get all registered plugins\n   */\n  getAllPlugins(): IPlugin[] {\n    return Array.from(this.plugins.values());\n  }\n\n  /**\n   * Get plugin status\n   */\n  getPluginStatus(pluginId: string): PluginStatus {\n    const status = this.status.get(pluginId);\n    if (!status) {\n      throw new PluginNotFoundError(`Plugin ${pluginId} not found`);\n    }\n    return status;\n  }\n\n  /**\n   * Validate plugin object\n   */\n  private validatePlugin(plugin: IPlugin): void {\n    if (!plugin.id) {\n      throw new PluginRegistrationError('Plugin must have an id');\n    }\n  }\n\n  /**\n   * Validate plugin manifest\n   */\n  private validateManifest(manifest: PluginManifest): void {\n    if (!manifest.id) {\n      throw new PluginRegistrationError('Manifest must have an id');\n    }\n    if (!manifest.name) {\n      throw new PluginRegistrationError('Manifest must have a name');\n    }\n    if (!manifest.version) {\n      throw new PluginRegistrationError('Manifest must have a version');\n    }\n    if (!Array.isArray(manifest.provides)) {\n      throw new PluginRegistrationError('Manifest must have a provides array');\n    }\n    if (!Array.isArray(manifest.requires)) {\n      throw new PluginRegistrationError('Manifest must have a requires array');\n    }\n    if (!Array.isArray(manifest.optional)) {\n      throw new PluginRegistrationError('Manifest must have an optional array');\n    }\n  }\n\n  isDestroyed(): boolean {\n    return this.destroyed;\n  }\n\n  /**\n   * DESTROY EVERYTHING – waits for any ongoing initialise(), once  *\n   */\n  async destroy(): Promise<void> {\n    if (this.destroyed) throw new PluginRegistrationError('Registry has already been destroyed');\n    this.destroyed = true;\n\n    // If initialisation is still underway, wait (success OR failure)\n    try {\n      await this.initPromise;\n    } catch {\n      /* ignore – still need to clean up */\n    }\n\n    /* ------- original teardown, unchanged except the guard ------ */\n    for (const plugin of Array.from(this.plugins.values()).reverse()) {\n      await plugin.destroy?.();\n    }\n\n    this.store.destroy();\n\n    this.plugins.clear();\n    this.manifests.clear();\n    this.capabilities.clear();\n    this.status.clear();\n    this.pendingRegistrations.length = 0;\n    this.processingRegistrations.length = 0;\n  }\n}\n","/**\n * Restrict a numeric value to the inclusive range [min, max].\n *\n * @example\n *   clamp( 5, 0, 10)  // 5\n *   clamp(-3, 0, 10)  // 0\n *   clamp(17, 0, 10)  // 10\n */\nexport function clamp(value: number, min: number, max: number): number {\n  return value < min ? min : value > max ? max : value;\n}\n\n/**\n * Deeply compares two values (objects, arrays, primitives)\n * with the following rules:\n *  - Objects are compared ignoring property order.\n *  - Arrays are compared ignoring element order (multiset comparison).\n *  - Primitives are compared by strict equality.\n *  - null/undefined are treated as normal primitives.\n *\n * @param a First value\n * @param b Second value\n * @param visited Used internally to detect cycles\n */\nexport function arePropsEqual(a: any, b: any, visited?: Set<any>): boolean {\n  // Quick path for reference equality or same primitive\n  if (a === b) {\n    return true;\n  }\n\n  // Handle null/undefined mismatch\n  if (a == null || b == null) {\n    // If one is null/undefined and the other isn't, no match\n    return a === b;\n  }\n\n  // Check types\n  const aType = typeof a;\n  const bType = typeof b;\n  if (aType !== bType) return false;\n\n  // If they are both objects or arrays, handle recursively\n  if (aType === 'object') {\n    // Optionally handle cyclical references\n    if (!visited) visited = new Set();\n    const pairId = getPairId(a, b);\n    if (visited.has(pairId)) {\n      // Already compared these two objects => assume true to avoid infinite recursion\n      // or return false if you want to treat cycles as inequality\n      return true;\n    }\n    visited.add(pairId);\n\n    const aIsArray = Array.isArray(a);\n    const bIsArray = Array.isArray(b);\n    if (aIsArray && bIsArray) {\n      // Compare as arrays ignoring order\n      return arraysEqualUnordered(a, b, visited);\n    } else if (!aIsArray && !bIsArray) {\n      // Compare as plain objects (order of properties doesn't matter)\n      return objectsEqual(a, b, visited);\n    } else {\n      // One is array, the other is object => not equal\n      return false;\n    }\n  }\n\n  // If both are function, symbol, etc. - typically we might say false\n  // But you can decide your own logic for function or symbol equality\n  return false;\n}\n\nfunction getPairId(a: any, b: any) {\n  // Could do something more advanced. This is a cheap approach:\n  // e.g. use the memory reference or an object identity approach\n  return `${objectId(a)}__${objectId(b)}`;\n}\n\n/**\n * If you want stable object IDs, you'd need a WeakMap to store them.\n * This simplistic approach just calls toString on the object.\n */\nlet objectIdCounter = 0;\nconst objectIds = new WeakMap<object, number>();\n\nfunction objectId(obj: object): number {\n  if (!objectIds.has(obj)) {\n    objectIds.set(obj, ++objectIdCounter);\n  }\n  return objectIds.get(obj)!;\n}\n\nfunction arraysEqualUnordered(a: any[], b: any[], visited?: Set<any>): boolean {\n  if (a.length !== b.length) return false;\n\n  const used = new Array<boolean>(b.length).fill(false);\n\n  // For each element in a, find an unused matching element in b\n  outer: for (let i = 0; i < a.length; i++) {\n    const elemA = a[i];\n    for (let j = 0; j < b.length; j++) {\n      if (used[j]) continue; // already used that slot\n      if (arePropsEqual(elemA, b[j], visited)) {\n        used[j] = true;\n        continue outer; // found match for a[i], proceed\n      }\n    }\n    // If we never found a match\n    return false;\n  }\n\n  return true;\n}\n\nfunction objectsEqual(a: object, b: object, visited?: Set<any>): boolean {\n  // Get all prop keys\n  const aKeys = Object.keys(a).sort();\n  const bKeys = Object.keys(b).sort();\n  if (aKeys.length !== bKeys.length) return false;\n\n  // Compare each property name\n  for (let i = 0; i < aKeys.length; i++) {\n    if (aKeys[i] !== bKeys[i]) return false;\n  }\n\n  // Compare each property value\n  for (const key of aKeys) {\n    // @ts-ignore\n    const valA = a[key];\n    // @ts-ignore\n    const valB = b[key];\n    if (!arePropsEqual(valA, valB, visited)) {\n      return false;\n    }\n  }\n  return true;\n}\n","import { CoreState } from './initial-state';\nimport { transformSize, PdfPageObjectWithRotatedSize } from '@embedpdf/models';\n\nexport const getPagesWithRotatedSize = (state: CoreState): PdfPageObjectWithRotatedSize[][] => {\n  return state.pages.map((page) =>\n    page.map((p) => ({\n      ...p,\n      rotatedSize: transformSize(p.size, state.rotation, 1),\n    })),\n  );\n};\n","import { Action } from '../store';\nimport { IPlugin, PluginBatchRegistration, PluginPackage } from '../types/plugin';\n\n/**\n * Helper function to create a properly typed plugin registration\n */\nexport function createPluginRegistration<\n  T extends IPlugin<TConfig>,\n  TConfig,\n  TState,\n  TAction extends Action,\n>(\n  pluginPackage: PluginPackage<T, TConfig, TState, TAction>,\n  config?: Partial<TConfig>,\n): PluginBatchRegistration<T, TConfig, any, any> {\n  return {\n    package: pluginPackage,\n    config,\n  };\n}\n","import { IPlugin } from '../types/plugin';\nimport { PluginRegistry } from '../registry/plugin-registry';\nimport { Action, CoreAction, CoreState, PluginStore, Store, StoreState } from '../store';\n\nexport interface StateChangeHandler<TState> {\n  (state: TState): void;\n}\n\nexport abstract class BasePlugin<\n  TConfig = unknown,\n  TCapability = unknown,\n  TState = unknown,\n  TAction extends Action = Action,\n> implements IPlugin<TConfig>\n{\n  static readonly id: string;\n\n  protected pluginStore: PluginStore<TState, TAction>;\n  protected coreStore: Store<CoreState, CoreAction>;\n  // Track debounced actions\n  private debouncedActions: Record<string, number> = {};\n  private unsubscribeFromState: (() => void) | null = null;\n  private unsubscribeFromCoreStore: (() => void) | null = null;\n\n  private _capability?: Readonly<TCapability>;\n\n  private readyPromise: Promise<void>;\n  private readyResolve!: () => void;\n\n  constructor(\n    public readonly id: string,\n    protected registry: PluginRegistry,\n  ) {\n    if (id !== (this.constructor as typeof BasePlugin).id) {\n      throw new Error(\n        `Plugin ID mismatch: ${id} !== ${(this.constructor as typeof BasePlugin).id}`,\n      );\n    }\n    this.coreStore = this.registry.getStore();\n    this.pluginStore = this.coreStore.getPluginStore<TState, TAction>(this.id);\n    this.unsubscribeFromState = this.pluginStore.subscribeToState((action, newState, oldState) => {\n      this.onStoreUpdated(oldState, newState);\n    });\n    this.unsubscribeFromCoreStore = this.coreStore.subscribe((action, newState, oldState) => {\n      this.onCoreStoreUpdated(oldState, newState);\n    });\n\n    // Initialize ready state\n    this.readyPromise = new Promise((resolve) => {\n      this.readyResolve = resolve;\n    });\n    // By default, plugins are ready immediately\n    this.readyResolve();\n  }\n\n  /** Construct the public capability (called once & cached). */\n  protected abstract buildCapability(): TCapability;\n\n  public provides(): Readonly<TCapability> {\n    if (!this._capability) {\n      const cap = this.buildCapability();\n\n      this._capability = Object.freeze(cap);\n    }\n    return this._capability;\n  }\n\n  /**\n   * Initialize plugin with config\n   */\n  abstract initialize(config: TConfig): Promise<void>;\n\n  /**\n   *  Get a copy of the current state\n   */\n  protected get state(): Readonly<TState> {\n    return this.pluginStore.getState();\n  }\n\n  /**\n   *  Get a copy of the current core state\n   */\n  protected get coreState(): Readonly<StoreState<CoreState>> {\n    return this.coreStore.getState();\n  }\n\n  /**\n   * @deprecated  use `this.state` Get a copy of the current state\n   */\n  protected getState(): TState {\n    return this.pluginStore.getState();\n  }\n\n  /**\n   * @deprecated  use `this.coreState` Get a copy of the current core state\n   */\n  protected getCoreState(): StoreState<CoreState> {\n    return this.coreStore.getState();\n  }\n\n  /**\n   * Core Dispatch\n   */\n  protected dispatchCoreAction(action: CoreAction): StoreState<CoreState> {\n    return this.coreStore.dispatchToCore(action);\n  }\n\n  /**\n   * Dispatch an action to all plugins\n   */\n  protected dispatchToAllPlugins(action: TAction): StoreState<CoreState> {\n    return this.coreStore.dispatch(action);\n  }\n\n  /**\n   * Dispatch an action\n   */\n  protected dispatch(action: TAction): TState {\n    return this.pluginStore.dispatch(action);\n  }\n\n  /**\n   * Dispatch an action with debouncing to prevent rapid repeated calls\n   * @param action The action to dispatch\n   * @param debounceTime Time in ms to debounce (default: 100ms)\n   * @returns boolean indicating whether the action was dispatched or debounced\n   */\n  protected debouncedDispatch(action: TAction, debounceTime: number = 100): boolean {\n    const now = Date.now();\n    const lastActionTime = this.debouncedActions[action.type] || 0;\n\n    if (now - lastActionTime >= debounceTime) {\n      this.debouncedActions[action.type] = now;\n      this.dispatch(action);\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Subscribe to state changes\n   */\n  protected subscribe(listener: (action: TAction, state: TState) => void): () => void {\n    return this.pluginStore.subscribeToState(listener);\n  }\n\n  /**\n   * Subscribe to core store changes\n   */\n  protected subscribeToCoreStore(\n    listener: (action: Action, state: StoreState<CoreState>) => void,\n  ): () => void {\n    return this.coreStore.subscribe(listener);\n  }\n\n  /**\n   * Called when the plugin store state is updated\n   * @param oldState Previous state\n   * @param newState New state\n   */\n  protected onStoreUpdated(oldState: TState, newState: TState): void {\n    // Default implementation does nothing - can be overridden by plugins\n  }\n\n  /**\n   * Called when the core store state is updated\n   * @param oldState Previous state\n   * @param newState New state\n   */\n  protected onCoreStoreUpdated(\n    oldState: StoreState<CoreState>,\n    newState: StoreState<CoreState>,\n  ): void {\n    // Default implementation does nothing - can be overridden by plugins\n  }\n\n  /**\n   * Cleanup method to be called when plugin is being destroyed\n   */\n  public destroy(): void {\n    if (this.unsubscribeFromState) {\n      this.unsubscribeFromState();\n      this.unsubscribeFromState = null;\n    }\n    if (this.unsubscribeFromCoreStore) {\n      this.unsubscribeFromCoreStore();\n      this.unsubscribeFromCoreStore = null;\n    }\n  }\n\n  /**\n   * Returns a promise that resolves when the plugin is ready\n   */\n  public ready(): Promise<void> {\n    return this.readyPromise;\n  }\n\n  /**\n   * Mark the plugin as ready\n   */\n  protected markReady(): void {\n    this.readyResolve();\n  }\n\n  /**\n   * Reset the ready state (useful for plugins that need to reinitialize)\n   */\n  protected resetReady(): void {\n    this.readyPromise = new Promise((resolve) => {\n      this.readyResolve = resolve;\n    });\n  }\n}\n","export type EventHandler<T> = (data: T) => void;\n\nexport interface BaseEventControlOptions {\n  wait: number;\n}\n\nexport interface DebounceOptions extends BaseEventControlOptions {\n  mode: 'debounce';\n}\n\nexport interface ThrottleOptions extends BaseEventControlOptions {\n  mode: 'throttle';\n  throttleMode?: 'leading-trailing' | 'trailing';\n}\n\nexport type EventControlOptions = DebounceOptions | ThrottleOptions;\n\nexport class EventControl<T> {\n  private timeoutId?: number;\n  private lastRun: number = 0;\n\n  constructor(\n    private handler: EventHandler<T>,\n    private options: EventControlOptions,\n  ) {}\n\n  handle = (data: T): void => {\n    if (this.options.mode === 'debounce') {\n      this.debounce(data);\n    } else {\n      this.throttle(data);\n    }\n  };\n\n  private debounce(data: T): void {\n    if (this.timeoutId) {\n      window.clearTimeout(this.timeoutId);\n    }\n\n    this.timeoutId = window.setTimeout(() => {\n      this.handler(data);\n      this.timeoutId = undefined;\n    }, this.options.wait);\n  }\n\n  private throttle(data: T): void {\n    if (this.options.mode === 'debounce') return;\n\n    const now = Date.now();\n    const throttleMode = this.options.throttleMode || 'leading-trailing';\n\n    if (now - this.lastRun >= this.options.wait) {\n      if (throttleMode === 'leading-trailing') {\n        this.handler(data);\n      }\n      this.lastRun = now;\n    }\n\n    // Always schedule the trailing execution\n    if (this.timeoutId) {\n      window.clearTimeout(this.timeoutId);\n    }\n\n    this.timeoutId = window.setTimeout(\n      () => {\n        this.handler(data);\n        this.lastRun = Date.now();\n        this.timeoutId = undefined;\n      },\n      this.options.wait - (now - this.lastRun),\n    );\n  }\n\n  destroy(): void {\n    if (this.timeoutId) {\n      window.clearTimeout(this.timeoutId);\n    }\n  }\n}\n","import { EventControl, EventControlOptions } from './event-control';\nimport { arePropsEqual } from './math';\n\n/* ------------------------------------------------------------------ */\n/* basic types                                                        */\n/* ------------------------------------------------------------------ */\nexport type Listener<T = any> = (value: T) => void;\nexport type Unsubscribe = () => void;\n\n/* ------------------------------------------------------------------ */\n/* EventListener                                                      */\n/* ------------------------------------------------------------------ */\nexport type EventListener<T> =\n  | ((listener: Listener<T>) => Unsubscribe)\n  | ((listener: Listener<T>, options?: EventControlOptions) => Unsubscribe);\n\n/* ------------------------------------------------------------ */\n/* helpers for typing `.on()` with an optional second argument  */\n/* ------------------------------------------------------------ */\nexport type EventHook<T = any> = EventListener<T>;\n/* ------------------------------------------------------------------ */\n/* minimal “dumb” emitter (no value cache, no equality)               */\n/* ------------------------------------------------------------------ */\nexport interface Emitter<T = any> {\n  emit(value?: T): void;\n  on(listener: Listener<T>): Unsubscribe;\n  off(listener: Listener<T>): void;\n  clear(): void;\n}\n\nexport function createEmitter<T = any>(): Emitter<T> {\n  const listeners = new Set<Listener<T>>();\n\n  const on: EventHook<T> = (l: Listener<T>) => {\n    listeners.add(l);\n    return () => listeners.delete(l);\n  };\n\n  return {\n    emit: (v = undefined as T) => listeners.forEach((l) => l(v)),\n    on,\n    off: (l) => listeners.delete(l),\n    clear: () => listeners.clear(),\n  };\n}\n\n/* ------------------------------------------------------------ */\n/* public interface                                              */\n/* ------------------------------------------------------------ */\nexport interface BehaviorEmitter<T = any> extends Omit<Emitter<T>, 'on' | 'off'> {\n  readonly value?: T;\n  on: EventHook<T>;\n  off(listener: Listener<T>): void;\n  select<U>(selector: (v: T) => U, equality?: (a: U, b: U) => boolean): EventHook<U>;\n}\n\n/* ------------------------------------------------------------ */\n/* implementation                                               */\n/* ------------------------------------------------------------ */\nexport function createBehaviorEmitter<T = any>(\n  initial?: T,\n  equality: (a: T, b: T) => boolean = arePropsEqual,\n): BehaviorEmitter<T> {\n  const listeners = new Set<Listener<T>>();\n  const proxyMap = new Map<Listener<T>, { wrapped: Listener<T>; destroy: () => void }>();\n  let _value = initial; // cached value\n\n  /* -------------- helpers ----------------------------------- */\n  const notify = (v: T) => listeners.forEach((l) => l(v));\n\n  const baseOn: EventHook<T> = (listener: Listener<T>, options?: EventControlOptions) => {\n    /* wrap & remember if we have control options ------------------ */\n    let realListener = listener;\n    let destroy = () => {};\n\n    if (options) {\n      const ctl = new EventControl(listener, options);\n      realListener = ctl.handle as Listener<T>;\n      destroy = () => ctl.destroy();\n      proxyMap.set(listener, { wrapped: realListener, destroy });\n    }\n\n    /* immediate replay of last value ------------------------------ */\n    if (_value !== undefined) realListener(_value);\n\n    listeners.add(realListener);\n\n    return () => {\n      listeners.delete(realListener);\n      destroy();\n      proxyMap.delete(listener);\n    };\n  };\n\n  /* -------------- public object ------------------------------ */\n  return {\n    /* emitter behaviour ---------------------------------------- */\n    get value() {\n      return _value;\n    },\n\n    emit(v = undefined as T) {\n      if (_value === undefined || !equality(_value, v)) {\n        _value = v;\n        notify(v);\n      }\n    },\n\n    on: baseOn,\n    off(listener: Listener<T>) {\n      /* did we wrap this listener? */\n      const proxy = proxyMap.get(listener);\n      if (proxy) {\n        listeners.delete(proxy.wrapped);\n        proxy.destroy();\n        proxyMap.delete(listener);\n      } else {\n        listeners.delete(listener);\n      }\n    },\n\n    clear() {\n      listeners.clear();\n      proxyMap.forEach((p) => p.destroy());\n      proxyMap.clear();\n    },\n\n    /* derived hook --------------------------------------------- */\n    select<U>(selector: (v: T) => U, eq: (a: U, b: U) => boolean = arePropsEqual): EventHook<U> {\n      return (listener: Listener<U>, options?: EventControlOptions) => {\n        let prev: U | undefined;\n\n        /* replay */\n        if (_value !== undefined) {\n          const mapped = selector(_value);\n          prev = mapped;\n          listener(mapped);\n        }\n\n        /* subscribe to parent */\n        return baseOn(\n          (next) => {\n            const mapped = selector(next);\n            if (prev === undefined || !eq(prev, mapped)) {\n              prev = mapped;\n              listener(mapped);\n            }\n          },\n          options as EventControlOptions | undefined,\n        ); // pass control opts straight through\n      };\n    },\n  };\n}\n","/* ------------------------------------------------------------------ */\n/*  enumEntries – iterate over enum-keyed Records with strong typing  */\n/* ------------------------------------------------------------------ */\n\ntype EnumKey = string | number;\n\n/**\n * Iterate over a Record whose keys are enum members (numeric or string),\n * getting back a fully-typed `[key, value]` tuple array.\n *\n * Usage:\n *   for (const [subtype, defaults] of enumEntries(this.state.toolDefaults)) {\n *     // subtype is inferred as keyof ToolDefaultsBySubtype\n *   }\n */\nexport function enumEntries<E extends EnumKey, V>(record: Record<E, V>): Array<[E, V]> {\n  // Tell TS the values are V (not unknown) *before* we map.\n  return (Object.entries(record) as [string, V][]).map(([k, v]) => {\n    // Numeric enums come out of Object.entries as \"0\", \"1\", …  → convert.\n    const maybeNum = Number(k);\n    const typedKey: E =\n      Number.isFinite(maybeNum) && k.trim() !== '' // looks like a number?\n        ? (maybeNum as unknown as E) // numeric enum key\n        : (k as unknown as E); // string enum key\n\n    return [typedKey, v]; // v is already typed as V\n  });\n}\n","import { Action } from '@embedpdf/core';\n\nexport const SET_FULLSCREEN = 'SET_FULLSCREEN';\n\nexport interface SetFullscreenAction extends Action {\n  type: typeof SET_FULLSCREEN;\n  payload: boolean;\n}\n\nexport type FullscreenAction = SetFullscreenAction;\n\nexport function setFullscreen(payload: boolean): SetFullscreenAction {\n  return { type: SET_FULLSCREEN, payload };\n}\n","import { BasePlugin, createBehaviorEmitter, createEmitter, PluginRegistry } from '@embedpdf/core';\nimport { FullscreenCapability, FullscreenPluginConfig, FullscreenState } from './types';\nimport { FullscreenAction, setFullscreen } from './actions';\n\nexport class FullscreenPlugin extends BasePlugin<\n  FullscreenPluginConfig,\n  FullscreenCapability,\n  FullscreenState,\n  FullscreenAction\n> {\n  static readonly id = 'fullscreen' as const;\n\n  private readonly onStateChange$ = createBehaviorEmitter<FullscreenState>();\n  private readonly fullscreenRequest$ = createEmitter<'enter' | 'exit'>();\n\n  constructor(id: string, registry: PluginRegistry) {\n    super(id, registry);\n  }\n\n  async initialize(_: FullscreenPluginConfig): Promise<void> {}\n\n  protected buildCapability(): FullscreenCapability {\n    return {\n      isFullscreen: () => this.state.isFullscreen,\n      enableFullscreen: () => this.enableFullscreen(),\n      exitFullscreen: () => this.exitFullscreen(),\n      toggleFullscreen: () => this.toggleFullscreen(),\n      onRequest: this.fullscreenRequest$.on,\n      onStateChange: this.onStateChange$.on,\n    };\n  }\n\n  private toggleFullscreen(): void {\n    if (this.state.isFullscreen) {\n      this.exitFullscreen();\n    } else {\n      this.enableFullscreen();\n    }\n  }\n\n  private enableFullscreen(): void {\n    this.fullscreenRequest$.emit('enter');\n  }\n\n  private exitFullscreen(): void {\n    this.fullscreenRequest$.emit('exit');\n  }\n\n  override onStoreUpdated(_: FullscreenState, newState: FullscreenState): void {\n    this.onStateChange$.emit(newState);\n  }\n\n  public setFullscreenState(isFullscreen: boolean): void {\n    this.dispatch(setFullscreen(isFullscreen));\n  }\n\n  async destroy(): Promise<void> {\n    this.fullscreenRequest$.clear();\n    super.destroy();\n  }\n}\n","import { Reducer } from '@embedpdf/core';\nimport { FullscreenState } from './types';\nimport { FullscreenAction, SET_FULLSCREEN } from './actions';\n\nexport const initialState: FullscreenState = {\n  isFullscreen: false,\n};\n\nexport const reducer: Reducer<FullscreenState, FullscreenAction> = (state, action) => {\n  switch (action.type) {\n    case SET_FULLSCREEN:\n      return { ...state, isFullscreen: action.payload };\n    default:\n      return state;\n  }\n};\n","import { PluginPackage } from '@embedpdf/core';\nimport { manifest, FULLSCREEN_PLUGIN_ID } from './manifest';\nimport { FullscreenPluginConfig, FullscreenState } from './types';\nimport { FullscreenPlugin } from './fullscreen-plugin';\nimport { initialState } from './reducer';\nimport { reducer } from './reducer';\nimport { FullscreenAction } from './actions';\n\nexport const FullscreenPluginPackage: PluginPackage<\n  FullscreenPlugin,\n  FullscreenPluginConfig,\n  FullscreenState,\n  FullscreenAction\n> = {\n  manifest,\n  create: (registry) => new FullscreenPlugin(FULLSCREEN_PLUGIN_ID, registry),\n  reducer,\n  initialState,\n};\n\nexport * from './fullscreen-plugin';\nexport * from './types';\nexport * from './manifest';\nexport * from './actions';\nexport { initialState };\n","import { useCapability, usePlugin } from '@embedpdf/core/react';\nimport { FullscreenPlugin, FullscreenState, initialState } from '@embedpdf/plugin-fullscreen';\nimport { useState, useEffect } from 'react';\n\nexport const useFullscreenPlugin = () => usePlugin<FullscreenPlugin>(FullscreenPlugin.id);\nexport const useFullscreenCapability = () => useCapability<FullscreenPlugin>(FullscreenPlugin.id);\n\nexport const useFullscreen = () => {\n  const { provides } = useFullscreenCapability();\n  const [state, setState] = useState<FullscreenState>(initialState);\n\n  useEffect(() => {\n    return provides?.onStateChange((state) => {\n      setState(state);\n    });\n  }, [provides]);\n\n  return {\n    provides,\n    state,\n  };\n};\n","import { useEffect, useRef } from 'react';\n\nimport { useFullscreenPlugin, useFullscreenCapability } from '../hooks';\n\ntype FullscreenProviderProps = Omit<React.HTMLAttributes<HTMLDivElement>, 'style'> & {\n  children: React.ReactNode;\n  style?: React.CSSProperties;\n};\n\nexport function FullscreenProvider({ children, ...props }: FullscreenProviderProps) {\n  const { provides: fullscreenCapability } = useFullscreenCapability();\n  const { plugin } = useFullscreenPlugin();\n  const ref = useRef<HTMLDivElement>(null);\n\n  useEffect(() => {\n    if (!fullscreenCapability) return;\n\n    const unsub = fullscreenCapability.onRequest(async (action) => {\n      if (action === 'enter') {\n        const el = ref.current;\n        if (el && !document.fullscreenElement) await el.requestFullscreen();\n      } else {\n        if (document.fullscreenElement) await document.exitFullscreen();\n      }\n    });\n\n    return unsub;\n  }, [fullscreenCapability]);\n\n  useEffect(() => {\n    if (!plugin) return;\n    const handler = () => plugin.setFullscreenState(!!document.fullscreenElement);\n    document.addEventListener('fullscreenchange', handler);\n    return () => document.removeEventListener('fullscreenchange', handler);\n  }, [plugin]);\n\n  return (\n    <div\n      {...props}\n      style={{ position: 'relative', width: '100%', height: '100%', ...props.style }}\n      ref={ref}\n    >\n      {children}\n    </div>\n  );\n}\n"],"mappings":"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","names":["PdfSoftHyphenMarker","PdfZeroWidthSpace","PdfWordJoiner","PdfBomOrZwnbsp","PdfNonCharacterFFFE","PdfNonCharacterFFFF","PdfUnwantedTextMarkers","BLEND_MODE_INFOS","m","info","PdfAnnotationFlagName","acc","bit","name","g","n","t","e","E","r","N","T","F","u","o","U","V","W","P","j","B","i","H","q","G","J","K","Q","X","en","rn","un","on","cn","fn","c","an","sn","PDFContext","createContext","useRegistry","contextValue","useContext","PDFContext","registry","isInitializing","usePlugin","pluginId","plugin","useCapability","isLoading","ready","PdfSoftHyphenMarker","PdfZeroWidthSpace","PdfWordJoiner","PdfBomOrZwnbsp","PdfNonCharacterFFFE","PdfNonCharacterFFFF","PdfUnwantedTextMarkers","BLEND_MODE_INFOS","m","info","PdfAnnotationFlagName","acc","bit","name","arePropsEqual","a","b","visited","aType","pairId","getPairId","aIsArray","bIsArray","arraysEqualUnordered","objectsEqual","objectId","objectIdCounter","objectIds","obj","used","outer","i","elemA","j","aKeys","bKeys","key","valA","valB","BasePlugin","id","registry","action","newState","oldState","resolve","cap","debounceTime","now","lastActionTime","listener","EventControl","handler","options","data","throttleMode","createEmitter","listeners","v","l","createBehaviorEmitter","initial","equality","proxyMap","_value","notify","baseOn","realListener","destroy","ctl","proxy","p","selector","eq","prev","mapped","next","w","C","E","_","ee","state","useEffect","useEffect"]}