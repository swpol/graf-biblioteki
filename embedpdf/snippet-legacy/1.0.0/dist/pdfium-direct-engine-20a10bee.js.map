{"version":3,"file":"pdfium-direct-engine-20a10bee.js","sources":["../../packages/pdfium/dist/index.browser.js","../../packages/engines/dist/pdfium-direct-engine.js"],"sourcesContent":["var createPdfium = (() => {\n  var _scriptName = import.meta.url;\n\n  return async function (moduleArg = {}) {\n    var moduleRtn;\n\n    // include: shell.js\n    // The Module object: Our interface to the outside world. We import\n    // and export values on it. There are various ways Module can be used:\n    // 1. Not defined. We create it here\n    // 2. A function parameter, function(moduleArg) => Promise<Module>\n    // 3. pre-run appended it, var Module = {}; ..generated code..\n    // 4. External script tag defines var Module.\n    // We need to check if Module already exists (e.g. case 3 above).\n    // Substitution will be replaced with actual code on later stage of the build,\n    // this way Closure Compiler will not mangle it (e.g. case 4. above).\n    // Note that if you want to run closure, and also to use Module\n    // after the generated code, you will need to define   var Module = {};\n    // before the code. Then that object will be used in the code, and you\n    // can continue to use Module afterwards as well.\n    var Module = moduleArg;\n\n    // Set up the promise that indicates the Module is initialized\n    var readyPromiseResolve, readyPromiseReject;\n    var readyPromise = new Promise((resolve, reject) => {\n      readyPromiseResolve = resolve;\n      readyPromiseReject = reject;\n    });\n    [\n      '_EPDF_RenderAnnotBitmap',\n      '_EPDFAnnot_GenerateAppearance',\n      '_EPDFAnnot_GenerateAppearanceWithBlend',\n      '_EPDFAnnot_GetBlendMode',\n      '_EPDFAnnot_GetBorderDashPattern',\n      '_EPDFAnnot_GetBorderDashPatternCount',\n      '_EPDFAnnot_GetBorderEffect',\n      '_EPDFAnnot_GetBorderStyle',\n      '_EPDFAnnot_GetColor',\n      '_EPDFAnnot_GetIntent',\n      '_EPDFAnnot_GetRectangleDifferences',\n      '_EPDFAnnot_GetRichContent',\n      '_EPDFAnnot_SetBorderStyle',\n      '_EPDFAnnot_SetColor',\n      '_EPDFAnnot_SetIntent',\n      '_FORM_CanRedo',\n      '_FORM_CanUndo',\n      '_FORM_DoDocumentAAction',\n      '_FORM_DoDocumentJSAction',\n      '_FORM_DoDocumentOpenAction',\n      '_FORM_DoPageAAction',\n      '_FORM_ForceToKillFocus',\n      '_FORM_GetFocusedAnnot',\n      '_FORM_GetFocusedText',\n      '_FORM_GetSelectedText',\n      '_FORM_IsIndexSelected',\n      '_FORM_OnAfterLoadPage',\n      '_FORM_OnBeforeClosePage',\n      '_FORM_OnChar',\n      '_FORM_OnFocus',\n      '_FORM_OnKeyDown',\n      '_FORM_OnKeyUp',\n      '_FORM_OnLButtonDoubleClick',\n      '_FORM_OnLButtonDown',\n      '_FORM_OnLButtonUp',\n      '_FORM_OnMouseMove',\n      '_FORM_OnMouseWheel',\n      '_FORM_OnRButtonDown',\n      '_FORM_OnRButtonUp',\n      '_FORM_Redo',\n      '_FORM_ReplaceAndKeepSelection',\n      '_FORM_ReplaceSelection',\n      '_FORM_SelectAllText',\n      '_FORM_SetFocusedAnnot',\n      '_FORM_SetIndexSelected',\n      '_FORM_Undo',\n      '_FPDF_AddInstalledFont',\n      '_FPDF_CloseDocument',\n      '_FPDF_ClosePage',\n      '_FPDF_CloseXObject',\n      '_FPDF_CopyViewerPreferences',\n      '_FPDF_CountNamedDests',\n      '_FPDF_CreateClipPath',\n      '_FPDF_CreateNewDocument',\n      '_FPDF_DestroyClipPath',\n      '_FPDF_DestroyLibrary',\n      '_FPDF_DeviceToPage',\n      '_FPDF_DocumentHasValidCrossReferenceTable',\n      '_FPDF_FFLDraw',\n      '_FPDF_FreeDefaultSystemFontInfo',\n      '_FPDF_GetDefaultSystemFontInfo',\n      '_FPDF_GetDefaultTTFMap',\n      '_FPDF_GetDefaultTTFMapCount',\n      '_FPDF_GetDefaultTTFMapEntry',\n      '_FPDF_GetDocPermissions',\n      '_FPDF_GetDocUserPermissions',\n      '_FPDF_GetFileIdentifier',\n      '_FPDF_GetFileVersion',\n      '_FPDF_GetFormType',\n      '_FPDF_GetLastError',\n      '_FPDF_GetMetaText',\n      '_FPDF_GetNamedDest',\n      '_FPDF_GetNamedDestByName',\n      '_FPDF_GetPageAAction',\n      '_FPDF_GetPageBoundingBox',\n      '_FPDF_GetPageCount',\n      '_FPDF_GetPageHeight',\n      '_FPDF_GetPageHeightF',\n      '_FPDF_GetPageLabel',\n      '_FPDF_GetPageSizeByIndex',\n      '_FPDF_GetPageSizeByIndexF',\n      '_FPDF_GetPageWidth',\n      '_FPDF_GetPageWidthF',\n      '_FPDF_GetSecurityHandlerRevision',\n      '_FPDF_GetSignatureCount',\n      '_FPDF_GetSignatureObject',\n      '_FPDF_GetTrailerEnds',\n      '_FPDF_GetXFAPacketContent',\n      '_FPDF_GetXFAPacketCount',\n      '_FPDF_GetXFAPacketName',\n      '_FPDF_ImportNPagesToOne',\n      '_FPDF_ImportPages',\n      '_FPDF_ImportPagesByIndex',\n      '_FPDF_InitLibrary',\n      '_FPDF_InitLibraryWithConfig',\n      '_FPDF_LoadCustomDocument',\n      '_FPDF_LoadDocument',\n      '_FPDF_LoadMemDocument',\n      '_FPDF_LoadMemDocument64',\n      '_FPDF_LoadPage',\n      '_FPDF_LoadXFA',\n      '_FPDF_MovePages',\n      '_FPDF_NewFormObjectFromXObject',\n      '_FPDF_NewXObjectFromPage',\n      '_FPDF_PageToDevice',\n      '_FPDF_RemoveFormFieldHighlight',\n      '_FPDF_RenderPage_Close',\n      '_FPDF_RenderPage_Continue',\n      '_FPDF_RenderPageBitmap',\n      '_FPDF_RenderPageBitmap_Start',\n      '_FPDF_RenderPageBitmapWithColorScheme_Start',\n      '_FPDF_RenderPageBitmapWithMatrix',\n      '_FPDF_SaveAsCopy',\n      '_FPDF_SaveWithVersion',\n      '_FPDF_SetFormFieldHighlightAlpha',\n      '_FPDF_SetFormFieldHighlightColor',\n      '_FPDF_SetSandBoxPolicy',\n      '_FPDF_SetSystemFontInfo',\n      '_FPDF_StructElement_Attr_CountChildren',\n      '_FPDF_StructElement_Attr_GetBlobValue',\n      '_FPDF_StructElement_Attr_GetBooleanValue',\n      '_FPDF_StructElement_Attr_GetChildAtIndex',\n      '_FPDF_StructElement_Attr_GetCount',\n      '_FPDF_StructElement_Attr_GetName',\n      '_FPDF_StructElement_Attr_GetNumberValue',\n      '_FPDF_StructElement_Attr_GetStringValue',\n      '_FPDF_StructElement_Attr_GetType',\n      '_FPDF_StructElement_Attr_GetValue',\n      '_FPDF_StructElement_CountChildren',\n      '_FPDF_StructElement_GetActualText',\n      '_FPDF_StructElement_GetAltText',\n      '_FPDF_StructElement_GetAttributeAtIndex',\n      '_FPDF_StructElement_GetAttributeCount',\n      '_FPDF_StructElement_GetChildAtIndex',\n      '_FPDF_StructElement_GetChildMarkedContentID',\n      '_FPDF_StructElement_GetID',\n      '_FPDF_StructElement_GetLang',\n      '_FPDF_StructElement_GetMarkedContentID',\n      '_FPDF_StructElement_GetMarkedContentIdAtIndex',\n      '_FPDF_StructElement_GetMarkedContentIdCount',\n      '_FPDF_StructElement_GetObjType',\n      '_FPDF_StructElement_GetParent',\n      '_FPDF_StructElement_GetStringAttribute',\n      '_FPDF_StructElement_GetTitle',\n      '_FPDF_StructElement_GetType',\n      '_FPDF_StructTree_Close',\n      '_FPDF_StructTree_CountChildren',\n      '_FPDF_StructTree_GetChildAtIndex',\n      '_FPDF_StructTree_GetForPage',\n      '_FPDF_VIEWERREF_GetDuplex',\n      '_FPDF_VIEWERREF_GetName',\n      '_FPDF_VIEWERREF_GetNumCopies',\n      '_FPDF_VIEWERREF_GetPrintPageRange',\n      '_FPDF_VIEWERREF_GetPrintPageRangeCount',\n      '_FPDF_VIEWERREF_GetPrintPageRangeElement',\n      '_FPDF_VIEWERREF_GetPrintScaling',\n      '_FPDFAction_GetDest',\n      '_FPDFAction_GetFilePath',\n      '_FPDFAction_GetType',\n      '_FPDFAction_GetURIPath',\n      '_FPDFAnnot_AddFileAttachment',\n      '_FPDFAnnot_AddInkStroke',\n      '_FPDFAnnot_AppendAttachmentPoints',\n      '_FPDFAnnot_AppendObject',\n      '_FPDFAnnot_CountAttachmentPoints',\n      '_FPDFAnnot_GetAP',\n      '_FPDFAnnot_GetAttachmentPoints',\n      '_FPDFAnnot_GetBorder',\n      '_FPDFAnnot_GetColor',\n      '_FPDFAnnot_GetFileAttachment',\n      '_FPDFAnnot_GetFlags',\n      '_FPDFAnnot_GetFocusableSubtypes',\n      '_FPDFAnnot_GetFocusableSubtypesCount',\n      '_FPDFAnnot_GetFontColor',\n      '_FPDFAnnot_GetFontSize',\n      '_FPDFAnnot_GetFormAdditionalActionJavaScript',\n      '_FPDFAnnot_GetFormControlCount',\n      '_FPDFAnnot_GetFormControlIndex',\n      '_FPDFAnnot_GetFormFieldAlternateName',\n      '_FPDFAnnot_GetFormFieldAtPoint',\n      '_FPDFAnnot_GetFormFieldExportValue',\n      '_FPDFAnnot_GetFormFieldFlags',\n      '_FPDFAnnot_GetFormFieldName',\n      '_FPDFAnnot_GetFormFieldType',\n      '_FPDFAnnot_GetFormFieldValue',\n      '_FPDFAnnot_GetInkListCount',\n      '_FPDFAnnot_GetInkListPath',\n      '_FPDFAnnot_GetLine',\n      '_FPDFAnnot_GetLink',\n      '_FPDFAnnot_GetLinkedAnnot',\n      '_FPDFAnnot_GetNumberValue',\n      '_FPDFAnnot_GetObject',\n      '_FPDFAnnot_GetObjectCount',\n      '_FPDFAnnot_GetOptionCount',\n      '_FPDFAnnot_GetOptionLabel',\n      '_FPDFAnnot_GetRect',\n      '_FPDFAnnot_GetStringValue',\n      '_FPDFAnnot_GetSubtype',\n      '_FPDFAnnot_GetValueType',\n      '_FPDFAnnot_GetVertices',\n      '_FPDFAnnot_HasAttachmentPoints',\n      '_FPDFAnnot_HasKey',\n      '_FPDFAnnot_IsChecked',\n      '_FPDFAnnot_IsObjectSupportedSubtype',\n      '_FPDFAnnot_IsOptionSelected',\n      '_FPDFAnnot_IsSupportedSubtype',\n      '_FPDFAnnot_RemoveInkList',\n      '_FPDFAnnot_RemoveObject',\n      '_FPDFAnnot_SetAP',\n      '_FPDFAnnot_SetAttachmentPoints',\n      '_FPDFAnnot_SetBorder',\n      '_FPDFAnnot_SetColor',\n      '_FPDFAnnot_SetFlags',\n      '_FPDFAnnot_SetFocusableSubtypes',\n      '_FPDFAnnot_SetFontColor',\n      '_FPDFAnnot_SetFormFieldFlags',\n      '_FPDFAnnot_SetRect',\n      '_FPDFAnnot_SetStringValue',\n      '_FPDFAnnot_SetURI',\n      '_FPDFAnnot_UpdateObject',\n      '_FPDFAttachment_GetFile',\n      '_FPDFAttachment_GetName',\n      '_FPDFAttachment_GetStringValue',\n      '_FPDFAttachment_GetSubtype',\n      '_FPDFAttachment_GetValueType',\n      '_FPDFAttachment_HasKey',\n      '_FPDFAttachment_SetFile',\n      '_FPDFAttachment_SetStringValue',\n      '_FPDFAvail_Create',\n      '_FPDFAvail_Destroy',\n      '_FPDFAvail_GetDocument',\n      '_FPDFAvail_GetFirstPageNum',\n      '_FPDFAvail_IsDocAvail',\n      '_FPDFAvail_IsFormAvail',\n      '_FPDFAvail_IsLinearized',\n      '_FPDFAvail_IsPageAvail',\n      '_FPDFBitmap_Create',\n      '_FPDFBitmap_CreateEx',\n      '_FPDFBitmap_Destroy',\n      '_FPDFBitmap_FillRect',\n      '_FPDFBitmap_GetBuffer',\n      '_FPDFBitmap_GetFormat',\n      '_FPDFBitmap_GetHeight',\n      '_FPDFBitmap_GetStride',\n      '_FPDFBitmap_GetWidth',\n      '_FPDFBookmark_Find',\n      '_FPDFBookmark_GetAction',\n      '_FPDFBookmark_GetCount',\n      '_FPDFBookmark_GetDest',\n      '_FPDFBookmark_GetFirstChild',\n      '_FPDFBookmark_GetNextSibling',\n      '_FPDFBookmark_GetTitle',\n      '_FPDFCatalog_IsTagged',\n      '_FPDFCatalog_SetLanguage',\n      '_FPDFClipPath_CountPaths',\n      '_FPDFClipPath_CountPathSegments',\n      '_FPDFClipPath_GetPathSegment',\n      '_FPDFDest_GetDestPageIndex',\n      '_FPDFDest_GetLocationInPage',\n      '_FPDFDest_GetView',\n      '_FPDFDoc_AddAttachment',\n      '_FPDFDoc_CloseJavaScriptAction',\n      '_FPDFDoc_DeleteAttachment',\n      '_FPDFDOC_ExitFormFillEnvironment',\n      '_FPDFDoc_GetAttachment',\n      '_FPDFDoc_GetAttachmentCount',\n      '_FPDFDoc_GetJavaScriptAction',\n      '_FPDFDoc_GetJavaScriptActionCount',\n      '_FPDFDoc_GetPageMode',\n      '_FPDFDOC_InitFormFillEnvironment',\n      '_FPDFFont_Close',\n      '_FPDFFont_GetAscent',\n      '_FPDFFont_GetBaseFontName',\n      '_FPDFFont_GetDescent',\n      '_FPDFFont_GetFamilyName',\n      '_FPDFFont_GetFlags',\n      '_FPDFFont_GetFontData',\n      '_FPDFFont_GetGlyphPath',\n      '_FPDFFont_GetGlyphWidth',\n      '_FPDFFont_GetIsEmbedded',\n      '_FPDFFont_GetItalicAngle',\n      '_FPDFFont_GetWeight',\n      '_FPDFFormObj_CountObjects',\n      '_FPDFFormObj_GetObject',\n      '_FPDFFormObj_RemoveObject',\n      '_FPDFGlyphPath_CountGlyphSegments',\n      '_FPDFGlyphPath_GetGlyphPathSegment',\n      '_FPDFImageObj_GetBitmap',\n      '_FPDFImageObj_GetIccProfileDataDecoded',\n      '_FPDFImageObj_GetImageDataDecoded',\n      '_FPDFImageObj_GetImageDataRaw',\n      '_FPDFImageObj_GetImageFilter',\n      '_FPDFImageObj_GetImageFilterCount',\n      '_FPDFImageObj_GetImageMetadata',\n      '_FPDFImageObj_GetImagePixelSize',\n      '_FPDFImageObj_GetRenderedBitmap',\n      '_FPDFImageObj_LoadJpegFile',\n      '_FPDFImageObj_LoadJpegFileInline',\n      '_FPDFImageObj_SetBitmap',\n      '_FPDFImageObj_SetMatrix',\n      '_FPDFJavaScriptAction_GetName',\n      '_FPDFJavaScriptAction_GetScript',\n      '_FPDFLink_CloseWebLinks',\n      '_FPDFLink_CountQuadPoints',\n      '_FPDFLink_CountRects',\n      '_FPDFLink_CountWebLinks',\n      '_FPDFLink_Enumerate',\n      '_FPDFLink_GetAction',\n      '_FPDFLink_GetAnnot',\n      '_FPDFLink_GetAnnotRect',\n      '_FPDFLink_GetDest',\n      '_FPDFLink_GetLinkAtPoint',\n      '_FPDFLink_GetLinkZOrderAtPoint',\n      '_FPDFLink_GetQuadPoints',\n      '_FPDFLink_GetRect',\n      '_FPDFLink_GetTextRange',\n      '_FPDFLink_GetURL',\n      '_FPDFLink_LoadWebLinks',\n      '_FPDFPage_CloseAnnot',\n      '_FPDFPage_CountObjects',\n      '_FPDFPage_CreateAnnot',\n      '_FPDFPage_Delete',\n      '_FPDFPage_Flatten',\n      '_FPDFPage_FormFieldZOrderAtPoint',\n      '_FPDFPage_GenerateContent',\n      '_FPDFPage_GetAnnot',\n      '_FPDFPage_GetAnnotCount',\n      '_FPDFPage_GetAnnotIndex',\n      '_FPDFPage_GetArtBox',\n      '_FPDFPage_GetBleedBox',\n      '_FPDFPage_GetCropBox',\n      '_FPDFPage_GetDecodedThumbnailData',\n      '_FPDFPage_GetMediaBox',\n      '_FPDFPage_GetObject',\n      '_FPDFPage_GetRawThumbnailData',\n      '_FPDFPage_GetRotation',\n      '_FPDFPage_GetThumbnailAsBitmap',\n      '_FPDFPage_GetTrimBox',\n      '_FPDFPage_HasFormFieldAtPoint',\n      '_FPDFPage_HasTransparency',\n      '_FPDFPage_InsertClipPath',\n      '_FPDFPage_InsertObject',\n      '_FPDFPage_InsertObjectAtIndex',\n      '_FPDFPage_New',\n      '_FPDFPage_RemoveAnnot',\n      '_FPDFPage_RemoveObject',\n      '_FPDFPage_SetArtBox',\n      '_FPDFPage_SetBleedBox',\n      '_FPDFPage_SetCropBox',\n      '_FPDFPage_SetMediaBox',\n      '_FPDFPage_SetRotation',\n      '_FPDFPage_SetTrimBox',\n      '_FPDFPage_TransformAnnots',\n      '_FPDFPage_TransFormWithClip',\n      '_FPDFPageObj_AddMark',\n      '_FPDFPageObj_CountMarks',\n      '_FPDFPageObj_CreateNewPath',\n      '_FPDFPageObj_CreateNewRect',\n      '_FPDFPageObj_CreateTextObj',\n      '_FPDFPageObj_Destroy',\n      '_FPDFPageObj_GetBounds',\n      '_FPDFPageObj_GetClipPath',\n      '_FPDFPageObj_GetDashArray',\n      '_FPDFPageObj_GetDashCount',\n      '_FPDFPageObj_GetDashPhase',\n      '_FPDFPageObj_GetFillColor',\n      '_FPDFPageObj_GetIsActive',\n      '_FPDFPageObj_GetLineCap',\n      '_FPDFPageObj_GetLineJoin',\n      '_FPDFPageObj_GetMark',\n      '_FPDFPageObj_GetMarkedContentID',\n      '_FPDFPageObj_GetMatrix',\n      '_FPDFPageObj_GetRotatedBounds',\n      '_FPDFPageObj_GetStrokeColor',\n      '_FPDFPageObj_GetStrokeWidth',\n      '_FPDFPageObj_GetType',\n      '_FPDFPageObj_HasTransparency',\n      '_FPDFPageObj_NewImageObj',\n      '_FPDFPageObj_NewTextObj',\n      '_FPDFPageObj_RemoveMark',\n      '_FPDFPageObj_SetBlendMode',\n      '_FPDFPageObj_SetDashArray',\n      '_FPDFPageObj_SetDashPhase',\n      '_FPDFPageObj_SetFillColor',\n      '_FPDFPageObj_SetIsActive',\n      '_FPDFPageObj_SetLineCap',\n      '_FPDFPageObj_SetLineJoin',\n      '_FPDFPageObj_SetMatrix',\n      '_FPDFPageObj_SetStrokeColor',\n      '_FPDFPageObj_SetStrokeWidth',\n      '_FPDFPageObj_Transform',\n      '_FPDFPageObj_TransformClipPath',\n      '_FPDFPageObj_TransformF',\n      '_FPDFPageObjMark_CountParams',\n      '_FPDFPageObjMark_GetName',\n      '_FPDFPageObjMark_GetParamBlobValue',\n      '_FPDFPageObjMark_GetParamIntValue',\n      '_FPDFPageObjMark_GetParamKey',\n      '_FPDFPageObjMark_GetParamStringValue',\n      '_FPDFPageObjMark_GetParamValueType',\n      '_FPDFPageObjMark_RemoveParam',\n      '_FPDFPageObjMark_SetBlobParam',\n      '_FPDFPageObjMark_SetIntParam',\n      '_FPDFPageObjMark_SetStringParam',\n      '_FPDFPath_BezierTo',\n      '_FPDFPath_Close',\n      '_FPDFPath_CountSegments',\n      '_FPDFPath_GetDrawMode',\n      '_FPDFPath_GetPathSegment',\n      '_FPDFPath_LineTo',\n      '_FPDFPath_MoveTo',\n      '_FPDFPath_SetDrawMode',\n      '_FPDFPathSegment_GetClose',\n      '_FPDFPathSegment_GetPoint',\n      '_FPDFPathSegment_GetType',\n      '_FPDFSignatureObj_GetByteRange',\n      '_FPDFSignatureObj_GetContents',\n      '_FPDFSignatureObj_GetDocMDPPermission',\n      '_FPDFSignatureObj_GetReason',\n      '_FPDFSignatureObj_GetSubFilter',\n      '_FPDFSignatureObj_GetTime',\n      '_FPDFText_ClosePage',\n      '_FPDFText_CountChars',\n      '_FPDFText_CountRects',\n      '_FPDFText_FindClose',\n      '_FPDFText_FindNext',\n      '_FPDFText_FindPrev',\n      '_FPDFText_FindStart',\n      '_FPDFText_GetBoundedText',\n      '_FPDFText_GetCharAngle',\n      '_FPDFText_GetCharBox',\n      '_FPDFText_GetCharIndexAtPos',\n      '_FPDFText_GetCharIndexFromTextIndex',\n      '_FPDFText_GetCharOrigin',\n      '_FPDFText_GetFillColor',\n      '_FPDFText_GetFontInfo',\n      '_FPDFText_GetFontSize',\n      '_FPDFText_GetFontWeight',\n      '_FPDFText_GetLooseCharBox',\n      '_FPDFText_GetMatrix',\n      '_FPDFText_GetRect',\n      '_FPDFText_GetSchCount',\n      '_FPDFText_GetSchResultIndex',\n      '_FPDFText_GetStrokeColor',\n      '_FPDFText_GetText',\n      '_FPDFText_GetTextIndexFromCharIndex',\n      '_FPDFText_GetTextObject',\n      '_FPDFText_GetUnicode',\n      '_FPDFText_HasUnicodeMapError',\n      '_FPDFText_IsGenerated',\n      '_FPDFText_IsHyphen',\n      '_FPDFText_LoadCidType2Font',\n      '_FPDFText_LoadFont',\n      '_FPDFText_LoadPage',\n      '_FPDFText_LoadStandardFont',\n      '_FPDFText_SetCharcodes',\n      '_FPDFText_SetText',\n      '_FPDFTextObj_GetFont',\n      '_FPDFTextObj_GetFontSize',\n      '_FPDFTextObj_GetRenderedBitmap',\n      '_FPDFTextObj_GetText',\n      '_FPDFTextObj_GetTextRenderMode',\n      '_FPDFTextObj_SetTextRenderMode',\n      '_PDFiumExt_CloseFileWriter',\n      '_PDFiumExt_CloseFormFillInfo',\n      '_PDFiumExt_ExitFormFillEnvironment',\n      '_PDFiumExt_GetFileWriterData',\n      '_PDFiumExt_GetFileWriterSize',\n      '_PDFiumExt_Init',\n      '_PDFiumExt_InitFormFillEnvironment',\n      '_PDFiumExt_OpenFileWriter',\n      '_PDFiumExt_OpenFormFillInfo',\n      '_PDFiumExt_SaveAsCopy',\n      '_malloc',\n      '_free',\n      '_memory',\n      '___indirect_function_table',\n      'onRuntimeInitialized',\n    ].forEach((prop) => {\n      if (!Object.getOwnPropertyDescriptor(readyPromise, prop)) {\n        Object.defineProperty(readyPromise, prop, {\n          get: () =>\n            abort(\n              'You are getting ' +\n                prop +\n                ' on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js',\n            ),\n          set: () =>\n            abort(\n              'You are setting ' +\n                prop +\n                ' on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js',\n            ),\n        });\n      }\n    });\n\n    // Determine the runtime environment we are in. You can customize this by\n    // setting the ENVIRONMENT setting at compile time (see settings.js).\n\n    // Attempt to auto-detect the environment\n    var ENVIRONMENT_IS_WEB = typeof window == 'object';\n    var ENVIRONMENT_IS_WORKER = typeof importScripts == 'function';\n    // N.b. Electron.js environment is simultaneously a NODE-environment, but\n    // also a web environment.\n    typeof process == 'object' &&\n      typeof process.versions == 'object' &&\n      typeof process.versions.node == 'string' &&\n      process.type != 'renderer';\n    var ENVIRONMENT_IS_SHELL =\n      !ENVIRONMENT_IS_WEB && !false && !ENVIRONMENT_IS_WORKER;\n\n    var require; \n\n    // --pre-jses are emitted after the Module integration code, so that they can\n    // refer to Module (if they choose; they can also define Module)\n\n    // Sometimes an existing Module object exists with properties\n    // meant to overwrite the default module functionality. Here\n    // we collect those properties and reapply _after_ we configure\n    // the current environment's defaults to avoid having to be so\n    // defensive during initialization.\n    var moduleOverrides = Object.assign({}, Module);\n    var thisProgram = './this.program';\n\n    // `/` should be present at the end if `scriptDirectory` is not empty\n    var scriptDirectory = '';\n    function locateFile(path) {\n      if (Module['locateFile']) {\n        return Module['locateFile'](path, scriptDirectory);\n      }\n      return scriptDirectory + path;\n    }\n\n    // Hooks that are implemented differently in different runtime environments.\n    var readAsync, readBinary;\n\n    if (ENVIRONMENT_IS_SHELL) {\n      if (\n        (typeof process == 'object' && typeof require === 'function') ||\n        typeof window == 'object' ||\n        typeof importScripts == 'function'\n      )\n        throw new Error(\n          'not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)',\n        );\n\n      readBinary = (f) => {\n        if (typeof readbuffer == 'function') {\n          return new Uint8Array(readbuffer(f));\n        }\n        let data = read(f, 'binary');\n        assert(typeof data == 'object');\n        return data;\n      };\n\n      readAsync = (f) => {\n        return new Promise((resolve, reject) => {\n          setTimeout(() => resolve(readBinary(f)));\n        });\n      };\n\n      globalThis.clearTimeout ??= (id) => {};\n\n      // spidermonkey lacks setTimeout but we use it above in readAsync.\n      globalThis.setTimeout ??= (f) => (typeof f == 'function' ? f() : abort());\n\n      if (typeof print != 'undefined') {\n        // Prefer to use print/printErr where they exist, as they usually work better.\n        globalThis.console ??= /** @type{!Console} */ ({});\n        console.log = /** @type{!function(this:Console, ...*): undefined} */ (print);\n        console.warn = console.error = /** @type{!function(this:Console, ...*): undefined} */ (\n          globalThis.printErr ?? print\n        );\n      }\n    } else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\n      // Note that this includes Node.js workers when relevant (pthreads is enabled).\n      // Node.js workers are detected as a combination of ENVIRONMENT_IS_WORKER and\n      // ENVIRONMENT_IS_NODE.\n      if (ENVIRONMENT_IS_WORKER) {\n        // Check worker, not web, since window could be polyfilled\n        scriptDirectory = self.location.href;\n      } else if (typeof document != 'undefined' && document.currentScript) {\n        // web\n        scriptDirectory = document.currentScript.src;\n      }\n      // When MODULARIZE, this JS may be executed later, after document.currentScript\n      // is gone, so we saved it, and we use it here instead of any other info.\n      if (_scriptName) {\n        scriptDirectory = _scriptName;\n      }\n      // blob urls look like blob:http://site.com/etc/etc and we cannot infer anything from them.\n      // otherwise, slice off the final part of the url to find the script directory.\n      // if scriptDirectory does not contain a slash, lastIndexOf will return -1,\n      // and scriptDirectory will correctly be replaced with an empty string.\n      // If scriptDirectory contains a query (starting with ?) or a fragment (starting with #),\n      // they are removed because they could contain a slash.\n      if (scriptDirectory.startsWith('blob:')) {\n        scriptDirectory = '';\n      } else {\n        scriptDirectory = scriptDirectory.substr(\n          0,\n          scriptDirectory.replace(/[?#].*/, '').lastIndexOf('/') + 1,\n        );\n      }\n\n      if (!(typeof window == 'object' || typeof importScripts == 'function'))\n        throw new Error(\n          'not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)',\n        );\n\n      {\n        // include: web_or_worker_shell_read.js\n        if (ENVIRONMENT_IS_WORKER) {\n          readBinary = (url) => {\n            var xhr = new XMLHttpRequest();\n            xhr.open('GET', url, false);\n            xhr.responseType = 'arraybuffer';\n            xhr.send(null);\n            return new Uint8Array(/** @type{!ArrayBuffer} */ (xhr.response));\n          };\n        }\n\n        readAsync = (url) => {\n          assert(!isFileURI(url), 'readAsync does not work with file:// URLs');\n          return fetch(url, { credentials: 'same-origin' }).then((response) => {\n            if (response.ok) {\n              return response.arrayBuffer();\n            }\n            return Promise.reject(new Error(response.status + ' : ' + response.url));\n          });\n        };\n        // end include: web_or_worker_shell_read.js\n      }\n    } else {\n      throw new Error('environment detection error');\n    }\n\n    var out = Module['print'] || console.log.bind(console);\n    var err = Module['printErr'] || console.error.bind(console);\n\n    // Merge back in the overrides\n    Object.assign(Module, moduleOverrides);\n    // Free the object hierarchy contained in the overrides, this lets the GC\n    // reclaim data used.\n    moduleOverrides = null;\n    checkIncomingModuleAPI();\n\n    // Emit code to handle expected values on the Module object. This applies Module.x\n    // to the proper local x. This has two benefits: first, we only emit it if it is\n    // expected to arrive, and second, by using a local everywhere else that can be\n    // minified.\n\n    if (Module['arguments']) Module['arguments'];\n    legacyModuleProp('arguments', 'arguments_');\n\n    if (Module['thisProgram']) thisProgram = Module['thisProgram'];\n    legacyModuleProp('thisProgram', 'thisProgram');\n\n    // perform assertions in shell.js after we set up out() and err(), as otherwise if an assertion fails it cannot print the message\n    // Assertions on removed incoming Module JS APIs.\n    assert(\n      typeof Module['memoryInitializerPrefixURL'] == 'undefined',\n      'Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead',\n    );\n    assert(\n      typeof Module['pthreadMainPrefixURL'] == 'undefined',\n      'Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead',\n    );\n    assert(\n      typeof Module['cdInitializerPrefixURL'] == 'undefined',\n      'Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead',\n    );\n    assert(\n      typeof Module['filePackagePrefixURL'] == 'undefined',\n      'Module.filePackagePrefixURL option was removed, use Module.locateFile instead',\n    );\n    assert(typeof Module['read'] == 'undefined', 'Module.read option was removed');\n    assert(\n      typeof Module['readAsync'] == 'undefined',\n      'Module.readAsync option was removed (modify readAsync in JS)',\n    );\n    assert(\n      typeof Module['readBinary'] == 'undefined',\n      'Module.readBinary option was removed (modify readBinary in JS)',\n    );\n    assert(\n      typeof Module['setWindowTitle'] == 'undefined',\n      'Module.setWindowTitle option was removed (modify emscripten_set_window_title in JS)',\n    );\n    assert(\n      typeof Module['TOTAL_MEMORY'] == 'undefined',\n      'Module.TOTAL_MEMORY has been renamed Module.INITIAL_MEMORY',\n    );\n    legacyModuleProp('asm', 'wasmExports');\n    legacyModuleProp('readAsync', 'readAsync');\n    legacyModuleProp('readBinary', 'readBinary');\n    legacyModuleProp('setWindowTitle', 'setWindowTitle');\n\n    // end include: shell.js\n\n    // include: preamble.js\n    // === Preamble library stuff ===\n\n    // Documentation for the public APIs defined in this file must be updated in:\n    //    site/source/docs/api_reference/preamble.js.rst\n    // A prebuilt local version of the documentation is available at:\n    //    site/build/text/docs/api_reference/preamble.js.txt\n    // You can also build docs locally as HTML or other formats in site/\n    // An online HTML version (which may be of a different version of Emscripten)\n    //    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html\n\n    var wasmBinary = Module['wasmBinary'];\n    legacyModuleProp('wasmBinary', 'wasmBinary');\n\n    if (typeof WebAssembly != 'object') {\n      err('no native wasm support detected');\n    }\n\n    // Wasm globals\n\n    var wasmMemory;\n\n    //========================================\n    // Runtime essentials\n    //========================================\n\n    // whether we are quitting the application. no code should run after this.\n    // set in exit() and abort()\n    var ABORT = false;\n\n    // In STRICT mode, we only define assert() when ASSERTIONS is set.  i.e. we\n    // don't define it at all in release modes.  This matches the behaviour of\n    // MINIMAL_RUNTIME.\n    // TODO(sbc): Make this the default even without STRICT enabled.\n    /** @type {function(*, string=)} */\n    function assert(condition, text) {\n      if (!condition) {\n        abort('Assertion failed' + (text ? ': ' + text : ''));\n      }\n    }\n\n    // We used to include malloc/free by default in the past. Show a helpful error in\n    // builds with assertions.\n\n    // Memory management\n\n    var /** @type {!Int8Array} */\n      HEAP8,\n      /** @type {!Uint8Array} */\n      HEAPU8,\n      /** @type {!Int16Array} */\n      HEAP16,\n      /** @type {!Uint16Array} */\n      HEAPU16,\n      /** @type {!Int32Array} */\n      HEAP32,\n      /** @type {!Uint32Array} */\n      HEAPU32,\n      /** @type {!Float32Array} */\n      HEAPF32,\n      /** @type {!Float64Array} */\n      HEAPF64;\n\n    // include: runtime_shared.js\n    function updateMemoryViews() {\n      var b = wasmMemory.buffer;\n      Module['HEAP8'] = HEAP8 = new Int8Array(b);\n      Module['HEAP16'] = HEAP16 = new Int16Array(b);\n      Module['HEAPU8'] = HEAPU8 = new Uint8Array(b);\n      Module['HEAPU16'] = HEAPU16 = new Uint16Array(b);\n      Module['HEAP32'] = HEAP32 = new Int32Array(b);\n      Module['HEAPU32'] = HEAPU32 = new Uint32Array(b);\n      Module['HEAPF32'] = HEAPF32 = new Float32Array(b);\n      Module['HEAPF64'] = HEAPF64 = new Float64Array(b);\n    }\n\n    // end include: runtime_shared.js\n    assert(\n      !Module['STACK_SIZE'],\n      'STACK_SIZE can no longer be set at runtime.  Use -sSTACK_SIZE at link time',\n    );\n\n    assert(\n      typeof Int32Array != 'undefined' &&\n        typeof Float64Array !== 'undefined' &&\n        Int32Array.prototype.subarray != undefined &&\n        Int32Array.prototype.set != undefined,\n      'JS engine does not provide full typed array support',\n    );\n\n    // If memory is defined in wasm, the user can't provide it, or set INITIAL_MEMORY\n    assert(\n      !Module['wasmMemory'],\n      'Use of `wasmMemory` detected.  Use -sIMPORTED_MEMORY to define wasmMemory externally',\n    );\n    assert(\n      !Module['INITIAL_MEMORY'],\n      'Detected runtime INITIAL_MEMORY setting.  Use -sIMPORTED_MEMORY to define wasmMemory dynamically',\n    );\n\n    // include: runtime_stack_check.js\n    // Initializes the stack cookie. Called at the startup of main and at the startup of each thread in pthreads mode.\n    function writeStackCookie() {\n      var max = _emscripten_stack_get_end();\n      assert((max & 3) == 0);\n      // If the stack ends at address zero we write our cookies 4 bytes into the\n      // stack.  This prevents interference with SAFE_HEAP and ASAN which also\n      // monitor writes to address zero.\n      if (max == 0) {\n        max += 4;\n      }\n      // The stack grow downwards towards _emscripten_stack_get_end.\n      // We write cookies to the final two words in the stack and detect if they are\n      // ever overwritten.\n      HEAPU32[max >> 2] = 0x02135467;\n      HEAPU32[(max + 4) >> 2] = 0x89bacdfe;\n      // Also test the global address 0 for integrity.\n      HEAPU32[0 >> 2] = 1668509029;\n    }\n\n    function checkStackCookie() {\n      if (ABORT) return;\n      var max = _emscripten_stack_get_end();\n      // See writeStackCookie().\n      if (max == 0) {\n        max += 4;\n      }\n      var cookie1 = HEAPU32[max >> 2];\n      var cookie2 = HEAPU32[(max + 4) >> 2];\n      if (cookie1 != 0x02135467 || cookie2 != 0x89bacdfe) {\n        abort(\n          `Stack overflow! Stack cookie has been overwritten at ${ptrToString(max)}, expected hex dwords 0x89BACDFE and 0x2135467, but received ${ptrToString(cookie2)} ${ptrToString(cookie1)}`,\n        );\n      }\n      // Also test the global address 0 for integrity.\n      if (HEAPU32[0 >> 2] != 0x63736d65 /* 'emsc' */) {\n        abort('Runtime error: The application has corrupted its heap memory area (address zero)!');\n      }\n    }\n    // end include: runtime_stack_check.js\n    var __ATPRERUN__ = []; // functions called before the runtime is initialized\n    var __ATINIT__ = []; // functions called during startup\n    var __ATPOSTRUN__ = []; // functions called after the main() is called\n\n    var runtimeInitialized = false;\n\n    function preRun() {\n      var preRuns = Module['preRun'];\n      if (preRuns) {\n        if (typeof preRuns == 'function') preRuns = [preRuns];\n        preRuns.forEach(addOnPreRun);\n      }\n      callRuntimeCallbacks(__ATPRERUN__);\n    }\n\n    function initRuntime() {\n      assert(!runtimeInitialized);\n      runtimeInitialized = true;\n\n      checkStackCookie();\n\n      if (!Module['noFSInit'] && !FS.initialized) FS.init();\n      FS.ignorePermissions = false;\n      callRuntimeCallbacks(__ATINIT__);\n    }\n\n    function postRun() {\n      checkStackCookie();\n\n      var postRuns = Module['postRun'];\n      if (postRuns) {\n        if (typeof postRuns == 'function') postRuns = [postRuns];\n        postRuns.forEach(addOnPostRun);\n      }\n\n      callRuntimeCallbacks(__ATPOSTRUN__);\n    }\n\n    function addOnPreRun(cb) {\n      __ATPRERUN__.unshift(cb);\n    }\n\n    function addOnInit(cb) {\n      __ATINIT__.unshift(cb);\n    }\n\n    function addOnPostRun(cb) {\n      __ATPOSTRUN__.unshift(cb);\n    }\n\n    // include: runtime_math.js\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul\n\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/fround\n\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32\n\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc\n\n    assert(\n      Math.imul,\n      'This browser does not support Math.imul(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill',\n    );\n    assert(\n      Math.fround,\n      'This browser does not support Math.fround(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill',\n    );\n    assert(\n      Math.clz32,\n      'This browser does not support Math.clz32(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill',\n    );\n    assert(\n      Math.trunc,\n      'This browser does not support Math.trunc(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill',\n    );\n    // end include: runtime_math.js\n    // A counter of dependencies for calling run(). If we need to\n    // do asynchronous work before running, increment this and\n    // decrement it. Incrementing must happen in a place like\n    // Module.preRun (used by emcc to add file preloading).\n    // Note that you can add dependencies in preRun, even though\n    // it happens right before run - run will be postponed until\n    // the dependencies are met.\n    var runDependencies = 0;\n    var runDependencyWatcher = null;\n    var dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled\n    var runDependencyTracking = {};\n\n    function getUniqueRunDependency(id) {\n      var orig = id;\n      while (1) {\n        if (!runDependencyTracking[id]) return id;\n        id = orig + Math.random();\n      }\n    }\n\n    function addRunDependency(id) {\n      runDependencies++;\n\n      Module['monitorRunDependencies']?.(runDependencies);\n\n      if (id) {\n        assert(!runDependencyTracking[id]);\n        runDependencyTracking[id] = 1;\n        if (runDependencyWatcher === null && typeof setInterval != 'undefined') {\n          // Check for missing dependencies every few seconds\n          runDependencyWatcher = setInterval(() => {\n            if (ABORT) {\n              clearInterval(runDependencyWatcher);\n              runDependencyWatcher = null;\n              return;\n            }\n            var shown = false;\n            for (var dep in runDependencyTracking) {\n              if (!shown) {\n                shown = true;\n                err('still waiting on run dependencies:');\n              }\n              err(`dependency: ${dep}`);\n            }\n            if (shown) {\n              err('(end of list)');\n            }\n          }, 10000);\n        }\n      } else {\n        err('warning: run dependency added without ID');\n      }\n    }\n\n    function removeRunDependency(id) {\n      runDependencies--;\n\n      Module['monitorRunDependencies']?.(runDependencies);\n\n      if (id) {\n        assert(runDependencyTracking[id]);\n        delete runDependencyTracking[id];\n      } else {\n        err('warning: run dependency removed without ID');\n      }\n      if (runDependencies == 0) {\n        if (runDependencyWatcher !== null) {\n          clearInterval(runDependencyWatcher);\n          runDependencyWatcher = null;\n        }\n        if (dependenciesFulfilled) {\n          var callback = dependenciesFulfilled;\n          dependenciesFulfilled = null;\n          callback(); // can add another dependenciesFulfilled\n        }\n      }\n    }\n\n    /** @param {string|number=} what */\n    function abort(what) {\n      Module['onAbort']?.(what);\n\n      what = 'Aborted(' + what + ')';\n      // TODO(sbc): Should we remove printing and leave it up to whoever\n      // catches the exception?\n      err(what);\n\n      ABORT = true;\n\n      // Use a wasm runtime error, because a JS error might be seen as a foreign\n      // exception, which means we'd run destructors on it. We need the error to\n      // simply make the program stop.\n      // FIXME This approach does not work in Wasm EH because it currently does not assume\n      // all RuntimeErrors are from traps; it decides whether a RuntimeError is from\n      // a trap or not based on a hidden field within the object. So at the moment\n      // we don't have a way of throwing a wasm trap from JS. TODO Make a JS API that\n      // allows this in the wasm spec.\n\n      // Suppress closure compiler warning here. Closure compiler's builtin extern\n      // definition for WebAssembly.RuntimeError claims it takes no arguments even\n      // though it can.\n      // TODO(https://github.com/google/closure-compiler/pull/3913): Remove if/when upstream closure gets fixed.\n      /** @suppress {checkTypes} */\n      var e = new WebAssembly.RuntimeError(what);\n\n      readyPromiseReject(e);\n      // Throw the error whether or not MODULARIZE is set because abort is used\n      // in code paths apart from instantiation where an exception is expected\n      // to be thrown when abort is called.\n      throw e;\n    }\n\n    // include: memoryprofiler.js\n    // end include: memoryprofiler.js\n    // include: URIUtils.js\n    // Prefix of data URIs emitted by SINGLE_FILE and related options.\n    var dataURIPrefix = 'data:application/octet-stream;base64,';\n\n    /**\n     * Indicates whether filename is a base64 data URI.\n     * @noinline\n     */\n    var isDataURI = (filename) => filename.startsWith(dataURIPrefix);\n\n    /**\n     * Indicates whether filename is delivered via file protocol (as opposed to http/https)\n     * @noinline\n     */\n    var isFileURI = (filename) => filename.startsWith('file://');\n    // end include: URIUtils.js\n    function createExportWrapper(name, nargs) {\n      return (...args) => {\n        assert(\n          runtimeInitialized,\n          `native function \\`${name}\\` called before runtime initialization`,\n        );\n        var f = wasmExports[name];\n        assert(f, `exported native function \\`${name}\\` not found`);\n        // Only assert for too many arguments. Too few can be valid since the missing arguments will be zero filled.\n        assert(\n          args.length <= nargs,\n          `native function \\`${name}\\` called with ${args.length} args but expects ${nargs}`,\n        );\n        return f(...args);\n      };\n    }\n\n    // include: runtime_exceptions.js\n    // end include: runtime_exceptions.js\n    function findWasmBinary() {\n      if (Module['locateFile']) {\n        var f = 'pdfium.wasm';\n        if (!isDataURI(f)) {\n          return locateFile(f);\n        }\n        return f;\n      }\n      if (ENVIRONMENT_IS_SHELL) return 'pdfium.wasm';\n      // Use bundler-friendly `new URL(..., import.meta.url)` pattern; works in browsers too.\n      return new URL('pdfium.wasm', import.meta.url).href;\n    }\n\n    var wasmBinaryFile;\n\n    function getBinarySync(file) {\n      if (file == wasmBinaryFile && wasmBinary) {\n        return new Uint8Array(wasmBinary);\n      }\n      if (readBinary) {\n        return readBinary(file);\n      }\n      throw 'both async and sync fetching of the wasm failed';\n    }\n\n    function getBinaryPromise(binaryFile) {\n      // If we don't have the binary yet, load it asynchronously using readAsync.\n      if (!wasmBinary) {\n        // Fetch the binary using readAsync\n        return readAsync(binaryFile).then(\n          (response) => new Uint8Array(/** @type{!ArrayBuffer} */ (response)),\n          // Fall back to getBinarySync if readAsync fails\n          () => getBinarySync(binaryFile),\n        );\n      }\n\n      // Otherwise, getBinarySync should be able to get it synchronously\n      return Promise.resolve().then(() => getBinarySync(binaryFile));\n    }\n\n    function instantiateArrayBuffer(binaryFile, imports, receiver) {\n      return getBinaryPromise(binaryFile)\n        .then((binary) => {\n          return WebAssembly.instantiate(binary, imports);\n        })\n        .then(receiver, (reason) => {\n          err(`failed to asynchronously prepare wasm: ${reason}`);\n\n          // Warn on some common problems.\n          if (isFileURI(wasmBinaryFile)) {\n            err(\n              `warning: Loading from a file URI (${wasmBinaryFile}) is not supported in most browsers. See https://emscripten.org/docs/getting_started/FAQ.html#how-do-i-run-a-local-webserver-for-testing-why-does-my-program-stall-in-downloading-or-preparing`,\n            );\n          }\n          abort(reason);\n        });\n    }\n\n    function instantiateAsync(binary, binaryFile, imports, callback) {\n      if (\n        !binary &&\n        typeof WebAssembly.instantiateStreaming == 'function' &&\n        !isDataURI(binaryFile) &&\n        // Avoid instantiateStreaming() on Node.js environment for now, as while\n        // Node.js v18.1.0 implements it, it does not have a full fetch()\n        // implementation yet.\n        //\n        // Reference:\n        //   https://github.com/emscripten-core/emscripten/pull/16917\n        !false &&\n        typeof fetch == 'function'\n      ) {\n        return fetch(binaryFile, { credentials: 'same-origin' }).then((response) => {\n          // Suppress closure warning here since the upstream definition for\n          // instantiateStreaming only allows Promise<Repsponse> rather than\n          // an actual Response.\n          // TODO(https://github.com/google/closure-compiler/pull/3913): Remove if/when upstream closure is fixed.\n          /** @suppress {checkTypes} */\n          var result = WebAssembly.instantiateStreaming(response, imports);\n\n          return result.then(callback, function (reason) {\n            // We expect the most common failure cause to be a bad MIME type for the binary,\n            // in which case falling back to ArrayBuffer instantiation should work.\n            err(`wasm streaming compile failed: ${reason}`);\n            err('falling back to ArrayBuffer instantiation');\n            return instantiateArrayBuffer(binaryFile, imports, callback);\n          });\n        });\n      }\n      return instantiateArrayBuffer(binaryFile, imports, callback);\n    }\n\n    function getWasmImports() {\n      // prepare imports\n      return {\n        env: wasmImports,\n        wasi_snapshot_preview1: wasmImports,\n      };\n    }\n\n    // Create the wasm instance.\n    // Receives the wasm imports, returns the exports.\n    function createWasm() {\n      var info = getWasmImports();\n      // Load the wasm module and create an instance of using native support in the JS engine.\n      // handle a generated wasm instance, receiving its exports and\n      // performing other necessary setup\n      /** @param {WebAssembly.Module=} module*/\n      function receiveInstance(instance, module) {\n        wasmExports = instance.exports;\n\n        Module['wasmExports'] = wasmExports;\n\n        wasmMemory = wasmExports['memory'];\n\n        assert(wasmMemory, 'memory not found in wasm exports');\n        updateMemoryViews();\n\n        wasmTable = wasmExports['__indirect_function_table'];\n\n        assert(wasmTable, 'table not found in wasm exports');\n\n        addOnInit(wasmExports['__wasm_call_ctors']);\n\n        removeRunDependency('wasm-instantiate');\n        return wasmExports;\n      }\n      // wait for the pthread pool (if any)\n      addRunDependency('wasm-instantiate');\n\n      // Prefer streaming instantiation if available.\n      // Async compilation can be confusing when an error on the page overwrites Module\n      // (for example, if the order of elements is wrong, and the one defining Module is\n      // later), so we save Module and check it later.\n      var trueModule = Module;\n      function receiveInstantiationResult(result) {\n        // 'result' is a ResultObject object which has both the module and instance.\n        // receiveInstance() will swap in the exports (to Module.asm) so they can be called\n        assert(\n          Module === trueModule,\n          'the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?',\n        );\n        trueModule = null;\n        // TODO: Due to Closure regression https://github.com/google/closure-compiler/issues/3193, the above line no longer optimizes out down to the following line.\n        // When the regression is fixed, can restore the above PTHREADS-enabled path.\n        receiveInstance(result['instance']);\n      }\n\n      // User shell pages can write their own Module.instantiateWasm = function(imports, successCallback) callback\n      // to manually instantiate the Wasm module themselves. This allows pages to\n      // run the instantiation parallel to any other async startup actions they are\n      // performing.\n      // Also pthreads and wasm workers initialize the wasm instance through this\n      // path.\n      if (Module['instantiateWasm']) {\n        try {\n          return Module['instantiateWasm'](info, receiveInstance);\n        } catch (e) {\n          err(`Module.instantiateWasm callback failed with error: ${e}`);\n          // If instantiation fails, reject the module ready promise.\n          readyPromiseReject(e);\n        }\n      }\n\n      wasmBinaryFile ??= findWasmBinary();\n\n      // If instantiation fails, reject the module ready promise.\n      instantiateAsync(wasmBinary, wasmBinaryFile, info, receiveInstantiationResult).catch(\n        readyPromiseReject,\n      );\n      return {}; // no exports yet; we'll fill them in later\n    }\n\n    // Globals used by JS i64 conversions (see makeSetValue)\n    var tempDouble;\n    var tempI64;\n\n    // include: runtime_debug.js\n    // Endianness check\n    (() => {\n      var h16 = new Int16Array(1);\n      var h8 = new Int8Array(h16.buffer);\n      h16[0] = 0x6373;\n      if (h8[0] !== 0x73 || h8[1] !== 0x63)\n        throw 'Runtime error: expected the system to be little-endian! (Run with -sSUPPORT_BIG_ENDIAN to bypass)';\n    })();\n\n    if (Module['ENVIRONMENT']) {\n      throw new Error(\n        'Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -sENVIRONMENT=web or -sENVIRONMENT=node)',\n      );\n    }\n\n    function legacyModuleProp(prop, newName, incoming = true) {\n      if (!Object.getOwnPropertyDescriptor(Module, prop)) {\n        Object.defineProperty(Module, prop, {\n          configurable: true,\n          get() {\n            let extra = incoming\n              ? ' (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)'\n              : '';\n            abort(`\\`Module.${prop}\\` has been replaced by \\`${newName}\\`` + extra);\n          },\n        });\n      }\n    }\n\n    function ignoredModuleProp(prop) {\n      if (Object.getOwnPropertyDescriptor(Module, prop)) {\n        abort(\n          `\\`Module.${prop}\\` was supplied but \\`${prop}\\` not included in INCOMING_MODULE_JS_API`,\n        );\n      }\n    }\n\n    // forcing the filesystem exports a few things by default\n    function isExportedByForceFilesystem(name) {\n      return (\n        name === 'FS_createPath' ||\n        name === 'FS_createDataFile' ||\n        name === 'FS_createPreloadedFile' ||\n        name === 'FS_unlink' ||\n        name === 'addRunDependency' ||\n        // The old FS has some functionality that WasmFS lacks.\n        name === 'FS_createLazyFile' ||\n        name === 'FS_createDevice' ||\n        name === 'removeRunDependency'\n      );\n    }\n\n    /**\n     * Intercept access to a global symbol.  This enables us to give informative\n     * warnings/errors when folks attempt to use symbols they did not include in\n     * their build, or no symbols that no longer exist.\n     */\n    function hookGlobalSymbolAccess(sym, func) {\n      if (typeof globalThis != 'undefined' && !Object.getOwnPropertyDescriptor(globalThis, sym)) {\n        Object.defineProperty(globalThis, sym, {\n          configurable: true,\n          get() {\n            func();\n            return undefined;\n          },\n        });\n      }\n    }\n\n    function missingGlobal(sym, msg) {\n      hookGlobalSymbolAccess(sym, () => {\n        warnOnce(`\\`${sym}\\` is not longer defined by emscripten. ${msg}`);\n      });\n    }\n\n    missingGlobal('buffer', 'Please use HEAP8.buffer or wasmMemory.buffer');\n    missingGlobal('asm', 'Please use wasmExports instead');\n\n    function missingLibrarySymbol(sym) {\n      hookGlobalSymbolAccess(sym, () => {\n        // Can't `abort()` here because it would break code that does runtime\n        // checks.  e.g. `if (typeof SDL === 'undefined')`.\n        var msg = `\\`${sym}\\` is a library symbol and not included by default; add it to your library.js __deps or to DEFAULT_LIBRARY_FUNCS_TO_INCLUDE on the command line`;\n        // DEFAULT_LIBRARY_FUNCS_TO_INCLUDE requires the name as it appears in\n        // library.js, which means $name for a JS name with no prefix, or name\n        // for a JS name like _name.\n        var librarySymbol = sym;\n        if (!librarySymbol.startsWith('_')) {\n          librarySymbol = '$' + sym;\n        }\n        msg += ` (e.g. -sDEFAULT_LIBRARY_FUNCS_TO_INCLUDE='${librarySymbol}')`;\n        if (isExportedByForceFilesystem(sym)) {\n          msg +=\n            '. Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you';\n        }\n        warnOnce(msg);\n      });\n\n      // Any symbol that is not included from the JS library is also (by definition)\n      // not exported on the Module object.\n      unexportedRuntimeSymbol(sym);\n    }\n\n    function unexportedRuntimeSymbol(sym) {\n      if (!Object.getOwnPropertyDescriptor(Module, sym)) {\n        Object.defineProperty(Module, sym, {\n          configurable: true,\n          get() {\n            var msg = `'${sym}' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the Emscripten FAQ)`;\n            if (isExportedByForceFilesystem(sym)) {\n              msg +=\n                '. Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you';\n            }\n            abort(msg);\n          },\n        });\n      }\n    }\n\n    var callRuntimeCallbacks = (callbacks) => {\n      // Pass the module as the first argument.\n      callbacks.forEach((f) => f(Module));\n    };\n\n    /**\n     * @param {number} ptr\n     * @param {string} type\n     */\n    function getValue(ptr, type = 'i8') {\n      if (type.endsWith('*')) type = '*';\n      switch (type) {\n        case 'i1':\n          return HEAP8[ptr];\n        case 'i8':\n          return HEAP8[ptr];\n        case 'i16':\n          return HEAP16[ptr >> 1];\n        case 'i32':\n          return HEAP32[ptr >> 2];\n        case 'i64':\n          abort('to do getValue(i64) use WASM_BIGINT');\n        case 'float':\n          return HEAPF32[ptr >> 2];\n        case 'double':\n          return HEAPF64[ptr >> 3];\n        case '*':\n          return HEAPU32[ptr >> 2];\n        default:\n          abort(`invalid type for getValue: ${type}`);\n      }\n    }\n\n    Module['noExitRuntime'] || true;\n\n    var ptrToString = (ptr) => {\n      assert(typeof ptr === 'number');\n      // With CAN_ADDRESS_2GB or MEMORY64, pointers are already unsigned.\n      ptr >>>= 0;\n      return '0x' + ptr.toString(16).padStart(8, '0');\n    };\n\n    /**\n     * @param {number} ptr\n     * @param {number} value\n     * @param {string} type\n     */\n    function setValue(ptr, value, type = 'i8') {\n      if (type.endsWith('*')) type = '*';\n      switch (type) {\n        case 'i1':\n          HEAP8[ptr] = value;\n          break;\n        case 'i8':\n          HEAP8[ptr] = value;\n          break;\n        case 'i16':\n          HEAP16[ptr >> 1] = value;\n          break;\n        case 'i32':\n          HEAP32[ptr >> 2] = value;\n          break;\n        case 'i64':\n          abort('to do setValue(i64) use WASM_BIGINT');\n        case 'float':\n          HEAPF32[ptr >> 2] = value;\n          break;\n        case 'double':\n          HEAPF64[ptr >> 3] = value;\n          break;\n        case '*':\n          HEAPU32[ptr >> 2] = value;\n          break;\n        default:\n          abort(`invalid type for setValue: ${type}`);\n      }\n    }\n\n    var stackRestore = (val) => __emscripten_stack_restore(val);\n\n    var stackSave = () => _emscripten_stack_get_current();\n\n    var warnOnce = (text) => {\n      warnOnce.shown ||= {};\n      if (!warnOnce.shown[text]) {\n        warnOnce.shown[text] = 1;\n        err(text);\n      }\n    };\n\n    var UTF8Decoder = typeof TextDecoder != 'undefined' ? new TextDecoder() : undefined;\n\n    /**\n     * Given a pointer 'idx' to a null-terminated UTF8-encoded string in the given\n     * array that contains uint8 values, returns a copy of that string as a\n     * Javascript String object.\n     * heapOrArray is either a regular array, or a JavaScript typed array view.\n     * @param {number=} idx\n     * @param {number=} maxBytesToRead\n     * @return {string}\n     */\n    var UTF8ArrayToString = (heapOrArray, idx = 0, maxBytesToRead = NaN) => {\n      var endIdx = idx + maxBytesToRead;\n      var endPtr = idx;\n      // TextDecoder needs to know the byte length in advance, it doesn't stop on\n      // null terminator by itself.  Also, use the length info to avoid running tiny\n      // strings through TextDecoder, since .subarray() allocates garbage.\n      // (As a tiny code save trick, compare endPtr against endIdx using a negation,\n      // so that undefined/NaN means Infinity)\n      while (heapOrArray[endPtr] && !(endPtr >= endIdx)) ++endPtr;\n\n      if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {\n        return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));\n      }\n      var str = '';\n      // If building with TextDecoder, we have already computed the string length\n      // above, so test loop end condition against that\n      while (idx < endPtr) {\n        // For UTF8 byte structure, see:\n        // http://en.wikipedia.org/wiki/UTF-8#Description\n        // https://www.ietf.org/rfc/rfc2279.txt\n        // https://tools.ietf.org/html/rfc3629\n        var u0 = heapOrArray[idx++];\n        if (!(u0 & 0x80)) {\n          str += String.fromCharCode(u0);\n          continue;\n        }\n        var u1 = heapOrArray[idx++] & 63;\n        if ((u0 & 0xe0) == 0xc0) {\n          str += String.fromCharCode(((u0 & 31) << 6) | u1);\n          continue;\n        }\n        var u2 = heapOrArray[idx++] & 63;\n        if ((u0 & 0xf0) == 0xe0) {\n          u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;\n        } else {\n          if ((u0 & 0xf8) != 0xf0)\n            warnOnce(\n              'Invalid UTF-8 leading byte ' +\n                ptrToString(u0) +\n                ' encountered when deserializing a UTF-8 string in wasm memory to a JS string!',\n            );\n          u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | (heapOrArray[idx++] & 63);\n        }\n\n        if (u0 < 0x10000) {\n          str += String.fromCharCode(u0);\n        } else {\n          var ch = u0 - 0x10000;\n          str += String.fromCharCode(0xd800 | (ch >> 10), 0xdc00 | (ch & 0x3ff));\n        }\n      }\n      return str;\n    };\n\n    /**\n     * Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the\n     * emscripten HEAP, returns a copy of that string as a Javascript String object.\n     *\n     * @param {number} ptr\n     * @param {number=} maxBytesToRead - An optional length that specifies the\n     *   maximum number of bytes to read. You can omit this parameter to scan the\n     *   string until the first 0 byte. If maxBytesToRead is passed, and the string\n     *   at [ptr, ptr+maxBytesToReadr[ contains a null byte in the middle, then the\n     *   string will cut short at that byte index (i.e. maxBytesToRead will not\n     *   produce a string of exact length [ptr, ptr+maxBytesToRead[) N.B. mixing\n     *   frequent uses of UTF8ToString() with and without maxBytesToRead may throw\n     *   JS JIT optimizations off, so it is worth to consider consistently using one\n     * @return {string}\n     */\n    var UTF8ToString = (ptr, maxBytesToRead) => {\n      assert(typeof ptr == 'number', `UTF8ToString expects a number (got ${typeof ptr})`);\n      return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : '';\n    };\n    var ___assert_fail = (condition, filename, line, func) => {\n      abort(\n        `Assertion failed: ${UTF8ToString(condition)}, at: ` +\n          [\n            filename ? UTF8ToString(filename) : 'unknown filename',\n            line,\n            func ? UTF8ToString(func) : 'unknown function',\n          ],\n      );\n    };\n\n    /** @suppress {duplicate } */\n    function syscallGetVarargI() {\n      assert(SYSCALLS.varargs != undefined);\n      // the `+` prepended here is necessary to convince the JSCompiler that varargs is indeed a number.\n      var ret = HEAP32[+SYSCALLS.varargs >> 2];\n      SYSCALLS.varargs += 4;\n      return ret;\n    }\n    var syscallGetVarargP = syscallGetVarargI;\n\n    var PATH = {\n      isAbs: (path) => path.charAt(0) === '/',\n      splitPath: (filename) => {\n        var splitPathRe = /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\n        return splitPathRe.exec(filename).slice(1);\n      },\n      normalizeArray: (parts, allowAboveRoot) => {\n        // if the path tries to go above the root, `up` ends up > 0\n        var up = 0;\n        for (var i = parts.length - 1; i >= 0; i--) {\n          var last = parts[i];\n          if (last === '.') {\n            parts.splice(i, 1);\n          } else if (last === '..') {\n            parts.splice(i, 1);\n            up++;\n          } else if (up) {\n            parts.splice(i, 1);\n            up--;\n          }\n        }\n        // if the path is allowed to go above the root, restore leading ..s\n        if (allowAboveRoot) {\n          for (; up; up--) {\n            parts.unshift('..');\n          }\n        }\n        return parts;\n      },\n      normalize: (path) => {\n        var isAbsolute = PATH.isAbs(path),\n          trailingSlash = path.substr(-1) === '/';\n        // Normalize the path\n        path = PATH.normalizeArray(\n          path.split('/').filter((p) => !!p),\n          !isAbsolute,\n        ).join('/');\n        if (!path && !isAbsolute) {\n          path = '.';\n        }\n        if (path && trailingSlash) {\n          path += '/';\n        }\n        return (isAbsolute ? '/' : '') + path;\n      },\n      dirname: (path) => {\n        var result = PATH.splitPath(path),\n          root = result[0],\n          dir = result[1];\n        if (!root && !dir) {\n          // No dirname whatsoever\n          return '.';\n        }\n        if (dir) {\n          // It has a dirname, strip trailing slash\n          dir = dir.substr(0, dir.length - 1);\n        }\n        return root + dir;\n      },\n      basename: (path) => {\n        // EMSCRIPTEN return '/'' for '/', not an empty string\n        if (path === '/') return '/';\n        path = PATH.normalize(path);\n        path = path.replace(/\\/$/, '');\n        var lastSlash = path.lastIndexOf('/');\n        if (lastSlash === -1) return path;\n        return path.substr(lastSlash + 1);\n      },\n      join: (...paths) => PATH.normalize(paths.join('/')),\n      join2: (l, r) => PATH.normalize(l + '/' + r),\n    };\n\n    var initRandomFill = () => {\n      if (typeof crypto == 'object' && typeof crypto['getRandomValues'] == 'function') {\n        // for modern web browsers\n        return (view) => crypto.getRandomValues(view);\n      }\n      // we couldn't find a proper implementation, as Math.random() is not suitable for /dev/random, see emscripten-core/emscripten/pull/7096\n      abort(\n        'no cryptographic support found for randomDevice. consider polyfilling it if you want to use something insecure like Math.random(), e.g. put this in a --pre-js: var crypto = { getRandomValues: (array) => { for (var i = 0; i < array.length; i++) array[i] = (Math.random()*256)|0 } };',\n      );\n    };\n    var randomFill = (view) => {\n      // Lazily init on the first invocation.\n      return (randomFill = initRandomFill())(view);\n    };\n\n    var PATH_FS = {\n      resolve: (...args) => {\n        var resolvedPath = '',\n          resolvedAbsolute = false;\n        for (var i = args.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n          var path = i >= 0 ? args[i] : FS.cwd();\n          // Skip empty and invalid entries\n          if (typeof path != 'string') {\n            throw new TypeError('Arguments to path.resolve must be strings');\n          } else if (!path) {\n            return ''; // an invalid portion invalidates the whole thing\n          }\n          resolvedPath = path + '/' + resolvedPath;\n          resolvedAbsolute = PATH.isAbs(path);\n        }\n        // At this point the path should be resolved to a full absolute path, but\n        // handle relative paths to be safe (might happen when process.cwd() fails)\n        resolvedPath = PATH.normalizeArray(\n          resolvedPath.split('/').filter((p) => !!p),\n          !resolvedAbsolute,\n        ).join('/');\n        return (resolvedAbsolute ? '/' : '') + resolvedPath || '.';\n      },\n      relative: (from, to) => {\n        from = PATH_FS.resolve(from).substr(1);\n        to = PATH_FS.resolve(to).substr(1);\n        function trim(arr) {\n          var start = 0;\n          for (; start < arr.length; start++) {\n            if (arr[start] !== '') break;\n          }\n          var end = arr.length - 1;\n          for (; end >= 0; end--) {\n            if (arr[end] !== '') break;\n          }\n          if (start > end) return [];\n          return arr.slice(start, end - start + 1);\n        }\n        var fromParts = trim(from.split('/'));\n        var toParts = trim(to.split('/'));\n        var length = Math.min(fromParts.length, toParts.length);\n        var samePartsLength = length;\n        for (var i = 0; i < length; i++) {\n          if (fromParts[i] !== toParts[i]) {\n            samePartsLength = i;\n            break;\n          }\n        }\n        var outputParts = [];\n        for (var i = samePartsLength; i < fromParts.length; i++) {\n          outputParts.push('..');\n        }\n        outputParts = outputParts.concat(toParts.slice(samePartsLength));\n        return outputParts.join('/');\n      },\n    };\n\n    var FS_stdin_getChar_buffer = [];\n\n    var lengthBytesUTF8 = (str) => {\n      var len = 0;\n      for (var i = 0; i < str.length; ++i) {\n        // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code\n        // unit, not a Unicode code point of the character! So decode\n        // UTF16->UTF32->UTF8.\n        // See http://unicode.org/faq/utf_bom.html#utf16-3\n        var c = str.charCodeAt(i); // possibly a lead surrogate\n        if (c <= 0x7f) {\n          len++;\n        } else if (c <= 0x7ff) {\n          len += 2;\n        } else if (c >= 0xd800 && c <= 0xdfff) {\n          len += 4;\n          ++i;\n        } else {\n          len += 3;\n        }\n      }\n      return len;\n    };\n\n    var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {\n      assert(typeof str === 'string', `stringToUTF8Array expects a string (got ${typeof str})`);\n      // Parameter maxBytesToWrite is not optional. Negative values, 0, null,\n      // undefined and false each don't write out any bytes.\n      if (!(maxBytesToWrite > 0)) return 0;\n\n      var startIdx = outIdx;\n      var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.\n      for (var i = 0; i < str.length; ++i) {\n        // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code\n        // unit, not a Unicode code point of the character! So decode\n        // UTF16->UTF32->UTF8.\n        // See http://unicode.org/faq/utf_bom.html#utf16-3\n        // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description\n        // and https://www.ietf.org/rfc/rfc2279.txt\n        // and https://tools.ietf.org/html/rfc3629\n        var u = str.charCodeAt(i); // possibly a lead surrogate\n        if (u >= 0xd800 && u <= 0xdfff) {\n          var u1 = str.charCodeAt(++i);\n          u = (0x10000 + ((u & 0x3ff) << 10)) | (u1 & 0x3ff);\n        }\n        if (u <= 0x7f) {\n          if (outIdx >= endIdx) break;\n          heap[outIdx++] = u;\n        } else if (u <= 0x7ff) {\n          if (outIdx + 1 >= endIdx) break;\n          heap[outIdx++] = 0xc0 | (u >> 6);\n          heap[outIdx++] = 0x80 | (u & 63);\n        } else if (u <= 0xffff) {\n          if (outIdx + 2 >= endIdx) break;\n          heap[outIdx++] = 0xe0 | (u >> 12);\n          heap[outIdx++] = 0x80 | ((u >> 6) & 63);\n          heap[outIdx++] = 0x80 | (u & 63);\n        } else {\n          if (outIdx + 3 >= endIdx) break;\n          if (u > 0x10ffff)\n            warnOnce(\n              'Invalid Unicode code point ' +\n                ptrToString(u) +\n                ' encountered when serializing a JS string to a UTF-8 string in wasm memory! (Valid unicode code points should be in range 0-0x10FFFF).',\n            );\n          heap[outIdx++] = 0xf0 | (u >> 18);\n          heap[outIdx++] = 0x80 | ((u >> 12) & 63);\n          heap[outIdx++] = 0x80 | ((u >> 6) & 63);\n          heap[outIdx++] = 0x80 | (u & 63);\n        }\n      }\n      // Null-terminate the pointer to the buffer.\n      heap[outIdx] = 0;\n      return outIdx - startIdx;\n    };\n    /** @type {function(string, boolean=, number=)} */\n    function intArrayFromString(stringy, dontAddNull, length) {\n      var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;\n      var u8array = new Array(len);\n      var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);\n      if (dontAddNull) u8array.length = numBytesWritten;\n      return u8array;\n    }\n    var FS_stdin_getChar = () => {\n      if (!FS_stdin_getChar_buffer.length) {\n        var result = null;\n        if (typeof window != 'undefined' && typeof window.prompt == 'function') {\n          // Browser.\n          result = window.prompt('Input: '); // returns null on cancel\n          if (result !== null) {\n            result += '\\n';\n          }\n        } else if (typeof readline == 'function') {\n          // Command line.\n          result = readline();\n          if (result) {\n            result += '\\n';\n          }\n        } else ;\n        if (!result) {\n          return null;\n        }\n        FS_stdin_getChar_buffer = intArrayFromString(result, true);\n      }\n      return FS_stdin_getChar_buffer.shift();\n    };\n    var TTY = {\n      ttys: [],\n      init() {\n        // https://github.com/emscripten-core/emscripten/pull/1555\n        // if (false) {\n        //   // currently, FS.init does not distinguish if process.stdin is a file or TTY\n        //   // device, it always assumes it's a TTY device. because of this, we're forcing\n        //   // process.stdin to UTF8 encoding to at least make stdin reading compatible\n        //   // with text files until FS.init can be refactored.\n        //   process.stdin.setEncoding('utf8');\n        // }\n      },\n      shutdown() {\n        // https://github.com/emscripten-core/emscripten/pull/1555\n        // if (false) {\n        //   // inolen: any idea as to why node -e 'process.stdin.read()' wouldn't exit immediately (with process.stdin being a tty)?\n        //   // isaacs: because now it's reading from the stream, you've expressed interest in it, so that read() kicks off a _read() which creates a ReadReq operation\n        //   // inolen: I thought read() in that case was a synchronous operation that just grabbed some amount of buffered data if it exists?\n        //   // isaacs: it is. but it also triggers a _read() call, which calls readStart() on the handle\n        //   // isaacs: do process.stdin.pause() and i'd think it'd probably close the pending call\n        //   process.stdin.pause();\n        // }\n      },\n      register(dev, ops) {\n        TTY.ttys[dev] = { input: [], output: [], ops: ops };\n        FS.registerDevice(dev, TTY.stream_ops);\n      },\n      stream_ops: {\n        open(stream) {\n          var tty = TTY.ttys[stream.node.rdev];\n          if (!tty) {\n            throw new FS.ErrnoError(43);\n          }\n          stream.tty = tty;\n          stream.seekable = false;\n        },\n        close(stream) {\n          // flush any pending line data\n          stream.tty.ops.fsync(stream.tty);\n        },\n        fsync(stream) {\n          stream.tty.ops.fsync(stream.tty);\n        },\n        read(stream, buffer, offset, length, pos /* ignored */) {\n          if (!stream.tty || !stream.tty.ops.get_char) {\n            throw new FS.ErrnoError(60);\n          }\n          var bytesRead = 0;\n          for (var i = 0; i < length; i++) {\n            var result;\n            try {\n              result = stream.tty.ops.get_char(stream.tty);\n            } catch (e) {\n              throw new FS.ErrnoError(29);\n            }\n            if (result === undefined && bytesRead === 0) {\n              throw new FS.ErrnoError(6);\n            }\n            if (result === null || result === undefined) break;\n            bytesRead++;\n            buffer[offset + i] = result;\n          }\n          if (bytesRead) {\n            stream.node.timestamp = Date.now();\n          }\n          return bytesRead;\n        },\n        write(stream, buffer, offset, length, pos) {\n          if (!stream.tty || !stream.tty.ops.put_char) {\n            throw new FS.ErrnoError(60);\n          }\n          try {\n            for (var i = 0; i < length; i++) {\n              stream.tty.ops.put_char(stream.tty, buffer[offset + i]);\n            }\n          } catch (e) {\n            throw new FS.ErrnoError(29);\n          }\n          if (length) {\n            stream.node.timestamp = Date.now();\n          }\n          return i;\n        },\n      },\n      default_tty_ops: {\n        get_char(tty) {\n          return FS_stdin_getChar();\n        },\n        put_char(tty, val) {\n          if (val === null || val === 10) {\n            out(UTF8ArrayToString(tty.output));\n            tty.output = [];\n          } else {\n            if (val != 0) tty.output.push(val); // val == 0 would cut text output off in the middle.\n          }\n        },\n        fsync(tty) {\n          if (tty.output && tty.output.length > 0) {\n            out(UTF8ArrayToString(tty.output));\n            tty.output = [];\n          }\n        },\n        ioctl_tcgets(tty) {\n          // typical setting\n          return {\n            c_iflag: 25856,\n            c_oflag: 5,\n            c_cflag: 191,\n            c_lflag: 35387,\n            c_cc: [\n              0x03, 0x1c, 0x7f, 0x15, 0x04, 0x00, 0x01, 0x00, 0x11, 0x13, 0x1a, 0x00, 0x12, 0x0f,\n              0x17, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n              0x00, 0x00, 0x00, 0x00,\n            ],\n          };\n        },\n        ioctl_tcsets(tty, optional_actions, data) {\n          // currently just ignore\n          return 0;\n        },\n        ioctl_tiocgwinsz(tty) {\n          return [24, 80];\n        },\n      },\n      default_tty1_ops: {\n        put_char(tty, val) {\n          if (val === null || val === 10) {\n            err(UTF8ArrayToString(tty.output));\n            tty.output = [];\n          } else {\n            if (val != 0) tty.output.push(val);\n          }\n        },\n        fsync(tty) {\n          if (tty.output && tty.output.length > 0) {\n            err(UTF8ArrayToString(tty.output));\n            tty.output = [];\n          }\n        },\n      },\n    };\n\n    var zeroMemory = (address, size) => {\n      HEAPU8.fill(0, address, address + size);\n    };\n\n    var alignMemory = (size, alignment) => {\n      assert(alignment, 'alignment argument is required');\n      return Math.ceil(size / alignment) * alignment;\n    };\n    var mmapAlloc = (size) => {\n      size = alignMemory(size, 65536);\n      var ptr = _emscripten_builtin_memalign(65536, size);\n      if (ptr) zeroMemory(ptr, size);\n      return ptr;\n    };\n    var MEMFS = {\n      ops_table: null,\n      mount(mount) {\n        return MEMFS.createNode(null, '/', 16384 | 511 /* 0777 */, 0);\n      },\n      createNode(parent, name, mode, dev) {\n        if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {\n          // no supported\n          throw new FS.ErrnoError(63);\n        }\n        MEMFS.ops_table ||= {\n          dir: {\n            node: {\n              getattr: MEMFS.node_ops.getattr,\n              setattr: MEMFS.node_ops.setattr,\n              lookup: MEMFS.node_ops.lookup,\n              mknod: MEMFS.node_ops.mknod,\n              rename: MEMFS.node_ops.rename,\n              unlink: MEMFS.node_ops.unlink,\n              rmdir: MEMFS.node_ops.rmdir,\n              readdir: MEMFS.node_ops.readdir,\n              symlink: MEMFS.node_ops.symlink,\n            },\n            stream: {\n              llseek: MEMFS.stream_ops.llseek,\n            },\n          },\n          file: {\n            node: {\n              getattr: MEMFS.node_ops.getattr,\n              setattr: MEMFS.node_ops.setattr,\n            },\n            stream: {\n              llseek: MEMFS.stream_ops.llseek,\n              read: MEMFS.stream_ops.read,\n              write: MEMFS.stream_ops.write,\n              allocate: MEMFS.stream_ops.allocate,\n              mmap: MEMFS.stream_ops.mmap,\n              msync: MEMFS.stream_ops.msync,\n            },\n          },\n          link: {\n            node: {\n              getattr: MEMFS.node_ops.getattr,\n              setattr: MEMFS.node_ops.setattr,\n              readlink: MEMFS.node_ops.readlink,\n            },\n            stream: {},\n          },\n          chrdev: {\n            node: {\n              getattr: MEMFS.node_ops.getattr,\n              setattr: MEMFS.node_ops.setattr,\n            },\n            stream: FS.chrdev_stream_ops,\n          },\n        };\n        var node = FS.createNode(parent, name, mode, dev);\n        if (FS.isDir(node.mode)) {\n          node.node_ops = MEMFS.ops_table.dir.node;\n          node.stream_ops = MEMFS.ops_table.dir.stream;\n          node.contents = {};\n        } else if (FS.isFile(node.mode)) {\n          node.node_ops = MEMFS.ops_table.file.node;\n          node.stream_ops = MEMFS.ops_table.file.stream;\n          node.usedBytes = 0; // The actual number of bytes used in the typed array, as opposed to contents.length which gives the whole capacity.\n          // When the byte data of the file is populated, this will point to either a typed array, or a normal JS array. Typed arrays are preferred\n          // for performance, and used by default. However, typed arrays are not resizable like normal JS arrays are, so there is a small disk size\n          // penalty involved for appending file writes that continuously grow a file similar to std::vector capacity vs used -scheme.\n          node.contents = null;\n        } else if (FS.isLink(node.mode)) {\n          node.node_ops = MEMFS.ops_table.link.node;\n          node.stream_ops = MEMFS.ops_table.link.stream;\n        } else if (FS.isChrdev(node.mode)) {\n          node.node_ops = MEMFS.ops_table.chrdev.node;\n          node.stream_ops = MEMFS.ops_table.chrdev.stream;\n        }\n        node.timestamp = Date.now();\n        // add the new node to the parent\n        if (parent) {\n          parent.contents[name] = node;\n          parent.timestamp = node.timestamp;\n        }\n        return node;\n      },\n      getFileDataAsTypedArray(node) {\n        if (!node.contents) return new Uint8Array(0);\n        if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes); // Make sure to not return excess unused bytes.\n        return new Uint8Array(node.contents);\n      },\n      expandFileStorage(node, newCapacity) {\n        var prevCapacity = node.contents ? node.contents.length : 0;\n        if (prevCapacity >= newCapacity) return; // No need to expand, the storage was already large enough.\n        // Don't expand strictly to the given requested limit if it's only a very small increase, but instead geometrically grow capacity.\n        // For small filesizes (<1MB), perform size*2 geometric increase, but for large sizes, do a much more conservative size*1.125 increase to\n        // avoid overshooting the allocation cap by a very large margin.\n        var CAPACITY_DOUBLING_MAX = 1024 * 1024;\n        newCapacity = Math.max(\n          newCapacity,\n          (prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2.0 : 1.125)) >>> 0,\n        );\n        if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256); // At minimum allocate 256b for each file when expanding.\n        var oldContents = node.contents;\n        node.contents = new Uint8Array(newCapacity); // Allocate new storage.\n        if (node.usedBytes > 0) node.contents.set(oldContents.subarray(0, node.usedBytes), 0); // Copy old data over to the new storage.\n      },\n      resizeFileStorage(node, newSize) {\n        if (node.usedBytes == newSize) return;\n        if (newSize == 0) {\n          node.contents = null; // Fully decommit when requesting a resize to zero.\n          node.usedBytes = 0;\n        } else {\n          var oldContents = node.contents;\n          node.contents = new Uint8Array(newSize); // Allocate new storage.\n          if (oldContents) {\n            node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes))); // Copy old data over to the new storage.\n          }\n          node.usedBytes = newSize;\n        }\n      },\n      node_ops: {\n        getattr(node) {\n          var attr = {};\n          // device numbers reuse inode numbers.\n          attr.dev = FS.isChrdev(node.mode) ? node.id : 1;\n          attr.ino = node.id;\n          attr.mode = node.mode;\n          attr.nlink = 1;\n          attr.uid = 0;\n          attr.gid = 0;\n          attr.rdev = node.rdev;\n          if (FS.isDir(node.mode)) {\n            attr.size = 4096;\n          } else if (FS.isFile(node.mode)) {\n            attr.size = node.usedBytes;\n          } else if (FS.isLink(node.mode)) {\n            attr.size = node.link.length;\n          } else {\n            attr.size = 0;\n          }\n          attr.atime = new Date(node.timestamp);\n          attr.mtime = new Date(node.timestamp);\n          attr.ctime = new Date(node.timestamp);\n          // NOTE: In our implementation, st_blocks = Math.ceil(st_size/st_blksize),\n          //       but this is not required by the standard.\n          attr.blksize = 4096;\n          attr.blocks = Math.ceil(attr.size / attr.blksize);\n          return attr;\n        },\n        setattr(node, attr) {\n          if (attr.mode !== undefined) {\n            node.mode = attr.mode;\n          }\n          if (attr.timestamp !== undefined) {\n            node.timestamp = attr.timestamp;\n          }\n          if (attr.size !== undefined) {\n            MEMFS.resizeFileStorage(node, attr.size);\n          }\n        },\n        lookup(parent, name) {\n          throw FS.genericErrors[44];\n        },\n        mknod(parent, name, mode, dev) {\n          return MEMFS.createNode(parent, name, mode, dev);\n        },\n        rename(old_node, new_dir, new_name) {\n          // if we're overwriting a directory at new_name, make sure it's empty.\n          if (FS.isDir(old_node.mode)) {\n            var new_node;\n            try {\n              new_node = FS.lookupNode(new_dir, new_name);\n            } catch (e) {}\n            if (new_node) {\n              for (var i in new_node.contents) {\n                throw new FS.ErrnoError(55);\n              }\n            }\n          }\n          // do the internal rewiring\n          delete old_node.parent.contents[old_node.name];\n          old_node.parent.timestamp = Date.now();\n          old_node.name = new_name;\n          new_dir.contents[new_name] = old_node;\n          new_dir.timestamp = old_node.parent.timestamp;\n        },\n        unlink(parent, name) {\n          delete parent.contents[name];\n          parent.timestamp = Date.now();\n        },\n        rmdir(parent, name) {\n          var node = FS.lookupNode(parent, name);\n          for (var i in node.contents) {\n            throw new FS.ErrnoError(55);\n          }\n          delete parent.contents[name];\n          parent.timestamp = Date.now();\n        },\n        readdir(node) {\n          var entries = ['.', '..'];\n          for (var key of Object.keys(node.contents)) {\n            entries.push(key);\n          }\n          return entries;\n        },\n        symlink(parent, newname, oldpath) {\n          var node = MEMFS.createNode(parent, newname, 511 /* 0777 */ | 40960, 0);\n          node.link = oldpath;\n          return node;\n        },\n        readlink(node) {\n          if (!FS.isLink(node.mode)) {\n            throw new FS.ErrnoError(28);\n          }\n          return node.link;\n        },\n      },\n      stream_ops: {\n        read(stream, buffer, offset, length, position) {\n          var contents = stream.node.contents;\n          if (position >= stream.node.usedBytes) return 0;\n          var size = Math.min(stream.node.usedBytes - position, length);\n          assert(size >= 0);\n          if (size > 8 && contents.subarray) {\n            // non-trivial, and typed array\n            buffer.set(contents.subarray(position, position + size), offset);\n          } else {\n            for (var i = 0; i < size; i++) buffer[offset + i] = contents[position + i];\n          }\n          return size;\n        },\n        write(stream, buffer, offset, length, position, canOwn) {\n          // The data buffer should be a typed array view\n          assert(!(buffer instanceof ArrayBuffer));\n          // If the buffer is located in main memory (HEAP), and if\n          // memory can grow, we can't hold on to references of the\n          // memory buffer, as they may get invalidated. That means we\n          // need to do copy its contents.\n          if (buffer.buffer === HEAP8.buffer) {\n            canOwn = false;\n          }\n\n          if (!length) return 0;\n          var node = stream.node;\n          node.timestamp = Date.now();\n\n          if (buffer.subarray && (!node.contents || node.contents.subarray)) {\n            // This write is from a typed array to a typed array?\n            if (canOwn) {\n              assert(position === 0, 'canOwn must imply no weird position inside the file');\n              node.contents = buffer.subarray(offset, offset + length);\n              node.usedBytes = length;\n              return length;\n            } else if (node.usedBytes === 0 && position === 0) {\n              // If this is a simple first write to an empty file, do a fast set since we don't need to care about old data.\n              node.contents = buffer.slice(offset, offset + length);\n              node.usedBytes = length;\n              return length;\n            } else if (position + length <= node.usedBytes) {\n              // Writing to an already allocated and used subrange of the file?\n              node.contents.set(buffer.subarray(offset, offset + length), position);\n              return length;\n            }\n          }\n\n          // Appending to an existing file and we need to reallocate, or source data did not come as a typed array.\n          MEMFS.expandFileStorage(node, position + length);\n          if (node.contents.subarray && buffer.subarray) {\n            // Use typed array write which is available.\n            node.contents.set(buffer.subarray(offset, offset + length), position);\n          } else {\n            for (var i = 0; i < length; i++) {\n              node.contents[position + i] = buffer[offset + i]; // Or fall back to manual write if not.\n            }\n          }\n          node.usedBytes = Math.max(node.usedBytes, position + length);\n          return length;\n        },\n        llseek(stream, offset, whence) {\n          var position = offset;\n          if (whence === 1) {\n            position += stream.position;\n          } else if (whence === 2) {\n            if (FS.isFile(stream.node.mode)) {\n              position += stream.node.usedBytes;\n            }\n          }\n          if (position < 0) {\n            throw new FS.ErrnoError(28);\n          }\n          return position;\n        },\n        allocate(stream, offset, length) {\n          MEMFS.expandFileStorage(stream.node, offset + length);\n          stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);\n        },\n        mmap(stream, length, position, prot, flags) {\n          if (!FS.isFile(stream.node.mode)) {\n            throw new FS.ErrnoError(43);\n          }\n          var ptr;\n          var allocated;\n          var contents = stream.node.contents;\n          // Only make a new copy when MAP_PRIVATE is specified.\n          if (!(flags & 2) && contents && contents.buffer === HEAP8.buffer) {\n            // We can't emulate MAP_SHARED when the file is not backed by the\n            // buffer we're mapping to (e.g. the HEAP buffer).\n            allocated = false;\n            ptr = contents.byteOffset;\n          } else {\n            allocated = true;\n            ptr = mmapAlloc(length);\n            if (!ptr) {\n              throw new FS.ErrnoError(48);\n            }\n            if (contents) {\n              // Try to avoid unnecessary slices.\n              if (position > 0 || position + length < contents.length) {\n                if (contents.subarray) {\n                  contents = contents.subarray(position, position + length);\n                } else {\n                  contents = Array.prototype.slice.call(contents, position, position + length);\n                }\n              }\n              HEAP8.set(contents, ptr);\n            }\n          }\n          return { ptr, allocated };\n        },\n        msync(stream, buffer, offset, length, mmapFlags) {\n          MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);\n          // should we check if bytesWritten and length are the same?\n          return 0;\n        },\n      },\n    };\n\n    /** @param {boolean=} noRunDep */\n    var asyncLoad = (url, onload, onerror, noRunDep) => {\n      var dep = !noRunDep ? getUniqueRunDependency(`al ${url}`) : '';\n      readAsync(url).then(\n        (arrayBuffer) => {\n          assert(arrayBuffer, `Loading data file \"${url}\" failed (no arrayBuffer).`);\n          onload(new Uint8Array(arrayBuffer));\n          if (dep) removeRunDependency(dep);\n        },\n        (err) => {\n          if (onerror) {\n            onerror();\n          } else {\n            throw `Loading data file \"${url}\" failed.`;\n          }\n        },\n      );\n      if (dep) addRunDependency(dep);\n    };\n\n    var FS_createDataFile = (parent, name, fileData, canRead, canWrite, canOwn) => {\n      FS.createDataFile(parent, name, fileData, canRead, canWrite, canOwn);\n    };\n\n    var preloadPlugins = Module['preloadPlugins'] || [];\n    var FS_handledByPreloadPlugin = (byteArray, fullname, finish, onerror) => {\n      // Ensure plugins are ready.\n      if (typeof Browser != 'undefined') Browser.init();\n\n      var handled = false;\n      preloadPlugins.forEach((plugin) => {\n        if (handled) return;\n        if (plugin['canHandle'](fullname)) {\n          plugin['handle'](byteArray, fullname, finish, onerror);\n          handled = true;\n        }\n      });\n      return handled;\n    };\n    var FS_createPreloadedFile = (\n      parent,\n      name,\n      url,\n      canRead,\n      canWrite,\n      onload,\n      onerror,\n      dontCreateFile,\n      canOwn,\n      preFinish,\n    ) => {\n      // TODO we should allow people to just pass in a complete filename instead\n      // of parent and name being that we just join them anyways\n      var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;\n      var dep = getUniqueRunDependency(`cp ${fullname}`); // might have several active requests for the same fullname\n      function processData(byteArray) {\n        function finish(byteArray) {\n          preFinish?.();\n          if (!dontCreateFile) {\n            FS_createDataFile(parent, name, byteArray, canRead, canWrite, canOwn);\n          }\n          onload?.();\n          removeRunDependency(dep);\n        }\n        if (\n          FS_handledByPreloadPlugin(byteArray, fullname, finish, () => {\n            onerror?.();\n            removeRunDependency(dep);\n          })\n        ) {\n          return;\n        }\n        finish(byteArray);\n      }\n      addRunDependency(dep);\n      if (typeof url == 'string') {\n        asyncLoad(url, processData, onerror);\n      } else {\n        processData(url);\n      }\n    };\n\n    var FS_modeStringToFlags = (str) => {\n      var flagModes = {\n        r: 0,\n        'r+': 2,\n        w: 512 | 64 | 1,\n        'w+': 512 | 64 | 2,\n        a: 1024 | 64 | 1,\n        'a+': 1024 | 64 | 2,\n      };\n      var flags = flagModes[str];\n      if (typeof flags == 'undefined') {\n        throw new Error(`Unknown file open mode: ${str}`);\n      }\n      return flags;\n    };\n\n    var FS_getMode = (canRead, canWrite) => {\n      var mode = 0;\n      if (canRead) mode |= 292 | 73;\n      if (canWrite) mode |= 146;\n      return mode;\n    };\n\n    var strError = (errno) => {\n      return UTF8ToString(_strerror(errno));\n    };\n\n    var ERRNO_CODES = {\n      EPERM: 63,\n      ENOENT: 44,\n      ESRCH: 71,\n      EINTR: 27,\n      EIO: 29,\n      ENXIO: 60,\n      E2BIG: 1,\n      ENOEXEC: 45,\n      EBADF: 8,\n      ECHILD: 12,\n      EAGAIN: 6,\n      EWOULDBLOCK: 6,\n      ENOMEM: 48,\n      EACCES: 2,\n      EFAULT: 21,\n      ENOTBLK: 105,\n      EBUSY: 10,\n      EEXIST: 20,\n      EXDEV: 75,\n      ENODEV: 43,\n      ENOTDIR: 54,\n      EISDIR: 31,\n      EINVAL: 28,\n      ENFILE: 41,\n      EMFILE: 33,\n      ENOTTY: 59,\n      ETXTBSY: 74,\n      EFBIG: 22,\n      ENOSPC: 51,\n      ESPIPE: 70,\n      EROFS: 69,\n      EMLINK: 34,\n      EPIPE: 64,\n      EDOM: 18,\n      ERANGE: 68,\n      ENOMSG: 49,\n      EIDRM: 24,\n      ECHRNG: 106,\n      EL2NSYNC: 156,\n      EL3HLT: 107,\n      EL3RST: 108,\n      ELNRNG: 109,\n      EUNATCH: 110,\n      ENOCSI: 111,\n      EL2HLT: 112,\n      EDEADLK: 16,\n      ENOLCK: 46,\n      EBADE: 113,\n      EBADR: 114,\n      EXFULL: 115,\n      ENOANO: 104,\n      EBADRQC: 103,\n      EBADSLT: 102,\n      EDEADLOCK: 16,\n      EBFONT: 101,\n      ENOSTR: 100,\n      ENODATA: 116,\n      ETIME: 117,\n      ENOSR: 118,\n      ENONET: 119,\n      ENOPKG: 120,\n      EREMOTE: 121,\n      ENOLINK: 47,\n      EADV: 122,\n      ESRMNT: 123,\n      ECOMM: 124,\n      EPROTO: 65,\n      EMULTIHOP: 36,\n      EDOTDOT: 125,\n      EBADMSG: 9,\n      ENOTUNIQ: 126,\n      EBADFD: 127,\n      EREMCHG: 128,\n      ELIBACC: 129,\n      ELIBBAD: 130,\n      ELIBSCN: 131,\n      ELIBMAX: 132,\n      ELIBEXEC: 133,\n      ENOSYS: 52,\n      ENOTEMPTY: 55,\n      ENAMETOOLONG: 37,\n      ELOOP: 32,\n      EOPNOTSUPP: 138,\n      EPFNOSUPPORT: 139,\n      ECONNRESET: 15,\n      ENOBUFS: 42,\n      EAFNOSUPPORT: 5,\n      EPROTOTYPE: 67,\n      ENOTSOCK: 57,\n      ENOPROTOOPT: 50,\n      ESHUTDOWN: 140,\n      ECONNREFUSED: 14,\n      EADDRINUSE: 3,\n      ECONNABORTED: 13,\n      ENETUNREACH: 40,\n      ENETDOWN: 38,\n      ETIMEDOUT: 73,\n      EHOSTDOWN: 142,\n      EHOSTUNREACH: 23,\n      EINPROGRESS: 26,\n      EALREADY: 7,\n      EDESTADDRREQ: 17,\n      EMSGSIZE: 35,\n      EPROTONOSUPPORT: 66,\n      ESOCKTNOSUPPORT: 137,\n      EADDRNOTAVAIL: 4,\n      ENETRESET: 39,\n      EISCONN: 30,\n      ENOTCONN: 53,\n      ETOOMANYREFS: 141,\n      EUSERS: 136,\n      EDQUOT: 19,\n      ESTALE: 72,\n      ENOTSUP: 138,\n      ENOMEDIUM: 148,\n      EILSEQ: 25,\n      EOVERFLOW: 61,\n      ECANCELED: 11,\n      ENOTRECOVERABLE: 56,\n      EOWNERDEAD: 62,\n      ESTRPIPE: 135,\n    };\n    var FS = {\n      root: null,\n      mounts: [],\n      devices: {},\n      streams: [],\n      nextInode: 1,\n      nameTable: null,\n      currentPath: '/',\n      initialized: false,\n      ignorePermissions: true,\n      ErrnoError: class extends Error {\n        // We set the `name` property to be able to identify `FS.ErrnoError`\n        // - the `name` is a standard ECMA-262 property of error objects. Kind of good to have it anyway.\n        // - when using PROXYFS, an error can come from an underlying FS\n        // as different FS objects have their own FS.ErrnoError each,\n        // the test `err instanceof FS.ErrnoError` won't detect an error coming from another filesystem, causing bugs.\n        // we'll use the reliable test `err.name == \"ErrnoError\"` instead\n        constructor(errno) {\n          super(runtimeInitialized ? strError(errno) : '');\n          // TODO(sbc): Use the inline member declaration syntax once we\n          // support it in acorn and closure.\n          this.name = 'ErrnoError';\n          this.errno = errno;\n          for (var key in ERRNO_CODES) {\n            if (ERRNO_CODES[key] === errno) {\n              this.code = key;\n              break;\n            }\n          }\n        }\n      },\n      genericErrors: {},\n      filesystems: null,\n      syncFSRequests: 0,\n      readFiles: {},\n      FSStream: class {\n        constructor() {\n          // TODO(https://github.com/emscripten-core/emscripten/issues/21414):\n          // Use inline field declarations.\n          this.shared = {};\n        }\n        get object() {\n          return this.node;\n        }\n        set object(val) {\n          this.node = val;\n        }\n        get isRead() {\n          return (this.flags & 2097155) !== 1;\n        }\n        get isWrite() {\n          return (this.flags & 2097155) !== 0;\n        }\n        get isAppend() {\n          return this.flags & 1024;\n        }\n        get flags() {\n          return this.shared.flags;\n        }\n        set flags(val) {\n          this.shared.flags = val;\n        }\n        get position() {\n          return this.shared.position;\n        }\n        set position(val) {\n          this.shared.position = val;\n        }\n      },\n      FSNode: class {\n        constructor(parent, name, mode, rdev) {\n          if (!parent) {\n            parent = this; // root node sets parent to itself\n          }\n          this.parent = parent;\n          this.mount = parent.mount;\n          this.mounted = null;\n          this.id = FS.nextInode++;\n          this.name = name;\n          this.mode = mode;\n          this.node_ops = {};\n          this.stream_ops = {};\n          this.rdev = rdev;\n          this.readMode = 292 | 73;\n          this.writeMode = 146;\n        }\n        get read() {\n          return (this.mode & this.readMode) === this.readMode;\n        }\n        set read(val) {\n          val ? (this.mode |= this.readMode) : (this.mode &= ~this.readMode);\n        }\n        get write() {\n          return (this.mode & this.writeMode) === this.writeMode;\n        }\n        set write(val) {\n          val ? (this.mode |= this.writeMode) : (this.mode &= ~this.writeMode);\n        }\n        get isFolder() {\n          return FS.isDir(this.mode);\n        }\n        get isDevice() {\n          return FS.isChrdev(this.mode);\n        }\n      },\n      lookupPath(path, opts = {}) {\n        path = PATH_FS.resolve(path);\n\n        if (!path) return { path: '', node: null };\n\n        var defaults = {\n          follow_mount: true,\n          recurse_count: 0,\n        };\n        opts = Object.assign(defaults, opts);\n\n        if (opts.recurse_count > 8) {\n          // max recursive lookup of 8\n          throw new FS.ErrnoError(32);\n        }\n\n        // split the absolute path\n        var parts = path.split('/').filter((p) => !!p);\n\n        // start at the root\n        var current = FS.root;\n        var current_path = '/';\n\n        for (var i = 0; i < parts.length; i++) {\n          var islast = i === parts.length - 1;\n          if (islast && opts.parent) {\n            // stop resolving\n            break;\n          }\n\n          current = FS.lookupNode(current, parts[i]);\n          current_path = PATH.join2(current_path, parts[i]);\n\n          // jump to the mount's root node if this is a mountpoint\n          if (FS.isMountpoint(current)) {\n            if (!islast || (islast && opts.follow_mount)) {\n              current = current.mounted.root;\n            }\n          }\n\n          // by default, lookupPath will not follow a symlink if it is the final path component.\n          // setting opts.follow = true will override this behavior.\n          if (!islast || opts.follow) {\n            var count = 0;\n            while (FS.isLink(current.mode)) {\n              var link = FS.readlink(current_path);\n              current_path = PATH_FS.resolve(PATH.dirname(current_path), link);\n\n              var lookup = FS.lookupPath(current_path, { recurse_count: opts.recurse_count + 1 });\n              current = lookup.node;\n\n              if (count++ > 40) {\n                // limit max consecutive symlinks to 40 (SYMLOOP_MAX).\n                throw new FS.ErrnoError(32);\n              }\n            }\n          }\n        }\n\n        return { path: current_path, node: current };\n      },\n      getPath(node) {\n        var path;\n        while (true) {\n          if (FS.isRoot(node)) {\n            var mount = node.mount.mountpoint;\n            if (!path) return mount;\n            return mount[mount.length - 1] !== '/' ? `${mount}/${path}` : mount + path;\n          }\n          path = path ? `${node.name}/${path}` : node.name;\n          node = node.parent;\n        }\n      },\n      hashName(parentid, name) {\n        var hash = 0;\n\n        for (var i = 0; i < name.length; i++) {\n          hash = ((hash << 5) - hash + name.charCodeAt(i)) | 0;\n        }\n        return ((parentid + hash) >>> 0) % FS.nameTable.length;\n      },\n      hashAddNode(node) {\n        var hash = FS.hashName(node.parent.id, node.name);\n        node.name_next = FS.nameTable[hash];\n        FS.nameTable[hash] = node;\n      },\n      hashRemoveNode(node) {\n        var hash = FS.hashName(node.parent.id, node.name);\n        if (FS.nameTable[hash] === node) {\n          FS.nameTable[hash] = node.name_next;\n        } else {\n          var current = FS.nameTable[hash];\n          while (current) {\n            if (current.name_next === node) {\n              current.name_next = node.name_next;\n              break;\n            }\n            current = current.name_next;\n          }\n        }\n      },\n      lookupNode(parent, name) {\n        var errCode = FS.mayLookup(parent);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        var hash = FS.hashName(parent.id, name);\n        for (var node = FS.nameTable[hash]; node; node = node.name_next) {\n          var nodeName = node.name;\n          if (node.parent.id === parent.id && nodeName === name) {\n            return node;\n          }\n        }\n        // if we failed to find it in the cache, call into the VFS\n        return FS.lookup(parent, name);\n      },\n      createNode(parent, name, mode, rdev) {\n        assert(typeof parent == 'object');\n        var node = new FS.FSNode(parent, name, mode, rdev);\n\n        FS.hashAddNode(node);\n\n        return node;\n      },\n      destroyNode(node) {\n        FS.hashRemoveNode(node);\n      },\n      isRoot(node) {\n        return node === node.parent;\n      },\n      isMountpoint(node) {\n        return !!node.mounted;\n      },\n      isFile(mode) {\n        return (mode & 61440) === 32768;\n      },\n      isDir(mode) {\n        return (mode & 61440) === 16384;\n      },\n      isLink(mode) {\n        return (mode & 61440) === 40960;\n      },\n      isChrdev(mode) {\n        return (mode & 61440) === 8192;\n      },\n      isBlkdev(mode) {\n        return (mode & 61440) === 24576;\n      },\n      isFIFO(mode) {\n        return (mode & 61440) === 4096;\n      },\n      isSocket(mode) {\n        return (mode & 49152) === 49152;\n      },\n      flagsToPermissionString(flag) {\n        var perms = ['r', 'w', 'rw'][flag & 3];\n        if (flag & 512) {\n          perms += 'w';\n        }\n        return perms;\n      },\n      nodePermissions(node, perms) {\n        if (FS.ignorePermissions) {\n          return 0;\n        }\n        // return 0 if any user, group or owner bits are set.\n        if (perms.includes('r') && !(node.mode & 292)) {\n          return 2;\n        } else if (perms.includes('w') && !(node.mode & 146)) {\n          return 2;\n        } else if (perms.includes('x') && !(node.mode & 73)) {\n          return 2;\n        }\n        return 0;\n      },\n      mayLookup(dir) {\n        if (!FS.isDir(dir.mode)) return 54;\n        var errCode = FS.nodePermissions(dir, 'x');\n        if (errCode) return errCode;\n        if (!dir.node_ops.lookup) return 2;\n        return 0;\n      },\n      mayCreate(dir, name) {\n        try {\n          var node = FS.lookupNode(dir, name);\n          return 20;\n        } catch (e) {}\n        return FS.nodePermissions(dir, 'wx');\n      },\n      mayDelete(dir, name, isdir) {\n        var node;\n        try {\n          node = FS.lookupNode(dir, name);\n        } catch (e) {\n          return e.errno;\n        }\n        var errCode = FS.nodePermissions(dir, 'wx');\n        if (errCode) {\n          return errCode;\n        }\n        if (isdir) {\n          if (!FS.isDir(node.mode)) {\n            return 54;\n          }\n          if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {\n            return 10;\n          }\n        } else {\n          if (FS.isDir(node.mode)) {\n            return 31;\n          }\n        }\n        return 0;\n      },\n      mayOpen(node, flags) {\n        if (!node) {\n          return 44;\n        }\n        if (FS.isLink(node.mode)) {\n          return 32;\n        } else if (FS.isDir(node.mode)) {\n          if (\n            FS.flagsToPermissionString(flags) !== 'r' || // opening for write\n            flags & 512\n          ) {\n            // TODO: check for O_SEARCH? (== search for dir only)\n            return 31;\n          }\n        }\n        return FS.nodePermissions(node, FS.flagsToPermissionString(flags));\n      },\n      MAX_OPEN_FDS: 4096,\n      nextfd() {\n        for (var fd = 0; fd <= FS.MAX_OPEN_FDS; fd++) {\n          if (!FS.streams[fd]) {\n            return fd;\n          }\n        }\n        throw new FS.ErrnoError(33);\n      },\n      getStreamChecked(fd) {\n        var stream = FS.getStream(fd);\n        if (!stream) {\n          throw new FS.ErrnoError(8);\n        }\n        return stream;\n      },\n      getStream: (fd) => FS.streams[fd],\n      createStream(stream, fd = -1) {\n        assert(fd >= -1);\n\n        // clone it, so we can return an instance of FSStream\n        stream = Object.assign(new FS.FSStream(), stream);\n        if (fd == -1) {\n          fd = FS.nextfd();\n        }\n        stream.fd = fd;\n        FS.streams[fd] = stream;\n        return stream;\n      },\n      closeStream(fd) {\n        FS.streams[fd] = null;\n      },\n      dupStream(origStream, fd = -1) {\n        var stream = FS.createStream(origStream, fd);\n        stream.stream_ops?.dup?.(stream);\n        return stream;\n      },\n      chrdev_stream_ops: {\n        open(stream) {\n          var device = FS.getDevice(stream.node.rdev);\n          // override node's stream ops with the device's\n          stream.stream_ops = device.stream_ops;\n          // forward the open call\n          stream.stream_ops.open?.(stream);\n        },\n        llseek() {\n          throw new FS.ErrnoError(70);\n        },\n      },\n      major: (dev) => dev >> 8,\n      minor: (dev) => dev & 0xff,\n      makedev: (ma, mi) => (ma << 8) | mi,\n      registerDevice(dev, ops) {\n        FS.devices[dev] = { stream_ops: ops };\n      },\n      getDevice: (dev) => FS.devices[dev],\n      getMounts(mount) {\n        var mounts = [];\n        var check = [mount];\n\n        while (check.length) {\n          var m = check.pop();\n\n          mounts.push(m);\n\n          check.push(...m.mounts);\n        }\n\n        return mounts;\n      },\n      syncfs(populate, callback) {\n        if (typeof populate == 'function') {\n          callback = populate;\n          populate = false;\n        }\n\n        FS.syncFSRequests++;\n\n        if (FS.syncFSRequests > 1) {\n          err(\n            `warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`,\n          );\n        }\n\n        var mounts = FS.getMounts(FS.root.mount);\n        var completed = 0;\n\n        function doCallback(errCode) {\n          assert(FS.syncFSRequests > 0);\n          FS.syncFSRequests--;\n          return callback(errCode);\n        }\n\n        function done(errCode) {\n          if (errCode) {\n            if (!done.errored) {\n              done.errored = true;\n              return doCallback(errCode);\n            }\n            return;\n          }\n          if (++completed >= mounts.length) {\n            doCallback(null);\n          }\n        }\n\n        // sync all mounts\n        mounts.forEach((mount) => {\n          if (!mount.type.syncfs) {\n            return done(null);\n          }\n          mount.type.syncfs(mount, populate, done);\n        });\n      },\n      mount(type, opts, mountpoint) {\n        if (typeof type == 'string') {\n          // The filesystem was not included, and instead we have an error\n          // message stored in the variable.\n          throw type;\n        }\n        var root = mountpoint === '/';\n        var pseudo = !mountpoint;\n        var node;\n\n        if (root && FS.root) {\n          throw new FS.ErrnoError(10);\n        } else if (!root && !pseudo) {\n          var lookup = FS.lookupPath(mountpoint, { follow_mount: false });\n\n          mountpoint = lookup.path; // use the absolute path\n          node = lookup.node;\n\n          if (FS.isMountpoint(node)) {\n            throw new FS.ErrnoError(10);\n          }\n\n          if (!FS.isDir(node.mode)) {\n            throw new FS.ErrnoError(54);\n          }\n        }\n\n        var mount = {\n          type,\n          opts,\n          mountpoint,\n          mounts: [],\n        };\n\n        // create a root node for the fs\n        var mountRoot = type.mount(mount);\n        mountRoot.mount = mount;\n        mount.root = mountRoot;\n\n        if (root) {\n          FS.root = mountRoot;\n        } else if (node) {\n          // set as a mountpoint\n          node.mounted = mount;\n\n          // add the new mount to the current mount's children\n          if (node.mount) {\n            node.mount.mounts.push(mount);\n          }\n        }\n\n        return mountRoot;\n      },\n      unmount(mountpoint) {\n        var lookup = FS.lookupPath(mountpoint, { follow_mount: false });\n\n        if (!FS.isMountpoint(lookup.node)) {\n          throw new FS.ErrnoError(28);\n        }\n\n        // destroy the nodes for this mount, and all its child mounts\n        var node = lookup.node;\n        var mount = node.mounted;\n        var mounts = FS.getMounts(mount);\n\n        Object.keys(FS.nameTable).forEach((hash) => {\n          var current = FS.nameTable[hash];\n\n          while (current) {\n            var next = current.name_next;\n\n            if (mounts.includes(current.mount)) {\n              FS.destroyNode(current);\n            }\n\n            current = next;\n          }\n        });\n\n        // no longer a mountpoint\n        node.mounted = null;\n\n        // remove this mount from the child mounts\n        var idx = node.mount.mounts.indexOf(mount);\n        assert(idx !== -1);\n        node.mount.mounts.splice(idx, 1);\n      },\n      lookup(parent, name) {\n        return parent.node_ops.lookup(parent, name);\n      },\n      mknod(path, mode, dev) {\n        var lookup = FS.lookupPath(path, { parent: true });\n        var parent = lookup.node;\n        var name = PATH.basename(path);\n        if (!name || name === '.' || name === '..') {\n          throw new FS.ErrnoError(28);\n        }\n        var errCode = FS.mayCreate(parent, name);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        if (!parent.node_ops.mknod) {\n          throw new FS.ErrnoError(63);\n        }\n        return parent.node_ops.mknod(parent, name, mode, dev);\n      },\n      create(path, mode) {\n        mode = mode !== undefined ? mode : 438 /* 0666 */;\n        mode &= 4095;\n        mode |= 32768;\n        return FS.mknod(path, mode, 0);\n      },\n      mkdir(path, mode) {\n        mode = mode !== undefined ? mode : 511 /* 0777 */;\n        mode &= 511 | 512;\n        mode |= 16384;\n        return FS.mknod(path, mode, 0);\n      },\n      mkdirTree(path, mode) {\n        var dirs = path.split('/');\n        var d = '';\n        for (var i = 0; i < dirs.length; ++i) {\n          if (!dirs[i]) continue;\n          d += '/' + dirs[i];\n          try {\n            FS.mkdir(d, mode);\n          } catch (e) {\n            if (e.errno != 20) throw e;\n          }\n        }\n      },\n      mkdev(path, mode, dev) {\n        if (typeof dev == 'undefined') {\n          dev = mode;\n          mode = 438 /* 0666 */;\n        }\n        mode |= 8192;\n        return FS.mknod(path, mode, dev);\n      },\n      symlink(oldpath, newpath) {\n        if (!PATH_FS.resolve(oldpath)) {\n          throw new FS.ErrnoError(44);\n        }\n        var lookup = FS.lookupPath(newpath, { parent: true });\n        var parent = lookup.node;\n        if (!parent) {\n          throw new FS.ErrnoError(44);\n        }\n        var newname = PATH.basename(newpath);\n        var errCode = FS.mayCreate(parent, newname);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        if (!parent.node_ops.symlink) {\n          throw new FS.ErrnoError(63);\n        }\n        return parent.node_ops.symlink(parent, newname, oldpath);\n      },\n      rename(old_path, new_path) {\n        var old_dirname = PATH.dirname(old_path);\n        var new_dirname = PATH.dirname(new_path);\n        var old_name = PATH.basename(old_path);\n        var new_name = PATH.basename(new_path);\n        // parents must exist\n        var lookup, old_dir, new_dir;\n\n        // let the errors from non existent directories percolate up\n        lookup = FS.lookupPath(old_path, { parent: true });\n        old_dir = lookup.node;\n        lookup = FS.lookupPath(new_path, { parent: true });\n        new_dir = lookup.node;\n\n        if (!old_dir || !new_dir) throw new FS.ErrnoError(44);\n        // need to be part of the same mount\n        if (old_dir.mount !== new_dir.mount) {\n          throw new FS.ErrnoError(75);\n        }\n        // source must exist\n        var old_node = FS.lookupNode(old_dir, old_name);\n        // old path should not be an ancestor of the new path\n        var relative = PATH_FS.relative(old_path, new_dirname);\n        if (relative.charAt(0) !== '.') {\n          throw new FS.ErrnoError(28);\n        }\n        // new path should not be an ancestor of the old path\n        relative = PATH_FS.relative(new_path, old_dirname);\n        if (relative.charAt(0) !== '.') {\n          throw new FS.ErrnoError(55);\n        }\n        // see if the new path already exists\n        var new_node;\n        try {\n          new_node = FS.lookupNode(new_dir, new_name);\n        } catch (e) {\n          // not fatal\n        }\n        // early out if nothing needs to change\n        if (old_node === new_node) {\n          return;\n        }\n        // we'll need to delete the old entry\n        var isdir = FS.isDir(old_node.mode);\n        var errCode = FS.mayDelete(old_dir, old_name, isdir);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        // need delete permissions if we'll be overwriting.\n        // need create permissions if new doesn't already exist.\n        errCode = new_node\n          ? FS.mayDelete(new_dir, new_name, isdir)\n          : FS.mayCreate(new_dir, new_name);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        if (!old_dir.node_ops.rename) {\n          throw new FS.ErrnoError(63);\n        }\n        if (FS.isMountpoint(old_node) || (new_node && FS.isMountpoint(new_node))) {\n          throw new FS.ErrnoError(10);\n        }\n        // if we are going to change the parent, check write permissions\n        if (new_dir !== old_dir) {\n          errCode = FS.nodePermissions(old_dir, 'w');\n          if (errCode) {\n            throw new FS.ErrnoError(errCode);\n          }\n        }\n        // remove the node from the lookup hash\n        FS.hashRemoveNode(old_node);\n        // do the underlying fs rename\n        try {\n          old_dir.node_ops.rename(old_node, new_dir, new_name);\n          // update old node (we do this here to avoid each backend\n          // needing to)\n          old_node.parent = new_dir;\n        } catch (e) {\n          throw e;\n        } finally {\n          // add the node back to the hash (in case node_ops.rename\n          // changed its name)\n          FS.hashAddNode(old_node);\n        }\n      },\n      rmdir(path) {\n        var lookup = FS.lookupPath(path, { parent: true });\n        var parent = lookup.node;\n        var name = PATH.basename(path);\n        var node = FS.lookupNode(parent, name);\n        var errCode = FS.mayDelete(parent, name, true);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        if (!parent.node_ops.rmdir) {\n          throw new FS.ErrnoError(63);\n        }\n        if (FS.isMountpoint(node)) {\n          throw new FS.ErrnoError(10);\n        }\n        parent.node_ops.rmdir(parent, name);\n        FS.destroyNode(node);\n      },\n      readdir(path) {\n        var lookup = FS.lookupPath(path, { follow: true });\n        var node = lookup.node;\n        if (!node.node_ops.readdir) {\n          throw new FS.ErrnoError(54);\n        }\n        return node.node_ops.readdir(node);\n      },\n      unlink(path) {\n        var lookup = FS.lookupPath(path, { parent: true });\n        var parent = lookup.node;\n        if (!parent) {\n          throw new FS.ErrnoError(44);\n        }\n        var name = PATH.basename(path);\n        var node = FS.lookupNode(parent, name);\n        var errCode = FS.mayDelete(parent, name, false);\n        if (errCode) {\n          // According to POSIX, we should map EISDIR to EPERM, but\n          // we instead do what Linux does (and we must, as we use\n          // the musl linux libc).\n          throw new FS.ErrnoError(errCode);\n        }\n        if (!parent.node_ops.unlink) {\n          throw new FS.ErrnoError(63);\n        }\n        if (FS.isMountpoint(node)) {\n          throw new FS.ErrnoError(10);\n        }\n        parent.node_ops.unlink(parent, name);\n        FS.destroyNode(node);\n      },\n      readlink(path) {\n        var lookup = FS.lookupPath(path);\n        var link = lookup.node;\n        if (!link) {\n          throw new FS.ErrnoError(44);\n        }\n        if (!link.node_ops.readlink) {\n          throw new FS.ErrnoError(28);\n        }\n        return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));\n      },\n      stat(path, dontFollow) {\n        var lookup = FS.lookupPath(path, { follow: !dontFollow });\n        var node = lookup.node;\n        if (!node) {\n          throw new FS.ErrnoError(44);\n        }\n        if (!node.node_ops.getattr) {\n          throw new FS.ErrnoError(63);\n        }\n        return node.node_ops.getattr(node);\n      },\n      lstat(path) {\n        return FS.stat(path, true);\n      },\n      chmod(path, mode, dontFollow) {\n        var node;\n        if (typeof path == 'string') {\n          var lookup = FS.lookupPath(path, { follow: !dontFollow });\n          node = lookup.node;\n        } else {\n          node = path;\n        }\n        if (!node.node_ops.setattr) {\n          throw new FS.ErrnoError(63);\n        }\n        node.node_ops.setattr(node, {\n          mode: (mode & 4095) | (node.mode & ~4095),\n          timestamp: Date.now(),\n        });\n      },\n      lchmod(path, mode) {\n        FS.chmod(path, mode, true);\n      },\n      fchmod(fd, mode) {\n        var stream = FS.getStreamChecked(fd);\n        FS.chmod(stream.node, mode);\n      },\n      chown(path, uid, gid, dontFollow) {\n        var node;\n        if (typeof path == 'string') {\n          var lookup = FS.lookupPath(path, { follow: !dontFollow });\n          node = lookup.node;\n        } else {\n          node = path;\n        }\n        if (!node.node_ops.setattr) {\n          throw new FS.ErrnoError(63);\n        }\n        node.node_ops.setattr(node, {\n          timestamp: Date.now(),\n          // we ignore the uid / gid for now\n        });\n      },\n      lchown(path, uid, gid) {\n        FS.chown(path, uid, gid, true);\n      },\n      fchown(fd, uid, gid) {\n        var stream = FS.getStreamChecked(fd);\n        FS.chown(stream.node, uid, gid);\n      },\n      truncate(path, len) {\n        if (len < 0) {\n          throw new FS.ErrnoError(28);\n        }\n        var node;\n        if (typeof path == 'string') {\n          var lookup = FS.lookupPath(path, { follow: true });\n          node = lookup.node;\n        } else {\n          node = path;\n        }\n        if (!node.node_ops.setattr) {\n          throw new FS.ErrnoError(63);\n        }\n        if (FS.isDir(node.mode)) {\n          throw new FS.ErrnoError(31);\n        }\n        if (!FS.isFile(node.mode)) {\n          throw new FS.ErrnoError(28);\n        }\n        var errCode = FS.nodePermissions(node, 'w');\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        node.node_ops.setattr(node, {\n          size: len,\n          timestamp: Date.now(),\n        });\n      },\n      ftruncate(fd, len) {\n        var stream = FS.getStreamChecked(fd);\n        if ((stream.flags & 2097155) === 0) {\n          throw new FS.ErrnoError(28);\n        }\n        FS.truncate(stream.node, len);\n      },\n      utime(path, atime, mtime) {\n        var lookup = FS.lookupPath(path, { follow: true });\n        var node = lookup.node;\n        node.node_ops.setattr(node, {\n          timestamp: Math.max(atime, mtime),\n        });\n      },\n      open(path, flags, mode) {\n        if (path === '') {\n          throw new FS.ErrnoError(44);\n        }\n        flags = typeof flags == 'string' ? FS_modeStringToFlags(flags) : flags;\n        if (flags & 64) {\n          mode = typeof mode == 'undefined' ? 438 /* 0666 */ : mode;\n          mode = (mode & 4095) | 32768;\n        } else {\n          mode = 0;\n        }\n        var node;\n        if (typeof path == 'object') {\n          node = path;\n        } else {\n          path = PATH.normalize(path);\n          try {\n            var lookup = FS.lookupPath(path, {\n              follow: !(flags & 131072),\n            });\n            node = lookup.node;\n          } catch (e) {\n            // ignore\n          }\n        }\n        // perhaps we need to create the node\n        var created = false;\n        if (flags & 64) {\n          if (node) {\n            // if O_CREAT and O_EXCL are set, error out if the node already exists\n            if (flags & 128) {\n              throw new FS.ErrnoError(20);\n            }\n          } else {\n            // node doesn't exist, try to create it\n            node = FS.mknod(path, mode, 0);\n            created = true;\n          }\n        }\n        if (!node) {\n          throw new FS.ErrnoError(44);\n        }\n        // can't truncate a device\n        if (FS.isChrdev(node.mode)) {\n          flags &= ~512;\n        }\n        // if asked only for a directory, then this must be one\n        if (flags & 65536 && !FS.isDir(node.mode)) {\n          throw new FS.ErrnoError(54);\n        }\n        // check permissions, if this is not a file we just created now (it is ok to\n        // create and write to a file with read-only permissions; it is read-only\n        // for later use)\n        if (!created) {\n          var errCode = FS.mayOpen(node, flags);\n          if (errCode) {\n            throw new FS.ErrnoError(errCode);\n          }\n        }\n        // do truncation if necessary\n        if (flags & 512 && !created) {\n          FS.truncate(node, 0);\n        }\n        // we've already handled these, don't pass down to the underlying vfs\n        flags &= ~(128 | 512 | 131072);\n\n        // register the stream with the filesystem\n        var stream = FS.createStream({\n          node,\n          path: FS.getPath(node), // we want the absolute path to the node\n          flags,\n          seekable: true,\n          position: 0,\n          stream_ops: node.stream_ops,\n          // used by the file family libc calls (fopen, fwrite, ferror, etc.)\n          ungotten: [],\n          error: false,\n        });\n        // call the new stream's open function\n        if (stream.stream_ops.open) {\n          stream.stream_ops.open(stream);\n        }\n        if (Module['logReadFiles'] && !(flags & 1)) {\n          if (!(path in FS.readFiles)) {\n            FS.readFiles[path] = 1;\n          }\n        }\n        return stream;\n      },\n      close(stream) {\n        if (FS.isClosed(stream)) {\n          throw new FS.ErrnoError(8);\n        }\n        if (stream.getdents) stream.getdents = null; // free readdir state\n        try {\n          if (stream.stream_ops.close) {\n            stream.stream_ops.close(stream);\n          }\n        } catch (e) {\n          throw e;\n        } finally {\n          FS.closeStream(stream.fd);\n        }\n        stream.fd = null;\n      },\n      isClosed(stream) {\n        return stream.fd === null;\n      },\n      llseek(stream, offset, whence) {\n        if (FS.isClosed(stream)) {\n          throw new FS.ErrnoError(8);\n        }\n        if (!stream.seekable || !stream.stream_ops.llseek) {\n          throw new FS.ErrnoError(70);\n        }\n        if (whence != 0 && whence != 1 && whence != 2) {\n          throw new FS.ErrnoError(28);\n        }\n        stream.position = stream.stream_ops.llseek(stream, offset, whence);\n        stream.ungotten = [];\n        return stream.position;\n      },\n      read(stream, buffer, offset, length, position) {\n        assert(offset >= 0);\n        if (length < 0 || position < 0) {\n          throw new FS.ErrnoError(28);\n        }\n        if (FS.isClosed(stream)) {\n          throw new FS.ErrnoError(8);\n        }\n        if ((stream.flags & 2097155) === 1) {\n          throw new FS.ErrnoError(8);\n        }\n        if (FS.isDir(stream.node.mode)) {\n          throw new FS.ErrnoError(31);\n        }\n        if (!stream.stream_ops.read) {\n          throw new FS.ErrnoError(28);\n        }\n        var seeking = typeof position != 'undefined';\n        if (!seeking) {\n          position = stream.position;\n        } else if (!stream.seekable) {\n          throw new FS.ErrnoError(70);\n        }\n        var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);\n        if (!seeking) stream.position += bytesRead;\n        return bytesRead;\n      },\n      write(stream, buffer, offset, length, position, canOwn) {\n        assert(offset >= 0);\n        if (length < 0 || position < 0) {\n          throw new FS.ErrnoError(28);\n        }\n        if (FS.isClosed(stream)) {\n          throw new FS.ErrnoError(8);\n        }\n        if ((stream.flags & 2097155) === 0) {\n          throw new FS.ErrnoError(8);\n        }\n        if (FS.isDir(stream.node.mode)) {\n          throw new FS.ErrnoError(31);\n        }\n        if (!stream.stream_ops.write) {\n          throw new FS.ErrnoError(28);\n        }\n        if (stream.seekable && stream.flags & 1024) {\n          // seek to the end before writing in append mode\n          FS.llseek(stream, 0, 2);\n        }\n        var seeking = typeof position != 'undefined';\n        if (!seeking) {\n          position = stream.position;\n        } else if (!stream.seekable) {\n          throw new FS.ErrnoError(70);\n        }\n        var bytesWritten = stream.stream_ops.write(\n          stream,\n          buffer,\n          offset,\n          length,\n          position,\n          canOwn,\n        );\n        if (!seeking) stream.position += bytesWritten;\n        return bytesWritten;\n      },\n      allocate(stream, offset, length) {\n        if (FS.isClosed(stream)) {\n          throw new FS.ErrnoError(8);\n        }\n        if (offset < 0 || length <= 0) {\n          throw new FS.ErrnoError(28);\n        }\n        if ((stream.flags & 2097155) === 0) {\n          throw new FS.ErrnoError(8);\n        }\n        if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {\n          throw new FS.ErrnoError(43);\n        }\n        if (!stream.stream_ops.allocate) {\n          throw new FS.ErrnoError(138);\n        }\n        stream.stream_ops.allocate(stream, offset, length);\n      },\n      mmap(stream, length, position, prot, flags) {\n        // User requests writing to file (prot & PROT_WRITE != 0).\n        // Checking if we have permissions to write to the file unless\n        // MAP_PRIVATE flag is set. According to POSIX spec it is possible\n        // to write to file opened in read-only mode with MAP_PRIVATE flag,\n        // as all modifications will be visible only in the memory of\n        // the current process.\n        if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {\n          throw new FS.ErrnoError(2);\n        }\n        if ((stream.flags & 2097155) === 1) {\n          throw new FS.ErrnoError(2);\n        }\n        if (!stream.stream_ops.mmap) {\n          throw new FS.ErrnoError(43);\n        }\n        if (!length) {\n          throw new FS.ErrnoError(28);\n        }\n        return stream.stream_ops.mmap(stream, length, position, prot, flags);\n      },\n      msync(stream, buffer, offset, length, mmapFlags) {\n        assert(offset >= 0);\n        if (!stream.stream_ops.msync) {\n          return 0;\n        }\n        return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);\n      },\n      ioctl(stream, cmd, arg) {\n        if (!stream.stream_ops.ioctl) {\n          throw new FS.ErrnoError(59);\n        }\n        return stream.stream_ops.ioctl(stream, cmd, arg);\n      },\n      readFile(path, opts = {}) {\n        opts.flags = opts.flags || 0;\n        opts.encoding = opts.encoding || 'binary';\n        if (opts.encoding !== 'utf8' && opts.encoding !== 'binary') {\n          throw new Error(`Invalid encoding type \"${opts.encoding}\"`);\n        }\n        var ret;\n        var stream = FS.open(path, opts.flags);\n        var stat = FS.stat(path);\n        var length = stat.size;\n        var buf = new Uint8Array(length);\n        FS.read(stream, buf, 0, length, 0);\n        if (opts.encoding === 'utf8') {\n          ret = UTF8ArrayToString(buf);\n        } else if (opts.encoding === 'binary') {\n          ret = buf;\n        }\n        FS.close(stream);\n        return ret;\n      },\n      writeFile(path, data, opts = {}) {\n        opts.flags = opts.flags || 577;\n        var stream = FS.open(path, opts.flags, opts.mode);\n        if (typeof data == 'string') {\n          var buf = new Uint8Array(lengthBytesUTF8(data) + 1);\n          var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);\n          FS.write(stream, buf, 0, actualNumBytes, undefined, opts.canOwn);\n        } else if (ArrayBuffer.isView(data)) {\n          FS.write(stream, data, 0, data.byteLength, undefined, opts.canOwn);\n        } else {\n          throw new Error('Unsupported data type');\n        }\n        FS.close(stream);\n      },\n      cwd: () => FS.currentPath,\n      chdir(path) {\n        var lookup = FS.lookupPath(path, { follow: true });\n        if (lookup.node === null) {\n          throw new FS.ErrnoError(44);\n        }\n        if (!FS.isDir(lookup.node.mode)) {\n          throw new FS.ErrnoError(54);\n        }\n        var errCode = FS.nodePermissions(lookup.node, 'x');\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        FS.currentPath = lookup.path;\n      },\n      createDefaultDirectories() {\n        FS.mkdir('/tmp');\n        FS.mkdir('/home');\n        FS.mkdir('/home/web_user');\n      },\n      createDefaultDevices() {\n        // create /dev\n        FS.mkdir('/dev');\n        // setup /dev/null\n        FS.registerDevice(FS.makedev(1, 3), {\n          read: () => 0,\n          write: (stream, buffer, offset, length, pos) => length,\n        });\n        FS.mkdev('/dev/null', FS.makedev(1, 3));\n        // setup /dev/tty and /dev/tty1\n        // stderr needs to print output using err() rather than out()\n        // so we register a second tty just for it.\n        TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);\n        TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);\n        FS.mkdev('/dev/tty', FS.makedev(5, 0));\n        FS.mkdev('/dev/tty1', FS.makedev(6, 0));\n        // setup /dev/[u]random\n        // use a buffer to avoid overhead of individual crypto calls per byte\n        var randomBuffer = new Uint8Array(1024),\n          randomLeft = 0;\n        var randomByte = () => {\n          if (randomLeft === 0) {\n            randomLeft = randomFill(randomBuffer).byteLength;\n          }\n          return randomBuffer[--randomLeft];\n        };\n        FS.createDevice('/dev', 'random', randomByte);\n        FS.createDevice('/dev', 'urandom', randomByte);\n        // we're not going to emulate the actual shm device,\n        // just create the tmp dirs that reside in it commonly\n        FS.mkdir('/dev/shm');\n        FS.mkdir('/dev/shm/tmp');\n      },\n      createSpecialDirectories() {\n        // create /proc/self/fd which allows /proc/self/fd/6 => readlink gives the\n        // name of the stream for fd 6 (see test_unistd_ttyname)\n        FS.mkdir('/proc');\n        var proc_self = FS.mkdir('/proc/self');\n        FS.mkdir('/proc/self/fd');\n        FS.mount(\n          {\n            mount() {\n              var node = FS.createNode(proc_self, 'fd', 16384 | 511 /* 0777 */, 73);\n              node.node_ops = {\n                lookup(parent, name) {\n                  var fd = +name;\n                  var stream = FS.getStreamChecked(fd);\n                  var ret = {\n                    parent: null,\n                    mount: { mountpoint: 'fake' },\n                    node_ops: { readlink: () => stream.path },\n                  };\n                  ret.parent = ret; // make it look like a simple root node\n                  return ret;\n                },\n              };\n              return node;\n            },\n          },\n          {},\n          '/proc/self/fd',\n        );\n      },\n      createStandardStreams(input, output, error) {\n        // TODO deprecate the old functionality of a single\n        // input / output callback and that utilizes FS.createDevice\n        // and instead require a unique set of stream ops\n\n        // by default, we symlink the standard streams to the\n        // default tty devices. however, if the standard streams\n        // have been overwritten we create a unique device for\n        // them instead.\n        if (input) {\n          FS.createDevice('/dev', 'stdin', input);\n        } else {\n          FS.symlink('/dev/tty', '/dev/stdin');\n        }\n        if (output) {\n          FS.createDevice('/dev', 'stdout', null, output);\n        } else {\n          FS.symlink('/dev/tty', '/dev/stdout');\n        }\n        if (error) {\n          FS.createDevice('/dev', 'stderr', null, error);\n        } else {\n          FS.symlink('/dev/tty1', '/dev/stderr');\n        }\n\n        // open default streams for the stdin, stdout and stderr devices\n        var stdin = FS.open('/dev/stdin', 0);\n        var stdout = FS.open('/dev/stdout', 1);\n        var stderr = FS.open('/dev/stderr', 1);\n        assert(stdin.fd === 0, `invalid handle for stdin (${stdin.fd})`);\n        assert(stdout.fd === 1, `invalid handle for stdout (${stdout.fd})`);\n        assert(stderr.fd === 2, `invalid handle for stderr (${stderr.fd})`);\n      },\n      staticInit() {\n        // Some errors may happen quite a bit, to avoid overhead we reuse them (and suffer a lack of stack info)\n        [44].forEach((code) => {\n          FS.genericErrors[code] = new FS.ErrnoError(code);\n          FS.genericErrors[code].stack = '<generic error, no stack>';\n        });\n\n        FS.nameTable = new Array(4096);\n\n        FS.mount(MEMFS, {}, '/');\n\n        FS.createDefaultDirectories();\n        FS.createDefaultDevices();\n        FS.createSpecialDirectories();\n\n        FS.filesystems = {\n          MEMFS: MEMFS,\n        };\n      },\n      init(input, output, error) {\n        assert(\n          !FS.initialized,\n          'FS.init was previously called. If you want to initialize later with custom parameters, remove any earlier calls (note that one is automatically added to the generated code)',\n        );\n        FS.initialized = true;\n\n        // Allow Module.stdin etc. to provide defaults, if none explicitly passed to us here\n        input ??= Module['stdin'];\n        output ??= Module['stdout'];\n        error ??= Module['stderr'];\n\n        FS.createStandardStreams(input, output, error);\n      },\n      quit() {\n        FS.initialized = false;\n        // force-flush all streams, so we get musl std streams printed out\n        _fflush(0);\n        // close all of our streams\n        for (var i = 0; i < FS.streams.length; i++) {\n          var stream = FS.streams[i];\n          if (!stream) {\n            continue;\n          }\n          FS.close(stream);\n        }\n      },\n      findObject(path, dontResolveLastLink) {\n        var ret = FS.analyzePath(path, dontResolveLastLink);\n        if (!ret.exists) {\n          return null;\n        }\n        return ret.object;\n      },\n      analyzePath(path, dontResolveLastLink) {\n        // operate from within the context of the symlink's target\n        try {\n          var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });\n          path = lookup.path;\n        } catch (e) {}\n        var ret = {\n          isRoot: false,\n          exists: false,\n          error: 0,\n          name: null,\n          path: null,\n          object: null,\n          parentExists: false,\n          parentPath: null,\n          parentObject: null,\n        };\n        try {\n          var lookup = FS.lookupPath(path, { parent: true });\n          ret.parentExists = true;\n          ret.parentPath = lookup.path;\n          ret.parentObject = lookup.node;\n          ret.name = PATH.basename(path);\n          lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });\n          ret.exists = true;\n          ret.path = lookup.path;\n          ret.object = lookup.node;\n          ret.name = lookup.node.name;\n          ret.isRoot = lookup.path === '/';\n        } catch (e) {\n          ret.error = e.errno;\n        }\n        return ret;\n      },\n      createPath(parent, path, canRead, canWrite) {\n        parent = typeof parent == 'string' ? parent : FS.getPath(parent);\n        var parts = path.split('/').reverse();\n        while (parts.length) {\n          var part = parts.pop();\n          if (!part) continue;\n          var current = PATH.join2(parent, part);\n          try {\n            FS.mkdir(current);\n          } catch (e) {\n            // ignore EEXIST\n          }\n          parent = current;\n        }\n        return current;\n      },\n      createFile(parent, name, properties, canRead, canWrite) {\n        var path = PATH.join2(typeof parent == 'string' ? parent : FS.getPath(parent), name);\n        var mode = FS_getMode(canRead, canWrite);\n        return FS.create(path, mode);\n      },\n      createDataFile(parent, name, data, canRead, canWrite, canOwn) {\n        var path = name;\n        if (parent) {\n          parent = typeof parent == 'string' ? parent : FS.getPath(parent);\n          path = name ? PATH.join2(parent, name) : parent;\n        }\n        var mode = FS_getMode(canRead, canWrite);\n        var node = FS.create(path, mode);\n        if (data) {\n          if (typeof data == 'string') {\n            var arr = new Array(data.length);\n            for (var i = 0, len = data.length; i < len; ++i) arr[i] = data.charCodeAt(i);\n            data = arr;\n          }\n          // make sure we can write to the file\n          FS.chmod(node, mode | 146);\n          var stream = FS.open(node, 577);\n          FS.write(stream, data, 0, data.length, 0, canOwn);\n          FS.close(stream);\n          FS.chmod(node, mode);\n        }\n      },\n      createDevice(parent, name, input, output) {\n        var path = PATH.join2(typeof parent == 'string' ? parent : FS.getPath(parent), name);\n        var mode = FS_getMode(!!input, !!output);\n        FS.createDevice.major ??= 64;\n        var dev = FS.makedev(FS.createDevice.major++, 0);\n        // Create a fake device that a set of stream ops to emulate\n        // the old behavior.\n        FS.registerDevice(dev, {\n          open(stream) {\n            stream.seekable = false;\n          },\n          close(stream) {\n            // flush any pending line data\n            if (output?.buffer?.length) {\n              output(10);\n            }\n          },\n          read(stream, buffer, offset, length, pos /* ignored */) {\n            var bytesRead = 0;\n            for (var i = 0; i < length; i++) {\n              var result;\n              try {\n                result = input();\n              } catch (e) {\n                throw new FS.ErrnoError(29);\n              }\n              if (result === undefined && bytesRead === 0) {\n                throw new FS.ErrnoError(6);\n              }\n              if (result === null || result === undefined) break;\n              bytesRead++;\n              buffer[offset + i] = result;\n            }\n            if (bytesRead) {\n              stream.node.timestamp = Date.now();\n            }\n            return bytesRead;\n          },\n          write(stream, buffer, offset, length, pos) {\n            for (var i = 0; i < length; i++) {\n              try {\n                output(buffer[offset + i]);\n              } catch (e) {\n                throw new FS.ErrnoError(29);\n              }\n            }\n            if (length) {\n              stream.node.timestamp = Date.now();\n            }\n            return i;\n          },\n        });\n        return FS.mkdev(path, mode, dev);\n      },\n      forceLoadFile(obj) {\n        if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;\n        if (typeof XMLHttpRequest != 'undefined') {\n          throw new Error(\n            'Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.',\n          );\n        } else {\n          // Command-line.\n          try {\n            obj.contents = readBinary(obj.url);\n            obj.usedBytes = obj.contents.length;\n          } catch (e) {\n            throw new FS.ErrnoError(29);\n          }\n        }\n      },\n      createLazyFile(parent, name, url, canRead, canWrite) {\n        // Lazy chunked Uint8Array (implements get and length from Uint8Array).\n        // Actual getting is abstracted away for eventual reuse.\n        class LazyUint8Array {\n          constructor() {\n            this.lengthKnown = false;\n            this.chunks = []; // Loaded chunks. Index is the chunk number\n          }\n          get(idx) {\n            if (idx > this.length - 1 || idx < 0) {\n              return undefined;\n            }\n            var chunkOffset = idx % this.chunkSize;\n            var chunkNum = (idx / this.chunkSize) | 0;\n            return this.getter(chunkNum)[chunkOffset];\n          }\n          setDataGetter(getter) {\n            this.getter = getter;\n          }\n          cacheLength() {\n            // Find length\n            var xhr = new XMLHttpRequest();\n            xhr.open('HEAD', url, false);\n            xhr.send(null);\n            if (!((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304))\n              throw new Error(\"Couldn't load \" + url + '. Status: ' + xhr.status);\n            var datalength = Number(xhr.getResponseHeader('Content-length'));\n            var header;\n            var hasByteServing =\n              (header = xhr.getResponseHeader('Accept-Ranges')) && header === 'bytes';\n            var usesGzip =\n              (header = xhr.getResponseHeader('Content-Encoding')) && header === 'gzip';\n\n            var chunkSize = 1024 * 1024; // Chunk size in bytes\n\n            if (!hasByteServing) chunkSize = datalength;\n\n            // Function to get a range from the remote URL.\n            var doXHR = (from, to) => {\n              if (from > to)\n                throw new Error('invalid range (' + from + ', ' + to + ') or no bytes requested!');\n              if (to > datalength - 1)\n                throw new Error('only ' + datalength + ' bytes available! programmer error!');\n\n              // TODO: Use mozResponseArrayBuffer, responseStream, etc. if available.\n              var xhr = new XMLHttpRequest();\n              xhr.open('GET', url, false);\n              if (datalength !== chunkSize)\n                xhr.setRequestHeader('Range', 'bytes=' + from + '-' + to);\n\n              // Some hints to the browser that we want binary data.\n              xhr.responseType = 'arraybuffer';\n              if (xhr.overrideMimeType) {\n                xhr.overrideMimeType('text/plain; charset=x-user-defined');\n              }\n\n              xhr.send(null);\n              if (!((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304))\n                throw new Error(\"Couldn't load \" + url + '. Status: ' + xhr.status);\n              if (xhr.response !== undefined) {\n                return new Uint8Array(/** @type{Array<number>} */ (xhr.response || []));\n              }\n              return intArrayFromString(xhr.responseText || '', true);\n            };\n            var lazyArray = this;\n            lazyArray.setDataGetter((chunkNum) => {\n              var start = chunkNum * chunkSize;\n              var end = (chunkNum + 1) * chunkSize - 1; // including this byte\n              end = Math.min(end, datalength - 1); // if datalength-1 is selected, this is the last block\n              if (typeof lazyArray.chunks[chunkNum] == 'undefined') {\n                lazyArray.chunks[chunkNum] = doXHR(start, end);\n              }\n              if (typeof lazyArray.chunks[chunkNum] == 'undefined')\n                throw new Error('doXHR failed!');\n              return lazyArray.chunks[chunkNum];\n            });\n\n            if (usesGzip || !datalength) {\n              // if the server uses gzip or doesn't supply the length, we have to download the whole file to get the (uncompressed) length\n              chunkSize = datalength = 1; // this will force getter(0)/doXHR do download the whole file\n              datalength = this.getter(0).length;\n              chunkSize = datalength;\n              out('LazyFiles on gzip forces download of the whole file when length is accessed');\n            }\n\n            this._length = datalength;\n            this._chunkSize = chunkSize;\n            this.lengthKnown = true;\n          }\n          get length() {\n            if (!this.lengthKnown) {\n              this.cacheLength();\n            }\n            return this._length;\n          }\n          get chunkSize() {\n            if (!this.lengthKnown) {\n              this.cacheLength();\n            }\n            return this._chunkSize;\n          }\n        }\n\n        if (typeof XMLHttpRequest != 'undefined') {\n          if (!ENVIRONMENT_IS_WORKER)\n            throw 'Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc';\n          var lazyArray = new LazyUint8Array();\n          var properties = { isDevice: false, contents: lazyArray };\n        } else {\n          var properties = { isDevice: false, url: url };\n        }\n\n        var node = FS.createFile(parent, name, properties, canRead, canWrite);\n        // This is a total hack, but I want to get this lazy file code out of the\n        // core of MEMFS. If we want to keep this lazy file concept I feel it should\n        // be its own thin LAZYFS proxying calls to MEMFS.\n        if (properties.contents) {\n          node.contents = properties.contents;\n        } else if (properties.url) {\n          node.contents = null;\n          node.url = properties.url;\n        }\n        // Add a function that defers querying the file size until it is asked the first time.\n        Object.defineProperties(node, {\n          usedBytes: {\n            get: function () {\n              return this.contents.length;\n            },\n          },\n        });\n        // override each stream op with one that tries to force load the lazy file first\n        var stream_ops = {};\n        var keys = Object.keys(node.stream_ops);\n        keys.forEach((key) => {\n          var fn = node.stream_ops[key];\n          stream_ops[key] = (...args) => {\n            FS.forceLoadFile(node);\n            return fn(...args);\n          };\n        });\n        function writeChunks(stream, buffer, offset, length, position) {\n          var contents = stream.node.contents;\n          if (position >= contents.length) return 0;\n          var size = Math.min(contents.length - position, length);\n          assert(size >= 0);\n          if (contents.slice) {\n            // normal array\n            for (var i = 0; i < size; i++) {\n              buffer[offset + i] = contents[position + i];\n            }\n          } else {\n            for (var i = 0; i < size; i++) {\n              // LazyUint8Array from sync binary XHR\n              buffer[offset + i] = contents.get(position + i);\n            }\n          }\n          return size;\n        }\n        // use a custom read function\n        stream_ops.read = (stream, buffer, offset, length, position) => {\n          FS.forceLoadFile(node);\n          return writeChunks(stream, buffer, offset, length, position);\n        };\n        // use a custom mmap function\n        stream_ops.mmap = (stream, length, position, prot, flags) => {\n          FS.forceLoadFile(node);\n          var ptr = mmapAlloc(length);\n          if (!ptr) {\n            throw new FS.ErrnoError(48);\n          }\n          writeChunks(stream, HEAP8, ptr, length, position);\n          return { ptr, allocated: true };\n        };\n        node.stream_ops = stream_ops;\n        return node;\n      },\n      absolutePath() {\n        abort('FS.absolutePath has been removed; use PATH_FS.resolve instead');\n      },\n      createFolder() {\n        abort('FS.createFolder has been removed; use FS.mkdir instead');\n      },\n      createLink() {\n        abort('FS.createLink has been removed; use FS.symlink instead');\n      },\n      joinPath() {\n        abort('FS.joinPath has been removed; use PATH.join instead');\n      },\n      mmapAlloc() {\n        abort('FS.mmapAlloc has been replaced by the top level function mmapAlloc');\n      },\n      standardizePath() {\n        abort('FS.standardizePath has been removed; use PATH.normalize instead');\n      },\n    };\n\n    var SYSCALLS = {\n      DEFAULT_POLLMASK: 5,\n      calculateAt(dirfd, path, allowEmpty) {\n        if (PATH.isAbs(path)) {\n          return path;\n        }\n        // relative path\n        var dir;\n        if (dirfd === -100) {\n          dir = FS.cwd();\n        } else {\n          var dirstream = SYSCALLS.getStreamFromFD(dirfd);\n          dir = dirstream.path;\n        }\n        if (path.length == 0) {\n          if (!allowEmpty) {\n            throw new FS.ErrnoError(44);\n          }\n          return dir;\n        }\n        return PATH.join2(dir, path);\n      },\n      doStat(func, path, buf) {\n        var stat = func(path);\n        HEAP32[buf >> 2] = stat.dev;\n        HEAP32[(buf + 4) >> 2] = stat.mode;\n        HEAPU32[(buf + 8) >> 2] = stat.nlink;\n        HEAP32[(buf + 12) >> 2] = stat.uid;\n        HEAP32[(buf + 16) >> 2] = stat.gid;\n        HEAP32[(buf + 20) >> 2] = stat.rdev;\n        (tempI64 = [\n          stat.size >>> 0,\n          ((tempDouble = stat.size),\n          +Math.abs(tempDouble) >= 1.0\n            ? tempDouble > 0.0\n              ? +Math.floor(tempDouble / 4294967296.0) >>> 0\n              : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296.0) >>> 0\n            : 0),\n        ]),\n          (HEAP32[(buf + 24) >> 2] = tempI64[0]),\n          (HEAP32[(buf + 28) >> 2] = tempI64[1]);\n        HEAP32[(buf + 32) >> 2] = 4096;\n        HEAP32[(buf + 36) >> 2] = stat.blocks;\n        var atime = stat.atime.getTime();\n        var mtime = stat.mtime.getTime();\n        var ctime = stat.ctime.getTime();\n        (tempI64 = [\n          Math.floor(atime / 1000) >>> 0,\n          ((tempDouble = Math.floor(atime / 1000)),\n          +Math.abs(tempDouble) >= 1.0\n            ? tempDouble > 0.0\n              ? +Math.floor(tempDouble / 4294967296.0) >>> 0\n              : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296.0) >>> 0\n            : 0),\n        ]),\n          (HEAP32[(buf + 40) >> 2] = tempI64[0]),\n          (HEAP32[(buf + 44) >> 2] = tempI64[1]);\n        HEAPU32[(buf + 48) >> 2] = (atime % 1000) * 1000 * 1000;\n        (tempI64 = [\n          Math.floor(mtime / 1000) >>> 0,\n          ((tempDouble = Math.floor(mtime / 1000)),\n          +Math.abs(tempDouble) >= 1.0\n            ? tempDouble > 0.0\n              ? +Math.floor(tempDouble / 4294967296.0) >>> 0\n              : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296.0) >>> 0\n            : 0),\n        ]),\n          (HEAP32[(buf + 56) >> 2] = tempI64[0]),\n          (HEAP32[(buf + 60) >> 2] = tempI64[1]);\n        HEAPU32[(buf + 64) >> 2] = (mtime % 1000) * 1000 * 1000;\n        (tempI64 = [\n          Math.floor(ctime / 1000) >>> 0,\n          ((tempDouble = Math.floor(ctime / 1000)),\n          +Math.abs(tempDouble) >= 1.0\n            ? tempDouble > 0.0\n              ? +Math.floor(tempDouble / 4294967296.0) >>> 0\n              : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296.0) >>> 0\n            : 0),\n        ]),\n          (HEAP32[(buf + 72) >> 2] = tempI64[0]),\n          (HEAP32[(buf + 76) >> 2] = tempI64[1]);\n        HEAPU32[(buf + 80) >> 2] = (ctime % 1000) * 1000 * 1000;\n        (tempI64 = [\n          stat.ino >>> 0,\n          ((tempDouble = stat.ino),\n          +Math.abs(tempDouble) >= 1.0\n            ? tempDouble > 0.0\n              ? +Math.floor(tempDouble / 4294967296.0) >>> 0\n              : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296.0) >>> 0\n            : 0),\n        ]),\n          (HEAP32[(buf + 88) >> 2] = tempI64[0]),\n          (HEAP32[(buf + 92) >> 2] = tempI64[1]);\n        return 0;\n      },\n      doMsync(addr, stream, len, flags, offset) {\n        if (!FS.isFile(stream.node.mode)) {\n          throw new FS.ErrnoError(43);\n        }\n        if (flags & 2) {\n          // MAP_PRIVATE calls need not to be synced back to underlying fs\n          return 0;\n        }\n        var buffer = HEAPU8.slice(addr, addr + len);\n        FS.msync(stream, buffer, offset, len, flags);\n      },\n      getStreamFromFD(fd) {\n        var stream = FS.getStreamChecked(fd);\n        return stream;\n      },\n      varargs: undefined,\n      getStr(ptr) {\n        var ret = UTF8ToString(ptr);\n        return ret;\n      },\n    };\n    function ___syscall_fcntl64(fd, cmd, varargs) {\n      SYSCALLS.varargs = varargs;\n      try {\n        var stream = SYSCALLS.getStreamFromFD(fd);\n        switch (cmd) {\n          case 0: {\n            var arg = syscallGetVarargI();\n            if (arg < 0) {\n              return -28;\n            }\n            while (FS.streams[arg]) {\n              arg++;\n            }\n            var newStream;\n            newStream = FS.dupStream(stream, arg);\n            return newStream.fd;\n          }\n          case 1:\n          case 2:\n            return 0; // FD_CLOEXEC makes no sense for a single process.\n          case 3:\n            return stream.flags;\n          case 4: {\n            var arg = syscallGetVarargI();\n            stream.flags |= arg;\n            return 0;\n          }\n          case 12: {\n            var arg = syscallGetVarargP();\n            var offset = 0;\n            // We're always unlocked.\n            HEAP16[(arg + offset) >> 1] = 2;\n            return 0;\n          }\n          case 13:\n          case 14:\n            return 0; // Pretend that the locking is successful.\n        }\n        return -28;\n      } catch (e) {\n        if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n        return -e.errno;\n      }\n    }\n\n    function ___syscall_fstat64(fd, buf) {\n      try {\n        var stream = SYSCALLS.getStreamFromFD(fd);\n        return SYSCALLS.doStat(FS.stat, stream.path, buf);\n      } catch (e) {\n        if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n        return -e.errno;\n      }\n    }\n\n    var convertI32PairToI53Checked = (lo, hi) => {\n      assert(lo == lo >>> 0 || lo == (lo | 0)); // lo should either be a i32 or a u32\n      assert(hi === (hi | 0)); // hi should be a i32\n      return (hi + 0x200000) >>> 0 < 0x400001 - !!lo ? (lo >>> 0) + hi * 4294967296 : NaN;\n    };\n    function ___syscall_ftruncate64(fd, length_low, length_high) {\n      var length = convertI32PairToI53Checked(length_low, length_high);\n\n      try {\n        if (isNaN(length)) return 61;\n        FS.ftruncate(fd, length);\n        return 0;\n      } catch (e) {\n        if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n        return -e.errno;\n      }\n    }\n\n    var stringToUTF8 = (str, outPtr, maxBytesToWrite) => {\n      assert(\n        typeof maxBytesToWrite == 'number',\n        'stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!',\n      );\n      return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);\n    };\n\n    function ___syscall_getdents64(fd, dirp, count) {\n      try {\n        var stream = SYSCALLS.getStreamFromFD(fd);\n        stream.getdents ||= FS.readdir(stream.path);\n\n        var struct_size = 280;\n        var pos = 0;\n        var off = FS.llseek(stream, 0, 1);\n\n        var idx = Math.floor(off / struct_size);\n\n        while (idx < stream.getdents.length && pos + struct_size <= count) {\n          var id;\n          var type;\n          var name = stream.getdents[idx];\n          if (name === '.') {\n            id = stream.node.id;\n            type = 4; // DT_DIR\n          } else if (name === '..') {\n            var lookup = FS.lookupPath(stream.path, { parent: true });\n            id = lookup.node.id;\n            type = 4; // DT_DIR\n          } else {\n            var child = FS.lookupNode(stream.node, name);\n            id = child.id;\n            type = FS.isChrdev(child.mode)\n              ? 2 // DT_CHR, character device.\n              : FS.isDir(child.mode)\n                ? 4 // DT_DIR, directory.\n                : FS.isLink(child.mode)\n                  ? 10 // DT_LNK, symbolic link.\n                  : 8; // DT_REG, regular file.\n          }\n          assert(id);\n          (tempI64 = [\n            id >>> 0,\n            ((tempDouble = id),\n            +Math.abs(tempDouble) >= 1.0\n              ? tempDouble > 0.0\n                ? +Math.floor(tempDouble / 4294967296.0) >>> 0\n                : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296.0) >>> 0\n              : 0),\n          ]),\n            (HEAP32[(dirp + pos) >> 2] = tempI64[0]),\n            (HEAP32[(dirp + pos + 4) >> 2] = tempI64[1]);\n          (tempI64 = [\n            ((idx + 1) * struct_size) >>> 0,\n            ((tempDouble = (idx + 1) * struct_size),\n            +Math.abs(tempDouble) >= 1.0\n              ? tempDouble > 0.0\n                ? +Math.floor(tempDouble / 4294967296.0) >>> 0\n                : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296.0) >>> 0\n              : 0),\n          ]),\n            (HEAP32[(dirp + pos + 8) >> 2] = tempI64[0]),\n            (HEAP32[(dirp + pos + 12) >> 2] = tempI64[1]);\n          HEAP16[(dirp + pos + 16) >> 1] = 280;\n          HEAP8[dirp + pos + 18] = type;\n          stringToUTF8(name, dirp + pos + 19, 256);\n          pos += struct_size;\n          idx += 1;\n        }\n        FS.llseek(stream, idx * struct_size, 0);\n        return pos;\n      } catch (e) {\n        if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n        return -e.errno;\n      }\n    }\n\n    function ___syscall_ioctl(fd, op, varargs) {\n      SYSCALLS.varargs = varargs;\n      try {\n        var stream = SYSCALLS.getStreamFromFD(fd);\n        switch (op) {\n          case 21509: {\n            if (!stream.tty) return -59;\n            return 0;\n          }\n          case 21505: {\n            if (!stream.tty) return -59;\n            if (stream.tty.ops.ioctl_tcgets) {\n              var termios = stream.tty.ops.ioctl_tcgets(stream);\n              var argp = syscallGetVarargP();\n              HEAP32[argp >> 2] = termios.c_iflag || 0;\n              HEAP32[(argp + 4) >> 2] = termios.c_oflag || 0;\n              HEAP32[(argp + 8) >> 2] = termios.c_cflag || 0;\n              HEAP32[(argp + 12) >> 2] = termios.c_lflag || 0;\n              for (var i = 0; i < 32; i++) {\n                HEAP8[argp + i + 17] = termios.c_cc[i] || 0;\n              }\n              return 0;\n            }\n            return 0;\n          }\n          case 21510:\n          case 21511:\n          case 21512: {\n            if (!stream.tty) return -59;\n            return 0; // no-op, not actually adjusting terminal settings\n          }\n          case 21506:\n          case 21507:\n          case 21508: {\n            if (!stream.tty) return -59;\n            if (stream.tty.ops.ioctl_tcsets) {\n              var argp = syscallGetVarargP();\n              var c_iflag = HEAP32[argp >> 2];\n              var c_oflag = HEAP32[(argp + 4) >> 2];\n              var c_cflag = HEAP32[(argp + 8) >> 2];\n              var c_lflag = HEAP32[(argp + 12) >> 2];\n              var c_cc = [];\n              for (var i = 0; i < 32; i++) {\n                c_cc.push(HEAP8[argp + i + 17]);\n              }\n              return stream.tty.ops.ioctl_tcsets(stream.tty, op, {\n                c_iflag,\n                c_oflag,\n                c_cflag,\n                c_lflag,\n                c_cc,\n              });\n            }\n            return 0; // no-op, not actually adjusting terminal settings\n          }\n          case 21519: {\n            if (!stream.tty) return -59;\n            var argp = syscallGetVarargP();\n            HEAP32[argp >> 2] = 0;\n            return 0;\n          }\n          case 21520: {\n            if (!stream.tty) return -59;\n            return -28; // not supported\n          }\n          case 21531: {\n            var argp = syscallGetVarargP();\n            return FS.ioctl(stream, op, argp);\n          }\n          case 21523: {\n            // TODO: in theory we should write to the winsize struct that gets\n            // passed in, but for now musl doesn't read anything on it\n            if (!stream.tty) return -59;\n            if (stream.tty.ops.ioctl_tiocgwinsz) {\n              var winsize = stream.tty.ops.ioctl_tiocgwinsz(stream.tty);\n              var argp = syscallGetVarargP();\n              HEAP16[argp >> 1] = winsize[0];\n              HEAP16[(argp + 2) >> 1] = winsize[1];\n            }\n            return 0;\n          }\n          case 21524: {\n            // TODO: technically, this ioctl call should change the window size.\n            // but, since emscripten doesn't have any concept of a terminal window\n            // yet, we'll just silently throw it away as we do TIOCGWINSZ\n            if (!stream.tty) return -59;\n            return 0;\n          }\n          case 21515: {\n            if (!stream.tty) return -59;\n            return 0;\n          }\n          default:\n            return -28; // not supported\n        }\n      } catch (e) {\n        if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n        return -e.errno;\n      }\n    }\n\n    function ___syscall_lstat64(path, buf) {\n      try {\n        path = SYSCALLS.getStr(path);\n        return SYSCALLS.doStat(FS.lstat, path, buf);\n      } catch (e) {\n        if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n        return -e.errno;\n      }\n    }\n\n    function ___syscall_newfstatat(dirfd, path, buf, flags) {\n      try {\n        path = SYSCALLS.getStr(path);\n        var nofollow = flags & 256;\n        var allowEmpty = flags & 4096;\n        flags = flags & ~6400;\n        assert(!flags, `unknown flags in __syscall_newfstatat: ${flags}`);\n        path = SYSCALLS.calculateAt(dirfd, path, allowEmpty);\n        return SYSCALLS.doStat(nofollow ? FS.lstat : FS.stat, path, buf);\n      } catch (e) {\n        if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n        return -e.errno;\n      }\n    }\n\n    function ___syscall_openat(dirfd, path, flags, varargs) {\n      SYSCALLS.varargs = varargs;\n      try {\n        path = SYSCALLS.getStr(path);\n        path = SYSCALLS.calculateAt(dirfd, path);\n        var mode = varargs ? syscallGetVarargI() : 0;\n        return FS.open(path, flags, mode).fd;\n      } catch (e) {\n        if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n        return -e.errno;\n      }\n    }\n\n    function ___syscall_rmdir(path) {\n      try {\n        path = SYSCALLS.getStr(path);\n        FS.rmdir(path);\n        return 0;\n      } catch (e) {\n        if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n        return -e.errno;\n      }\n    }\n\n    function ___syscall_stat64(path, buf) {\n      try {\n        path = SYSCALLS.getStr(path);\n        return SYSCALLS.doStat(FS.stat, path, buf);\n      } catch (e) {\n        if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n        return -e.errno;\n      }\n    }\n\n    function ___syscall_unlinkat(dirfd, path, flags) {\n      try {\n        path = SYSCALLS.getStr(path);\n        path = SYSCALLS.calculateAt(dirfd, path);\n        if (flags === 0) {\n          FS.unlink(path);\n        } else if (flags === 512) {\n          FS.rmdir(path);\n        } else {\n          abort('Invalid flags passed to unlinkat');\n        }\n        return 0;\n      } catch (e) {\n        if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n        return -e.errno;\n      }\n    }\n\n    var __abort_js = () => {\n      abort('native code called abort()');\n    };\n\n    var __emscripten_memcpy_js = (dest, src, num) => HEAPU8.copyWithin(dest, src, src + num);\n\n    var __emscripten_throw_longjmp = () => {\n      throw Infinity;\n    };\n\n    function __gmtime_js(time_low, time_high, tmPtr) {\n      var time = convertI32PairToI53Checked(time_low, time_high);\n\n      var date = new Date(time * 1000);\n      HEAP32[tmPtr >> 2] = date.getUTCSeconds();\n      HEAP32[(tmPtr + 4) >> 2] = date.getUTCMinutes();\n      HEAP32[(tmPtr + 8) >> 2] = date.getUTCHours();\n      HEAP32[(tmPtr + 12) >> 2] = date.getUTCDate();\n      HEAP32[(tmPtr + 16) >> 2] = date.getUTCMonth();\n      HEAP32[(tmPtr + 20) >> 2] = date.getUTCFullYear() - 1900;\n      HEAP32[(tmPtr + 24) >> 2] = date.getUTCDay();\n      var start = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0);\n      var yday = ((date.getTime() - start) / (1000 * 60 * 60 * 24)) | 0;\n      HEAP32[(tmPtr + 28) >> 2] = yday;\n    }\n\n    var isLeapYear = (year) => year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);\n\n    var MONTH_DAYS_LEAP_CUMULATIVE = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];\n\n    var MONTH_DAYS_REGULAR_CUMULATIVE = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];\n    var ydayFromDate = (date) => {\n      var leap = isLeapYear(date.getFullYear());\n      var monthDaysCumulative = leap ? MONTH_DAYS_LEAP_CUMULATIVE : MONTH_DAYS_REGULAR_CUMULATIVE;\n      var yday = monthDaysCumulative[date.getMonth()] + date.getDate() - 1; // -1 since it's days since Jan 1\n\n      return yday;\n    };\n\n    function __localtime_js(time_low, time_high, tmPtr) {\n      var time = convertI32PairToI53Checked(time_low, time_high);\n\n      var date = new Date(time * 1000);\n      HEAP32[tmPtr >> 2] = date.getSeconds();\n      HEAP32[(tmPtr + 4) >> 2] = date.getMinutes();\n      HEAP32[(tmPtr + 8) >> 2] = date.getHours();\n      HEAP32[(tmPtr + 12) >> 2] = date.getDate();\n      HEAP32[(tmPtr + 16) >> 2] = date.getMonth();\n      HEAP32[(tmPtr + 20) >> 2] = date.getFullYear() - 1900;\n      HEAP32[(tmPtr + 24) >> 2] = date.getDay();\n\n      var yday = ydayFromDate(date) | 0;\n      HEAP32[(tmPtr + 28) >> 2] = yday;\n      HEAP32[(tmPtr + 36) >> 2] = -(date.getTimezoneOffset() * 60);\n\n      // Attention: DST is in December in South, and some regions don't have DST at all.\n      var start = new Date(date.getFullYear(), 0, 1);\n      var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();\n      var winterOffset = start.getTimezoneOffset();\n      var dst =\n        (summerOffset != winterOffset &&\n          date.getTimezoneOffset() == Math.min(winterOffset, summerOffset)) | 0;\n      HEAP32[(tmPtr + 32) >> 2] = dst;\n    }\n\n    var __tzset_js = (timezone, daylight, std_name, dst_name) => {\n      // TODO: Use (malleable) environment variables instead of system settings.\n      var currentYear = new Date().getFullYear();\n      var winter = new Date(currentYear, 0, 1);\n      var summer = new Date(currentYear, 6, 1);\n      var winterOffset = winter.getTimezoneOffset();\n      var summerOffset = summer.getTimezoneOffset();\n\n      // Local standard timezone offset. Local standard time is not adjusted for\n      // daylight savings.  This code uses the fact that getTimezoneOffset returns\n      // a greater value during Standard Time versus Daylight Saving Time (DST).\n      // Thus it determines the expected output during Standard Time, and it\n      // compares whether the output of the given date the same (Standard) or less\n      // (DST).\n      var stdTimezoneOffset = Math.max(winterOffset, summerOffset);\n\n      // timezone is specified as seconds west of UTC (\"The external variable\n      // `timezone` shall be set to the difference, in seconds, between\n      // Coordinated Universal Time (UTC) and local standard time.\"), the same\n      // as returned by stdTimezoneOffset.\n      // See http://pubs.opengroup.org/onlinepubs/009695399/functions/tzset.html\n      HEAPU32[timezone >> 2] = stdTimezoneOffset * 60;\n\n      HEAP32[daylight >> 2] = Number(winterOffset != summerOffset);\n\n      var extractZone = (timezoneOffset) => {\n        // Why inverse sign?\n        // Read here https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/getTimezoneOffset\n        var sign = timezoneOffset >= 0 ? '-' : '+';\n\n        var absOffset = Math.abs(timezoneOffset);\n        var hours = String(Math.floor(absOffset / 60)).padStart(2, '0');\n        var minutes = String(absOffset % 60).padStart(2, '0');\n\n        return `UTC${sign}${hours}${minutes}`;\n      };\n\n      var winterName = extractZone(winterOffset);\n      var summerName = extractZone(summerOffset);\n      assert(winterName);\n      assert(summerName);\n      assert(\n        lengthBytesUTF8(winterName) <= 16,\n        `timezone name truncated to fit in TZNAME_MAX (${winterName})`,\n      );\n      assert(\n        lengthBytesUTF8(summerName) <= 16,\n        `timezone name truncated to fit in TZNAME_MAX (${summerName})`,\n      );\n      if (summerOffset < winterOffset) {\n        // Northern hemisphere\n        stringToUTF8(winterName, std_name, 17);\n        stringToUTF8(summerName, dst_name, 17);\n      } else {\n        stringToUTF8(winterName, dst_name, 17);\n        stringToUTF8(summerName, std_name, 17);\n      }\n    };\n\n    var _emscripten_date_now = () => Date.now();\n\n    var getHeapMax = () =>\n      // Stay one Wasm page short of 4GB: while e.g. Chrome is able to allocate\n      // full 4GB Wasm memories, the size will wrap back to 0 bytes in Wasm side\n      // for any code that deals with heap sizes, which would require special\n      // casing all heap size related code to treat 0 specially.\n      2147483648;\n\n    var growMemory = (size) => {\n      var b = wasmMemory.buffer;\n      var pages = ((size - b.byteLength + 65535) / 65536) | 0;\n      try {\n        // round size grow request up to wasm page size (fixed 64KB per spec)\n        wasmMemory.grow(pages); // .grow() takes a delta compared to the previous size\n        updateMemoryViews();\n        return 1 /*success*/;\n      } catch (e) {\n        err(\n          `growMemory: Attempted to grow heap from ${b.byteLength} bytes to ${size} bytes, but got error: ${e}`,\n        );\n      }\n      // implicit 0 return to save code size (caller will cast \"undefined\" into 0\n      // anyhow)\n    };\n    var _emscripten_resize_heap = (requestedSize) => {\n      var oldSize = HEAPU8.length;\n      // With CAN_ADDRESS_2GB or MEMORY64, pointers are already unsigned.\n      requestedSize >>>= 0;\n      // With multithreaded builds, races can happen (another thread might increase the size\n      // in between), so return a failure, and let the caller retry.\n      assert(requestedSize > oldSize);\n\n      // Memory resize rules:\n      // 1.  Always increase heap size to at least the requested size, rounded up\n      //     to next page multiple.\n      // 2a. If MEMORY_GROWTH_LINEAR_STEP == -1, excessively resize the heap\n      //     geometrically: increase the heap size according to\n      //     MEMORY_GROWTH_GEOMETRIC_STEP factor (default +20%), At most\n      //     overreserve by MEMORY_GROWTH_GEOMETRIC_CAP bytes (default 96MB).\n      // 2b. If MEMORY_GROWTH_LINEAR_STEP != -1, excessively resize the heap\n      //     linearly: increase the heap size by at least\n      //     MEMORY_GROWTH_LINEAR_STEP bytes.\n      // 3.  Max size for the heap is capped at 2048MB-WASM_PAGE_SIZE, or by\n      //     MAXIMUM_MEMORY, or by ASAN limit, depending on which is smallest\n      // 4.  If we were unable to allocate as much memory, it may be due to\n      //     over-eager decision to excessively reserve due to (3) above.\n      //     Hence if an allocation fails, cut down on the amount of excess\n      //     growth, in an attempt to succeed to perform a smaller allocation.\n\n      // A limit is set for how much we can grow. We should not exceed that\n      // (the wasm binary specifies it, so if we tried, we'd fail anyhow).\n      var maxHeapSize = getHeapMax();\n      if (requestedSize > maxHeapSize) {\n        err(\n          `Cannot enlarge memory, requested ${requestedSize} bytes, but the limit is ${maxHeapSize} bytes!`,\n        );\n        return false;\n      }\n\n      // Loop through potential heap size increases. If we attempt a too eager\n      // reservation that fails, cut down on the attempted size and reserve a\n      // smaller bump instead. (max 3 times, chosen somewhat arbitrarily)\n      for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {\n        var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown); // ensure geometric growth\n        // but limit overreserving (default to capping at +96MB overgrowth at most)\n        overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);\n\n        var newSize = Math.min(\n          maxHeapSize,\n          alignMemory(Math.max(requestedSize, overGrownHeapSize), 65536),\n        );\n\n        var replacement = growMemory(newSize);\n        if (replacement) {\n          return true;\n        }\n      }\n      err(`Failed to grow the heap from ${oldSize} bytes to ${newSize} bytes, not enough memory!`);\n      return false;\n    };\n\n    var ENV = {};\n\n    var getExecutableName = () => {\n      return thisProgram || './this.program';\n    };\n    var getEnvStrings = () => {\n      if (!getEnvStrings.strings) {\n        // Default values.\n        // Browser language detection #8751\n        var lang =\n          (\n            (typeof navigator == 'object' && navigator.languages && navigator.languages[0]) ||\n            'C'\n          ).replace('-', '_') + '.UTF-8';\n        var env = {\n          USER: 'web_user',\n          LOGNAME: 'web_user',\n          PATH: '/',\n          PWD: '/',\n          HOME: '/home/web_user',\n          LANG: lang,\n          _: getExecutableName(),\n        };\n        // Apply the user-provided values, if any.\n        for (var x in ENV) {\n          // x is a key in ENV; if ENV[x] is undefined, that means it was\n          // explicitly set to be so. We allow user code to do that to\n          // force variables with default values to remain unset.\n          if (ENV[x] === undefined) delete env[x];\n          else env[x] = ENV[x];\n        }\n        var strings = [];\n        for (var x in env) {\n          strings.push(`${x}=${env[x]}`);\n        }\n        getEnvStrings.strings = strings;\n      }\n      return getEnvStrings.strings;\n    };\n\n    var stringToAscii = (str, buffer) => {\n      for (var i = 0; i < str.length; ++i) {\n        assert(str.charCodeAt(i) === (str.charCodeAt(i) & 0xff));\n        HEAP8[buffer++] = str.charCodeAt(i);\n      }\n      // Null-terminate the string\n      HEAP8[buffer] = 0;\n    };\n    var _environ_get = (__environ, environ_buf) => {\n      var bufSize = 0;\n      getEnvStrings().forEach((string, i) => {\n        var ptr = environ_buf + bufSize;\n        HEAPU32[(__environ + i * 4) >> 2] = ptr;\n        stringToAscii(string, ptr);\n        bufSize += string.length + 1;\n      });\n      return 0;\n    };\n\n    var _environ_sizes_get = (penviron_count, penviron_buf_size) => {\n      var strings = getEnvStrings();\n      HEAPU32[penviron_count >> 2] = strings.length;\n      var bufSize = 0;\n      strings.forEach((string) => (bufSize += string.length + 1));\n      HEAPU32[penviron_buf_size >> 2] = bufSize;\n      return 0;\n    };\n\n    function _fd_close(fd) {\n      try {\n        var stream = SYSCALLS.getStreamFromFD(fd);\n        FS.close(stream);\n        return 0;\n      } catch (e) {\n        if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n        return e.errno;\n      }\n    }\n\n    /** @param {number=} offset */\n    var doReadv = (stream, iov, iovcnt, offset) => {\n      var ret = 0;\n      for (var i = 0; i < iovcnt; i++) {\n        var ptr = HEAPU32[iov >> 2];\n        var len = HEAPU32[(iov + 4) >> 2];\n        iov += 8;\n        var curr = FS.read(stream, HEAP8, ptr, len, offset);\n        if (curr < 0) return -1;\n        ret += curr;\n        if (curr < len) break; // nothing more to read\n        if (typeof offset != 'undefined') {\n          offset += curr;\n        }\n      }\n      return ret;\n    };\n\n    function _fd_read(fd, iov, iovcnt, pnum) {\n      try {\n        var stream = SYSCALLS.getStreamFromFD(fd);\n        var num = doReadv(stream, iov, iovcnt);\n        HEAPU32[pnum >> 2] = num;\n        return 0;\n      } catch (e) {\n        if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n        return e.errno;\n      }\n    }\n\n    function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {\n      var offset = convertI32PairToI53Checked(offset_low, offset_high);\n\n      try {\n        if (isNaN(offset)) return 61;\n        var stream = SYSCALLS.getStreamFromFD(fd);\n        FS.llseek(stream, offset, whence);\n        (tempI64 = [\n          stream.position >>> 0,\n          ((tempDouble = stream.position),\n          +Math.abs(tempDouble) >= 1.0\n            ? tempDouble > 0.0\n              ? +Math.floor(tempDouble / 4294967296.0) >>> 0\n              : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296.0) >>> 0\n            : 0),\n        ]),\n          (HEAP32[newOffset >> 2] = tempI64[0]),\n          (HEAP32[(newOffset + 4) >> 2] = tempI64[1]);\n        if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null; // reset readdir state\n        return 0;\n      } catch (e) {\n        if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n        return e.errno;\n      }\n    }\n\n    function _fd_sync(fd) {\n      try {\n        var stream = SYSCALLS.getStreamFromFD(fd);\n        if (stream.stream_ops?.fsync) {\n          return stream.stream_ops.fsync(stream);\n        }\n        return 0; // we can't do anything synchronously; the in-memory FS is already synced to\n      } catch (e) {\n        if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n        return e.errno;\n      }\n    }\n\n    /** @param {number=} offset */\n    var doWritev = (stream, iov, iovcnt, offset) => {\n      var ret = 0;\n      for (var i = 0; i < iovcnt; i++) {\n        var ptr = HEAPU32[iov >> 2];\n        var len = HEAPU32[(iov + 4) >> 2];\n        iov += 8;\n        var curr = FS.write(stream, HEAP8, ptr, len, offset);\n        if (curr < 0) return -1;\n        ret += curr;\n        if (curr < len) {\n          // No more space to write.\n          break;\n        }\n        if (typeof offset != 'undefined') {\n          offset += curr;\n        }\n      }\n      return ret;\n    };\n\n    function _fd_write(fd, iov, iovcnt, pnum) {\n      try {\n        var stream = SYSCALLS.getStreamFromFD(fd);\n        var num = doWritev(stream, iov, iovcnt);\n        HEAPU32[pnum >> 2] = num;\n        return 0;\n      } catch (e) {\n        if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n        return e.errno;\n      }\n    }\n\n    var wasmTableMirror = [];\n\n    /** @type {WebAssembly.Table} */\n    var wasmTable;\n    var getWasmTableEntry = (funcPtr) => {\n      var func = wasmTableMirror[funcPtr];\n      if (!func) {\n        if (funcPtr >= wasmTableMirror.length) wasmTableMirror.length = funcPtr + 1;\n        wasmTableMirror[funcPtr] = func = wasmTable.get(funcPtr);\n      }\n      assert(\n        wasmTable.get(funcPtr) == func,\n        'JavaScript-side Wasm function table mirror is out of date!',\n      );\n      return func;\n    };\n\n    var UTF16Decoder = typeof TextDecoder != 'undefined' ? new TextDecoder('utf-16le') : undefined;\n    var UTF16ToString = (ptr, maxBytesToRead) => {\n      assert(ptr % 2 == 0, 'Pointer passed to UTF16ToString must be aligned to two bytes!');\n      var endPtr = ptr;\n      // TextDecoder needs to know the byte length in advance, it doesn't stop on\n      // null terminator by itself.\n      // Also, use the length info to avoid running tiny strings through\n      // TextDecoder, since .subarray() allocates garbage.\n      var idx = endPtr >> 1;\n      var maxIdx = idx + maxBytesToRead / 2;\n      // If maxBytesToRead is not passed explicitly, it will be undefined, and this\n      // will always evaluate to true. This saves on code size.\n      while (!(idx >= maxIdx) && HEAPU16[idx]) ++idx;\n      endPtr = idx << 1;\n\n      if (endPtr - ptr > 32 && UTF16Decoder)\n        return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));\n\n      // Fallback: decode without UTF16Decoder\n      var str = '';\n\n      // If maxBytesToRead is not passed explicitly, it will be undefined, and the\n      // for-loop's condition will always evaluate to true. The loop is then\n      // terminated on the first null char.\n      for (var i = 0; !(i >= maxBytesToRead / 2); ++i) {\n        var codeUnit = HEAP16[(ptr + i * 2) >> 1];\n        if (codeUnit == 0) break;\n        // fromCharCode constructs a character from a UTF-16 code unit, so we can\n        // pass the UTF16 string right through.\n        str += String.fromCharCode(codeUnit);\n      }\n\n      return str;\n    };\n\n    var uleb128Encode = (n, target) => {\n      assert(n < 16384);\n      if (n < 128) {\n        target.push(n);\n      } else {\n        target.push(n % 128 | 128, n >> 7);\n      }\n    };\n\n    var sigToWasmTypes = (sig) => {\n      assert(\n        !sig.includes('j'),\n        'i64 not permitted in function signatures when WASM_BIGINT is disabled',\n      );\n      var typeNames = {\n        i: 'i32',\n        j: 'i64',\n        f: 'f32',\n        d: 'f64',\n        e: 'externref',\n        p: 'i32',\n      };\n      var type = {\n        parameters: [],\n        results: sig[0] == 'v' ? [] : [typeNames[sig[0]]],\n      };\n      for (var i = 1; i < sig.length; ++i) {\n        assert(sig[i] in typeNames, 'invalid signature char: ' + sig[i]);\n        type.parameters.push(typeNames[sig[i]]);\n      }\n      return type;\n    };\n\n    var generateFuncType = (sig, target) => {\n      var sigRet = sig.slice(0, 1);\n      var sigParam = sig.slice(1);\n      var typeCodes = {\n        i: 0x7f, // i32\n        p: 0x7f, // i32\n        j: 0x7e, // i64\n        f: 0x7d, // f32\n        d: 0x7c, // f64\n        e: 0x6f, // externref\n      };\n\n      // Parameters, length + signatures\n      target.push(0x60 /* form: func */);\n      uleb128Encode(sigParam.length, target);\n      for (var i = 0; i < sigParam.length; ++i) {\n        assert(sigParam[i] in typeCodes, 'invalid signature char: ' + sigParam[i]);\n        target.push(typeCodes[sigParam[i]]);\n      }\n\n      // Return values, length + signatures\n      // With no multi-return in MVP, either 0 (void) or 1 (anything else)\n      if (sigRet == 'v') {\n        target.push(0x00);\n      } else {\n        target.push(0x01, typeCodes[sigRet]);\n      }\n    };\n    var convertJsFunctionToWasm = (func, sig) => {\n      assert(\n        !sig.includes('j'),\n        'i64 not permitted in function signatures when WASM_BIGINT is disabled',\n      );\n\n      // If the type reflection proposal is available, use the new\n      // \"WebAssembly.Function\" constructor.\n      // Otherwise, construct a minimal wasm module importing the JS function and\n      // re-exporting it.\n      if (typeof WebAssembly.Function == 'function') {\n        return new WebAssembly.Function(sigToWasmTypes(sig), func);\n      }\n\n      // The module is static, with the exception of the type section, which is\n      // generated based on the signature passed in.\n      var typeSectionBody = [\n        0x01, // count: 1\n      ];\n      generateFuncType(sig, typeSectionBody);\n\n      // Rest of the module is static\n      var bytes = [\n        0x00,\n        0x61,\n        0x73,\n        0x6d, // magic (\"\\0asm\")\n        0x01,\n        0x00,\n        0x00,\n        0x00, // version: 1\n        0x01, // Type section code\n      ];\n      // Write the overall length of the type section followed by the body\n      uleb128Encode(typeSectionBody.length, bytes);\n      bytes.push(...typeSectionBody);\n\n      // The rest of the module is static\n      bytes.push(\n        0x02,\n        0x07, // import section\n        // (import \"e\" \"f\" (func 0 (type 0)))\n        0x01,\n        0x01,\n        0x65,\n        0x01,\n        0x66,\n        0x00,\n        0x00,\n        0x07,\n        0x05, // export section\n        // (export \"f\" (func 0 (type 0)))\n        0x01,\n        0x01,\n        0x66,\n        0x00,\n        0x00,\n      );\n\n      // We can compile this wasm module synchronously because it is very small.\n      // This accepts an import (at \"e.f\"), that it reroutes to an export (at \"f\")\n      var module = new WebAssembly.Module(new Uint8Array(bytes));\n      var instance = new WebAssembly.Instance(module, { e: { f: func } });\n      var wrappedFunc = instance.exports['f'];\n      return wrappedFunc;\n    };\n\n    var updateTableMap = (offset, count) => {\n      if (functionsInTableMap) {\n        for (var i = offset; i < offset + count; i++) {\n          var item = getWasmTableEntry(i);\n          // Ignore null values.\n          if (item) {\n            functionsInTableMap.set(item, i);\n          }\n        }\n      }\n    };\n\n    var functionsInTableMap;\n\n    var getFunctionAddress = (func) => {\n      // First, create the map if this is the first use.\n      if (!functionsInTableMap) {\n        functionsInTableMap = new WeakMap();\n        updateTableMap(0, wasmTable.length);\n      }\n      return functionsInTableMap.get(func) || 0;\n    };\n\n    var freeTableIndexes = [];\n\n    var getEmptyTableSlot = () => {\n      // Reuse a free index if there is one, otherwise grow.\n      if (freeTableIndexes.length) {\n        return freeTableIndexes.pop();\n      }\n      // Grow the table\n      try {\n        wasmTable.grow(1);\n      } catch (err) {\n        if (!(err instanceof RangeError)) {\n          throw err;\n        }\n        throw 'Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.';\n      }\n      return wasmTable.length - 1;\n    };\n\n    var setWasmTableEntry = (idx, func) => {\n      wasmTable.set(idx, func);\n      // With ABORT_ON_WASM_EXCEPTIONS wasmTable.get is overridden to return wrapped\n      // functions so we need to call it here to retrieve the potential wrapper correctly\n      // instead of just storing 'func' directly into wasmTableMirror\n      wasmTableMirror[idx] = wasmTable.get(idx);\n    };\n\n    /** @param {string=} sig */\n    var addFunction = (func, sig) => {\n      assert(typeof func != 'undefined');\n      // Check if the function is already in the table, to ensure each function\n      // gets a unique index.\n      var rtn = getFunctionAddress(func);\n      if (rtn) {\n        return rtn;\n      }\n\n      // It's not in the table, add it now.\n\n      var ret = getEmptyTableSlot();\n\n      // Set the new value.\n      try {\n        // Attempting to call this with JS function will cause of table.set() to fail\n        setWasmTableEntry(ret, func);\n      } catch (err) {\n        if (!(err instanceof TypeError)) {\n          throw err;\n        }\n        assert(typeof sig != 'undefined', 'Missing signature argument to addFunction: ' + func);\n        var wrapped = convertJsFunctionToWasm(func, sig);\n        setWasmTableEntry(ret, wrapped);\n      }\n\n      functionsInTableMap.set(func, ret);\n\n      return ret;\n    };\n\n    var getCFunc = (ident) => {\n      var func = Module['_' + ident]; // closure exported function\n      assert(func, 'Cannot call unknown function ' + ident + ', make sure it is exported');\n      return func;\n    };\n\n    var writeArrayToMemory = (array, buffer) => {\n      assert(\n        array.length >= 0,\n        'writeArrayToMemory array must have a length (should be an array or typed array)',\n      );\n      HEAP8.set(array, buffer);\n    };\n\n    var stackAlloc = (sz) => __emscripten_stack_alloc(sz);\n    var stringToUTF8OnStack = (str) => {\n      var size = lengthBytesUTF8(str) + 1;\n      var ret = stackAlloc(size);\n      stringToUTF8(str, ret, size);\n      return ret;\n    };\n\n    /**\n     * @param {string|null=} returnType\n     * @param {Array=} argTypes\n     * @param {Arguments|Array=} args\n     * @param {Object=} opts\n     */\n    var ccall = (ident, returnType, argTypes, args, opts) => {\n      // For fast lookup of conversion functions\n      var toC = {\n        string: (str) => {\n          var ret = 0;\n          if (str !== null && str !== undefined && str !== 0) {\n            // null string\n            ret = stringToUTF8OnStack(str);\n          }\n          return ret;\n        },\n        array: (arr) => {\n          var ret = stackAlloc(arr.length);\n          writeArrayToMemory(arr, ret);\n          return ret;\n        },\n      };\n\n      function convertReturnValue(ret) {\n        if (returnType === 'string') {\n          return UTF8ToString(ret);\n        }\n        if (returnType === 'boolean') return Boolean(ret);\n        return ret;\n      }\n\n      var func = getCFunc(ident);\n      var cArgs = [];\n      var stack = 0;\n      assert(returnType !== 'array', 'Return type should not be \"array\".');\n      if (args) {\n        for (var i = 0; i < args.length; i++) {\n          var converter = toC[argTypes[i]];\n          if (converter) {\n            if (stack === 0) stack = stackSave();\n            cArgs[i] = converter(args[i]);\n          } else {\n            cArgs[i] = args[i];\n          }\n        }\n      }\n      var ret = func(...cArgs);\n      function onDone(ret) {\n        if (stack !== 0) stackRestore(stack);\n        return convertReturnValue(ret);\n      }\n\n      ret = onDone(ret);\n      return ret;\n    };\n\n    /**\n     * @param {string=} returnType\n     * @param {Array=} argTypes\n     * @param {Object=} opts\n     */\n    var cwrap = (ident, returnType, argTypes, opts) => {\n      return (...args) => ccall(ident, returnType, argTypes, args);\n    };\n\n    var removeFunction = (index) => {\n      functionsInTableMap.delete(getWasmTableEntry(index));\n      setWasmTableEntry(index, null);\n      freeTableIndexes.push(index);\n    };\n\n    var stringToUTF16 = (str, outPtr, maxBytesToWrite) => {\n      assert(outPtr % 2 == 0, 'Pointer passed to stringToUTF16 must be aligned to two bytes!');\n      assert(\n        typeof maxBytesToWrite == 'number',\n        'stringToUTF16(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!',\n      );\n      // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.\n      maxBytesToWrite ??= 0x7fffffff;\n      if (maxBytesToWrite < 2) return 0;\n      maxBytesToWrite -= 2; // Null terminator.\n      var startPtr = outPtr;\n      var numCharsToWrite = maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length;\n      for (var i = 0; i < numCharsToWrite; ++i) {\n        // charCodeAt returns a UTF-16 encoded code unit, so it can be directly written to the HEAP.\n        var codeUnit = str.charCodeAt(i); // possibly a lead surrogate\n        HEAP16[outPtr >> 1] = codeUnit;\n        outPtr += 2;\n      }\n      // Null-terminate the pointer to the HEAP.\n      HEAP16[outPtr >> 1] = 0;\n      return outPtr - startPtr;\n    };\n\n    FS.createPreloadedFile = FS_createPreloadedFile;\n    FS.staticInit();\n    // Set module methods based on EXPORTED_RUNTIME_METHODS\n    function checkIncomingModuleAPI() {\n      ignoredModuleProp('fetchSettings');\n    }\n    var wasmImports = {\n      /** @export */\n      __assert_fail: ___assert_fail,\n      /** @export */\n      __syscall_fcntl64: ___syscall_fcntl64,\n      /** @export */\n      __syscall_fstat64: ___syscall_fstat64,\n      /** @export */\n      __syscall_ftruncate64: ___syscall_ftruncate64,\n      /** @export */\n      __syscall_getdents64: ___syscall_getdents64,\n      /** @export */\n      __syscall_ioctl: ___syscall_ioctl,\n      /** @export */\n      __syscall_lstat64: ___syscall_lstat64,\n      /** @export */\n      __syscall_newfstatat: ___syscall_newfstatat,\n      /** @export */\n      __syscall_openat: ___syscall_openat,\n      /** @export */\n      __syscall_rmdir: ___syscall_rmdir,\n      /** @export */\n      __syscall_stat64: ___syscall_stat64,\n      /** @export */\n      __syscall_unlinkat: ___syscall_unlinkat,\n      /** @export */\n      _abort_js: __abort_js,\n      /** @export */\n      _emscripten_memcpy_js: __emscripten_memcpy_js,\n      /** @export */\n      _emscripten_throw_longjmp: __emscripten_throw_longjmp,\n      /** @export */\n      _gmtime_js: __gmtime_js,\n      /** @export */\n      _localtime_js: __localtime_js,\n      /** @export */\n      _tzset_js: __tzset_js,\n      /** @export */\n      emscripten_date_now: _emscripten_date_now,\n      /** @export */\n      emscripten_resize_heap: _emscripten_resize_heap,\n      /** @export */\n      environ_get: _environ_get,\n      /** @export */\n      environ_sizes_get: _environ_sizes_get,\n      /** @export */\n      fd_close: _fd_close,\n      /** @export */\n      fd_read: _fd_read,\n      /** @export */\n      fd_seek: _fd_seek,\n      /** @export */\n      fd_sync: _fd_sync,\n      /** @export */\n      fd_write: _fd_write,\n      /** @export */\n      invoke_ii,\n      /** @export */\n      invoke_iii,\n      /** @export */\n      invoke_iiii,\n      /** @export */\n      invoke_iiiii,\n      /** @export */\n      invoke_v,\n      /** @export */\n      invoke_viii,\n      /** @export */\n      invoke_viiii,\n    };\n    var wasmExports = createWasm();\n    (Module['_PDFiumExt_Init'] = createExportWrapper('PDFiumExt_Init', 0));\n    (Module['_FPDF_InitLibraryWithConfig'] = createExportWrapper(\n      'FPDF_InitLibraryWithConfig',\n      1,\n    ));\n    (Module['_PDFiumExt_OpenFileWriter'] = createExportWrapper(\n      'PDFiumExt_OpenFileWriter',\n      0,\n    ));\n    (Module['_PDFiumExt_GetFileWriterSize'] =\n      createExportWrapper('PDFiumExt_GetFileWriterSize', 1));\n    (Module['_PDFiumExt_GetFileWriterData'] =\n      createExportWrapper('PDFiumExt_GetFileWriterData', 3));\n    (Module['_PDFiumExt_CloseFileWriter'] = createExportWrapper(\n      'PDFiumExt_CloseFileWriter',\n      1,\n    ));\n    (Module['_PDFiumExt_SaveAsCopy'] = createExportWrapper(\n      'PDFiumExt_SaveAsCopy',\n      2,\n    ));\n    (Module['_FPDF_SaveAsCopy'] = createExportWrapper('FPDF_SaveAsCopy', 3));\n    (Module['_PDFiumExt_OpenFormFillInfo'] = createExportWrapper(\n      'PDFiumExt_OpenFormFillInfo',\n      0,\n    ));\n    (Module['_PDFiumExt_CloseFormFillInfo'] =\n      createExportWrapper('PDFiumExt_CloseFormFillInfo', 1));\n    (Module['_PDFiumExt_InitFormFillEnvironment'] =\n      createExportWrapper('PDFiumExt_InitFormFillEnvironment', 2));\n    (Module['_FPDFDOC_InitFormFillEnvironment'] =\n      createExportWrapper('FPDFDOC_InitFormFillEnvironment', 2));\n    (Module['_PDFiumExt_ExitFormFillEnvironment'] =\n      createExportWrapper('PDFiumExt_ExitFormFillEnvironment', 1));\n    (Module['_FPDFDOC_ExitFormFillEnvironment'] =\n      createExportWrapper('FPDFDOC_ExitFormFillEnvironment', 1));\n    (Module['_FPDFAnnot_IsSupportedSubtype'] =\n      createExportWrapper('FPDFAnnot_IsSupportedSubtype', 1));\n    (Module['_FPDFPage_CreateAnnot'] = createExportWrapper(\n      'FPDFPage_CreateAnnot',\n      2,\n    ));\n    (Module['_FPDFPage_GetAnnotCount'] = createExportWrapper(\n      'FPDFPage_GetAnnotCount',\n      1,\n    ));\n    (Module['_FPDFPage_GetAnnot'] = createExportWrapper(\n      'FPDFPage_GetAnnot',\n      2,\n    ));\n    (Module['_FPDFPage_GetAnnotIndex'] = createExportWrapper(\n      'FPDFPage_GetAnnotIndex',\n      2,\n    ));\n    (Module['_FPDFPage_CloseAnnot'] = createExportWrapper(\n      'FPDFPage_CloseAnnot',\n      1,\n    ));\n    (Module['_FPDFPage_RemoveAnnot'] = createExportWrapper(\n      'FPDFPage_RemoveAnnot',\n      2,\n    ));\n    (Module['_FPDFAnnot_GetSubtype'] = createExportWrapper(\n      'FPDFAnnot_GetSubtype',\n      1,\n    ));\n    (Module['_FPDFAnnot_IsObjectSupportedSubtype'] =\n      createExportWrapper('FPDFAnnot_IsObjectSupportedSubtype', 1));\n    (Module['_FPDFAnnot_UpdateObject'] = createExportWrapper(\n      'FPDFAnnot_UpdateObject',\n      2,\n    ));\n    (Module['_FPDFAnnot_AddInkStroke'] = createExportWrapper(\n      'FPDFAnnot_AddInkStroke',\n      3,\n    ));\n    (Module['_FPDFAnnot_RemoveInkList'] = createExportWrapper(\n      'FPDFAnnot_RemoveInkList',\n      1,\n    ));\n    (Module['_FPDFAnnot_AppendObject'] = createExportWrapper(\n      'FPDFAnnot_AppendObject',\n      2,\n    ));\n    (Module['_FPDFAnnot_GetObjectCount'] = createExportWrapper(\n      'FPDFAnnot_GetObjectCount',\n      1,\n    ));\n    (Module['_FPDFAnnot_GetObject'] = createExportWrapper(\n      'FPDFAnnot_GetObject',\n      2,\n    ));\n    (Module['_FPDFAnnot_RemoveObject'] = createExportWrapper(\n      'FPDFAnnot_RemoveObject',\n      2,\n    ));\n    (Module['_FPDFAnnot_SetColor'] = createExportWrapper(\n      'FPDFAnnot_SetColor',\n      6,\n    ));\n    (Module['_FPDFAnnot_GetColor'] = createExportWrapper(\n      'FPDFAnnot_GetColor',\n      6,\n    ));\n    (Module['_FPDFAnnot_HasAttachmentPoints'] =\n      createExportWrapper('FPDFAnnot_HasAttachmentPoints', 1));\n    (Module['_FPDFAnnot_SetAttachmentPoints'] =\n      createExportWrapper('FPDFAnnot_SetAttachmentPoints', 3));\n    (Module['_FPDFAnnot_AppendAttachmentPoints'] =\n      createExportWrapper('FPDFAnnot_AppendAttachmentPoints', 2));\n    (Module['_FPDFAnnot_CountAttachmentPoints'] =\n      createExportWrapper('FPDFAnnot_CountAttachmentPoints', 1));\n    (Module['_FPDFAnnot_GetAttachmentPoints'] =\n      createExportWrapper('FPDFAnnot_GetAttachmentPoints', 3));\n    (Module['_FPDFAnnot_SetRect'] = createExportWrapper(\n      'FPDFAnnot_SetRect',\n      2,\n    ));\n    (Module['_FPDFAnnot_GetRect'] = createExportWrapper(\n      'FPDFAnnot_GetRect',\n      2,\n    ));\n    (Module['_FPDFAnnot_GetVertices'] = createExportWrapper(\n      'FPDFAnnot_GetVertices',\n      3,\n    ));\n    (Module['_FPDFAnnot_GetInkListCount'] = createExportWrapper(\n      'FPDFAnnot_GetInkListCount',\n      1,\n    ));\n    (Module['_FPDFAnnot_GetInkListPath'] = createExportWrapper(\n      'FPDFAnnot_GetInkListPath',\n      4,\n    ));\n    (Module['_FPDFAnnot_GetLine'] = createExportWrapper(\n      'FPDFAnnot_GetLine',\n      3,\n    ));\n    (Module['_FPDFAnnot_SetBorder'] = createExportWrapper(\n      'FPDFAnnot_SetBorder',\n      4,\n    ));\n    (Module['_FPDFAnnot_GetBorder'] = createExportWrapper(\n      'FPDFAnnot_GetBorder',\n      4,\n    ));\n    (Module['_FPDFAnnot_HasKey'] = createExportWrapper(\n      'FPDFAnnot_HasKey',\n      2,\n    ));\n    (Module['_FPDFAnnot_GetValueType'] = createExportWrapper(\n      'FPDFAnnot_GetValueType',\n      2,\n    ));\n    (Module['_FPDFAnnot_SetStringValue'] = createExportWrapper(\n      'FPDFAnnot_SetStringValue',\n      3,\n    ));\n    (Module['_FPDFAnnot_GetStringValue'] = createExportWrapper(\n      'FPDFAnnot_GetStringValue',\n      4,\n    ));\n    (Module['_FPDFAnnot_GetNumberValue'] = createExportWrapper(\n      'FPDFAnnot_GetNumberValue',\n      3,\n    ));\n    (Module['_FPDFAnnot_SetAP'] = createExportWrapper('FPDFAnnot_SetAP', 3));\n    (Module['_FPDFAnnot_GetAP'] = createExportWrapper('FPDFAnnot_GetAP', 4));\n    (Module['_FPDFAnnot_GetLinkedAnnot'] = createExportWrapper(\n      'FPDFAnnot_GetLinkedAnnot',\n      2,\n    ));\n    (Module['_FPDFAnnot_GetFlags'] = createExportWrapper(\n      'FPDFAnnot_GetFlags',\n      1,\n    ));\n    (Module['_FPDFAnnot_SetFlags'] = createExportWrapper(\n      'FPDFAnnot_SetFlags',\n      2,\n    ));\n    (Module['_FPDFAnnot_GetFormFieldFlags'] =\n      createExportWrapper('FPDFAnnot_GetFormFieldFlags', 2));\n    (Module['_FPDFAnnot_SetFormFieldFlags'] =\n      createExportWrapper('FPDFAnnot_SetFormFieldFlags', 3));\n    (Module['_FPDFAnnot_GetFormFieldAtPoint'] =\n      createExportWrapper('FPDFAnnot_GetFormFieldAtPoint', 3));\n    (Module['_FPDFAnnot_GetFormFieldName'] = createExportWrapper(\n      'FPDFAnnot_GetFormFieldName',\n      4,\n    ));\n    (Module['_FPDFAnnot_GetFormFieldType'] = createExportWrapper(\n      'FPDFAnnot_GetFormFieldType',\n      2,\n    ));\n    (Module[\n      '_FPDFAnnot_GetFormAdditionalActionJavaScript'\n    ] = createExportWrapper('FPDFAnnot_GetFormAdditionalActionJavaScript', 5));\n    (Module['_FPDFAnnot_GetFormFieldAlternateName'] =\n      createExportWrapper('FPDFAnnot_GetFormFieldAlternateName', 4));\n    (Module['_FPDFAnnot_GetFormFieldValue'] =\n      createExportWrapper('FPDFAnnot_GetFormFieldValue', 4));\n    (Module['_FPDFAnnot_GetOptionCount'] = createExportWrapper(\n      'FPDFAnnot_GetOptionCount',\n      2,\n    ));\n    (Module['_FPDFAnnot_GetOptionLabel'] = createExportWrapper(\n      'FPDFAnnot_GetOptionLabel',\n      5,\n    ));\n    (Module['_FPDFAnnot_IsOptionSelected'] = createExportWrapper(\n      'FPDFAnnot_IsOptionSelected',\n      3,\n    ));\n    (Module['_FPDFAnnot_GetFontSize'] = createExportWrapper(\n      'FPDFAnnot_GetFontSize',\n      3,\n    ));\n    (Module['_FPDFAnnot_SetFontColor'] = createExportWrapper(\n      'FPDFAnnot_SetFontColor',\n      5,\n    ));\n    (Module['_FPDFAnnot_GetFontColor'] = createExportWrapper(\n      'FPDFAnnot_GetFontColor',\n      5,\n    ));\n    (Module['_FPDFAnnot_IsChecked'] = createExportWrapper(\n      'FPDFAnnot_IsChecked',\n      2,\n    ));\n    (Module['_FPDFAnnot_SetFocusableSubtypes'] =\n      createExportWrapper('FPDFAnnot_SetFocusableSubtypes', 3));\n    (Module['_FPDFAnnot_GetFocusableSubtypesCount'] =\n      createExportWrapper('FPDFAnnot_GetFocusableSubtypesCount', 1));\n    (Module['_FPDFAnnot_GetFocusableSubtypes'] =\n      createExportWrapper('FPDFAnnot_GetFocusableSubtypes', 3));\n    (Module['_FPDFAnnot_GetLink'] = createExportWrapper(\n      'FPDFAnnot_GetLink',\n      1,\n    ));\n    (Module['_FPDFAnnot_GetFormControlCount'] =\n      createExportWrapper('FPDFAnnot_GetFormControlCount', 2));\n    (Module['_FPDFAnnot_GetFormControlIndex'] =\n      createExportWrapper('FPDFAnnot_GetFormControlIndex', 2));\n    (Module['_FPDFAnnot_GetFormFieldExportValue'] =\n      createExportWrapper('FPDFAnnot_GetFormFieldExportValue', 4));\n    (Module['_FPDFAnnot_SetURI'] = createExportWrapper(\n      'FPDFAnnot_SetURI',\n      2,\n    ));\n    (Module['_FPDFAnnot_GetFileAttachment'] =\n      createExportWrapper('FPDFAnnot_GetFileAttachment', 1));\n    (Module['_FPDFAnnot_AddFileAttachment'] =\n      createExportWrapper('FPDFAnnot_AddFileAttachment', 2));\n    (Module['_EPDFAnnot_SetColor'] = createExportWrapper(\n      'EPDFAnnot_SetColor',\n      6,\n    ));\n    (Module['_EPDFAnnot_GetColor'] = createExportWrapper(\n      'EPDFAnnot_GetColor',\n      6,\n    ));\n    (Module['_EPDFAnnot_GetBorderEffect'] = createExportWrapper(\n      'EPDFAnnot_GetBorderEffect',\n      2,\n    ));\n    (Module['_EPDFAnnot_GetRectangleDifferences'] =\n      createExportWrapper('EPDFAnnot_GetRectangleDifferences', 5));\n    (Module['_EPDFAnnot_GetBorderDashPatternCount'] =\n      createExportWrapper('EPDFAnnot_GetBorderDashPatternCount', 1));\n    (Module['_EPDFAnnot_GetBorderDashPattern'] =\n      createExportWrapper('EPDFAnnot_GetBorderDashPattern', 3));\n    (Module['_EPDFAnnot_GetBorderStyle'] = createExportWrapper(\n      'EPDFAnnot_GetBorderStyle',\n      2,\n    ));\n    (Module['_EPDFAnnot_SetBorderStyle'] = createExportWrapper(\n      'EPDFAnnot_SetBorderStyle',\n      3,\n    ));\n    (Module['_EPDFAnnot_GenerateAppearance'] =\n      createExportWrapper('EPDFAnnot_GenerateAppearance', 1));\n    (Module['_EPDFAnnot_GenerateAppearanceWithBlend'] =\n      createExportWrapper('EPDFAnnot_GenerateAppearanceWithBlend', 2));\n    (Module['_EPDFAnnot_GetBlendMode'] = createExportWrapper(\n      'EPDFAnnot_GetBlendMode',\n      1,\n    ));\n    (Module['_EPDFAnnot_SetIntent'] = createExportWrapper(\n      'EPDFAnnot_SetIntent',\n      2,\n    ));\n    (Module['_EPDFAnnot_GetIntent'] = createExportWrapper(\n      'EPDFAnnot_GetIntent',\n      3,\n    ));\n    (Module['_EPDFAnnot_GetRichContent'] = createExportWrapper(\n      'EPDFAnnot_GetRichContent',\n      3,\n    ));\n    (Module['_FPDFDoc_GetAttachmentCount'] = createExportWrapper(\n      'FPDFDoc_GetAttachmentCount',\n      1,\n    ));\n    (Module['_FPDFDoc_AddAttachment'] = createExportWrapper(\n      'FPDFDoc_AddAttachment',\n      2,\n    ));\n    (Module['_FPDFDoc_GetAttachment'] = createExportWrapper(\n      'FPDFDoc_GetAttachment',\n      2,\n    ));\n    (Module['_FPDFDoc_DeleteAttachment'] = createExportWrapper(\n      'FPDFDoc_DeleteAttachment',\n      2,\n    ));\n    (Module['_FPDFAttachment_GetName'] = createExportWrapper(\n      'FPDFAttachment_GetName',\n      3,\n    ));\n    (Module['_FPDFAttachment_HasKey'] = createExportWrapper(\n      'FPDFAttachment_HasKey',\n      2,\n    ));\n    (Module['_FPDFAttachment_GetValueType'] =\n      createExportWrapper('FPDFAttachment_GetValueType', 2));\n    (Module['_FPDFAttachment_SetStringValue'] =\n      createExportWrapper('FPDFAttachment_SetStringValue', 3));\n    (Module['_FPDFAttachment_GetStringValue'] =\n      createExportWrapper('FPDFAttachment_GetStringValue', 4));\n    (Module['_FPDFAttachment_SetFile'] = createExportWrapper(\n      'FPDFAttachment_SetFile',\n      4,\n    ));\n    (Module['_FPDFAttachment_GetFile'] = createExportWrapper(\n      'FPDFAttachment_GetFile',\n      4,\n    ));\n    (Module['_FPDFAttachment_GetSubtype'] = createExportWrapper(\n      'FPDFAttachment_GetSubtype',\n      3,\n    ));\n    (Module['_FPDFCatalog_IsTagged'] = createExportWrapper(\n      'FPDFCatalog_IsTagged',\n      1,\n    ));\n    (Module['_FPDFCatalog_SetLanguage'] = createExportWrapper(\n      'FPDFCatalog_SetLanguage',\n      2,\n    ));\n    (Module['_FPDFAvail_Create'] = createExportWrapper(\n      'FPDFAvail_Create',\n      2,\n    ));\n    (Module['_FPDFAvail_Destroy'] = createExportWrapper(\n      'FPDFAvail_Destroy',\n      1,\n    ));\n    (Module['_FPDFAvail_IsDocAvail'] = createExportWrapper(\n      'FPDFAvail_IsDocAvail',\n      2,\n    ));\n    (Module['_FPDFAvail_GetDocument'] = createExportWrapper(\n      'FPDFAvail_GetDocument',\n      2,\n    ));\n    (Module['_FPDFAvail_GetFirstPageNum'] = createExportWrapper(\n      'FPDFAvail_GetFirstPageNum',\n      1,\n    ));\n    (Module['_FPDFAvail_IsPageAvail'] = createExportWrapper(\n      'FPDFAvail_IsPageAvail',\n      3,\n    ));\n    (Module['_FPDFAvail_IsFormAvail'] = createExportWrapper(\n      'FPDFAvail_IsFormAvail',\n      2,\n    ));\n    (Module['_FPDFAvail_IsLinearized'] = createExportWrapper(\n      'FPDFAvail_IsLinearized',\n      1,\n    ));\n    (Module['_FPDFBookmark_GetFirstChild'] = createExportWrapper(\n      'FPDFBookmark_GetFirstChild',\n      2,\n    ));\n    (Module['_FPDFBookmark_GetNextSibling'] =\n      createExportWrapper('FPDFBookmark_GetNextSibling', 2));\n    (Module['_FPDFBookmark_GetTitle'] = createExportWrapper(\n      'FPDFBookmark_GetTitle',\n      3,\n    ));\n    (Module['_FPDFBookmark_GetCount'] = createExportWrapper(\n      'FPDFBookmark_GetCount',\n      1,\n    ));\n    (Module['_FPDFBookmark_Find'] = createExportWrapper(\n      'FPDFBookmark_Find',\n      2,\n    ));\n    (Module['_FPDFBookmark_GetDest'] = createExportWrapper(\n      'FPDFBookmark_GetDest',\n      2,\n    ));\n    (Module['_FPDFBookmark_GetAction'] = createExportWrapper(\n      'FPDFBookmark_GetAction',\n      1,\n    ));\n    (Module['_FPDFAction_GetType'] = createExportWrapper(\n      'FPDFAction_GetType',\n      1,\n    ));\n    (Module['_FPDFAction_GetDest'] = createExportWrapper(\n      'FPDFAction_GetDest',\n      2,\n    ));\n    (Module['_FPDFAction_GetFilePath'] = createExportWrapper(\n      'FPDFAction_GetFilePath',\n      3,\n    ));\n    (Module['_FPDFAction_GetURIPath'] = createExportWrapper(\n      'FPDFAction_GetURIPath',\n      4,\n    ));\n    (Module['_FPDFDest_GetDestPageIndex'] = createExportWrapper(\n      'FPDFDest_GetDestPageIndex',\n      2,\n    ));\n    (Module['_FPDFDest_GetView'] = createExportWrapper(\n      'FPDFDest_GetView',\n      3,\n    ));\n    (Module['_FPDFDest_GetLocationInPage'] = createExportWrapper(\n      'FPDFDest_GetLocationInPage',\n      7,\n    ));\n    (Module['_FPDFLink_GetLinkAtPoint'] = createExportWrapper(\n      'FPDFLink_GetLinkAtPoint',\n      3,\n    ));\n    (Module['_FPDFLink_GetLinkZOrderAtPoint'] =\n      createExportWrapper('FPDFLink_GetLinkZOrderAtPoint', 3));\n    (Module['_FPDFLink_GetDest'] = createExportWrapper(\n      'FPDFLink_GetDest',\n      2,\n    ));\n    (Module['_FPDFLink_GetAction'] = createExportWrapper(\n      'FPDFLink_GetAction',\n      1,\n    ));\n    (Module['_FPDFLink_Enumerate'] = createExportWrapper(\n      'FPDFLink_Enumerate',\n      3,\n    ));\n    (Module['_FPDFLink_GetAnnot'] = createExportWrapper(\n      'FPDFLink_GetAnnot',\n      2,\n    ));\n    (Module['_FPDFLink_GetAnnotRect'] = createExportWrapper(\n      'FPDFLink_GetAnnotRect',\n      2,\n    ));\n    (Module['_FPDFLink_CountQuadPoints'] = createExportWrapper(\n      'FPDFLink_CountQuadPoints',\n      1,\n    ));\n    (Module['_FPDFLink_GetQuadPoints'] = createExportWrapper(\n      'FPDFLink_GetQuadPoints',\n      3,\n    ));\n    (Module['_FPDF_GetPageAAction'] = createExportWrapper(\n      'FPDF_GetPageAAction',\n      2,\n    ));\n    (Module['_FPDF_GetFileIdentifier'] = createExportWrapper(\n      'FPDF_GetFileIdentifier',\n      4,\n    ));\n    (Module['_FPDF_GetMetaText'] = createExportWrapper(\n      'FPDF_GetMetaText',\n      4,\n    ));\n    (Module['_FPDF_GetPageLabel'] = createExportWrapper(\n      'FPDF_GetPageLabel',\n      4,\n    ));\n    (Module['_FPDFPageObj_NewImageObj'] = createExportWrapper(\n      'FPDFPageObj_NewImageObj',\n      1,\n    ));\n    (Module['_FPDFImageObj_LoadJpegFile'] = createExportWrapper(\n      'FPDFImageObj_LoadJpegFile',\n      4,\n    ));\n    (Module['_FPDFImageObj_LoadJpegFileInline'] =\n      createExportWrapper('FPDFImageObj_LoadJpegFileInline', 4));\n    (Module['_FPDFImageObj_SetMatrix'] = createExportWrapper(\n      'FPDFImageObj_SetMatrix',\n      7,\n    ));\n    (Module['_FPDFImageObj_SetBitmap'] = createExportWrapper(\n      'FPDFImageObj_SetBitmap',\n      4,\n    ));\n    (Module['_FPDFImageObj_GetBitmap'] = createExportWrapper(\n      'FPDFImageObj_GetBitmap',\n      1,\n    ));\n    (Module['_FPDFImageObj_GetRenderedBitmap'] =\n      createExportWrapper('FPDFImageObj_GetRenderedBitmap', 3));\n    (Module['_FPDFImageObj_GetImageDataDecoded'] =\n      createExportWrapper('FPDFImageObj_GetImageDataDecoded', 3));\n    (Module['_FPDFImageObj_GetImageDataRaw'] =\n      createExportWrapper('FPDFImageObj_GetImageDataRaw', 3));\n    (Module['_FPDFImageObj_GetImageFilterCount'] =\n      createExportWrapper('FPDFImageObj_GetImageFilterCount', 1));\n    (Module['_FPDFImageObj_GetImageFilter'] =\n      createExportWrapper('FPDFImageObj_GetImageFilter', 4));\n    (Module['_FPDFImageObj_GetImageMetadata'] =\n      createExportWrapper('FPDFImageObj_GetImageMetadata', 3));\n    (Module['_FPDFImageObj_GetImagePixelSize'] =\n      createExportWrapper('FPDFImageObj_GetImagePixelSize', 3));\n    (Module['_FPDFImageObj_GetIccProfileDataDecoded'] =\n      createExportWrapper('FPDFImageObj_GetIccProfileDataDecoded', 5));\n    (Module['_FPDF_CreateNewDocument'] = createExportWrapper(\n      'FPDF_CreateNewDocument',\n      0,\n    ));\n    (Module['_FPDFPage_Delete'] = createExportWrapper('FPDFPage_Delete', 2));\n    (Module['_FPDF_MovePages'] = createExportWrapper('FPDF_MovePages', 4));\n    (Module['_FPDFPage_New'] = createExportWrapper('FPDFPage_New', 4));\n    (Module['_FPDFPage_GetRotation'] = createExportWrapper(\n      'FPDFPage_GetRotation',\n      1,\n    ));\n    (Module['_FPDFPage_InsertObject'] = createExportWrapper(\n      'FPDFPage_InsertObject',\n      2,\n    ));\n    (Module['_FPDFPage_InsertObjectAtIndex'] =\n      createExportWrapper('FPDFPage_InsertObjectAtIndex', 3));\n    (Module['_FPDFPage_RemoveObject'] = createExportWrapper(\n      'FPDFPage_RemoveObject',\n      2,\n    ));\n    (Module['_FPDFPage_CountObjects'] = createExportWrapper(\n      'FPDFPage_CountObjects',\n      1,\n    ));\n    (Module['_FPDFPage_GetObject'] = createExportWrapper(\n      'FPDFPage_GetObject',\n      2,\n    ));\n    (Module['_FPDFPage_HasTransparency'] = createExportWrapper(\n      'FPDFPage_HasTransparency',\n      1,\n    ));\n    (Module['_FPDFPageObj_Destroy'] = createExportWrapper(\n      'FPDFPageObj_Destroy',\n      1,\n    ));\n    (Module['_FPDFPageObj_GetMarkedContentID'] =\n      createExportWrapper('FPDFPageObj_GetMarkedContentID', 1));\n    (Module['_FPDFPageObj_CountMarks'] = createExportWrapper(\n      'FPDFPageObj_CountMarks',\n      1,\n    ));\n    (Module['_FPDFPageObj_GetMark'] = createExportWrapper(\n      'FPDFPageObj_GetMark',\n      2,\n    ));\n    (Module['_FPDFPageObj_AddMark'] = createExportWrapper(\n      'FPDFPageObj_AddMark',\n      2,\n    ));\n    (Module['_FPDFPageObj_RemoveMark'] = createExportWrapper(\n      'FPDFPageObj_RemoveMark',\n      2,\n    ));\n    (Module['_FPDFPageObjMark_GetName'] = createExportWrapper(\n      'FPDFPageObjMark_GetName',\n      4,\n    ));\n    (Module['_FPDFPageObjMark_CountParams'] =\n      createExportWrapper('FPDFPageObjMark_CountParams', 1));\n    (Module['_FPDFPageObjMark_GetParamKey'] =\n      createExportWrapper('FPDFPageObjMark_GetParamKey', 5));\n    (Module['_FPDFPageObjMark_GetParamValueType'] =\n      createExportWrapper('FPDFPageObjMark_GetParamValueType', 2));\n    (Module['_FPDFPageObjMark_GetParamIntValue'] =\n      createExportWrapper('FPDFPageObjMark_GetParamIntValue', 3));\n    (Module['_FPDFPageObjMark_GetParamStringValue'] =\n      createExportWrapper('FPDFPageObjMark_GetParamStringValue', 5));\n    (Module['_FPDFPageObjMark_GetParamBlobValue'] =\n      createExportWrapper('FPDFPageObjMark_GetParamBlobValue', 5));\n    (Module['_FPDFPageObj_HasTransparency'] =\n      createExportWrapper('FPDFPageObj_HasTransparency', 1));\n    (Module['_FPDFPageObjMark_SetIntParam'] =\n      createExportWrapper('FPDFPageObjMark_SetIntParam', 5));\n    (Module['_FPDFPageObjMark_SetStringParam'] =\n      createExportWrapper('FPDFPageObjMark_SetStringParam', 5));\n    (Module['_FPDFPageObjMark_SetBlobParam'] =\n      createExportWrapper('FPDFPageObjMark_SetBlobParam', 6));\n    (Module['_FPDFPageObjMark_RemoveParam'] =\n      createExportWrapper('FPDFPageObjMark_RemoveParam', 3));\n    (Module['_FPDFPageObj_GetType'] = createExportWrapper(\n      'FPDFPageObj_GetType',\n      1,\n    ));\n    (Module['_FPDFPageObj_GetIsActive'] = createExportWrapper(\n      'FPDFPageObj_GetIsActive',\n      2,\n    ));\n    (Module['_FPDFPageObj_SetIsActive'] = createExportWrapper(\n      'FPDFPageObj_SetIsActive',\n      2,\n    ));\n    (Module['_FPDFPage_GenerateContent'] = createExportWrapper(\n      'FPDFPage_GenerateContent',\n      1,\n    ));\n    (Module['_FPDFPageObj_Transform'] = createExportWrapper(\n      'FPDFPageObj_Transform',\n      7,\n    ));\n    (Module['_FPDFPageObj_TransformF'] = createExportWrapper(\n      'FPDFPageObj_TransformF',\n      2,\n    ));\n    (Module['_FPDFPageObj_GetMatrix'] = createExportWrapper(\n      'FPDFPageObj_GetMatrix',\n      2,\n    ));\n    (Module['_FPDFPageObj_SetMatrix'] = createExportWrapper(\n      'FPDFPageObj_SetMatrix',\n      2,\n    ));\n    (Module['_FPDFPageObj_SetBlendMode'] = createExportWrapper(\n      'FPDFPageObj_SetBlendMode',\n      2,\n    ));\n    (Module['_FPDFPage_TransformAnnots'] = createExportWrapper(\n      'FPDFPage_TransformAnnots',\n      7,\n    ));\n    (Module['_FPDFPage_SetRotation'] = createExportWrapper(\n      'FPDFPage_SetRotation',\n      2,\n    ));\n    (Module['_FPDFPageObj_SetFillColor'] = createExportWrapper(\n      'FPDFPageObj_SetFillColor',\n      5,\n    ));\n    (Module['_FPDFPageObj_GetFillColor'] = createExportWrapper(\n      'FPDFPageObj_GetFillColor',\n      5,\n    ));\n    (Module['_FPDFPageObj_GetBounds'] = createExportWrapper(\n      'FPDFPageObj_GetBounds',\n      5,\n    ));\n    (Module['_FPDFPageObj_GetRotatedBounds'] =\n      createExportWrapper('FPDFPageObj_GetRotatedBounds', 2));\n    (Module['_FPDFPageObj_SetStrokeColor'] = createExportWrapper(\n      'FPDFPageObj_SetStrokeColor',\n      5,\n    ));\n    (Module['_FPDFPageObj_GetStrokeColor'] = createExportWrapper(\n      'FPDFPageObj_GetStrokeColor',\n      5,\n    ));\n    (Module['_FPDFPageObj_SetStrokeWidth'] = createExportWrapper(\n      'FPDFPageObj_SetStrokeWidth',\n      2,\n    ));\n    (Module['_FPDFPageObj_GetStrokeWidth'] = createExportWrapper(\n      'FPDFPageObj_GetStrokeWidth',\n      2,\n    ));\n    (Module['_FPDFPageObj_GetLineJoin'] = createExportWrapper(\n      'FPDFPageObj_GetLineJoin',\n      1,\n    ));\n    (Module['_FPDFPageObj_SetLineJoin'] = createExportWrapper(\n      'FPDFPageObj_SetLineJoin',\n      2,\n    ));\n    (Module['_FPDFPageObj_GetLineCap'] = createExportWrapper(\n      'FPDFPageObj_GetLineCap',\n      1,\n    ));\n    (Module['_FPDFPageObj_SetLineCap'] = createExportWrapper(\n      'FPDFPageObj_SetLineCap',\n      2,\n    ));\n    (Module['_FPDFPageObj_GetDashPhase'] = createExportWrapper(\n      'FPDFPageObj_GetDashPhase',\n      2,\n    ));\n    (Module['_FPDFPageObj_SetDashPhase'] = createExportWrapper(\n      'FPDFPageObj_SetDashPhase',\n      2,\n    ));\n    (Module['_FPDFPageObj_GetDashCount'] = createExportWrapper(\n      'FPDFPageObj_GetDashCount',\n      1,\n    ));\n    (Module['_FPDFPageObj_GetDashArray'] = createExportWrapper(\n      'FPDFPageObj_GetDashArray',\n      3,\n    ));\n    (Module['_FPDFPageObj_SetDashArray'] = createExportWrapper(\n      'FPDFPageObj_SetDashArray',\n      4,\n    ));\n    (Module['_FPDFFormObj_CountObjects'] = createExportWrapper(\n      'FPDFFormObj_CountObjects',\n      1,\n    ));\n    (Module['_FPDFFormObj_GetObject'] = createExportWrapper(\n      'FPDFFormObj_GetObject',\n      2,\n    ));\n    (Module['_FPDFFormObj_RemoveObject'] = createExportWrapper(\n      'FPDFFormObj_RemoveObject',\n      2,\n    ));\n    (Module['_FPDFPageObj_CreateNewPath'] = createExportWrapper(\n      'FPDFPageObj_CreateNewPath',\n      2,\n    ));\n    (Module['_FPDFPageObj_CreateNewRect'] = createExportWrapper(\n      'FPDFPageObj_CreateNewRect',\n      4,\n    ));\n    (Module['_FPDFPath_CountSegments'] = createExportWrapper(\n      'FPDFPath_CountSegments',\n      1,\n    ));\n    (Module['_FPDFPath_GetPathSegment'] = createExportWrapper(\n      'FPDFPath_GetPathSegment',\n      2,\n    ));\n    (Module['_FPDFPath_MoveTo'] = createExportWrapper('FPDFPath_MoveTo', 3));\n    (Module['_FPDFPath_LineTo'] = createExportWrapper('FPDFPath_LineTo', 3));\n    (Module['_FPDFPath_BezierTo'] = createExportWrapper(\n      'FPDFPath_BezierTo',\n      7,\n    ));\n    (Module['_FPDFPath_Close'] = createExportWrapper('FPDFPath_Close', 1));\n    (Module['_FPDFPath_SetDrawMode'] = createExportWrapper(\n      'FPDFPath_SetDrawMode',\n      3,\n    ));\n    (Module['_FPDFPath_GetDrawMode'] = createExportWrapper(\n      'FPDFPath_GetDrawMode',\n      3,\n    ));\n    (Module['_FPDFPathSegment_GetPoint'] = createExportWrapper(\n      'FPDFPathSegment_GetPoint',\n      3,\n    ));\n    (Module['_FPDFPathSegment_GetType'] = createExportWrapper(\n      'FPDFPathSegment_GetType',\n      1,\n    ));\n    (Module['_FPDFPathSegment_GetClose'] = createExportWrapper(\n      'FPDFPathSegment_GetClose',\n      1,\n    ));\n    (Module['_FPDFPageObj_NewTextObj'] = createExportWrapper(\n      'FPDFPageObj_NewTextObj',\n      3,\n    ));\n    (Module['_FPDFText_SetText'] = createExportWrapper(\n      'FPDFText_SetText',\n      2,\n    ));\n    (Module['_FPDFText_SetCharcodes'] = createExportWrapper(\n      'FPDFText_SetCharcodes',\n      3,\n    ));\n    (Module['_FPDFText_LoadFont'] = createExportWrapper(\n      'FPDFText_LoadFont',\n      5,\n    ));\n    (Module['_FPDFText_LoadStandardFont'] = createExportWrapper(\n      'FPDFText_LoadStandardFont',\n      2,\n    ));\n    (Module['_FPDFText_LoadCidType2Font'] = createExportWrapper(\n      'FPDFText_LoadCidType2Font',\n      6,\n    ));\n    (Module['_FPDFTextObj_GetFontSize'] = createExportWrapper(\n      'FPDFTextObj_GetFontSize',\n      2,\n    ));\n    (Module['_FPDFTextObj_GetText'] = createExportWrapper(\n      'FPDFTextObj_GetText',\n      4,\n    ));\n    (Module['_FPDFTextObj_GetRenderedBitmap'] =\n      createExportWrapper('FPDFTextObj_GetRenderedBitmap', 4));\n    (Module['_FPDFFont_Close'] = createExportWrapper('FPDFFont_Close', 1));\n    (Module['_FPDFPageObj_CreateTextObj'] = createExportWrapper(\n      'FPDFPageObj_CreateTextObj',\n      3,\n    ));\n    (Module['_FPDFTextObj_GetTextRenderMode'] =\n      createExportWrapper('FPDFTextObj_GetTextRenderMode', 1));\n    (Module['_FPDFTextObj_SetTextRenderMode'] =\n      createExportWrapper('FPDFTextObj_SetTextRenderMode', 2));\n    (Module['_FPDFTextObj_GetFont'] = createExportWrapper(\n      'FPDFTextObj_GetFont',\n      1,\n    ));\n    (Module['_FPDFFont_GetBaseFontName'] = createExportWrapper(\n      'FPDFFont_GetBaseFontName',\n      3,\n    ));\n    (Module['_FPDFFont_GetFamilyName'] = createExportWrapper(\n      'FPDFFont_GetFamilyName',\n      3,\n    ));\n    (Module['_FPDFFont_GetFontData'] = createExportWrapper(\n      'FPDFFont_GetFontData',\n      4,\n    ));\n    (Module['_FPDFFont_GetIsEmbedded'] = createExportWrapper(\n      'FPDFFont_GetIsEmbedded',\n      1,\n    ));\n    (Module['_FPDFFont_GetFlags'] = createExportWrapper(\n      'FPDFFont_GetFlags',\n      1,\n    ));\n    (Module['_FPDFFont_GetWeight'] = createExportWrapper(\n      'FPDFFont_GetWeight',\n      1,\n    ));\n    (Module['_FPDFFont_GetItalicAngle'] = createExportWrapper(\n      'FPDFFont_GetItalicAngle',\n      2,\n    ));\n    (Module['_FPDFFont_GetAscent'] = createExportWrapper(\n      'FPDFFont_GetAscent',\n      3,\n    ));\n    (Module['_FPDFFont_GetDescent'] = createExportWrapper(\n      'FPDFFont_GetDescent',\n      3,\n    ));\n    (Module['_FPDFFont_GetGlyphWidth'] = createExportWrapper(\n      'FPDFFont_GetGlyphWidth',\n      4,\n    ));\n    (Module['_FPDFFont_GetGlyphPath'] = createExportWrapper(\n      'FPDFFont_GetGlyphPath',\n      3,\n    ));\n    (Module['_FPDFGlyphPath_CountGlyphSegments'] =\n      createExportWrapper('FPDFGlyphPath_CountGlyphSegments', 1));\n    (Module['_FPDFGlyphPath_GetGlyphPathSegment'] =\n      createExportWrapper('FPDFGlyphPath_GetGlyphPathSegment', 2));\n    (Module['_FPDFDoc_GetPageMode'] = createExportWrapper(\n      'FPDFDoc_GetPageMode',\n      1,\n    ));\n    (Module['_FPDFPage_Flatten'] = createExportWrapper(\n      'FPDFPage_Flatten',\n      2,\n    ));\n    (Module['_FPDFPage_HasFormFieldAtPoint'] =\n      createExportWrapper('FPDFPage_HasFormFieldAtPoint', 4));\n    (Module['_FPDFPage_FormFieldZOrderAtPoint'] =\n      createExportWrapper('FPDFPage_FormFieldZOrderAtPoint', 4));\n    (Module['_malloc'] = createExportWrapper('malloc', 1));\n    (Module['_free'] = createExportWrapper('free', 1));\n    (Module['_FORM_OnMouseMove'] = createExportWrapper(\n      'FORM_OnMouseMove',\n      5,\n    ));\n    (Module['_FORM_OnMouseWheel'] = createExportWrapper(\n      'FORM_OnMouseWheel',\n      6,\n    ));\n    (Module['_FORM_OnFocus'] = createExportWrapper('FORM_OnFocus', 5));\n    (Module['_FORM_OnLButtonDown'] = createExportWrapper(\n      'FORM_OnLButtonDown',\n      5,\n    ));\n    (Module['_FORM_OnLButtonUp'] = createExportWrapper(\n      'FORM_OnLButtonUp',\n      5,\n    ));\n    (Module['_FORM_OnLButtonDoubleClick'] = createExportWrapper(\n      'FORM_OnLButtonDoubleClick',\n      5,\n    ));\n    (Module['_FORM_OnRButtonDown'] = createExportWrapper(\n      'FORM_OnRButtonDown',\n      5,\n    ));\n    (Module['_FORM_OnRButtonUp'] = createExportWrapper(\n      'FORM_OnRButtonUp',\n      5,\n    ));\n    (Module['_FORM_OnKeyDown'] = createExportWrapper('FORM_OnKeyDown', 4));\n    (Module['_FORM_OnKeyUp'] = createExportWrapper('FORM_OnKeyUp', 4));\n    (Module['_FORM_OnChar'] = createExportWrapper('FORM_OnChar', 4));\n    (Module['_FORM_GetFocusedText'] = createExportWrapper(\n      'FORM_GetFocusedText',\n      4,\n    ));\n    (Module['_FORM_GetSelectedText'] = createExportWrapper(\n      'FORM_GetSelectedText',\n      4,\n    ));\n    (Module['_FORM_ReplaceAndKeepSelection'] =\n      createExportWrapper('FORM_ReplaceAndKeepSelection', 3));\n    (Module['_FORM_ReplaceSelection'] = createExportWrapper(\n      'FORM_ReplaceSelection',\n      3,\n    ));\n    (Module['_FORM_SelectAllText'] = createExportWrapper(\n      'FORM_SelectAllText',\n      2,\n    ));\n    (Module['_FORM_CanUndo'] = createExportWrapper('FORM_CanUndo', 2));\n    (Module['_FORM_CanRedo'] = createExportWrapper('FORM_CanRedo', 2));\n    (Module['_FORM_Undo'] = createExportWrapper('FORM_Undo', 2));\n    (Module['_FORM_Redo'] = createExportWrapper('FORM_Redo', 2));\n    (Module['_FORM_ForceToKillFocus'] = createExportWrapper(\n      'FORM_ForceToKillFocus',\n      1,\n    ));\n    (Module['_FORM_GetFocusedAnnot'] = createExportWrapper(\n      'FORM_GetFocusedAnnot',\n      3,\n    ));\n    (Module['_FORM_SetFocusedAnnot'] = createExportWrapper(\n      'FORM_SetFocusedAnnot',\n      2,\n    ));\n    (Module['_FPDF_FFLDraw'] = createExportWrapper('FPDF_FFLDraw', 9));\n    (Module['_FPDF_SetFormFieldHighlightColor'] =\n      createExportWrapper('FPDF_SetFormFieldHighlightColor', 3));\n    (Module['_FPDF_SetFormFieldHighlightAlpha'] =\n      createExportWrapper('FPDF_SetFormFieldHighlightAlpha', 2));\n    (Module['_FPDF_RemoveFormFieldHighlight'] =\n      createExportWrapper('FPDF_RemoveFormFieldHighlight', 1));\n    (Module['_FORM_OnAfterLoadPage'] = createExportWrapper(\n      'FORM_OnAfterLoadPage',\n      2,\n    ));\n    (Module['_FORM_OnBeforeClosePage'] = createExportWrapper(\n      'FORM_OnBeforeClosePage',\n      2,\n    ));\n    (Module['_FORM_DoDocumentJSAction'] = createExportWrapper(\n      'FORM_DoDocumentJSAction',\n      1,\n    ));\n    (Module['_FORM_DoDocumentOpenAction'] = createExportWrapper(\n      'FORM_DoDocumentOpenAction',\n      1,\n    ));\n    (Module['_FORM_DoDocumentAAction'] = createExportWrapper(\n      'FORM_DoDocumentAAction',\n      2,\n    ));\n    (Module['_FORM_DoPageAAction'] = createExportWrapper(\n      'FORM_DoPageAAction',\n      3,\n    ));\n    (Module['_FORM_SetIndexSelected'] = createExportWrapper(\n      'FORM_SetIndexSelected',\n      4,\n    ));\n    (Module['_FORM_IsIndexSelected'] = createExportWrapper(\n      'FORM_IsIndexSelected',\n      3,\n    ));\n    (Module['_FPDFDoc_GetJavaScriptActionCount'] =\n      createExportWrapper('FPDFDoc_GetJavaScriptActionCount', 1));\n    (Module['_FPDFDoc_GetJavaScriptAction'] =\n      createExportWrapper('FPDFDoc_GetJavaScriptAction', 2));\n    (Module['_FPDFDoc_CloseJavaScriptAction'] =\n      createExportWrapper('FPDFDoc_CloseJavaScriptAction', 1));\n    (Module['_FPDFJavaScriptAction_GetName'] =\n      createExportWrapper('FPDFJavaScriptAction_GetName', 3));\n    (Module['_FPDFJavaScriptAction_GetScript'] =\n      createExportWrapper('FPDFJavaScriptAction_GetScript', 3));\n    (Module['_FPDF_ImportPagesByIndex'] = createExportWrapper(\n      'FPDF_ImportPagesByIndex',\n      5,\n    ));\n    (Module['_FPDF_ImportPages'] = createExportWrapper(\n      'FPDF_ImportPages',\n      4,\n    ));\n    (Module['_FPDF_ImportNPagesToOne'] = createExportWrapper(\n      'FPDF_ImportNPagesToOne',\n      5,\n    ));\n    (Module['_FPDF_NewXObjectFromPage'] = createExportWrapper(\n      'FPDF_NewXObjectFromPage',\n      3,\n    ));\n    (Module['_FPDF_CloseXObject'] = createExportWrapper(\n      'FPDF_CloseXObject',\n      1,\n    ));\n    (Module['_FPDF_NewFormObjectFromXObject'] =\n      createExportWrapper('FPDF_NewFormObjectFromXObject', 1));\n    (Module['_FPDF_CopyViewerPreferences'] = createExportWrapper(\n      'FPDF_CopyViewerPreferences',\n      2,\n    ));\n    (Module[\n      '_FPDF_RenderPageBitmapWithColorScheme_Start'\n    ] = createExportWrapper('FPDF_RenderPageBitmapWithColorScheme_Start', 10));\n    (Module['_FPDF_RenderPageBitmap_Start'] =\n      createExportWrapper('FPDF_RenderPageBitmap_Start', 9));\n    (Module['_FPDF_RenderPage_Continue'] = createExportWrapper(\n      'FPDF_RenderPage_Continue',\n      2,\n    ));\n    (Module['_FPDF_RenderPage_Close'] = createExportWrapper(\n      'FPDF_RenderPage_Close',\n      1,\n    ));\n    (Module['_FPDF_SaveWithVersion'] = createExportWrapper(\n      'FPDF_SaveWithVersion',\n      4,\n    ));\n    (Module['_FPDFText_GetCharIndexFromTextIndex'] =\n      createExportWrapper('FPDFText_GetCharIndexFromTextIndex', 2));\n    (Module['_FPDFText_GetTextIndexFromCharIndex'] =\n      createExportWrapper('FPDFText_GetTextIndexFromCharIndex', 2));\n    (Module['_FPDF_GetSignatureCount'] = createExportWrapper(\n      'FPDF_GetSignatureCount',\n      1,\n    ));\n    (Module['_FPDF_GetSignatureObject'] = createExportWrapper(\n      'FPDF_GetSignatureObject',\n      2,\n    ));\n    (Module['_FPDFSignatureObj_GetContents'] =\n      createExportWrapper('FPDFSignatureObj_GetContents', 3));\n    (Module['_FPDFSignatureObj_GetByteRange'] =\n      createExportWrapper('FPDFSignatureObj_GetByteRange', 3));\n    (Module['_FPDFSignatureObj_GetSubFilter'] =\n      createExportWrapper('FPDFSignatureObj_GetSubFilter', 3));\n    (Module['_FPDFSignatureObj_GetReason'] = createExportWrapper(\n      'FPDFSignatureObj_GetReason',\n      3,\n    ));\n    (Module['_FPDFSignatureObj_GetTime'] = createExportWrapper(\n      'FPDFSignatureObj_GetTime',\n      3,\n    ));\n    (Module['_FPDFSignatureObj_GetDocMDPPermission'] =\n      createExportWrapper('FPDFSignatureObj_GetDocMDPPermission', 1));\n    (Module['_FPDF_StructTree_GetForPage'] = createExportWrapper(\n      'FPDF_StructTree_GetForPage',\n      1,\n    ));\n    (Module['_FPDF_StructTree_Close'] = createExportWrapper(\n      'FPDF_StructTree_Close',\n      1,\n    ));\n    (Module['_FPDF_StructTree_CountChildren'] =\n      createExportWrapper('FPDF_StructTree_CountChildren', 1));\n    (Module['_FPDF_StructTree_GetChildAtIndex'] =\n      createExportWrapper('FPDF_StructTree_GetChildAtIndex', 2));\n    (Module['_FPDF_StructElement_GetAltText'] =\n      createExportWrapper('FPDF_StructElement_GetAltText', 3));\n    (Module['_FPDF_StructElement_GetActualText'] =\n      createExportWrapper('FPDF_StructElement_GetActualText', 3));\n    (Module['_FPDF_StructElement_GetID'] = createExportWrapper(\n      'FPDF_StructElement_GetID',\n      3,\n    ));\n    (Module['_FPDF_StructElement_GetLang'] = createExportWrapper(\n      'FPDF_StructElement_GetLang',\n      3,\n    ));\n    (Module['_FPDF_StructElement_GetAttributeCount'] =\n      createExportWrapper('FPDF_StructElement_GetAttributeCount', 1));\n    (Module[\n      '_FPDF_StructElement_GetAttributeAtIndex'\n    ] = createExportWrapper('FPDF_StructElement_GetAttributeAtIndex', 2));\n    (Module['_FPDF_StructElement_GetStringAttribute'] =\n      createExportWrapper('FPDF_StructElement_GetStringAttribute', 4));\n    (Module['_FPDF_StructElement_GetMarkedContentID'] =\n      createExportWrapper('FPDF_StructElement_GetMarkedContentID', 1));\n    (Module['_FPDF_StructElement_GetType'] = createExportWrapper(\n      'FPDF_StructElement_GetType',\n      3,\n    ));\n    (Module['_FPDF_StructElement_GetObjType'] =\n      createExportWrapper('FPDF_StructElement_GetObjType', 3));\n    (Module['_FPDF_StructElement_GetTitle'] =\n      createExportWrapper('FPDF_StructElement_GetTitle', 3));\n    (Module['_FPDF_StructElement_CountChildren'] =\n      createExportWrapper('FPDF_StructElement_CountChildren', 1));\n    (Module['_FPDF_StructElement_GetChildAtIndex'] =\n      createExportWrapper('FPDF_StructElement_GetChildAtIndex', 2));\n    (Module[\n      '_FPDF_StructElement_GetChildMarkedContentID'\n    ] = createExportWrapper('FPDF_StructElement_GetChildMarkedContentID', 2));\n    (Module['_FPDF_StructElement_GetParent'] =\n      createExportWrapper('FPDF_StructElement_GetParent', 1));\n    (Module['_FPDF_StructElement_Attr_GetCount'] =\n      createExportWrapper('FPDF_StructElement_Attr_GetCount', 1));\n    (Module['_FPDF_StructElement_Attr_GetName'] =\n      createExportWrapper('FPDF_StructElement_Attr_GetName', 5));\n    (Module['_FPDF_StructElement_Attr_GetValue'] =\n      createExportWrapper('FPDF_StructElement_Attr_GetValue', 2));\n    (Module['_FPDF_StructElement_Attr_GetType'] =\n      createExportWrapper('FPDF_StructElement_Attr_GetType', 1));\n    (Module[\n      '_FPDF_StructElement_Attr_GetBooleanValue'\n    ] = createExportWrapper('FPDF_StructElement_Attr_GetBooleanValue', 2));\n    (Module[\n      '_FPDF_StructElement_Attr_GetNumberValue'\n    ] = createExportWrapper('FPDF_StructElement_Attr_GetNumberValue', 2));\n    (Module[\n      '_FPDF_StructElement_Attr_GetStringValue'\n    ] = createExportWrapper('FPDF_StructElement_Attr_GetStringValue', 4));\n    (Module['_FPDF_StructElement_Attr_GetBlobValue'] =\n      createExportWrapper('FPDF_StructElement_Attr_GetBlobValue', 4));\n    (Module['_FPDF_StructElement_Attr_CountChildren'] =\n      createExportWrapper('FPDF_StructElement_Attr_CountChildren', 1));\n    (Module[\n      '_FPDF_StructElement_Attr_GetChildAtIndex'\n    ] = createExportWrapper('FPDF_StructElement_Attr_GetChildAtIndex', 2));\n    (Module[\n      '_FPDF_StructElement_GetMarkedContentIdCount'\n    ] = createExportWrapper('FPDF_StructElement_GetMarkedContentIdCount', 1));\n    (Module[\n      '_FPDF_StructElement_GetMarkedContentIdAtIndex'\n    ] = createExportWrapper('FPDF_StructElement_GetMarkedContentIdAtIndex', 2));\n    (Module['_FPDF_AddInstalledFont'] = createExportWrapper(\n      'FPDF_AddInstalledFont',\n      3,\n    ));\n    (Module['_FPDF_SetSystemFontInfo'] = createExportWrapper(\n      'FPDF_SetSystemFontInfo',\n      1,\n    ));\n    (Module['_FPDF_GetDefaultTTFMap'] = createExportWrapper(\n      'FPDF_GetDefaultTTFMap',\n      0,\n    ));\n    (Module['_FPDF_GetDefaultTTFMapCount'] = createExportWrapper(\n      'FPDF_GetDefaultTTFMapCount',\n      0,\n    ));\n    (Module['_FPDF_GetDefaultTTFMapEntry'] = createExportWrapper(\n      'FPDF_GetDefaultTTFMapEntry',\n      1,\n    ));\n    (Module['_FPDF_GetDefaultSystemFontInfo'] =\n      createExportWrapper('FPDF_GetDefaultSystemFontInfo', 0));\n    (Module['_FPDF_FreeDefaultSystemFontInfo'] =\n      createExportWrapper('FPDF_FreeDefaultSystemFontInfo', 1));\n    (Module['_FPDFText_LoadPage'] = createExportWrapper(\n      'FPDFText_LoadPage',\n      1,\n    ));\n    (Module['_FPDFText_ClosePage'] = createExportWrapper(\n      'FPDFText_ClosePage',\n      1,\n    ));\n    (Module['_FPDFText_CountChars'] = createExportWrapper(\n      'FPDFText_CountChars',\n      1,\n    ));\n    (Module['_FPDFText_GetUnicode'] = createExportWrapper(\n      'FPDFText_GetUnicode',\n      2,\n    ));\n    (Module['_FPDFText_GetTextObject'] = createExportWrapper(\n      'FPDFText_GetTextObject',\n      2,\n    ));\n    (Module['_FPDFText_IsGenerated'] = createExportWrapper(\n      'FPDFText_IsGenerated',\n      2,\n    ));\n    (Module['_FPDFText_IsHyphen'] = createExportWrapper(\n      'FPDFText_IsHyphen',\n      2,\n    ));\n    (Module['_FPDFText_HasUnicodeMapError'] =\n      createExportWrapper('FPDFText_HasUnicodeMapError', 2));\n    (Module['_FPDFText_GetFontSize'] = createExportWrapper(\n      'FPDFText_GetFontSize',\n      2,\n    ));\n    (Module['_FPDFText_GetFontInfo'] = createExportWrapper(\n      'FPDFText_GetFontInfo',\n      5,\n    ));\n    (Module['_FPDFText_GetFontWeight'] = createExportWrapper(\n      'FPDFText_GetFontWeight',\n      2,\n    ));\n    (Module['_FPDFText_GetFillColor'] = createExportWrapper(\n      'FPDFText_GetFillColor',\n      6,\n    ));\n    (Module['_FPDFText_GetStrokeColor'] = createExportWrapper(\n      'FPDFText_GetStrokeColor',\n      6,\n    ));\n    (Module['_FPDFText_GetCharAngle'] = createExportWrapper(\n      'FPDFText_GetCharAngle',\n      2,\n    ));\n    (Module['_FPDFText_GetCharBox'] = createExportWrapper(\n      'FPDFText_GetCharBox',\n      6,\n    ));\n    (Module['_FPDFText_GetLooseCharBox'] = createExportWrapper(\n      'FPDFText_GetLooseCharBox',\n      3,\n    ));\n    (Module['_FPDFText_GetMatrix'] = createExportWrapper(\n      'FPDFText_GetMatrix',\n      3,\n    ));\n    (Module['_FPDFText_GetCharOrigin'] = createExportWrapper(\n      'FPDFText_GetCharOrigin',\n      4,\n    ));\n    (Module['_FPDFText_GetCharIndexAtPos'] = createExportWrapper(\n      'FPDFText_GetCharIndexAtPos',\n      5,\n    ));\n    (Module['_FPDFText_GetText'] = createExportWrapper(\n      'FPDFText_GetText',\n      4,\n    ));\n    (Module['_FPDFText_CountRects'] = createExportWrapper(\n      'FPDFText_CountRects',\n      3,\n    ));\n    (Module['_FPDFText_GetRect'] = createExportWrapper(\n      'FPDFText_GetRect',\n      6,\n    ));\n    (Module['_FPDFText_GetBoundedText'] = createExportWrapper(\n      'FPDFText_GetBoundedText',\n      7,\n    ));\n    (Module['_FPDFText_FindStart'] = createExportWrapper(\n      'FPDFText_FindStart',\n      4,\n    ));\n    (Module['_FPDFText_FindNext'] = createExportWrapper(\n      'FPDFText_FindNext',\n      1,\n    ));\n    (Module['_FPDFText_FindPrev'] = createExportWrapper(\n      'FPDFText_FindPrev',\n      1,\n    ));\n    (Module['_FPDFText_GetSchResultIndex'] = createExportWrapper(\n      'FPDFText_GetSchResultIndex',\n      1,\n    ));\n    (Module['_FPDFText_GetSchCount'] = createExportWrapper(\n      'FPDFText_GetSchCount',\n      1,\n    ));\n    (Module['_FPDFText_FindClose'] = createExportWrapper(\n      'FPDFText_FindClose',\n      1,\n    ));\n    (Module['_FPDFLink_LoadWebLinks'] = createExportWrapper(\n      'FPDFLink_LoadWebLinks',\n      1,\n    ));\n    (Module['_FPDFLink_CountWebLinks'] = createExportWrapper(\n      'FPDFLink_CountWebLinks',\n      1,\n    ));\n    (Module['_FPDFLink_GetURL'] = createExportWrapper('FPDFLink_GetURL', 4));\n    (Module['_FPDFLink_CountRects'] = createExportWrapper(\n      'FPDFLink_CountRects',\n      2,\n    ));\n    (Module['_FPDFLink_GetRect'] = createExportWrapper(\n      'FPDFLink_GetRect',\n      7,\n    ));\n    (Module['_FPDFLink_GetTextRange'] = createExportWrapper(\n      'FPDFLink_GetTextRange',\n      4,\n    ));\n    (Module['_FPDFLink_CloseWebLinks'] = createExportWrapper(\n      'FPDFLink_CloseWebLinks',\n      1,\n    ));\n    (Module['_FPDFPage_GetDecodedThumbnailData'] =\n      createExportWrapper('FPDFPage_GetDecodedThumbnailData', 3));\n    (Module['_FPDFPage_GetRawThumbnailData'] =\n      createExportWrapper('FPDFPage_GetRawThumbnailData', 3));\n    (Module['_FPDFPage_GetThumbnailAsBitmap'] =\n      createExportWrapper('FPDFPage_GetThumbnailAsBitmap', 1));\n    (Module['_FPDFPage_SetMediaBox'] = createExportWrapper(\n      'FPDFPage_SetMediaBox',\n      5,\n    ));\n    (Module['_FPDFPage_SetCropBox'] = createExportWrapper(\n      'FPDFPage_SetCropBox',\n      5,\n    ));\n    (Module['_FPDFPage_SetBleedBox'] = createExportWrapper(\n      'FPDFPage_SetBleedBox',\n      5,\n    ));\n    (Module['_FPDFPage_SetTrimBox'] = createExportWrapper(\n      'FPDFPage_SetTrimBox',\n      5,\n    ));\n    (Module['_FPDFPage_SetArtBox'] = createExportWrapper(\n      'FPDFPage_SetArtBox',\n      5,\n    ));\n    (Module['_FPDFPage_GetMediaBox'] = createExportWrapper(\n      'FPDFPage_GetMediaBox',\n      5,\n    ));\n    (Module['_FPDFPage_GetCropBox'] = createExportWrapper(\n      'FPDFPage_GetCropBox',\n      5,\n    ));\n    (Module['_FPDFPage_GetBleedBox'] = createExportWrapper(\n      'FPDFPage_GetBleedBox',\n      5,\n    ));\n    (Module['_FPDFPage_GetTrimBox'] = createExportWrapper(\n      'FPDFPage_GetTrimBox',\n      5,\n    ));\n    (Module['_FPDFPage_GetArtBox'] = createExportWrapper(\n      'FPDFPage_GetArtBox',\n      5,\n    ));\n    (Module['_FPDFPage_TransFormWithClip'] = createExportWrapper(\n      'FPDFPage_TransFormWithClip',\n      3,\n    ));\n    (Module['_FPDFPageObj_TransformClipPath'] =\n      createExportWrapper('FPDFPageObj_TransformClipPath', 7));\n    (Module['_FPDFPageObj_GetClipPath'] = createExportWrapper(\n      'FPDFPageObj_GetClipPath',\n      1,\n    ));\n    (Module['_FPDFClipPath_CountPaths'] = createExportWrapper(\n      'FPDFClipPath_CountPaths',\n      1,\n    ));\n    (Module['_FPDFClipPath_CountPathSegments'] =\n      createExportWrapper('FPDFClipPath_CountPathSegments', 2));\n    (Module['_FPDFClipPath_GetPathSegment'] =\n      createExportWrapper('FPDFClipPath_GetPathSegment', 3));\n    (Module['_FPDF_CreateClipPath'] = createExportWrapper(\n      'FPDF_CreateClipPath',\n      4,\n    ));\n    (Module['_FPDF_DestroyClipPath'] = createExportWrapper(\n      'FPDF_DestroyClipPath',\n      1,\n    ));\n    (Module['_FPDFPage_InsertClipPath'] = createExportWrapper(\n      'FPDFPage_InsertClipPath',\n      2,\n    ));\n    (Module['_FPDF_InitLibrary'] = createExportWrapper(\n      'FPDF_InitLibrary',\n      0,\n    ));\n    (Module['_FPDF_DestroyLibrary'] = createExportWrapper(\n      'FPDF_DestroyLibrary',\n      0,\n    ));\n    (Module['_FPDF_SetSandBoxPolicy'] = createExportWrapper(\n      'FPDF_SetSandBoxPolicy',\n      2,\n    ));\n    (Module['_FPDF_LoadDocument'] = createExportWrapper(\n      'FPDF_LoadDocument',\n      2,\n    ));\n    (Module['_FPDF_GetFormType'] = createExportWrapper(\n      'FPDF_GetFormType',\n      1,\n    ));\n    (Module['_FPDF_LoadXFA'] = createExportWrapper('FPDF_LoadXFA', 1));\n    (Module['_FPDF_LoadMemDocument'] = createExportWrapper(\n      'FPDF_LoadMemDocument',\n      3,\n    ));\n    (Module['_FPDF_LoadMemDocument64'] = createExportWrapper(\n      'FPDF_LoadMemDocument64',\n      3,\n    ));\n    (Module['_FPDF_LoadCustomDocument'] = createExportWrapper(\n      'FPDF_LoadCustomDocument',\n      2,\n    ));\n    (Module['_FPDF_GetFileVersion'] = createExportWrapper(\n      'FPDF_GetFileVersion',\n      2,\n    ));\n    (Module[\n      '_FPDF_DocumentHasValidCrossReferenceTable'\n    ] = createExportWrapper('FPDF_DocumentHasValidCrossReferenceTable', 1));\n    (Module['_FPDF_GetDocPermissions'] = createExportWrapper(\n      'FPDF_GetDocPermissions',\n      1,\n    ));\n    (Module['_FPDF_GetDocUserPermissions'] = createExportWrapper(\n      'FPDF_GetDocUserPermissions',\n      1,\n    ));\n    (Module['_FPDF_GetSecurityHandlerRevision'] =\n      createExportWrapper('FPDF_GetSecurityHandlerRevision', 1));\n    (Module['_FPDF_GetPageCount'] = createExportWrapper(\n      'FPDF_GetPageCount',\n      1,\n    ));\n    (Module['_FPDF_LoadPage'] = createExportWrapper('FPDF_LoadPage', 2));\n    (Module['_FPDF_GetPageWidthF'] = createExportWrapper(\n      'FPDF_GetPageWidthF',\n      1,\n    ));\n    (Module['_FPDF_GetPageWidth'] = createExportWrapper(\n      'FPDF_GetPageWidth',\n      1,\n    ));\n    (Module['_FPDF_GetPageHeightF'] = createExportWrapper(\n      'FPDF_GetPageHeightF',\n      1,\n    ));\n    (Module['_FPDF_GetPageHeight'] = createExportWrapper(\n      'FPDF_GetPageHeight',\n      1,\n    ));\n    (Module['_FPDF_GetPageBoundingBox'] = createExportWrapper(\n      'FPDF_GetPageBoundingBox',\n      2,\n    ));\n    (Module['_FPDF_RenderPageBitmap'] = createExportWrapper(\n      'FPDF_RenderPageBitmap',\n      8,\n    ));\n    (Module['_FPDF_RenderPageBitmapWithMatrix'] =\n      createExportWrapper('FPDF_RenderPageBitmapWithMatrix', 5));\n    (Module['_EPDF_RenderAnnotBitmap'] = createExportWrapper(\n      'EPDF_RenderAnnotBitmap',\n      6,\n    ));\n    (Module['_FPDF_ClosePage'] = createExportWrapper('FPDF_ClosePage', 1));\n    (Module['_FPDF_CloseDocument'] = createExportWrapper(\n      'FPDF_CloseDocument',\n      1,\n    ));\n    (Module['_FPDF_GetLastError'] = createExportWrapper(\n      'FPDF_GetLastError',\n      0,\n    ));\n    (Module['_FPDF_DeviceToPage'] = createExportWrapper(\n      'FPDF_DeviceToPage',\n      10,\n    ));\n    (Module['_FPDF_PageToDevice'] = createExportWrapper(\n      'FPDF_PageToDevice',\n      10,\n    ));\n    (Module['_FPDFBitmap_Create'] = createExportWrapper(\n      'FPDFBitmap_Create',\n      3,\n    ));\n    (Module['_FPDFBitmap_CreateEx'] = createExportWrapper(\n      'FPDFBitmap_CreateEx',\n      5,\n    ));\n    (Module['_FPDFBitmap_GetFormat'] = createExportWrapper(\n      'FPDFBitmap_GetFormat',\n      1,\n    ));\n    (Module['_FPDFBitmap_FillRect'] = createExportWrapper(\n      'FPDFBitmap_FillRect',\n      6,\n    ));\n    (Module['_FPDFBitmap_GetBuffer'] = createExportWrapper(\n      'FPDFBitmap_GetBuffer',\n      1,\n    ));\n    (Module['_FPDFBitmap_GetWidth'] = createExportWrapper(\n      'FPDFBitmap_GetWidth',\n      1,\n    ));\n    (Module['_FPDFBitmap_GetHeight'] = createExportWrapper(\n      'FPDFBitmap_GetHeight',\n      1,\n    ));\n    (Module['_FPDFBitmap_GetStride'] = createExportWrapper(\n      'FPDFBitmap_GetStride',\n      1,\n    ));\n    (Module['_FPDFBitmap_Destroy'] = createExportWrapper(\n      'FPDFBitmap_Destroy',\n      1,\n    ));\n    (Module['_FPDF_GetPageSizeByIndexF'] = createExportWrapper(\n      'FPDF_GetPageSizeByIndexF',\n      3,\n    ));\n    (Module['_FPDF_GetPageSizeByIndex'] = createExportWrapper(\n      'FPDF_GetPageSizeByIndex',\n      4,\n    ));\n    (Module['_FPDF_VIEWERREF_GetPrintScaling'] =\n      createExportWrapper('FPDF_VIEWERREF_GetPrintScaling', 1));\n    (Module['_FPDF_VIEWERREF_GetNumCopies'] =\n      createExportWrapper('FPDF_VIEWERREF_GetNumCopies', 1));\n    (Module['_FPDF_VIEWERREF_GetPrintPageRange'] =\n      createExportWrapper('FPDF_VIEWERREF_GetPrintPageRange', 1));\n    (Module['_FPDF_VIEWERREF_GetPrintPageRangeCount'] =\n      createExportWrapper('FPDF_VIEWERREF_GetPrintPageRangeCount', 1));\n    (Module[\n      '_FPDF_VIEWERREF_GetPrintPageRangeElement'\n    ] = createExportWrapper('FPDF_VIEWERREF_GetPrintPageRangeElement', 2));\n    (Module['_FPDF_VIEWERREF_GetDuplex'] = createExportWrapper(\n      'FPDF_VIEWERREF_GetDuplex',\n      1,\n    ));\n    (Module['_FPDF_VIEWERREF_GetName'] = createExportWrapper(\n      'FPDF_VIEWERREF_GetName',\n      4,\n    ));\n    (Module['_FPDF_CountNamedDests'] = createExportWrapper(\n      'FPDF_CountNamedDests',\n      1,\n    ));\n    (Module['_FPDF_GetNamedDestByName'] = createExportWrapper(\n      'FPDF_GetNamedDestByName',\n      2,\n    ));\n    (Module['_FPDF_GetNamedDest'] = createExportWrapper(\n      'FPDF_GetNamedDest',\n      4,\n    ));\n    (Module['_FPDF_GetXFAPacketCount'] = createExportWrapper(\n      'FPDF_GetXFAPacketCount',\n      1,\n    ));\n    (Module['_FPDF_GetXFAPacketName'] = createExportWrapper(\n      'FPDF_GetXFAPacketName',\n      4,\n    ));\n    (Module['_FPDF_GetXFAPacketContent'] = createExportWrapper(\n      'FPDF_GetXFAPacketContent',\n      5,\n    ));\n    (Module['_FPDF_GetTrailerEnds'] = createExportWrapper(\n      'FPDF_GetTrailerEnds',\n      3,\n    ));\n    var _fflush = createExportWrapper('fflush', 1);\n    var _emscripten_builtin_memalign = createExportWrapper('emscripten_builtin_memalign', 2);\n    var _strerror = createExportWrapper('strerror', 1);\n    var _setThrew = createExportWrapper('setThrew', 2);\n    var _emscripten_stack_init = () =>\n      (_emscripten_stack_init = wasmExports['emscripten_stack_init'])();\n    var _emscripten_stack_get_end = () =>\n      (_emscripten_stack_get_end = wasmExports['emscripten_stack_get_end'])();\n    var __emscripten_stack_restore = (a0) =>\n      (__emscripten_stack_restore = wasmExports['_emscripten_stack_restore'])(a0);\n    var __emscripten_stack_alloc = (a0) =>\n      (__emscripten_stack_alloc = wasmExports['_emscripten_stack_alloc'])(a0);\n    var _emscripten_stack_get_current = () =>\n      (_emscripten_stack_get_current = wasmExports['emscripten_stack_get_current'])();\n    (Module['dynCall_ji'] = createExportWrapper('dynCall_ji', 2));\n    (Module['dynCall_jij'] = createExportWrapper('dynCall_jij', 4));\n    (Module['dynCall_iiij'] = createExportWrapper('dynCall_iiij', 5));\n    (Module['dynCall_iij'] = createExportWrapper('dynCall_iij', 4));\n    (Module['dynCall_j'] = createExportWrapper('dynCall_j', 1));\n    (Module['dynCall_jji'] = createExportWrapper('dynCall_jji', 4));\n    (Module['dynCall_iji'] = createExportWrapper('dynCall_iji', 4));\n    (Module['dynCall_viijii'] = createExportWrapper('dynCall_viijii', 7));\n    (Module['dynCall_iiji'] = createExportWrapper('dynCall_iiji', 5));\n    (Module['dynCall_jiji'] = createExportWrapper('dynCall_jiji', 5));\n    (Module['dynCall_iiiiij'] = createExportWrapper('dynCall_iiiiij', 7));\n    (Module['dynCall_iiiiijj'] = createExportWrapper('dynCall_iiiiijj', 9));\n    (Module['dynCall_iiiiiijj'] = createExportWrapper(\n      'dynCall_iiiiiijj',\n      10,\n    ));\n    (Module['dynCall_viji'] = createExportWrapper('dynCall_viji', 5));\n\n    function invoke_viii(index, a1, a2, a3) {\n      var sp = stackSave();\n      try {\n        getWasmTableEntry(index)(a1, a2, a3);\n      } catch (e) {\n        stackRestore(sp);\n        if (e !== e + 0) throw e;\n        _setThrew(1, 0);\n      }\n    }\n\n    function invoke_ii(index, a1) {\n      var sp = stackSave();\n      try {\n        return getWasmTableEntry(index)(a1);\n      } catch (e) {\n        stackRestore(sp);\n        if (e !== e + 0) throw e;\n        _setThrew(1, 0);\n      }\n    }\n\n    function invoke_iii(index, a1, a2) {\n      var sp = stackSave();\n      try {\n        return getWasmTableEntry(index)(a1, a2);\n      } catch (e) {\n        stackRestore(sp);\n        if (e !== e + 0) throw e;\n        _setThrew(1, 0);\n      }\n    }\n\n    function invoke_iiii(index, a1, a2, a3) {\n      var sp = stackSave();\n      try {\n        return getWasmTableEntry(index)(a1, a2, a3);\n      } catch (e) {\n        stackRestore(sp);\n        if (e !== e + 0) throw e;\n        _setThrew(1, 0);\n      }\n    }\n\n    function invoke_viiii(index, a1, a2, a3, a4) {\n      var sp = stackSave();\n      try {\n        getWasmTableEntry(index)(a1, a2, a3, a4);\n      } catch (e) {\n        stackRestore(sp);\n        if (e !== e + 0) throw e;\n        _setThrew(1, 0);\n      }\n    }\n\n    function invoke_iiiii(index, a1, a2, a3, a4) {\n      var sp = stackSave();\n      try {\n        return getWasmTableEntry(index)(a1, a2, a3, a4);\n      } catch (e) {\n        stackRestore(sp);\n        if (e !== e + 0) throw e;\n        _setThrew(1, 0);\n      }\n    }\n\n    function invoke_v(index) {\n      var sp = stackSave();\n      try {\n        getWasmTableEntry(index)();\n      } catch (e) {\n        stackRestore(sp);\n        if (e !== e + 0) throw e;\n        _setThrew(1, 0);\n      }\n    }\n\n    // include: postamble.js\n    // === Auto-generated postamble setup entry stuff ===\n\n    Module['wasmExports'] = wasmExports;\n    Module['ccall'] = ccall;\n    Module['cwrap'] = cwrap;\n    Module['addFunction'] = addFunction;\n    Module['removeFunction'] = removeFunction;\n    Module['setValue'] = setValue;\n    Module['getValue'] = getValue;\n    Module['UTF8ToString'] = UTF8ToString;\n    Module['stringToUTF8'] = stringToUTF8;\n    Module['UTF16ToString'] = UTF16ToString;\n    Module['stringToUTF16'] = stringToUTF16;\n    var missingLibrarySymbols = [\n      'writeI53ToI64',\n      'writeI53ToI64Clamped',\n      'writeI53ToI64Signaling',\n      'writeI53ToU64Clamped',\n      'writeI53ToU64Signaling',\n      'readI53FromI64',\n      'readI53FromU64',\n      'convertI32PairToI53',\n      'convertU32PairToI53',\n      'getTempRet0',\n      'setTempRet0',\n      'exitJS',\n      'inetPton4',\n      'inetNtop4',\n      'inetPton6',\n      'inetNtop6',\n      'readSockaddr',\n      'writeSockaddr',\n      'emscriptenLog',\n      'readEmAsmArgs',\n      'jstoi_q',\n      'listenOnce',\n      'autoResumeAudioContext',\n      'dynCallLegacy',\n      'getDynCaller',\n      'dynCall',\n      'handleException',\n      'keepRuntimeAlive',\n      'runtimeKeepalivePush',\n      'runtimeKeepalivePop',\n      'callUserCallback',\n      'maybeExit',\n      'asmjsMangle',\n      'HandleAllocator',\n      'getNativeTypeSize',\n      'STACK_SIZE',\n      'STACK_ALIGN',\n      'POINTER_SIZE',\n      'ASSERTIONS',\n      'reallyNegative',\n      'unSign',\n      'strLen',\n      'reSign',\n      'formatString',\n      'intArrayToString',\n      'AsciiToString',\n      'lengthBytesUTF16',\n      'UTF32ToString',\n      'stringToUTF32',\n      'lengthBytesUTF32',\n      'stringToNewUTF8',\n      'registerKeyEventCallback',\n      'maybeCStringToJsString',\n      'findEventTarget',\n      'getBoundingClientRect',\n      'fillMouseEventData',\n      'registerMouseEventCallback',\n      'registerWheelEventCallback',\n      'registerUiEventCallback',\n      'registerFocusEventCallback',\n      'fillDeviceOrientationEventData',\n      'registerDeviceOrientationEventCallback',\n      'fillDeviceMotionEventData',\n      'registerDeviceMotionEventCallback',\n      'screenOrientation',\n      'fillOrientationChangeEventData',\n      'registerOrientationChangeEventCallback',\n      'fillFullscreenChangeEventData',\n      'registerFullscreenChangeEventCallback',\n      'JSEvents_requestFullscreen',\n      'JSEvents_resizeCanvasForFullscreen',\n      'registerRestoreOldStyle',\n      'hideEverythingExceptGivenElement',\n      'restoreHiddenElements',\n      'setLetterbox',\n      'softFullscreenResizeWebGLRenderTarget',\n      'doRequestFullscreen',\n      'fillPointerlockChangeEventData',\n      'registerPointerlockChangeEventCallback',\n      'registerPointerlockErrorEventCallback',\n      'requestPointerLock',\n      'fillVisibilityChangeEventData',\n      'registerVisibilityChangeEventCallback',\n      'registerTouchEventCallback',\n      'fillGamepadEventData',\n      'registerGamepadEventCallback',\n      'registerBeforeUnloadEventCallback',\n      'fillBatteryEventData',\n      'battery',\n      'registerBatteryEventCallback',\n      'setCanvasElementSize',\n      'getCanvasElementSize',\n      'jsStackTrace',\n      'getCallstack',\n      'convertPCtoSourceLocation',\n      'checkWasiClock',\n      'wasiRightsToMuslOFlags',\n      'wasiOFlagsToMuslOFlags',\n      'createDyncallWrapper',\n      'safeSetTimeout',\n      'setImmediateWrapped',\n      'clearImmediateWrapped',\n      'polyfillSetImmediate',\n      'registerPostMainLoop',\n      'registerPreMainLoop',\n      'getPromise',\n      'makePromise',\n      'idsToPromises',\n      'makePromiseCallback',\n      'ExceptionInfo',\n      'findMatchingCatch',\n      'Browser_asyncPrepareDataCounter',\n      'safeRequestAnimationFrame',\n      'arraySum',\n      'addDays',\n      'getSocketFromFD',\n      'getSocketAddress',\n      'FS_unlink',\n      'FS_mkdirTree',\n      '_setNetworkCallback',\n      'heapObjectForWebGLType',\n      'toTypedArrayIndex',\n      'webgl_enable_ANGLE_instanced_arrays',\n      'webgl_enable_OES_vertex_array_object',\n      'webgl_enable_WEBGL_draw_buffers',\n      'webgl_enable_WEBGL_multi_draw',\n      'webgl_enable_EXT_polygon_offset_clamp',\n      'webgl_enable_EXT_clip_control',\n      'webgl_enable_WEBGL_polygon_mode',\n      'emscriptenWebGLGet',\n      'computeUnpackAlignedImageSize',\n      'colorChannelsInGlTextureFormat',\n      'emscriptenWebGLGetTexPixelData',\n      'emscriptenWebGLGetUniform',\n      'webglGetUniformLocation',\n      'webglPrepareUniformLocationsBeforeFirstUse',\n      'webglGetLeftBracePos',\n      'emscriptenWebGLGetVertexAttrib',\n      '__glGetActiveAttribOrUniform',\n      'writeGLArray',\n      'registerWebGlEventCallback',\n      'runAndAbortIfError',\n      'ALLOC_NORMAL',\n      'ALLOC_STACK',\n      'allocate',\n      'writeStringToMemory',\n      'writeAsciiToMemory',\n      'setErrNo',\n      'demangle',\n      'stackTrace',\n    ];\n    missingLibrarySymbols.forEach(missingLibrarySymbol);\n\n    var unexportedSymbols = [\n      'run',\n      'addOnPreRun',\n      'addOnInit',\n      'addOnPreMain',\n      'addOnExit',\n      'addOnPostRun',\n      'addRunDependency',\n      'removeRunDependency',\n      'out',\n      'err',\n      'callMain',\n      'abort',\n      'wasmMemory',\n      'writeStackCookie',\n      'checkStackCookie',\n      'convertI32PairToI53Checked',\n      'stackSave',\n      'stackRestore',\n      'stackAlloc',\n      'ptrToString',\n      'zeroMemory',\n      'getHeapMax',\n      'growMemory',\n      'ENV',\n      'ERRNO_CODES',\n      'strError',\n      'DNS',\n      'Protocols',\n      'Sockets',\n      'initRandomFill',\n      'randomFill',\n      'timers',\n      'warnOnce',\n      'readEmAsmArgsArray',\n      'jstoi_s',\n      'getExecutableName',\n      'asyncLoad',\n      'alignMemory',\n      'mmapAlloc',\n      'wasmTable',\n      'noExitRuntime',\n      'getCFunc',\n      'uleb128Encode',\n      'sigToWasmTypes',\n      'generateFuncType',\n      'convertJsFunctionToWasm',\n      'freeTableIndexes',\n      'functionsInTableMap',\n      'getEmptyTableSlot',\n      'updateTableMap',\n      'getFunctionAddress',\n      'PATH',\n      'PATH_FS',\n      'UTF8Decoder',\n      'UTF8ArrayToString',\n      'stringToUTF8Array',\n      'lengthBytesUTF8',\n      'intArrayFromString',\n      'stringToAscii',\n      'UTF16Decoder',\n      'stringToUTF8OnStack',\n      'writeArrayToMemory',\n      'JSEvents',\n      'specialHTMLTargets',\n      'findCanvasEventTarget',\n      'currentFullscreenStrategy',\n      'restoreOldWindowedStyle',\n      'UNWIND_CACHE',\n      'ExitStatus',\n      'getEnvStrings',\n      'doReadv',\n      'doWritev',\n      'promiseMap',\n      'uncaughtExceptionCount',\n      'exceptionLast',\n      'exceptionCaught',\n      'Browser',\n      'getPreloadedImageData__data',\n      'wget',\n      'MONTH_DAYS_REGULAR',\n      'MONTH_DAYS_LEAP',\n      'MONTH_DAYS_REGULAR_CUMULATIVE',\n      'MONTH_DAYS_LEAP_CUMULATIVE',\n      'isLeapYear',\n      'ydayFromDate',\n      'SYSCALLS',\n      'preloadPlugins',\n      'FS_createPreloadedFile',\n      'FS_modeStringToFlags',\n      'FS_getMode',\n      'FS_stdin_getChar_buffer',\n      'FS_stdin_getChar',\n      'FS_createPath',\n      'FS_createDevice',\n      'FS_readFile',\n      'FS',\n      'FS_createDataFile',\n      'FS_createLazyFile',\n      'MEMFS',\n      'TTY',\n      'PIPEFS',\n      'SOCKFS',\n      'tempFixedLengthArray',\n      'miniTempWebGLFloatBuffers',\n      'miniTempWebGLIntBuffers',\n      'GL',\n      'AL',\n      'GLUT',\n      'EGL',\n      'GLEW',\n      'IDBStore',\n      'SDL',\n      'SDL_gfx',\n      'allocateUTF8',\n      'allocateUTF8OnStack',\n      'print',\n      'printErr',\n    ];\n    unexportedSymbols.forEach(unexportedRuntimeSymbol);\n\n    var calledRun;\n    var calledPrerun;\n\n    dependenciesFulfilled = function runCaller() {\n      // If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)\n      if (!calledRun) run();\n      if (!calledRun) dependenciesFulfilled = runCaller; // try this again later, after new deps are fulfilled\n    };\n\n    function stackCheckInit() {\n      // This is normally called automatically during __wasm_call_ctors but need to\n      // get these values before even running any of the ctors so we call it redundantly\n      // here.\n      _emscripten_stack_init();\n      // TODO(sbc): Move writeStackCookie to native to to avoid this.\n      writeStackCookie();\n    }\n\n    function run() {\n      if (runDependencies > 0) {\n        return;\n      }\n\n      stackCheckInit();\n\n      if (!calledPrerun) {\n        calledPrerun = 1;\n        preRun();\n\n        // a preRun added a dependency, run will be called later\n        if (runDependencies > 0) {\n          return;\n        }\n      }\n\n      function doRun() {\n        // run may have just been called through dependencies being fulfilled just in this very frame,\n        // or while the async setStatus time below was happening\n        if (calledRun) return;\n        calledRun = 1;\n        Module['calledRun'] = 1;\n\n        if (ABORT) return;\n\n        initRuntime();\n\n        readyPromiseResolve(Module);\n        Module['onRuntimeInitialized']?.();\n\n        assert(\n          !Module['_main'],\n          'compiled without a main, but one is present. if you added it from JS, use Module[\"onRuntimeInitialized\"]',\n        );\n\n        postRun();\n      }\n\n      if (Module['setStatus']) {\n        Module['setStatus']('Running...');\n        setTimeout(() => {\n          setTimeout(() => Module['setStatus'](''), 1);\n          doRun();\n        }, 1);\n      } else {\n        doRun();\n      }\n      checkStackCookie();\n    }\n\n    if (Module['preInit']) {\n      if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];\n      while (Module['preInit'].length > 0) {\n        Module['preInit'].pop()();\n      }\n    }\n\n    run();\n\n    // end include: postamble.js\n\n    // include: postamble_modularize.js\n    // In MODULARIZE mode we wrap the generated code in a factory function\n    // and return either the Module itself, or a promise of the module.\n    //\n    // We assign to the `moduleRtn` global here and configure closure to see\n    // this as and extern so it won't get minified.\n\n    moduleRtn = readyPromise;\n\n    // Assertion for attempting to access module properties on the incoming\n    // moduleArg.  In the past we used this object as the prototype of the module\n    // and assigned properties to it, but now we return a distinct object.  This\n    // keeps the instance private until it is ready (i.e the promise has been\n    // resolved).\n    for (const prop of Object.keys(Module)) {\n      if (!(prop in moduleArg)) {\n        Object.defineProperty(moduleArg, prop, {\n          configurable: true,\n          get() {\n            abort(\n              `Access to module property ('${prop}') is no longer possible via the module constructor argument; Instead, use the result of the module constructor.`,\n            );\n          },\n        });\n      }\n    }\n    // end include: postamble_modularize.js\n\n    return moduleRtn;\n  };\n})();\n\n/* AUTO-GENERATED  DO NOT EDIT BY HAND */\nconst functions = {\n    EPDF_RenderAnnotBitmap: [\n        ['number', 'number', 'number', 'number', 'number', 'number'],\n        'boolean',\n    ],\n    EPDFAnnot_GenerateAppearance: [['number'], 'boolean'],\n    EPDFAnnot_GenerateAppearanceWithBlend: [['number', 'number'], 'boolean'],\n    EPDFAnnot_GetBlendMode: [['number'], 'number'],\n    EPDFAnnot_GetBorderDashPattern: [['number', 'number', 'number'], 'boolean'],\n    EPDFAnnot_GetBorderDashPatternCount: [['number'], 'number'],\n    EPDFAnnot_GetBorderEffect: [['number', 'number'], 'boolean'],\n    EPDFAnnot_GetBorderStyle: [['number', 'number'], 'number'],\n    EPDFAnnot_GetColor: [\n        ['number', 'number', 'number', 'number', 'number', 'number'],\n        'boolean',\n    ],\n    EPDFAnnot_GetIntent: [['number', 'number', 'number'], 'number'],\n    EPDFAnnot_GetRectangleDifferences: [\n        ['number', 'number', 'number', 'number', 'number'],\n        'boolean',\n    ],\n    EPDFAnnot_GetRichContent: [['number', 'number', 'number'], 'number'],\n    EPDFAnnot_SetBorderStyle: [['number', 'number', 'number'], 'boolean'],\n    EPDFAnnot_SetColor: [\n        ['number', 'number', 'number', 'number', 'number', 'number'],\n        'boolean',\n    ],\n    EPDFAnnot_SetIntent: [['number', 'string'], 'boolean'],\n    FORM_CanRedo: [['number', 'number'], 'boolean'],\n    FORM_CanUndo: [['number', 'number'], 'boolean'],\n    FORM_DoDocumentAAction: [['number', 'number'], null],\n    FORM_DoDocumentJSAction: [['number'], null],\n    FORM_DoDocumentOpenAction: [['number'], null],\n    FORM_DoPageAAction: [['number', 'number', 'number'], null],\n    FORM_ForceToKillFocus: [['number'], 'boolean'],\n    FORM_GetFocusedAnnot: [['number', 'number', 'number'], 'boolean'],\n    FORM_GetFocusedText: [['number', 'number', 'number', 'number'], 'number'],\n    FORM_GetSelectedText: [['number', 'number', 'number', 'number'], 'number'],\n    FORM_IsIndexSelected: [['number', 'number', 'number'], 'boolean'],\n    FORM_OnAfterLoadPage: [['number', 'number'], null],\n    FORM_OnBeforeClosePage: [['number', 'number'], null],\n    FORM_OnChar: [['number', 'number', 'number', 'number'], 'boolean'],\n    FORM_OnFocus: [['number', 'number', 'number', 'number', 'number'], 'boolean'],\n    FORM_OnKeyDown: [['number', 'number', 'number', 'number'], 'boolean'],\n    FORM_OnKeyUp: [['number', 'number', 'number', 'number'], 'boolean'],\n    FORM_OnLButtonDoubleClick: [\n        ['number', 'number', 'number', 'number', 'number'],\n        'boolean',\n    ],\n    FORM_OnLButtonDown: [\n        ['number', 'number', 'number', 'number', 'number'],\n        'boolean',\n    ],\n    FORM_OnLButtonUp: [\n        ['number', 'number', 'number', 'number', 'number'],\n        'boolean',\n    ],\n    FORM_OnMouseMove: [\n        ['number', 'number', 'number', 'number', 'number'],\n        'boolean',\n    ],\n    FORM_OnMouseWheel: [\n        ['number', 'number', 'number', 'number', 'number', 'number'],\n        'boolean',\n    ],\n    FORM_OnRButtonDown: [\n        ['number', 'number', 'number', 'number', 'number'],\n        'boolean',\n    ],\n    FORM_OnRButtonUp: [\n        ['number', 'number', 'number', 'number', 'number'],\n        'boolean',\n    ],\n    FORM_Redo: [['number', 'number'], 'boolean'],\n    FORM_ReplaceAndKeepSelection: [['number', 'number', 'number'], null],\n    FORM_ReplaceSelection: [['number', 'number', 'number'], null],\n    FORM_SelectAllText: [['number', 'number'], 'boolean'],\n    FORM_SetFocusedAnnot: [['number', 'number'], 'boolean'],\n    FORM_SetIndexSelected: [['number', 'number', 'number', 'boolean'], 'boolean'],\n    FORM_Undo: [['number', 'number'], 'boolean'],\n    FPDF_AddInstalledFont: [['number', 'number', 'number'], null],\n    FPDF_CloseDocument: [['number'], null],\n    FPDF_ClosePage: [['number'], null],\n    FPDF_CloseXObject: [['number'], null],\n    FPDF_CopyViewerPreferences: [['number', 'number'], 'boolean'],\n    FPDF_CountNamedDests: [['number'], 'number'],\n    FPDF_CreateClipPath: [['number', 'number', 'number', 'number'], 'number'],\n    FPDF_CreateNewDocument: [[], 'number'],\n    FPDF_DestroyClipPath: [['number'], null],\n    FPDF_DestroyLibrary: [[], null],\n    FPDF_DeviceToPage: [\n        [\n            'number',\n            'number',\n            'number',\n            'number',\n            'number',\n            'number',\n            'number',\n            'number',\n            'number',\n            'number',\n        ],\n        'boolean',\n    ],\n    FPDF_DocumentHasValidCrossReferenceTable: [['number'], 'boolean'],\n    FPDF_FFLDraw: [\n        [\n            'number',\n            'number',\n            'number',\n            'number',\n            'number',\n            'number',\n            'number',\n            'number',\n            'number',\n        ],\n        null,\n    ],\n    FPDF_FreeDefaultSystemFontInfo: [['number'], null],\n    FPDF_GetDefaultSystemFontInfo: [[], 'number'],\n    FPDF_GetDefaultTTFMap: [[], 'number'],\n    FPDF_GetDefaultTTFMapCount: [[], 'number'],\n    FPDF_GetDefaultTTFMapEntry: [['number'], 'number'],\n    FPDF_GetDocPermissions: [['number'], 'number'],\n    FPDF_GetDocUserPermissions: [['number'], 'number'],\n    FPDF_GetFileIdentifier: [['number', 'number', 'number', 'number'], 'number'],\n    FPDF_GetFileVersion: [['number', 'number'], 'boolean'],\n    FPDF_GetFormType: [['number'], 'number'],\n    FPDF_GetLastError: [[], 'number'],\n    FPDF_GetMetaText: [['number', 'string', 'number', 'number'], 'number'],\n    FPDF_GetNamedDest: [['number', 'number', 'number', 'number'], 'number'],\n    FPDF_GetNamedDestByName: [['number', 'string'], 'number'],\n    FPDF_GetPageAAction: [['number', 'number'], 'number'],\n    FPDF_GetPageBoundingBox: [['number', 'number'], 'boolean'],\n    FPDF_GetPageCount: [['number'], 'number'],\n    FPDF_GetPageHeight: [['number'], 'number'],\n    FPDF_GetPageHeightF: [['number'], 'number'],\n    FPDF_GetPageLabel: [['number', 'number', 'number', 'number'], 'number'],\n    FPDF_GetPageSizeByIndex: [['number', 'number', 'number', 'number'], 'number'],\n    FPDF_GetPageSizeByIndexF: [['number', 'number', 'number'], 'boolean'],\n    FPDF_GetPageWidth: [['number'], 'number'],\n    FPDF_GetPageWidthF: [['number'], 'number'],\n    FPDF_GetSecurityHandlerRevision: [['number'], 'number'],\n    FPDF_GetSignatureCount: [['number'], 'number'],\n    FPDF_GetSignatureObject: [['number', 'number'], 'number'],\n    FPDF_GetTrailerEnds: [['number', 'number', 'number'], 'number'],\n    FPDF_GetXFAPacketContent: [\n        ['number', 'number', 'number', 'number', 'number'],\n        'boolean',\n    ],\n    FPDF_GetXFAPacketCount: [['number'], 'number'],\n    FPDF_GetXFAPacketName: [['number', 'number', 'number', 'number'], 'number'],\n    FPDF_ImportNPagesToOne: [\n        ['number', 'number', 'number', 'number', 'number'],\n        'number',\n    ],\n    FPDF_ImportPages: [['number', 'number', 'string', 'number'], 'boolean'],\n    FPDF_ImportPagesByIndex: [\n        ['number', 'number', 'number', 'number', 'number'],\n        'boolean',\n    ],\n    FPDF_InitLibrary: [[], null],\n    FPDF_InitLibraryWithConfig: [['number'], null],\n    FPDF_LoadCustomDocument: [['number', 'string'], 'number'],\n    FPDF_LoadDocument: [['number', 'string'], 'number'],\n    FPDF_LoadMemDocument: [['number', 'number', 'string'], 'number'],\n    FPDF_LoadMemDocument64: [['number', 'number', 'string'], 'number'],\n    FPDF_LoadPage: [['number', 'number'], 'number'],\n    FPDF_LoadXFA: [['number'], 'boolean'],\n    FPDF_MovePages: [['number', 'number', 'number', 'number'], 'boolean'],\n    FPDF_NewFormObjectFromXObject: [['number'], 'number'],\n    FPDF_NewXObjectFromPage: [['number', 'number', 'number'], 'number'],\n    FPDF_PageToDevice: [\n        [\n            'number',\n            'number',\n            'number',\n            'number',\n            'number',\n            'number',\n            'number',\n            'number',\n            'number',\n            'number',\n        ],\n        'boolean',\n    ],\n    FPDF_RemoveFormFieldHighlight: [['number'], null],\n    FPDF_RenderPage_Close: [['number'], null],\n    FPDF_RenderPage_Continue: [['number', 'number'], 'number'],\n    FPDF_RenderPageBitmap: [\n        ['number', 'number', 'number', 'number', 'number', 'number', 'number', 'number'],\n        null,\n    ],\n    FPDF_RenderPageBitmap_Start: [\n        [\n            'number',\n            'number',\n            'number',\n            'number',\n            'number',\n            'number',\n            'number',\n            'number',\n            'number',\n        ],\n        'number',\n    ],\n    FPDF_RenderPageBitmapWithColorScheme_Start: [\n        [\n            'number',\n            'number',\n            'number',\n            'number',\n            'number',\n            'number',\n            'number',\n            'number',\n            'number',\n            'number',\n        ],\n        'number',\n    ],\n    FPDF_RenderPageBitmapWithMatrix: [\n        ['number', 'number', 'number', 'number', 'number'],\n        null,\n    ],\n    FPDF_SaveAsCopy: [['number', 'number', 'number'], 'boolean'],\n    FPDF_SaveWithVersion: [['number', 'number', 'number', 'number'], 'boolean'],\n    FPDF_SetFormFieldHighlightAlpha: [['number', 'number'], null],\n    FPDF_SetFormFieldHighlightColor: [['number', 'number', 'number'], null],\n    FPDF_SetSandBoxPolicy: [['number', 'boolean'], null],\n    FPDF_SetSystemFontInfo: [['number'], null],\n    FPDF_StructElement_Attr_CountChildren: [['number'], 'number'],\n    FPDF_StructElement_Attr_GetBlobValue: [\n        ['number', 'number', 'number', 'number'],\n        'boolean',\n    ],\n    FPDF_StructElement_Attr_GetBooleanValue: [['number', 'number'], 'boolean'],\n    FPDF_StructElement_Attr_GetChildAtIndex: [['number', 'number'], 'number'],\n    FPDF_StructElement_Attr_GetCount: [['number'], 'number'],\n    FPDF_StructElement_Attr_GetName: [\n        ['number', 'number', 'number', 'number', 'number'],\n        'boolean',\n    ],\n    FPDF_StructElement_Attr_GetNumberValue: [['number', 'number'], 'boolean'],\n    FPDF_StructElement_Attr_GetStringValue: [\n        ['number', 'number', 'number', 'number'],\n        'boolean',\n    ],\n    FPDF_StructElement_Attr_GetType: [['number'], 'number'],\n    FPDF_StructElement_Attr_GetValue: [['number', 'string'], 'number'],\n    FPDF_StructElement_CountChildren: [['number'], 'number'],\n    FPDF_StructElement_GetActualText: [['number', 'number', 'number'], 'number'],\n    FPDF_StructElement_GetAltText: [['number', 'number', 'number'], 'number'],\n    FPDF_StructElement_GetAttributeAtIndex: [['number', 'number'], 'number'],\n    FPDF_StructElement_GetAttributeCount: [['number'], 'number'],\n    FPDF_StructElement_GetChildAtIndex: [['number', 'number'], 'number'],\n    FPDF_StructElement_GetChildMarkedContentID: [['number', 'number'], 'number'],\n    FPDF_StructElement_GetID: [['number', 'number', 'number'], 'number'],\n    FPDF_StructElement_GetLang: [['number', 'number', 'number'], 'number'],\n    FPDF_StructElement_GetMarkedContentID: [['number'], 'number'],\n    FPDF_StructElement_GetMarkedContentIdAtIndex: [['number', 'number'], 'number'],\n    FPDF_StructElement_GetMarkedContentIdCount: [['number'], 'number'],\n    FPDF_StructElement_GetObjType: [['number', 'number', 'number'], 'number'],\n    FPDF_StructElement_GetParent: [['number'], 'number'],\n    FPDF_StructElement_GetStringAttribute: [\n        ['number', 'string', 'number', 'number'],\n        'number',\n    ],\n    FPDF_StructElement_GetTitle: [['number', 'number', 'number'], 'number'],\n    FPDF_StructElement_GetType: [['number', 'number', 'number'], 'number'],\n    FPDF_StructTree_Close: [['number'], null],\n    FPDF_StructTree_CountChildren: [['number'], 'number'],\n    FPDF_StructTree_GetChildAtIndex: [['number', 'number'], 'number'],\n    FPDF_StructTree_GetForPage: [['number'], 'number'],\n    FPDF_VIEWERREF_GetDuplex: [['number'], 'number'],\n    FPDF_VIEWERREF_GetName: [['number', 'string', 'number', 'number'], 'number'],\n    FPDF_VIEWERREF_GetNumCopies: [['number'], 'number'],\n    FPDF_VIEWERREF_GetPrintPageRange: [['number'], 'number'],\n    FPDF_VIEWERREF_GetPrintPageRangeCount: [['number'], 'number'],\n    FPDF_VIEWERREF_GetPrintPageRangeElement: [['number', 'number'], 'number'],\n    FPDF_VIEWERREF_GetPrintScaling: [['number'], 'boolean'],\n    FPDFAction_GetDest: [['number', 'number'], 'number'],\n    FPDFAction_GetFilePath: [['number', 'number', 'number'], 'number'],\n    FPDFAction_GetType: [['number'], 'number'],\n    FPDFAction_GetURIPath: [['number', 'number', 'number', 'number'], 'number'],\n    FPDFAnnot_AddFileAttachment: [['number', 'number'], 'number'],\n    FPDFAnnot_AddInkStroke: [['number', 'number', 'number'], 'number'],\n    FPDFAnnot_AppendAttachmentPoints: [['number', 'number'], 'boolean'],\n    FPDFAnnot_AppendObject: [['number', 'number'], 'boolean'],\n    FPDFAnnot_CountAttachmentPoints: [['number'], 'number'],\n    FPDFAnnot_GetAP: [['number', 'number', 'number', 'number'], 'number'],\n    FPDFAnnot_GetAttachmentPoints: [['number', 'number', 'number'], 'boolean'],\n    FPDFAnnot_GetBorder: [['number', 'number', 'number', 'number'], 'boolean'],\n    FPDFAnnot_GetColor: [\n        ['number', 'number', 'number', 'number', 'number', 'number'],\n        'boolean',\n    ],\n    FPDFAnnot_GetFileAttachment: [['number'], 'number'],\n    FPDFAnnot_GetFlags: [['number'], 'number'],\n    FPDFAnnot_GetFocusableSubtypes: [['number', 'number', 'number'], 'boolean'],\n    FPDFAnnot_GetFocusableSubtypesCount: [['number'], 'number'],\n    FPDFAnnot_GetFontColor: [\n        ['number', 'number', 'number', 'number', 'number'],\n        'boolean',\n    ],\n    FPDFAnnot_GetFontSize: [['number', 'number', 'number'], 'boolean'],\n    FPDFAnnot_GetFormAdditionalActionJavaScript: [\n        ['number', 'number', 'number', 'number', 'number'],\n        'number',\n    ],\n    FPDFAnnot_GetFormControlCount: [['number', 'number'], 'number'],\n    FPDFAnnot_GetFormControlIndex: [['number', 'number'], 'number'],\n    FPDFAnnot_GetFormFieldAlternateName: [\n        ['number', 'number', 'number', 'number'],\n        'number',\n    ],\n    FPDFAnnot_GetFormFieldAtPoint: [['number', 'number', 'number'], 'number'],\n    FPDFAnnot_GetFormFieldExportValue: [\n        ['number', 'number', 'number', 'number'],\n        'number',\n    ],\n    FPDFAnnot_GetFormFieldFlags: [['number', 'number'], 'number'],\n    FPDFAnnot_GetFormFieldName: [\n        ['number', 'number', 'number', 'number'],\n        'number',\n    ],\n    FPDFAnnot_GetFormFieldType: [['number', 'number'], 'number'],\n    FPDFAnnot_GetFormFieldValue: [\n        ['number', 'number', 'number', 'number'],\n        'number',\n    ],\n    FPDFAnnot_GetInkListCount: [['number'], 'number'],\n    FPDFAnnot_GetInkListPath: [['number', 'number', 'number', 'number'], 'number'],\n    FPDFAnnot_GetLine: [['number', 'number', 'number'], 'boolean'],\n    FPDFAnnot_GetLink: [['number'], 'number'],\n    FPDFAnnot_GetLinkedAnnot: [['number', 'string'], 'number'],\n    FPDFAnnot_GetNumberValue: [['number', 'string', 'number'], 'boolean'],\n    FPDFAnnot_GetObject: [['number', 'number'], 'number'],\n    FPDFAnnot_GetObjectCount: [['number'], 'number'],\n    FPDFAnnot_GetOptionCount: [['number', 'number'], 'number'],\n    FPDFAnnot_GetOptionLabel: [\n        ['number', 'number', 'number', 'number', 'number'],\n        'number',\n    ],\n    FPDFAnnot_GetRect: [['number', 'number'], 'boolean'],\n    FPDFAnnot_GetStringValue: [['number', 'string', 'number', 'number'], 'number'],\n    FPDFAnnot_GetSubtype: [['number'], 'number'],\n    FPDFAnnot_GetValueType: [['number', 'string'], 'number'],\n    FPDFAnnot_GetVertices: [['number', 'number', 'number'], 'number'],\n    FPDFAnnot_HasAttachmentPoints: [['number'], 'boolean'],\n    FPDFAnnot_HasKey: [['number', 'string'], 'boolean'],\n    FPDFAnnot_IsChecked: [['number', 'number'], 'boolean'],\n    FPDFAnnot_IsObjectSupportedSubtype: [['number'], 'boolean'],\n    FPDFAnnot_IsOptionSelected: [['number', 'number', 'number'], 'boolean'],\n    FPDFAnnot_IsSupportedSubtype: [['number'], 'boolean'],\n    FPDFAnnot_RemoveInkList: [['number'], 'boolean'],\n    FPDFAnnot_RemoveObject: [['number', 'number'], 'boolean'],\n    FPDFAnnot_SetAP: [['number', 'number', 'number'], 'boolean'],\n    FPDFAnnot_SetAttachmentPoints: [['number', 'number', 'number'], 'boolean'],\n    FPDFAnnot_SetBorder: [['number', 'number', 'number', 'number'], 'boolean'],\n    FPDFAnnot_SetColor: [\n        ['number', 'number', 'number', 'number', 'number', 'number'],\n        'boolean',\n    ],\n    FPDFAnnot_SetFlags: [['number', 'number'], 'boolean'],\n    FPDFAnnot_SetFocusableSubtypes: [['number', 'number', 'number'], 'boolean'],\n    FPDFAnnot_SetFontColor: [\n        ['number', 'number', 'number', 'number', 'number'],\n        'boolean',\n    ],\n    FPDFAnnot_SetFormFieldFlags: [['number', 'number', 'number'], 'boolean'],\n    FPDFAnnot_SetRect: [['number', 'number'], 'boolean'],\n    FPDFAnnot_SetStringValue: [['number', 'string', 'number'], 'boolean'],\n    FPDFAnnot_SetURI: [['number', 'number'], 'boolean'],\n    FPDFAnnot_UpdateObject: [['number', 'number'], 'boolean'],\n    FPDFAttachment_GetFile: [['number', 'number', 'number', 'number'], 'boolean'],\n    FPDFAttachment_GetName: [['number', 'number', 'number'], 'number'],\n    FPDFAttachment_GetStringValue: [\n        ['number', 'string', 'number', 'number'],\n        'number',\n    ],\n    FPDFAttachment_GetSubtype: [['number', 'number', 'number'], 'number'],\n    FPDFAttachment_GetValueType: [['number', 'string'], 'number'],\n    FPDFAttachment_HasKey: [['number', 'string'], 'boolean'],\n    FPDFAttachment_SetFile: [['number', 'number', 'number', 'number'], 'boolean'],\n    FPDFAttachment_SetStringValue: [['number', 'string', 'number'], 'boolean'],\n    FPDFAvail_Create: [['number', 'number'], 'number'],\n    FPDFAvail_Destroy: [['number'], null],\n    FPDFAvail_GetDocument: [['number', 'string'], 'number'],\n    FPDFAvail_GetFirstPageNum: [['number'], 'number'],\n    FPDFAvail_IsDocAvail: [['number', 'number'], 'number'],\n    FPDFAvail_IsFormAvail: [['number', 'number'], 'number'],\n    FPDFAvail_IsLinearized: [['number'], 'number'],\n    FPDFAvail_IsPageAvail: [['number', 'number', 'number'], 'number'],\n    FPDFBitmap_Create: [['number', 'number', 'number'], 'number'],\n    FPDFBitmap_CreateEx: [\n        ['number', 'number', 'number', 'number', 'number'],\n        'number',\n    ],\n    FPDFBitmap_Destroy: [['number'], null],\n    FPDFBitmap_FillRect: [\n        ['number', 'number', 'number', 'number', 'number', 'number'],\n        'boolean',\n    ],\n    FPDFBitmap_GetBuffer: [['number'], 'number'],\n    FPDFBitmap_GetFormat: [['number'], 'number'],\n    FPDFBitmap_GetHeight: [['number'], 'number'],\n    FPDFBitmap_GetStride: [['number'], 'number'],\n    FPDFBitmap_GetWidth: [['number'], 'number'],\n    FPDFBookmark_Find: [['number', 'number'], 'number'],\n    FPDFBookmark_GetAction: [['number'], 'number'],\n    FPDFBookmark_GetCount: [['number'], 'number'],\n    FPDFBookmark_GetDest: [['number', 'number'], 'number'],\n    FPDFBookmark_GetFirstChild: [['number', 'number'], 'number'],\n    FPDFBookmark_GetNextSibling: [['number', 'number'], 'number'],\n    FPDFBookmark_GetTitle: [['number', 'number', 'number'], 'number'],\n    FPDFCatalog_IsTagged: [['number'], 'boolean'],\n    FPDFCatalog_SetLanguage: [['number', 'string'], 'boolean'],\n    FPDFClipPath_CountPaths: [['number'], 'number'],\n    FPDFClipPath_CountPathSegments: [['number', 'number'], 'number'],\n    FPDFClipPath_GetPathSegment: [['number', 'number', 'number'], 'number'],\n    FPDFDest_GetDestPageIndex: [['number', 'number'], 'number'],\n    FPDFDest_GetLocationInPage: [\n        ['number', 'number', 'number', 'number', 'number', 'number', 'number'],\n        'boolean',\n    ],\n    FPDFDest_GetView: [['number', 'number', 'number'], 'number'],\n    FPDFDoc_AddAttachment: [['number', 'number'], 'number'],\n    FPDFDoc_CloseJavaScriptAction: [['number'], null],\n    FPDFDoc_DeleteAttachment: [['number', 'number'], 'boolean'],\n    FPDFDOC_ExitFormFillEnvironment: [['number'], null],\n    FPDFDoc_GetAttachment: [['number', 'number'], 'number'],\n    FPDFDoc_GetAttachmentCount: [['number'], 'number'],\n    FPDFDoc_GetJavaScriptAction: [['number', 'number'], 'number'],\n    FPDFDoc_GetJavaScriptActionCount: [['number'], 'number'],\n    FPDFDoc_GetPageMode: [['number'], 'number'],\n    FPDFDOC_InitFormFillEnvironment: [['number', 'number'], 'number'],\n    FPDFFont_Close: [['number'], null],\n    FPDFFont_GetAscent: [['number', 'number', 'number'], 'boolean'],\n    FPDFFont_GetBaseFontName: [['number', 'number', 'number'], 'number'],\n    FPDFFont_GetDescent: [['number', 'number', 'number'], 'boolean'],\n    FPDFFont_GetFamilyName: [['number', 'number', 'number'], 'number'],\n    FPDFFont_GetFlags: [['number'], 'number'],\n    FPDFFont_GetFontData: [['number', 'number', 'number', 'number'], 'boolean'],\n    FPDFFont_GetGlyphPath: [['number', 'number', 'number'], 'number'],\n    FPDFFont_GetGlyphWidth: [['number', 'number', 'number', 'number'], 'boolean'],\n    FPDFFont_GetIsEmbedded: [['number'], 'number'],\n    FPDFFont_GetItalicAngle: [['number', 'number'], 'boolean'],\n    FPDFFont_GetWeight: [['number'], 'number'],\n    FPDFFormObj_CountObjects: [['number'], 'number'],\n    FPDFFormObj_GetObject: [['number', 'number'], 'number'],\n    FPDFFormObj_RemoveObject: [['number', 'number'], 'boolean'],\n    FPDFGlyphPath_CountGlyphSegments: [['number'], 'number'],\n    FPDFGlyphPath_GetGlyphPathSegment: [['number', 'number'], 'number'],\n    FPDFImageObj_GetBitmap: [['number'], 'number'],\n    FPDFImageObj_GetIccProfileDataDecoded: [\n        ['number', 'number', 'number', 'number', 'number'],\n        'boolean',\n    ],\n    FPDFImageObj_GetImageDataDecoded: [['number', 'number', 'number'], 'number'],\n    FPDFImageObj_GetImageDataRaw: [['number', 'number', 'number'], 'number'],\n    FPDFImageObj_GetImageFilter: [\n        ['number', 'number', 'number', 'number'],\n        'number',\n    ],\n    FPDFImageObj_GetImageFilterCount: [['number'], 'number'],\n    FPDFImageObj_GetImageMetadata: [['number', 'number', 'number'], 'boolean'],\n    FPDFImageObj_GetImagePixelSize: [['number', 'number', 'number'], 'boolean'],\n    FPDFImageObj_GetRenderedBitmap: [['number', 'number', 'number'], 'number'],\n    FPDFImageObj_LoadJpegFile: [\n        ['number', 'number', 'number', 'number'],\n        'boolean',\n    ],\n    FPDFImageObj_LoadJpegFileInline: [\n        ['number', 'number', 'number', 'number'],\n        'boolean',\n    ],\n    FPDFImageObj_SetBitmap: [['number', 'number', 'number', 'number'], 'boolean'],\n    FPDFImageObj_SetMatrix: [\n        ['number', 'number', 'number', 'number', 'number', 'number', 'number'],\n        'boolean',\n    ],\n    FPDFJavaScriptAction_GetName: [['number', 'number', 'number'], 'number'],\n    FPDFJavaScriptAction_GetScript: [['number', 'number', 'number'], 'number'],\n    FPDFLink_CloseWebLinks: [['number'], null],\n    FPDFLink_CountQuadPoints: [['number'], 'number'],\n    FPDFLink_CountRects: [['number', 'number'], 'number'],\n    FPDFLink_CountWebLinks: [['number'], 'number'],\n    FPDFLink_Enumerate: [['number', 'number', 'number'], 'boolean'],\n    FPDFLink_GetAction: [['number'], 'number'],\n    FPDFLink_GetAnnot: [['number', 'number'], 'number'],\n    FPDFLink_GetAnnotRect: [['number', 'number'], 'boolean'],\n    FPDFLink_GetDest: [['number', 'number'], 'number'],\n    FPDFLink_GetLinkAtPoint: [['number', 'number', 'number'], 'number'],\n    FPDFLink_GetLinkZOrderAtPoint: [['number', 'number', 'number'], 'number'],\n    FPDFLink_GetQuadPoints: [['number', 'number', 'number'], 'boolean'],\n    FPDFLink_GetRect: [\n        ['number', 'number', 'number', 'number', 'number', 'number', 'number'],\n        'boolean',\n    ],\n    FPDFLink_GetTextRange: [['number', 'number', 'number', 'number'], 'boolean'],\n    FPDFLink_GetURL: [['number', 'number', 'number', 'number'], 'number'],\n    FPDFLink_LoadWebLinks: [['number'], 'number'],\n    FPDFPage_CloseAnnot: [['number'], null],\n    FPDFPage_CountObjects: [['number'], 'number'],\n    FPDFPage_CreateAnnot: [['number', 'number'], 'number'],\n    FPDFPage_Delete: [['number', 'number'], null],\n    FPDFPage_Flatten: [['number', 'number'], 'number'],\n    FPDFPage_FormFieldZOrderAtPoint: [\n        ['number', 'number', 'number', 'number'],\n        'number',\n    ],\n    FPDFPage_GenerateContent: [['number'], 'boolean'],\n    FPDFPage_GetAnnot: [['number', 'number'], 'number'],\n    FPDFPage_GetAnnotCount: [['number'], 'number'],\n    FPDFPage_GetAnnotIndex: [['number', 'number'], 'number'],\n    FPDFPage_GetArtBox: [\n        ['number', 'number', 'number', 'number', 'number'],\n        'boolean',\n    ],\n    FPDFPage_GetBleedBox: [\n        ['number', 'number', 'number', 'number', 'number'],\n        'boolean',\n    ],\n    FPDFPage_GetCropBox: [\n        ['number', 'number', 'number', 'number', 'number'],\n        'boolean',\n    ],\n    FPDFPage_GetDecodedThumbnailData: [['number', 'number', 'number'], 'number'],\n    FPDFPage_GetMediaBox: [\n        ['number', 'number', 'number', 'number', 'number'],\n        'boolean',\n    ],\n    FPDFPage_GetObject: [['number', 'number'], 'number'],\n    FPDFPage_GetRawThumbnailData: [['number', 'number', 'number'], 'number'],\n    FPDFPage_GetRotation: [['number'], 'number'],\n    FPDFPage_GetThumbnailAsBitmap: [['number'], 'number'],\n    FPDFPage_GetTrimBox: [\n        ['number', 'number', 'number', 'number', 'number'],\n        'boolean',\n    ],\n    FPDFPage_HasFormFieldAtPoint: [\n        ['number', 'number', 'number', 'number'],\n        'number',\n    ],\n    FPDFPage_HasTransparency: [['number'], 'boolean'],\n    FPDFPage_InsertClipPath: [['number', 'number'], null],\n    FPDFPage_InsertObject: [['number', 'number'], null],\n    FPDFPage_InsertObjectAtIndex: [['number', 'number', 'number'], 'boolean'],\n    FPDFPage_New: [['number', 'number', 'number', 'number'], 'number'],\n    FPDFPage_RemoveAnnot: [['number', 'number'], 'boolean'],\n    FPDFPage_RemoveObject: [['number', 'number'], 'boolean'],\n    FPDFPage_SetArtBox: [['number', 'number', 'number', 'number', 'number'], null],\n    FPDFPage_SetBleedBox: [\n        ['number', 'number', 'number', 'number', 'number'],\n        null,\n    ],\n    FPDFPage_SetCropBox: [['number', 'number', 'number', 'number', 'number'], null],\n    FPDFPage_SetMediaBox: [\n        ['number', 'number', 'number', 'number', 'number'],\n        null,\n    ],\n    FPDFPage_SetRotation: [['number', 'number'], null],\n    FPDFPage_SetTrimBox: [['number', 'number', 'number', 'number', 'number'], null],\n    FPDFPage_TransformAnnots: [\n        ['number', 'number', 'number', 'number', 'number', 'number', 'number'],\n        null,\n    ],\n    FPDFPage_TransFormWithClip: [['number', 'number', 'number'], 'boolean'],\n    FPDFPageObj_AddMark: [['number', 'string'], 'number'],\n    FPDFPageObj_CountMarks: [['number'], 'number'],\n    FPDFPageObj_CreateNewPath: [['number', 'number'], 'number'],\n    FPDFPageObj_CreateNewRect: [['number', 'number', 'number', 'number'], 'number'],\n    FPDFPageObj_CreateTextObj: [['number', 'number', 'number'], 'number'],\n    FPDFPageObj_Destroy: [['number'], null],\n    FPDFPageObj_GetBounds: [\n        ['number', 'number', 'number', 'number', 'number'],\n        'boolean',\n    ],\n    FPDFPageObj_GetClipPath: [['number'], 'number'],\n    FPDFPageObj_GetDashArray: [['number', 'number', 'number'], 'boolean'],\n    FPDFPageObj_GetDashCount: [['number'], 'number'],\n    FPDFPageObj_GetDashPhase: [['number', 'number'], 'boolean'],\n    FPDFPageObj_GetFillColor: [\n        ['number', 'number', 'number', 'number', 'number'],\n        'boolean',\n    ],\n    FPDFPageObj_GetIsActive: [['number', 'number'], 'boolean'],\n    FPDFPageObj_GetLineCap: [['number'], 'number'],\n    FPDFPageObj_GetLineJoin: [['number'], 'number'],\n    FPDFPageObj_GetMark: [['number', 'number'], 'number'],\n    FPDFPageObj_GetMarkedContentID: [['number'], 'number'],\n    FPDFPageObj_GetMatrix: [['number', 'number'], 'boolean'],\n    FPDFPageObj_GetRotatedBounds: [['number', 'number'], 'boolean'],\n    FPDFPageObj_GetStrokeColor: [\n        ['number', 'number', 'number', 'number', 'number'],\n        'boolean',\n    ],\n    FPDFPageObj_GetStrokeWidth: [['number', 'number'], 'boolean'],\n    FPDFPageObj_GetType: [['number'], 'number'],\n    FPDFPageObj_HasTransparency: [['number'], 'boolean'],\n    FPDFPageObj_NewImageObj: [['number'], 'number'],\n    FPDFPageObj_NewTextObj: [['number', 'string', 'number'], 'number'],\n    FPDFPageObj_RemoveMark: [['number', 'number'], 'boolean'],\n    FPDFPageObj_SetBlendMode: [['number', 'string'], null],\n    FPDFPageObj_SetDashArray: [['number', 'number', 'number', 'number'], 'boolean'],\n    FPDFPageObj_SetDashPhase: [['number', 'number'], 'boolean'],\n    FPDFPageObj_SetFillColor: [\n        ['number', 'number', 'number', 'number', 'number'],\n        'boolean',\n    ],\n    FPDFPageObj_SetIsActive: [['number', 'boolean'], 'boolean'],\n    FPDFPageObj_SetLineCap: [['number', 'number'], 'boolean'],\n    FPDFPageObj_SetLineJoin: [['number', 'number'], 'boolean'],\n    FPDFPageObj_SetMatrix: [['number', 'number'], 'boolean'],\n    FPDFPageObj_SetStrokeColor: [\n        ['number', 'number', 'number', 'number', 'number'],\n        'boolean',\n    ],\n    FPDFPageObj_SetStrokeWidth: [['number', 'number'], 'boolean'],\n    FPDFPageObj_Transform: [\n        ['number', 'number', 'number', 'number', 'number', 'number', 'number'],\n        null,\n    ],\n    FPDFPageObj_TransformClipPath: [\n        ['number', 'number', 'number', 'number', 'number', 'number', 'number'],\n        null,\n    ],\n    FPDFPageObj_TransformF: [['number', 'number'], 'boolean'],\n    FPDFPageObjMark_CountParams: [['number'], 'number'],\n    FPDFPageObjMark_GetName: [['number', 'number', 'number', 'number'], 'boolean'],\n    FPDFPageObjMark_GetParamBlobValue: [\n        ['number', 'string', 'number', 'number', 'number'],\n        'boolean',\n    ],\n    FPDFPageObjMark_GetParamIntValue: [['number', 'string', 'number'], 'boolean'],\n    FPDFPageObjMark_GetParamKey: [\n        ['number', 'number', 'number', 'number', 'number'],\n        'boolean',\n    ],\n    FPDFPageObjMark_GetParamStringValue: [\n        ['number', 'string', 'number', 'number', 'number'],\n        'boolean',\n    ],\n    FPDFPageObjMark_GetParamValueType: [['number', 'string'], 'number'],\n    FPDFPageObjMark_RemoveParam: [['number', 'number', 'string'], 'boolean'],\n    FPDFPageObjMark_SetBlobParam: [\n        ['number', 'number', 'number', 'string', 'number', 'number'],\n        'boolean',\n    ],\n    FPDFPageObjMark_SetIntParam: [\n        ['number', 'number', 'number', 'string', 'number'],\n        'boolean',\n    ],\n    FPDFPageObjMark_SetStringParam: [\n        ['number', 'number', 'number', 'string', 'string'],\n        'boolean',\n    ],\n    FPDFPath_BezierTo: [\n        ['number', 'number', 'number', 'number', 'number', 'number', 'number'],\n        'boolean',\n    ],\n    FPDFPath_Close: [['number'], 'boolean'],\n    FPDFPath_CountSegments: [['number'], 'number'],\n    FPDFPath_GetDrawMode: [['number', 'number', 'number'], 'boolean'],\n    FPDFPath_GetPathSegment: [['number', 'number'], 'number'],\n    FPDFPath_LineTo: [['number', 'number', 'number'], 'boolean'],\n    FPDFPath_MoveTo: [['number', 'number', 'number'], 'boolean'],\n    FPDFPath_SetDrawMode: [['number', 'number', 'boolean'], 'boolean'],\n    FPDFPathSegment_GetClose: [['number'], 'boolean'],\n    FPDFPathSegment_GetPoint: [['number', 'number', 'number'], 'boolean'],\n    FPDFPathSegment_GetType: [['number'], 'number'],\n    FPDFSignatureObj_GetByteRange: [['number', 'number', 'number'], 'number'],\n    FPDFSignatureObj_GetContents: [['number', 'number', 'number'], 'number'],\n    FPDFSignatureObj_GetDocMDPPermission: [['number'], 'number'],\n    FPDFSignatureObj_GetReason: [['number', 'number', 'number'], 'number'],\n    FPDFSignatureObj_GetSubFilter: [['number', 'number', 'number'], 'number'],\n    FPDFSignatureObj_GetTime: [['number', 'number', 'number'], 'number'],\n    FPDFText_ClosePage: [['number'], null],\n    FPDFText_CountChars: [['number'], 'number'],\n    FPDFText_CountRects: [['number', 'number', 'number'], 'number'],\n    FPDFText_FindClose: [['number'], null],\n    FPDFText_FindNext: [['number'], 'boolean'],\n    FPDFText_FindPrev: [['number'], 'boolean'],\n    FPDFText_FindStart: [['number', 'number', 'number', 'number'], 'number'],\n    FPDFText_GetBoundedText: [\n        ['number', 'number', 'number', 'number', 'number', 'number', 'number'],\n        'number',\n    ],\n    FPDFText_GetCharAngle: [['number', 'number'], 'number'],\n    FPDFText_GetCharBox: [\n        ['number', 'number', 'number', 'number', 'number', 'number'],\n        'boolean',\n    ],\n    FPDFText_GetCharIndexAtPos: [\n        ['number', 'number', 'number', 'number', 'number'],\n        'number',\n    ],\n    FPDFText_GetCharIndexFromTextIndex: [['number', 'number'], 'number'],\n    FPDFText_GetCharOrigin: [['number', 'number', 'number', 'number'], 'boolean'],\n    FPDFText_GetFillColor: [\n        ['number', 'number', 'number', 'number', 'number', 'number'],\n        'boolean',\n    ],\n    FPDFText_GetFontInfo: [\n        ['number', 'number', 'number', 'number', 'number'],\n        'number',\n    ],\n    FPDFText_GetFontSize: [['number', 'number'], 'number'],\n    FPDFText_GetFontWeight: [['number', 'number'], 'number'],\n    FPDFText_GetLooseCharBox: [['number', 'number', 'number'], 'boolean'],\n    FPDFText_GetMatrix: [['number', 'number', 'number'], 'boolean'],\n    FPDFText_GetRect: [\n        ['number', 'number', 'number', 'number', 'number', 'number'],\n        'boolean',\n    ],\n    FPDFText_GetSchCount: [['number'], 'number'],\n    FPDFText_GetSchResultIndex: [['number'], 'number'],\n    FPDFText_GetStrokeColor: [\n        ['number', 'number', 'number', 'number', 'number', 'number'],\n        'boolean',\n    ],\n    FPDFText_GetText: [['number', 'number', 'number', 'number'], 'number'],\n    FPDFText_GetTextIndexFromCharIndex: [['number', 'number'], 'number'],\n    FPDFText_GetTextObject: [['number', 'number'], 'number'],\n    FPDFText_GetUnicode: [['number', 'number'], 'number'],\n    FPDFText_HasUnicodeMapError: [['number', 'number'], 'number'],\n    FPDFText_IsGenerated: [['number', 'number'], 'number'],\n    FPDFText_IsHyphen: [['number', 'number'], 'number'],\n    FPDFText_LoadCidType2Font: [\n        ['number', 'number', 'number', 'string', 'number', 'number'],\n        'number',\n    ],\n    FPDFText_LoadFont: [\n        ['number', 'number', 'number', 'number', 'boolean'],\n        'number',\n    ],\n    FPDFText_LoadPage: [['number'], 'number'],\n    FPDFText_LoadStandardFont: [['number', 'string'], 'number'],\n    FPDFText_SetCharcodes: [['number', 'number', 'number'], 'boolean'],\n    FPDFText_SetText: [['number', 'number'], 'boolean'],\n    FPDFTextObj_GetFont: [['number'], 'number'],\n    FPDFTextObj_GetFontSize: [['number', 'number'], 'boolean'],\n    FPDFTextObj_GetRenderedBitmap: [\n        ['number', 'number', 'number', 'number'],\n        'number',\n    ],\n    FPDFTextObj_GetText: [['number', 'number', 'number', 'number'], 'number'],\n    FPDFTextObj_GetTextRenderMode: [['number'], 'number'],\n    FPDFTextObj_SetTextRenderMode: [['number', 'number'], 'boolean'],\n    PDFiumExt_CloseFileWriter: [['number'], null],\n    PDFiumExt_CloseFormFillInfo: [['number'], null],\n    PDFiumExt_ExitFormFillEnvironment: [['number'], null],\n    PDFiumExt_GetFileWriterData: [['number', 'number', 'number'], 'number'],\n    PDFiumExt_GetFileWriterSize: [['number'], 'number'],\n    PDFiumExt_Init: [[], null],\n    PDFiumExt_InitFormFillEnvironment: [['number', 'number'], 'number'],\n    PDFiumExt_OpenFileWriter: [[], 'number'],\n    PDFiumExt_OpenFormFillInfo: [[], 'number'],\n    PDFiumExt_SaveAsCopy: [['number', 'number'], 'number'],\n};\n\nasync function createWrappedModule(pdfium) {\n    const module = {\n        pdfium,\n    };\n    for (const key in functions) {\n        const ident = key;\n        const args = functions[ident][0];\n        const ret = functions[ident][1];\n        // @ts-ignore\n        module[ident] = pdfium.cwrap(key, ret, args);\n    }\n    return module;\n}\n\nasync function init(moduleOverrides) {\n    const pdfium = await createPdfium(moduleOverrides);\n    return createWrappedModule(pdfium);\n}\n\nexport { init };\n//# sourceMappingURL=index.browser.js.map\n","import { init } from '@embedpdf/pdfium';\nimport { NoopLogger, PdfTaskHelper, PdfErrorCode, Task, Rotation, PdfAnnotationSubtype, stripPdfUnwantedMarkers, PdfAnnotationBorderStyle, dateToPdfDate, PdfAnnotationColorType, PdfPageObjectType, pdfAlphaColorToWebAlphaColor, webAlphaColorToPdfAlphaColor, quadToRect, pdfDateToDate, flagsToNames, PDF_FORM_FIELD_TYPE, toIntRect, transformRect, makeMatrix, AppearanceMode, toIntSize, transformSize, PdfActionType, PdfZoomMode, MatchFlag, rectToQuad } from '@embedpdf/models';\n\n/**\n * Read string from WASM heap\n * @param wasmModule - pdfium wasm module instance\n * @param readChars - function to read chars\n * @param parseChars - function to parse chars\n * @param defaultLength - default length of chars that needs to read\n * @returns string from the heap\n *\n * @public\n */\nfunction readString(wasmModule, readChars, parseChars, defaultLength = 100) {\n    let buffer = wasmModule.wasmExports.malloc(defaultLength);\n    for (let i = 0; i < defaultLength; i++) {\n        wasmModule.HEAP8[buffer + i] = 0;\n    }\n    const actualLength = readChars(buffer, defaultLength);\n    let str;\n    if (actualLength > defaultLength) {\n        wasmModule.wasmExports.free(buffer);\n        buffer = wasmModule.wasmExports.malloc(actualLength);\n        for (let i = 0; i < actualLength; i++) {\n            wasmModule.HEAP8[buffer + i] = 0;\n        }\n        readChars(buffer, actualLength);\n        str = parseChars(buffer);\n    }\n    else {\n        str = parseChars(buffer);\n    }\n    wasmModule.wasmExports.free(buffer);\n    return str;\n}\n/**\n * Read arraybyffer from WASM heap\n * @param wasmModule - pdfium wasm module instance\n * @param readChars - function to read chars\n * @returns arraybuffer from the heap\n *\n * @public\n */\nfunction readArrayBuffer(wasmModule, readChars) {\n    const bufferSize = readChars(0, 0);\n    const bufferPtr = wasmModule.wasmExports.malloc(bufferSize);\n    readChars(bufferPtr, bufferSize);\n    const arrayBuffer = new ArrayBuffer(bufferSize);\n    const view = new DataView(arrayBuffer);\n    for (let i = 0; i < bufferSize; i++) {\n        view.setInt8(i, wasmModule.getValue(bufferPtr + i, 'i8'));\n    }\n    wasmModule.wasmExports.free(bufferPtr);\n    return arrayBuffer;\n}\n\nclass PdfCache {\n    constructor(pdfium) {\n        this.pdfium = pdfium;\n        this.docs = new Map();\n    }\n    /** Open (or re-use) a document */\n    setDocument(id, filePtr, docPtr) {\n        let ctx = this.docs.get(id);\n        if (!ctx) {\n            ctx = new DocumentContext(filePtr, docPtr, this.pdfium);\n            this.docs.set(id, ctx);\n        }\n    }\n    /** Retrieve the DocumentContext for a given PdfDocumentObject */\n    getContext(docId) {\n        return this.docs.get(docId);\n    }\n    /** Close & fully release a document and all its pages */\n    closeDocument(docId) {\n        const ctx = this.docs.get(docId);\n        if (!ctx)\n            return false;\n        ctx.dispose(); // tears down pages first, then FPDF_CloseDocument, free()\n        this.docs.delete(docId);\n        return true;\n    }\n}\nclass DocumentContext {\n    constructor(filePtr, docPtr, pdfium) {\n        this.filePtr = filePtr;\n        this.docPtr = docPtr;\n        this.pageCache = new PageCache(pdfium, docPtr);\n    }\n    /** Main accessor for pages */\n    acquirePage(pageIdx) {\n        return this.pageCache.acquire(pageIdx);\n    }\n    /** Tear down all pages + this document */\n    dispose() {\n        // 1 release all pages (with their TTL or immediate)\n        this.pageCache.forceReleaseAll();\n        // 2 close the PDFium document\n        this.pageCache.pdf.FPDF_CloseDocument(this.docPtr);\n        // 3 free the file handle\n        this.pageCache.pdf.pdfium.wasmExports.free(this.filePtr);\n    }\n}\nclass PageCache {\n    constructor(pdf, docPtr) {\n        this.pdf = pdf;\n        this.docPtr = docPtr;\n        this.cache = new Map();\n    }\n    acquire(pageIdx) {\n        let ctx = this.cache.get(pageIdx);\n        if (!ctx) {\n            const pagePtr = this.pdf.FPDF_LoadPage(this.docPtr, pageIdx);\n            ctx = new PageContext(this.pdf, this.docPtr, pageIdx, pagePtr, () => {\n                this.cache.delete(pageIdx);\n            });\n            this.cache.set(pageIdx, ctx);\n        }\n        ctx.clearExpiryTimer(); // cancel any pending teardown\n        ctx.bumpRefCount(); // bump refcount\n        return ctx;\n    }\n    forceReleaseAll() {\n        for (const ctx of this.cache.values()) {\n            ctx.disposeImmediate();\n        }\n        this.cache.clear();\n    }\n}\nconst PAGE_TTL = 5000; // 5 seconds\nclass PageContext {\n    constructor(pdf, docPtr, pageIdx, pagePtr, onFinalDispose) {\n        this.pdf = pdf;\n        this.docPtr = docPtr;\n        this.pageIdx = pageIdx;\n        this.pagePtr = pagePtr;\n        this.onFinalDispose = onFinalDispose;\n        this.refCount = 0;\n        this.disposed = false;\n    }\n    /** Called by PageCache.acquire() */\n    bumpRefCount() {\n        if (this.disposed)\n            throw new Error('Context already disposed');\n        this.refCount++;\n    }\n    /** Called by PageCache.acquire() */\n    clearExpiryTimer() {\n        if (this.expiryTimer) {\n            clearTimeout(this.expiryTimer);\n            this.expiryTimer = undefined;\n        }\n    }\n    /** Called by PageCache.release() internally */\n    release() {\n        if (this.disposed)\n            return;\n        this.refCount--;\n        if (this.refCount === 0) {\n            // schedule the one-and-only timer for the page\n            this.expiryTimer = setTimeout(() => this.disposeImmediate(), PAGE_TTL);\n        }\n    }\n    /** Tear down _all_ sub-pointers & the page. */\n    disposeImmediate() {\n        if (this.disposed)\n            return;\n        this.disposed = true;\n        // 2 close text-page if opened\n        if (this.textPagePtr !== undefined) {\n            this.pdf.FPDFText_ClosePage(this.textPagePtr);\n        }\n        // 3 close form-fill if opened\n        if (this.formHandle !== undefined) {\n            this.pdf.FORM_OnBeforeClosePage(this.pagePtr, this.formHandle);\n            this.pdf.PDFiumExt_ExitFormFillEnvironment(this.formHandle);\n        }\n        if (this.formInfoPtr !== undefined) {\n            this.pdf.PDFiumExt_CloseFormFillInfo(this.formInfoPtr);\n        }\n        // 4 finally close the page itself\n        this.pdf.FPDF_ClosePage(this.pagePtr);\n        // 5 remove from the cache\n        this.onFinalDispose();\n    }\n    //  public helpers \n    /** Always safe: opens (once) and returns the text-page ptr. */\n    getTextPage() {\n        this.ensureAlive();\n        if (this.textPagePtr === undefined) {\n            this.textPagePtr = this.pdf.FPDFText_LoadPage(this.pagePtr);\n        }\n        return this.textPagePtr;\n    }\n    /** Always safe: opens (once) and returns the form-fill handle. */\n    getFormHandle() {\n        this.ensureAlive();\n        if (this.formHandle === undefined) {\n            this.formInfoPtr = this.pdf.PDFiumExt_OpenFormFillInfo();\n            this.formHandle = this.pdf.PDFiumExt_InitFormFillEnvironment(this.docPtr, this.formInfoPtr);\n            this.pdf.FORM_OnAfterLoadPage(this.pagePtr, this.formHandle);\n        }\n        return this.formHandle;\n    }\n    /**\n     * Safely execute `fn` with an annotation pointer.\n     * Pointer is ALWAYS closed afterwards.\n     */\n    withAnnotation(annotIdx, fn) {\n        this.ensureAlive();\n        const annotPtr = this.pdf.FPDFPage_GetAnnot(this.pagePtr, annotIdx);\n        try {\n            return fn(annotPtr);\n        }\n        finally {\n            this.pdf.FPDFPage_CloseAnnot(annotPtr);\n        }\n    }\n    ensureAlive() {\n        if (this.disposed)\n            throw new Error('PageContext already disposed');\n    }\n}\n\n/**\n * Format of bitmap\n */\nvar BitmapFormat;\n(function (BitmapFormat) {\n    BitmapFormat[BitmapFormat[\"Bitmap_Gray\"] = 1] = \"Bitmap_Gray\";\n    BitmapFormat[BitmapFormat[\"Bitmap_BGR\"] = 2] = \"Bitmap_BGR\";\n    BitmapFormat[BitmapFormat[\"Bitmap_BGRx\"] = 3] = \"Bitmap_BGRx\";\n    BitmapFormat[BitmapFormat[\"Bitmap_BGRA\"] = 4] = \"Bitmap_BGRA\";\n})(BitmapFormat || (BitmapFormat = {}));\n/**\n * Pdf rendering flag\n */\nvar RenderFlag;\n(function (RenderFlag) {\n    RenderFlag[RenderFlag[\"ANNOT\"] = 1] = \"ANNOT\";\n    RenderFlag[RenderFlag[\"LCD_TEXT\"] = 2] = \"LCD_TEXT\";\n    RenderFlag[RenderFlag[\"NO_NATIVETEXT\"] = 4] = \"NO_NATIVETEXT\";\n    RenderFlag[RenderFlag[\"GRAYSCALE\"] = 8] = \"GRAYSCALE\";\n    RenderFlag[RenderFlag[\"DEBUG_INFO\"] = 128] = \"DEBUG_INFO\";\n    RenderFlag[RenderFlag[\"NO_CATCH\"] = 256] = \"NO_CATCH\";\n    RenderFlag[RenderFlag[\"RENDER_LIMITEDIMAGECACHE\"] = 512] = \"RENDER_LIMITEDIMAGECACHE\";\n    RenderFlag[RenderFlag[\"RENDER_FORCEHALFTONE\"] = 1024] = \"RENDER_FORCEHALFTONE\";\n    RenderFlag[RenderFlag[\"PRINTING\"] = 2048] = \"PRINTING\";\n    RenderFlag[RenderFlag[\"REVERSE_BYTE_ORDER\"] = 16] = \"REVERSE_BYTE_ORDER\";\n})(RenderFlag || (RenderFlag = {}));\nconst LOG_SOURCE = 'PDFiumEngine';\nconst LOG_CATEGORY = 'Engine';\n/**\n * Error code of pdfium library\n */\nvar PdfiumErrorCode;\n(function (PdfiumErrorCode) {\n    PdfiumErrorCode[PdfiumErrorCode[\"Success\"] = 0] = \"Success\";\n    PdfiumErrorCode[PdfiumErrorCode[\"Unknown\"] = 1] = \"Unknown\";\n    PdfiumErrorCode[PdfiumErrorCode[\"File\"] = 2] = \"File\";\n    PdfiumErrorCode[PdfiumErrorCode[\"Format\"] = 3] = \"Format\";\n    PdfiumErrorCode[PdfiumErrorCode[\"Password\"] = 4] = \"Password\";\n    PdfiumErrorCode[PdfiumErrorCode[\"Security\"] = 5] = \"Security\";\n    PdfiumErrorCode[PdfiumErrorCode[\"Page\"] = 6] = \"Page\";\n    PdfiumErrorCode[PdfiumErrorCode[\"XFALoad\"] = 7] = \"XFALoad\";\n    PdfiumErrorCode[PdfiumErrorCode[\"XFALayout\"] = 8] = \"XFALayout\";\n})(PdfiumErrorCode || (PdfiumErrorCode = {}));\nconst browserImageDataToBlobConverter = (pdfImageData, imageType = 'image/webp') => {\n    // Check if we're in a browser environment\n    if (typeof OffscreenCanvas === 'undefined') {\n        throw new Error('OffscreenCanvas is not available in this environment. ' +\n            'This converter is intended for browser use only. ' +\n            'Please use createNodeImageDataToBlobConverter() or createNodeCanvasImageDataToBlobConverter() for Node.js.');\n    }\n    const imageData = new ImageData(pdfImageData.data, pdfImageData.width, pdfImageData.height);\n    const off = new OffscreenCanvas(imageData.width, imageData.height);\n    off.getContext('2d').putImageData(imageData, 0, 0);\n    return off.convertToBlob({ type: imageType });\n};\n/**\n * Pdf engine that based on pdfium wasm\n */\nclass PdfiumEngine {\n    /**\n     * Create an instance of PdfiumEngine\n     * @param wasmModule - pdfium wasm module\n     * @param logger - logger instance\n     * @param imageDataToBlobConverter - function to convert ImageData to Blob\n     */\n    constructor(pdfiumModule, logger = new NoopLogger(), imageDataConverter = browserImageDataToBlobConverter) {\n        this.pdfiumModule = pdfiumModule;\n        this.logger = logger;\n        this.imageDataConverter = imageDataConverter;\n        this.cache = new PdfCache(this.pdfiumModule);\n    }\n    /**\n     * {@inheritDoc @embedpdf/models!PdfEngine.initialize}\n     *\n     * @public\n     */\n    initialize() {\n        this.logger.debug(LOG_SOURCE, LOG_CATEGORY, 'initialize');\n        this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `Initialize`, 'Begin', 'General');\n        this.pdfiumModule.PDFiumExt_Init();\n        this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `Initialize`, 'End', 'General');\n        return PdfTaskHelper.resolve(true);\n    }\n    /**\n     * {@inheritDoc @embedpdf/models!PdfEngine.destroy}\n     *\n     * @public\n     */\n    destroy() {\n        this.logger.debug(LOG_SOURCE, LOG_CATEGORY, 'destroy');\n        this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `Destroy`, 'Begin', 'General');\n        this.pdfiumModule.FPDF_DestroyLibrary();\n        this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `Destroy`, 'End', 'General');\n        return PdfTaskHelper.resolve(true);\n    }\n    /**\n     * {@inheritDoc @embedpdf/models!PdfEngine.openDocumentUrl}\n     *\n     * @public\n     */\n    openDocumentUrl(file, options) {\n        const mode = options?.mode ?? 'auto';\n        const password = options?.password ?? '';\n        this.logger.debug(LOG_SOURCE, LOG_CATEGORY, 'openDocumentUrl called', file.url, mode);\n        // We'll create a task to wrap asynchronous steps\n        const task = PdfTaskHelper.create();\n        // Start an async procedure\n        (async () => {\n            try {\n                // Decide on approach\n                if (mode === 'full-fetch') {\n                    const fetchFullTask = await this.fetchFullAndOpen(file, password);\n                    fetchFullTask.wait((doc) => task.resolve(doc), (err) => task.reject(err.reason));\n                }\n                else if (mode === 'range-request') {\n                    const openDocumentWithRangeRequestTask = await this.openDocumentWithRangeRequest(file, password);\n                    openDocumentWithRangeRequestTask.wait((doc) => task.resolve(doc), (err) => task.reject(err.reason));\n                }\n                else {\n                    // mode: 'auto'\n                    const { supportsRanges, fileLength, content } = await this.checkRangeSupport(file.url);\n                    if (supportsRanges) {\n                        const openDocumentWithRangeRequestTask = await this.openDocumentWithRangeRequest(file, password, fileLength);\n                        openDocumentWithRangeRequestTask.wait((doc) => task.resolve(doc), (err) => task.reject(err.reason));\n                    }\n                    else if (content) {\n                        // If we already have the content from the range check, use it\n                        const pdfFile = { id: file.id, content };\n                        this.openDocumentFromBuffer(pdfFile, password).wait((doc) => task.resolve(doc), (err) => task.reject(err.reason));\n                    }\n                    else {\n                        const fetchFullTask = await this.fetchFullAndOpen(file, password);\n                        fetchFullTask.wait((doc) => task.resolve(doc), (err) => task.reject(err.reason));\n                    }\n                }\n            }\n            catch (err) {\n                this.logger.error(LOG_SOURCE, LOG_CATEGORY, 'openDocumentUrl error', err);\n                task.reject({\n                    code: PdfErrorCode.Unknown,\n                    message: String(err),\n                });\n            }\n        })();\n        return task;\n    }\n    /**\n     * Check if the server supports range requests:\n     * Sends a HEAD request and sees if 'Accept-Ranges: bytes'.\n     */\n    async checkRangeSupport(url) {\n        try {\n            this.logger.debug(LOG_SOURCE, LOG_CATEGORY, 'checkRangeSupport', url);\n            // First try HEAD request\n            const headResponse = await fetch(url, { method: 'HEAD' });\n            const fileLength = headResponse.headers.get('Content-Length');\n            const acceptRanges = headResponse.headers.get('Accept-Ranges');\n            // If server explicitly supports ranges, we're done\n            if (acceptRanges === 'bytes') {\n                return {\n                    supportsRanges: true,\n                    fileLength: parseInt(fileLength ?? '0'),\n                    content: null,\n                };\n            }\n            // Test actual range request support\n            const testResponse = await fetch(url, {\n                headers: { Range: 'bytes=0-1' },\n            });\n            // If we get 200 instead of 206, server doesn't support ranges\n            // Return the full content since we'll need it anyway\n            if (testResponse.status === 200) {\n                const content = await testResponse.arrayBuffer();\n                return {\n                    supportsRanges: false,\n                    fileLength: parseInt(fileLength ?? '0'),\n                    content: content,\n                };\n            }\n            // 206 Partial Content indicates range support\n            return {\n                supportsRanges: testResponse.status === 206,\n                fileLength: parseInt(fileLength ?? '0'),\n                content: null,\n            };\n        }\n        catch (e) {\n            this.logger.error(LOG_SOURCE, LOG_CATEGORY, 'checkRangeSupport failed', e);\n            throw new Error('Failed to check range support: ' + e);\n        }\n    }\n    /**\n     * Fully fetch the file (using fetch) into an ArrayBuffer,\n     * then call openDocumentFromBuffer.\n     */\n    async fetchFullAndOpen(file, password) {\n        this.logger.debug(LOG_SOURCE, LOG_CATEGORY, 'fetchFullAndOpen', file.url);\n        // 1. fetch entire PDF as array buffer\n        const response = await fetch(file.url);\n        if (!response.ok) {\n            throw new Error(`Could not fetch PDF: ${response.statusText}`);\n        }\n        const arrayBuf = await response.arrayBuffer();\n        // 2. create a PdfFile object\n        const pdfFile = {\n            id: file.id,\n            content: arrayBuf,\n        };\n        // 3. call openDocumentFromBuffer (the method you already have)\n        //    that returns a PdfTask, but let's wrap it in a Promise\n        return this.openDocumentFromBuffer(pdfFile, password);\n    }\n    /**\n     * Use your synchronous partial-loading approach:\n     * - In your snippet, it's done via `openDocumentFromLoader`.\n     * - We'll do a synchronous XHR read callback that pulls\n     *   the desired byte ranges.\n     */\n    async openDocumentWithRangeRequest(file, password, knownFileLength) {\n        this.logger.debug(LOG_SOURCE, LOG_CATEGORY, 'openDocumentWithRangeRequest', file.url);\n        // We first do a HEAD or a partial fetch to get the fileLength:\n        const fileLength = knownFileLength ?? (await this.retrieveFileLength(file.url)).fileLength;\n        // 2. define the callback function used by openDocumentFromLoader\n        const callback = (offset, length) => {\n            // Perform synchronous XHR:\n            const xhr = new XMLHttpRequest();\n            xhr.open('GET', file.url, false); // note: block in the Worker\n            xhr.overrideMimeType('text/plain; charset=x-user-defined');\n            xhr.setRequestHeader('Range', `bytes=${offset}-${offset + length - 1}`);\n            xhr.send(null);\n            if (xhr.status === 206 || xhr.status === 200) {\n                return this.convertResponseToUint8Array(xhr.responseText);\n            }\n            throw new Error(`Range request failed with status ${xhr.status}`);\n        };\n        // 3. call `openDocumentFromLoader`\n        return this.openDocumentFromLoader({\n            id: file.id,\n            fileLength,\n            callback,\n        }, password);\n    }\n    /**\n     * Helper to do a HEAD request or partial GET to find file length.\n     */\n    async retrieveFileLength(url) {\n        this.logger.debug(LOG_SOURCE, LOG_CATEGORY, 'retrieveFileLength', url);\n        // We'll do a HEAD request to get Content-Length\n        const resp = await fetch(url, { method: 'HEAD' });\n        if (!resp.ok) {\n            throw new Error(`Failed HEAD request for file length: ${resp.statusText}`);\n        }\n        const lenStr = resp.headers.get('Content-Length') || '0';\n        const fileLength = parseInt(lenStr, 10) || 0;\n        if (!fileLength) {\n            throw new Error(`Content-Length not found or zero.`);\n        }\n        return { fileLength };\n    }\n    /**\n     * Convert response text (x-user-defined) to a Uint8Array\n     * for partial data.\n     */\n    convertResponseToUint8Array(text) {\n        const array = new Uint8Array(text.length);\n        for (let i = 0; i < text.length; i++) {\n            // & 0xff ensures we only get the lower 8 bits\n            array[i] = text.charCodeAt(i) & 0xff;\n        }\n        return array;\n    }\n    /**\n     * {@inheritDoc @embedpdf/models!PdfEngine.openDocument}\n     *\n     * @public\n     */\n    openDocumentFromBuffer(file, password = '') {\n        this.logger.debug(LOG_SOURCE, LOG_CATEGORY, 'openDocumentFromBuffer', file, password);\n        this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `OpenDocumentFromBuffer`, 'Begin', file.id);\n        const array = new Uint8Array(file.content);\n        const length = array.length;\n        const filePtr = this.malloc(length);\n        this.pdfiumModule.pdfium.HEAPU8.set(array, filePtr);\n        const docPtr = this.pdfiumModule.FPDF_LoadMemDocument(filePtr, length, password);\n        if (!docPtr) {\n            const lastError = this.pdfiumModule.FPDF_GetLastError();\n            this.logger.error(LOG_SOURCE, LOG_CATEGORY, `FPDF_LoadMemDocument failed with ${lastError}`);\n            this.free(filePtr);\n            this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `OpenDocumentFromBuffer`, 'End', file.id);\n            return PdfTaskHelper.reject({\n                code: lastError,\n                message: `FPDF_LoadMemDocument failed`,\n            });\n        }\n        const pageCount = this.pdfiumModule.FPDF_GetPageCount(docPtr);\n        const pages = [];\n        const sizePtr = this.malloc(8);\n        for (let index = 0; index < pageCount; index++) {\n            const result = this.pdfiumModule.FPDF_GetPageSizeByIndexF(docPtr, index, sizePtr);\n            if (!result) {\n                const lastError = this.pdfiumModule.FPDF_GetLastError();\n                this.logger.error(LOG_SOURCE, LOG_CATEGORY, `FPDF_GetPageSizeByIndexF failed with ${lastError}`);\n                this.free(sizePtr);\n                this.pdfiumModule.FPDF_CloseDocument(docPtr);\n                this.free(filePtr);\n                this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `OpenDocumentFromBuffer`, 'End', file.id);\n                return PdfTaskHelper.reject({\n                    code: lastError,\n                    message: `FPDF_GetPageSizeByIndexF failed`,\n                });\n            }\n            const page = {\n                index,\n                size: {\n                    width: this.pdfiumModule.pdfium.getValue(sizePtr, 'float'),\n                    height: this.pdfiumModule.pdfium.getValue(sizePtr + 4, 'float'),\n                },\n            };\n            pages.push(page);\n        }\n        this.free(sizePtr);\n        const pdfDoc = {\n            id: file.id,\n            pageCount,\n            pages,\n        };\n        this.cache.setDocument(file.id, filePtr, docPtr);\n        this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `OpenDocumentFromBuffer`, 'End', file.id);\n        return PdfTaskHelper.resolve(pdfDoc);\n    }\n    /**\n     * {@inheritDoc @embedpdf/models!PdfEngine.openDocumentFromLoader}\n     *\n     * @public\n     */\n    openDocumentFromLoader(fileLoader, password = '') {\n        const { fileLength, callback, ...file } = fileLoader;\n        this.logger.debug(LOG_SOURCE, LOG_CATEGORY, 'openDocumentFromLoader', file, password);\n        this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `OpenDocumentFromLoader`, 'Begin', file.id);\n        const readBlock = (_pThis, // Pointer to the FPDF_FILEACCESS structure\n        offset, // Pointer to a buffer to receive the data\n        pBuf, // Offset position from the beginning of the file\n        length) => {\n            try {\n                this.logger.debug(LOG_SOURCE, LOG_CATEGORY, 'readBlock', offset, length, pBuf);\n                if (offset < 0 || offset >= fileLength) {\n                    this.logger.error(LOG_SOURCE, LOG_CATEGORY, 'Offset out of bounds:', offset);\n                    return 0;\n                }\n                // Get data chunk using the callback\n                const data = callback(offset, length);\n                // Copy the data to PDFium's buffer\n                const dest = new Uint8Array(this.pdfiumModule.pdfium.HEAPU8.buffer, pBuf, data.length);\n                dest.set(data);\n                return data.length;\n            }\n            catch (error) {\n                this.logger.error(LOG_SOURCE, LOG_CATEGORY, 'ReadBlock error:', error);\n                return 0;\n            }\n        };\n        const callbackPtr = this.pdfiumModule.pdfium.addFunction(readBlock, 'iiiii');\n        // Create FPDF_FILEACCESS struct\n        const structSize = 12;\n        const fileAccessPtr = this.malloc(structSize);\n        // Set up struct fields\n        this.pdfiumModule.pdfium.setValue(fileAccessPtr, fileLength, 'i32');\n        this.pdfiumModule.pdfium.setValue(fileAccessPtr + 4, callbackPtr, 'i32');\n        this.pdfiumModule.pdfium.setValue(fileAccessPtr + 8, 0, 'i32');\n        // Load document\n        const docPtr = this.pdfiumModule.FPDF_LoadCustomDocument(fileAccessPtr, password);\n        if (!docPtr) {\n            const lastError = this.pdfiumModule.FPDF_GetLastError();\n            this.logger.error(LOG_SOURCE, LOG_CATEGORY, `FPDF_LoadCustomDocument failed with ${lastError}`);\n            this.free(fileAccessPtr);\n            this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `OpenDocumentFromLoader`, 'End', file.id);\n            return PdfTaskHelper.reject({\n                code: lastError,\n                message: `FPDF_LoadCustomDocument failed`,\n            });\n        }\n        const pageCount = this.pdfiumModule.FPDF_GetPageCount(docPtr);\n        const pages = [];\n        const sizePtr = this.malloc(8);\n        for (let index = 0; index < pageCount; index++) {\n            const result = this.pdfiumModule.FPDF_GetPageSizeByIndexF(docPtr, index, sizePtr);\n            if (!result) {\n                const lastError = this.pdfiumModule.FPDF_GetLastError();\n                this.logger.error(LOG_SOURCE, LOG_CATEGORY, `FPDF_GetPageSizeByIndexF failed with ${lastError}`);\n                this.free(sizePtr);\n                this.pdfiumModule.FPDF_CloseDocument(docPtr);\n                this.free(fileAccessPtr);\n                this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `OpenDocumentFromLoader`, 'End', file.id);\n                return PdfTaskHelper.reject({\n                    code: lastError,\n                    message: `FPDF_GetPageSizeByIndexF failed`,\n                });\n            }\n            const page = {\n                index,\n                size: {\n                    width: this.pdfiumModule.pdfium.getValue(sizePtr, 'float'),\n                    height: this.pdfiumModule.pdfium.getValue(sizePtr + 4, 'float'),\n                },\n            };\n            pages.push(page);\n        }\n        this.free(sizePtr);\n        const pdfDoc = {\n            id: file.id,\n            pageCount,\n            pages,\n        };\n        this.cache.setDocument(file.id, fileAccessPtr, docPtr);\n        this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `OpenDocumentFromLoader`, 'End', file.id);\n        return PdfTaskHelper.resolve(pdfDoc);\n    }\n    /**\n     * {@inheritDoc @embedpdf/models!PdfEngine.getMetadata}\n     *\n     * @public\n     */\n    getMetadata(doc) {\n        this.logger.debug(LOG_SOURCE, LOG_CATEGORY, 'getMetadata', doc);\n        this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `GetMetadata`, 'Begin', doc.id);\n        const ctx = this.cache.getContext(doc.id);\n        if (!ctx) {\n            this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `GetMetadata`, 'End', doc.id);\n            return PdfTaskHelper.reject({\n                code: PdfErrorCode.DocNotOpen,\n                message: 'document does not open',\n            });\n        }\n        const metadata = {\n            title: this.readMetaText(ctx.docPtr, 'Title'),\n            author: this.readMetaText(ctx.docPtr, 'Author'),\n            subject: this.readMetaText(ctx.docPtr, 'Subject'),\n            keywords: this.readMetaText(ctx.docPtr, 'Keywords'),\n            producer: this.readMetaText(ctx.docPtr, 'Producer'),\n            creator: this.readMetaText(ctx.docPtr, 'Creator'),\n            creationDate: this.readMetaText(ctx.docPtr, 'CreationDate'),\n            modificationDate: this.readMetaText(ctx.docPtr, 'ModDate'),\n        };\n        this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `GetMetadata`, 'End', doc.id);\n        return PdfTaskHelper.resolve(metadata);\n    }\n    /**\n     * {@inheritDoc @embedpdf/models!PdfEngine.getDocPermissions}\n     *\n     * @public\n     */\n    getDocPermissions(doc) {\n        this.logger.debug(LOG_SOURCE, LOG_CATEGORY, 'getDocPermissions', doc);\n        this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `getDocPermissions`, 'Begin', doc.id);\n        const ctx = this.cache.getContext(doc.id);\n        if (!ctx) {\n            this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `getDocPermissions`, 'End', doc.id);\n            return PdfTaskHelper.reject({\n                code: PdfErrorCode.DocNotOpen,\n                message: 'document does not open',\n            });\n        }\n        const permissions = this.pdfiumModule.FPDF_GetDocPermissions(ctx.docPtr);\n        return PdfTaskHelper.resolve(permissions);\n    }\n    /**\n     * {@inheritDoc @embedpdf/models!PdfEngine.getDocUserPermissions}\n     *\n     * @public\n     */\n    getDocUserPermissions(doc) {\n        this.logger.debug(LOG_SOURCE, LOG_CATEGORY, 'getDocUserPermissions', doc);\n        this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `getDocUserPermissions`, 'Begin', doc.id);\n        const ctx = this.cache.getContext(doc.id);\n        if (!ctx) {\n            this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `getDocUserPermissions`, 'End', doc.id);\n            return PdfTaskHelper.reject({\n                code: PdfErrorCode.DocNotOpen,\n                message: 'document does not open',\n            });\n        }\n        const permissions = this.pdfiumModule.FPDF_GetDocUserPermissions(ctx.docPtr);\n        return PdfTaskHelper.resolve(permissions);\n    }\n    /**\n     * {@inheritDoc @embedpdf/models!PdfEngine.getSignatures}\n     *\n     * @public\n     */\n    getSignatures(doc) {\n        this.logger.debug(LOG_SOURCE, LOG_CATEGORY, 'getSignatures', doc);\n        this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `GetSignatures`, 'Begin', doc.id);\n        const ctx = this.cache.getContext(doc.id);\n        if (!ctx) {\n            this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `GetSignatures`, 'End', doc.id);\n            return PdfTaskHelper.reject({\n                code: PdfErrorCode.DocNotOpen,\n                message: 'document does not open',\n            });\n        }\n        const signatures = [];\n        const count = this.pdfiumModule.FPDF_GetSignatureCount(ctx.docPtr);\n        for (let i = 0; i < count; i++) {\n            const signatureObjPtr = this.pdfiumModule.FPDF_GetSignatureObject(ctx.docPtr, i);\n            const contents = readArrayBuffer(this.pdfiumModule.pdfium, (buffer, bufferSize) => {\n                return this.pdfiumModule.FPDFSignatureObj_GetContents(signatureObjPtr, buffer, bufferSize);\n            });\n            const byteRange = readArrayBuffer(this.pdfiumModule.pdfium, (buffer, bufferSize) => {\n                return (this.pdfiumModule.FPDFSignatureObj_GetByteRange(signatureObjPtr, buffer, bufferSize) * 4);\n            });\n            const subFilter = readArrayBuffer(this.pdfiumModule.pdfium, (buffer, bufferSize) => {\n                return this.pdfiumModule.FPDFSignatureObj_GetSubFilter(signatureObjPtr, buffer, bufferSize);\n            });\n            const reason = readString(this.pdfiumModule.pdfium, (buffer, bufferLength) => {\n                return this.pdfiumModule.FPDFSignatureObj_GetReason(signatureObjPtr, buffer, bufferLength);\n            }, this.pdfiumModule.pdfium.UTF16ToString);\n            const time = readString(this.pdfiumModule.pdfium, (buffer, bufferLength) => {\n                return this.pdfiumModule.FPDFSignatureObj_GetTime(signatureObjPtr, buffer, bufferLength);\n            }, this.pdfiumModule.pdfium.UTF8ToString);\n            const docMDP = this.pdfiumModule.FPDFSignatureObj_GetDocMDPPermission(signatureObjPtr);\n            signatures.push({\n                contents,\n                byteRange,\n                subFilter,\n                reason,\n                time,\n                docMDP,\n            });\n        }\n        this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `GetSignatures`, 'End', doc.id);\n        return PdfTaskHelper.resolve(signatures);\n    }\n    /**\n     * {@inheritDoc @embedpdf/models!PdfEngine.getBookmarks}\n     *\n     * @public\n     */\n    getBookmarks(doc) {\n        this.logger.debug(LOG_SOURCE, LOG_CATEGORY, 'getBookmarks', doc);\n        this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `GetBookmarks`, 'Begin', doc.id);\n        const ctx = this.cache.getContext(doc.id);\n        if (!ctx) {\n            this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `getBookmarks`, 'End', doc.id);\n            return PdfTaskHelper.reject({\n                code: PdfErrorCode.DocNotOpen,\n                message: 'document does not open',\n            });\n        }\n        const bookmarks = this.readPdfBookmarks(ctx.docPtr, 0);\n        this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `GetBookmarks`, 'End', doc.id);\n        return PdfTaskHelper.resolve({\n            bookmarks,\n        });\n    }\n    /**\n     * {@inheritDoc @embedpdf/models!PdfEngine.renderPage}\n     *\n     * @public\n     */\n    renderPage(doc, page, scaleFactor = 1, rotation = Rotation.Degree0, dpr = 1, options = { withAnnotations: false }, imageType = 'image/webp') {\n        const task = new Task();\n        this.logger.debug(LOG_SOURCE, LOG_CATEGORY, 'renderPage', doc, page, scaleFactor, rotation, dpr, options);\n        this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `RenderPage`, 'Begin', `${doc.id}-${page.index}`);\n        const ctx = this.cache.getContext(doc.id);\n        if (!ctx) {\n            this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `RenderPage`, 'End', `${doc.id}-${page.index}`);\n            return PdfTaskHelper.reject({\n                code: PdfErrorCode.DocNotOpen,\n                message: 'document does not open',\n            });\n        }\n        const imageData = this.renderPageRectToImageData(ctx, page, {\n            origin: { x: 0, y: 0 },\n            size: page.size,\n        }, scaleFactor, rotation, dpr, options);\n        this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `RenderPage`, 'End', `${doc.id}-${page.index}`);\n        this.imageDataConverter(imageData, imageType).then((blob) => task.resolve(blob));\n        return task;\n    }\n    /**\n     * {@inheritDoc @embedpdf/models!PdfEngine.renderPageRect}\n     *\n     * @public\n     */\n    renderPageRect(doc, page, scaleFactor, rotation, dpr, rect, options, imageType = 'image/webp') {\n        const task = new Task();\n        this.logger.debug(LOG_SOURCE, LOG_CATEGORY, 'renderPageRect', doc, page, scaleFactor, rotation, dpr, rect, options);\n        this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `RenderPageRect`, 'Begin', `${doc.id}-${page.index}`);\n        const ctx = this.cache.getContext(doc.id);\n        if (!ctx) {\n            this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `RenderPageRect`, 'End', `${doc.id}-${page.index}`);\n            return PdfTaskHelper.reject({\n                code: PdfErrorCode.DocNotOpen,\n                message: 'document does not open',\n            });\n        }\n        const imageData = this.renderPageRectToImageData(ctx, page, rect, scaleFactor, rotation, dpr, options);\n        this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `RenderPageRect`, 'End', `${doc.id}-${page.index}`);\n        this.imageDataConverter(imageData, imageType).then((blob) => task.resolve(blob));\n        return task;\n    }\n    /**\n     * {@inheritDoc @embedpdf/models!PdfEngine.getAllAnnotations}\n     *\n     * @public\n     */\n    getAllAnnotations(doc) {\n        this.logger.debug(LOG_SOURCE, LOG_CATEGORY, 'getAllAnnotations', doc);\n        this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `GetAllAnnotations`, 'Begin', doc.id);\n        const ctx = this.cache.getContext(doc.id);\n        if (!ctx) {\n            this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `GetAllAnnotations`, 'End', doc.id);\n            return PdfTaskHelper.reject({\n                code: PdfErrorCode.DocNotOpen,\n                message: 'document does not open',\n            });\n        }\n        const annotations = this.readAllAnnotations(doc, ctx);\n        this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `GetAllAnnotations`, 'End', doc.id);\n        return PdfTaskHelper.resolve(annotations);\n    }\n    readAllAnnotations(doc, ctx) {\n        const annotationsByPage = {};\n        for (let i = 0; i < doc.pageCount; i++) {\n            const pageAnnotations = this.readPageAnnotations(ctx, doc.pages[i]);\n            annotationsByPage[i] = pageAnnotations;\n        }\n        return annotationsByPage;\n    }\n    /**\n     * {@inheritDoc @embedpdf/models!PdfEngine.getPageAnnotations}\n     *\n     * @public\n     */\n    getPageAnnotations(doc, page) {\n        this.logger.debug(LOG_SOURCE, LOG_CATEGORY, 'getPageAnnotations', doc, page);\n        this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `GetPageAnnotations`, 'Begin', `${doc.id}-${page.index}`);\n        const ctx = this.cache.getContext(doc.id);\n        if (!ctx) {\n            this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `GetPageAnnotations`, 'End', `${doc.id}-${page.index}`);\n            return PdfTaskHelper.reject({\n                code: PdfErrorCode.DocNotOpen,\n                message: 'document does not open',\n            });\n        }\n        const annotations = this.readPageAnnotations(ctx, page);\n        this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `GetPageAnnotations`, 'End', `${doc.id}-${page.index}`);\n        this.logger.debug(LOG_SOURCE, LOG_CATEGORY, `GetPageAnnotations`, `${doc.id}-${page.index}`, annotations);\n        return PdfTaskHelper.resolve(annotations);\n    }\n    /**\n     * {@inheritDoc @embedpdf/models!PdfEngine.createPageAnnotation}\n     *\n     * @public\n     */\n    createPageAnnotation(doc, page, annotation) {\n        this.logger.debug(LOG_SOURCE, LOG_CATEGORY, 'createPageAnnotation', doc, page, annotation);\n        this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `CreatePageAnnotation`, 'Begin', `${doc.id}-${page.index}`);\n        const ctx = this.cache.getContext(doc.id);\n        if (!ctx) {\n            this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `CreatePageAnnotation`, 'End', `${doc.id}-${page.index}`);\n            return PdfTaskHelper.reject({\n                code: PdfErrorCode.DocNotOpen,\n                message: 'document does not open',\n            });\n        }\n        const pageCtx = ctx.acquirePage(page.index);\n        const annotationPtr = this.pdfiumModule.FPDFPage_CreateAnnot(pageCtx.pagePtr, annotation.type);\n        if (!annotationPtr) {\n            this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `CreatePageAnnotation`, 'End', `${doc.id}-${page.index}`);\n            pageCtx.release();\n            return PdfTaskHelper.reject({\n                code: PdfErrorCode.CantCreateAnnot,\n                message: 'can not create annotation with specified type',\n            });\n        }\n        if (!this.setPageAnnoRect(page, pageCtx.pagePtr, annotationPtr, annotation.rect)) {\n            this.pdfiumModule.FPDFPage_CloseAnnot(annotationPtr);\n            pageCtx.release();\n            this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `CreatePageAnnotation`, 'End', `${doc.id}-${page.index}`);\n            return PdfTaskHelper.reject({\n                code: PdfErrorCode.CantSetAnnotRect,\n                message: 'can not set the rect of the annotation',\n            });\n        }\n        let isSucceed = false;\n        switch (annotation.type) {\n            case PdfAnnotationSubtype.INK:\n                isSucceed = this.addInkStroke(page, pageCtx.pagePtr, annotationPtr, annotation);\n                break;\n            case PdfAnnotationSubtype.STAMP:\n                isSucceed = this.addStampContent(ctx.docPtr, page, pageCtx.pagePtr, annotationPtr, annotation.rect, annotation.contents);\n                break;\n            case PdfAnnotationSubtype.UNDERLINE:\n            case PdfAnnotationSubtype.STRIKEOUT:\n            case PdfAnnotationSubtype.SQUIGGLY:\n            case PdfAnnotationSubtype.HIGHLIGHT:\n                isSucceed = this.addTextMarkupContent(page, pageCtx.pagePtr, annotationPtr, annotation);\n                break;\n        }\n        if (!isSucceed) {\n            this.pdfiumModule.FPDFPage_RemoveAnnot(pageCtx.pagePtr, annotationPtr);\n            pageCtx.release();\n            this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `CreatePageAnnotation`, 'End', `${doc.id}-${page.index}`);\n            return PdfTaskHelper.reject({\n                code: PdfErrorCode.CantSetAnnotContent,\n                message: 'can not add content of the annotation',\n            });\n        }\n        if (annotation.blendMode !== undefined) {\n            this.pdfiumModule.EPDFAnnot_GenerateAppearanceWithBlend(annotationPtr, annotation.blendMode);\n        }\n        else {\n            this.pdfiumModule.EPDFAnnot_GenerateAppearance(annotationPtr);\n        }\n        this.pdfiumModule.FPDFPage_GenerateContent(pageCtx.pagePtr);\n        const annotId = this.pdfiumModule.FPDFPage_GetAnnotIndex(pageCtx.pagePtr, annotationPtr);\n        this.pdfiumModule.FPDFPage_CloseAnnot(annotationPtr);\n        pageCtx.release();\n        this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `CreatePageAnnotation`, 'End', `${doc.id}-${page.index}`);\n        return annotId >= 0\n            ? PdfTaskHelper.resolve(annotId)\n            : PdfTaskHelper.reject({\n                code: PdfErrorCode.CantCreateAnnot,\n                message: 'annotation created but index could not be determined',\n            });\n    }\n    /**\n     * Update an existing page annotation in-place\n     *\n     *   Locates the annot by page-local index (`annotation.id`)\n     *   Re-writes its /Rect and type-specific payload\n     *   Calls FPDFPage_GenerateContent so the new appearance is rendered\n     *\n     * @returns PdfTask<boolean>    true on success\n     */\n    updatePageAnnotation(doc, page, annotation) {\n        this.logger.debug(LOG_SOURCE, LOG_CATEGORY, 'updatePageAnnotation', doc, page, annotation);\n        this.logger.perf(LOG_SOURCE, LOG_CATEGORY, 'UpdatePageAnnotation', 'Begin', `${doc.id}-${page.index}`);\n        const ctx = this.cache.getContext(doc.id);\n        if (!ctx) {\n            this.logger.perf(LOG_SOURCE, LOG_CATEGORY, 'UpdatePageAnnotation', 'End', `${doc.id}-${page.index}`);\n            return PdfTaskHelper.reject({\n                code: PdfErrorCode.DocNotOpen,\n                message: 'document does not open',\n            });\n        }\n        const pageCtx = ctx.acquirePage(page.index);\n        const annotPtr = this.pdfiumModule.FPDFPage_GetAnnot(pageCtx.pagePtr, annotation.id);\n        if (!annotPtr) {\n            pageCtx.release();\n            this.logger.perf(LOG_SOURCE, LOG_CATEGORY, 'UpdatePageAnnotation', 'End', `${doc.id}-${page.index}`);\n            return PdfTaskHelper.reject({ code: PdfErrorCode.NotFound, message: 'annotation not found' });\n        }\n        /* 1  (re)set bounding-box  */\n        if (!this.setPageAnnoRect(page, pageCtx.pagePtr, annotPtr, annotation.rect)) {\n            this.pdfiumModule.FPDFPage_CloseAnnot(annotPtr);\n            pageCtx.release();\n            this.logger.perf(LOG_SOURCE, LOG_CATEGORY, 'UpdatePageAnnotation', 'End', `${doc.id}-${page.index}`);\n            return PdfTaskHelper.reject({\n                code: PdfErrorCode.CantSetAnnotRect,\n                message: 'failed to move annotation',\n            });\n        }\n        /* 2  wipe previous payload and rebuild fresh one  */\n        let ok = false;\n        switch (annotation.type) {\n            /*  Ink  */\n            case PdfAnnotationSubtype.INK: {\n                /* clear every existing stroke first */\n                if (!this.pdfiumModule.FPDFAnnot_RemoveInkList(annotPtr))\n                    break;\n                ok = this.addInkStroke(page, pageCtx.pagePtr, annotPtr, annotation);\n                break;\n            }\n            /*  Stamp  */\n            case PdfAnnotationSubtype.STAMP: {\n                /* drop every page-object inside the annot */\n                for (let i = this.pdfiumModule.FPDFAnnot_GetObjectCount(annotPtr) - 1; i >= 0; i--) {\n                    this.pdfiumModule.FPDFAnnot_RemoveObject(annotPtr, i);\n                }\n                ok = this.addStampContent(ctx.docPtr, page, pageCtx.pagePtr, annotPtr, annotation.rect, annotation.contents);\n                break;\n            }\n            /*  Text-markup family  */\n            case PdfAnnotationSubtype.HIGHLIGHT:\n            case PdfAnnotationSubtype.UNDERLINE:\n            case PdfAnnotationSubtype.STRIKEOUT:\n            case PdfAnnotationSubtype.SQUIGGLY: {\n                /* replace quad-points / colour / strings in one go */\n                ok = this.addTextMarkupContent(page, pageCtx.pagePtr, annotPtr, annotation);\n                break;\n            }\n            /*  Unsupported edits  fall through to error  */\n            default:\n                ok = false;\n        }\n        /* 3  regenerate appearance if payload was changed  */\n        if (ok) {\n            if (annotation.blendMode !== undefined) {\n                this.pdfiumModule.EPDFAnnot_GenerateAppearanceWithBlend(annotPtr, annotation.blendMode);\n            }\n            else {\n                this.pdfiumModule.EPDFAnnot_GenerateAppearance(annotPtr);\n            }\n            this.pdfiumModule.FPDFPage_GenerateContent(pageCtx.pagePtr);\n        }\n        /* 4  tidy-up native handles  */\n        this.pdfiumModule.FPDFPage_CloseAnnot(annotPtr);\n        pageCtx.release();\n        this.logger.perf(LOG_SOURCE, LOG_CATEGORY, 'UpdatePageAnnotation', 'End', `${doc.id}-${page.index}`);\n        return ok\n            ? PdfTaskHelper.resolve(true)\n            : PdfTaskHelper.reject({\n                code: PdfErrorCode.CantSetAnnotContent,\n                message: 'failed to update annotation',\n            });\n    }\n    /**\n     * {@inheritDoc @embedpdf/models!PdfEngine.removePageAnnotation}\n     *\n     * @public\n     */\n    removePageAnnotation(doc, page, annotation) {\n        this.logger.debug(LOG_SOURCE, LOG_CATEGORY, 'removePageAnnotation', doc, page, annotation);\n        this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `RemovePageAnnotation`, 'Begin', `${doc.id}-${page.index}`);\n        const ctx = this.cache.getContext(doc.id);\n        if (!ctx) {\n            this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `RemovePageAnnotation`, 'End', `${doc.id}-${page.index}`);\n            return PdfTaskHelper.reject({\n                code: PdfErrorCode.DocNotOpen,\n                message: 'document does not open',\n            });\n        }\n        const pageCtx = ctx.acquirePage(page.index);\n        let result = false;\n        result = this.pdfiumModule.FPDFPage_RemoveAnnot(pageCtx.pagePtr, annotation.id);\n        if (!result) {\n            this.logger.error(LOG_SOURCE, LOG_CATEGORY, `FPDFPage_RemoveAnnot Failed`, `${doc.id}-${page.index}`);\n        }\n        else {\n            result = this.pdfiumModule.FPDFPage_GenerateContent(pageCtx.pagePtr);\n            if (!result) {\n                this.logger.error(LOG_SOURCE, LOG_CATEGORY, `FPDFPage_GenerateContent Failed`, `${doc.id}-${page.index}`);\n            }\n        }\n        pageCtx.release();\n        this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `RemovePageAnnotation`, 'End', `${doc.id}-${page.index}`);\n        return PdfTaskHelper.resolve(result);\n    }\n    /**\n     * {@inheritDoc @embedpdf/models!PdfEngine.getPageTextRects}\n     *\n     * @public\n     */\n    getPageTextRects(doc, page, scaleFactor, rotation) {\n        this.logger.debug(LOG_SOURCE, LOG_CATEGORY, 'getPageTextRects', doc, page, scaleFactor, rotation);\n        this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `GetPageTextRects`, 'Begin', `${doc.id}-${page.index}`);\n        const ctx = this.cache.getContext(doc.id);\n        if (!ctx) {\n            this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `GetPageTextRects`, 'End', `${doc.id}-${page.index}`);\n            return PdfTaskHelper.reject({\n                code: PdfErrorCode.DocNotOpen,\n                message: 'document does not open',\n            });\n        }\n        const pageCtx = ctx.acquirePage(page.index);\n        const textPagePtr = this.pdfiumModule.FPDFText_LoadPage(pageCtx.pagePtr);\n        const textRects = this.readPageTextRects(page, pageCtx.docPtr, pageCtx.pagePtr, textPagePtr);\n        this.pdfiumModule.FPDFText_ClosePage(textPagePtr);\n        pageCtx.release();\n        this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `GetPageTextRects`, 'End', `${doc.id}-${page.index}`);\n        return PdfTaskHelper.resolve(textRects);\n    }\n    /**\n     * {@inheritDoc @embedpdf/models!PdfEngine.renderThumbnail}\n     *\n     * @public\n     */\n    renderThumbnail(doc, page, scaleFactor, rotation, dpr) {\n        this.logger.debug(LOG_SOURCE, LOG_CATEGORY, 'renderThumbnail', doc, page, scaleFactor, rotation, dpr);\n        this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `RenderThumbnail`, 'Begin', `${doc.id}-${page.index}`);\n        const ctx = this.cache.getContext(doc.id);\n        if (!ctx) {\n            this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `RenderThumbnail`, 'End', `${doc.id}-${page.index}`);\n            return PdfTaskHelper.reject({\n                code: PdfErrorCode.DocNotOpen,\n                message: 'document does not open',\n            });\n        }\n        scaleFactor = Math.max(scaleFactor, 0.5);\n        const result = this.renderPage(doc, page, scaleFactor, rotation, dpr, {\n            withAnnotations: true,\n        });\n        this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `RenderThumbnail`, 'End', `${doc.id}-${page.index}`);\n        return result;\n    }\n    /**\n     * {@inheritDoc @embedpdf/models!PdfEngine.getAttachments}\n     *\n     * @public\n     */\n    getAttachments(doc) {\n        this.logger.debug(LOG_SOURCE, LOG_CATEGORY, 'getAttachments', doc);\n        this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `GetAttachments`, 'Begin', doc.id);\n        const ctx = this.cache.getContext(doc.id);\n        if (!ctx) {\n            this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `GetAttachments`, 'End', doc.id);\n            return PdfTaskHelper.reject({\n                code: PdfErrorCode.DocNotOpen,\n                message: 'document does not open',\n            });\n        }\n        const attachments = [];\n        const count = this.pdfiumModule.FPDFDoc_GetAttachmentCount(ctx.docPtr);\n        for (let i = 0; i < count; i++) {\n            const attachment = this.readPdfAttachment(ctx.docPtr, i);\n            attachments.push(attachment);\n        }\n        this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `GetAttachments`, 'End', doc.id);\n        return PdfTaskHelper.resolve(attachments);\n    }\n    /**\n     * {@inheritDoc @embedpdf/models!PdfEngine.readAttachmentContent}\n     *\n     * @public\n     */\n    readAttachmentContent(doc, attachment) {\n        this.logger.debug(LOG_SOURCE, LOG_CATEGORY, 'readAttachmentContent', doc, attachment);\n        this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `ReadAttachmentContent`, 'Begin', doc.id);\n        const ctx = this.cache.getContext(doc.id);\n        if (!ctx) {\n            this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `ReadAttachmentContent`, 'End', doc.id);\n            return PdfTaskHelper.reject({\n                code: PdfErrorCode.DocNotOpen,\n                message: 'document does not open',\n            });\n        }\n        const attachmentPtr = this.pdfiumModule.FPDFDoc_GetAttachment(ctx.docPtr, attachment.index);\n        const sizePtr = this.malloc(8);\n        if (!this.pdfiumModule.FPDFAttachment_GetFile(attachmentPtr, 0, 0, sizePtr)) {\n            this.free(sizePtr);\n            this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `ReadAttachmentContent`, 'End', doc.id);\n            return PdfTaskHelper.reject({\n                code: PdfErrorCode.CantReadAttachmentSize,\n                message: 'can not read attachment size',\n            });\n        }\n        const size = this.pdfiumModule.pdfium.getValue(sizePtr, 'i64');\n        const contentPtr = this.malloc(size);\n        if (!this.pdfiumModule.FPDFAttachment_GetFile(attachmentPtr, contentPtr, size, sizePtr)) {\n            this.free(sizePtr);\n            this.free(contentPtr);\n            this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `ReadAttachmentContent`, 'End', doc.id);\n            return PdfTaskHelper.reject({\n                code: PdfErrorCode.CantReadAttachmentContent,\n                message: 'can not read attachment content',\n            });\n        }\n        const buffer = new ArrayBuffer(size);\n        const view = new DataView(buffer);\n        for (let i = 0; i < size; i++) {\n            view.setInt8(i, this.pdfiumModule.pdfium.getValue(contentPtr + i, 'i8'));\n        }\n        this.free(sizePtr);\n        this.free(contentPtr);\n        this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `ReadAttachmentContent`, 'End', doc.id);\n        return PdfTaskHelper.resolve(buffer);\n    }\n    /**\n     * {@inheritDoc @embedpdf/models!PdfEngine.setFormFieldValue}\n     *\n     * @public\n     */\n    setFormFieldValue(doc, page, annotation, value) {\n        this.logger.debug(LOG_SOURCE, LOG_CATEGORY, 'SetFormFieldValue', doc, annotation, value);\n        this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `SetFormFieldValue`, 'Begin', `${doc.id}-${annotation.id}`);\n        const ctx = this.cache.getContext(doc.id);\n        if (!ctx) {\n            this.logger.debug(LOG_SOURCE, LOG_CATEGORY, 'SetFormFieldValue', 'document is not opened');\n            this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `SetFormFieldValue`, 'End', `${doc.id}-${annotation.id}`);\n            return PdfTaskHelper.reject({\n                code: PdfErrorCode.DocNotOpen,\n                message: 'document does not open',\n            });\n        }\n        const formFillInfoPtr = this.pdfiumModule.PDFiumExt_OpenFormFillInfo();\n        const formHandle = this.pdfiumModule.PDFiumExt_InitFormFillEnvironment(ctx.docPtr, formFillInfoPtr);\n        const pageCtx = ctx.acquirePage(page.index);\n        this.pdfiumModule.FORM_OnAfterLoadPage(pageCtx.pagePtr, formHandle);\n        const annotationPtr = this.pdfiumModule.FPDFPage_GetAnnot(pageCtx.pagePtr, annotation.id);\n        if (!this.pdfiumModule.FORM_SetFocusedAnnot(formHandle, annotationPtr)) {\n            this.logger.debug(LOG_SOURCE, LOG_CATEGORY, 'SetFormFieldValue', 'failed to set focused annotation');\n            this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `SetFormFieldValue`, 'End', `${doc.id}-${annotation.id}`);\n            this.pdfiumModule.FPDFPage_CloseAnnot(annotationPtr);\n            this.pdfiumModule.FORM_OnBeforeClosePage(pageCtx.pagePtr, formHandle);\n            pageCtx.release();\n            this.pdfiumModule.PDFiumExt_ExitFormFillEnvironment(formHandle);\n            this.pdfiumModule.PDFiumExt_CloseFormFillInfo(formFillInfoPtr);\n            return PdfTaskHelper.reject({\n                code: PdfErrorCode.CantFocusAnnot,\n                message: 'failed to set focused annotation',\n            });\n        }\n        switch (value.kind) {\n            case 'text':\n                {\n                    if (!this.pdfiumModule.FORM_SelectAllText(formHandle, pageCtx.pagePtr)) {\n                        this.logger.debug(LOG_SOURCE, LOG_CATEGORY, 'SetFormFieldValue', 'failed to select all text');\n                        this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `SetFormFieldValue`, 'End', `${doc.id}-${annotation.id}`);\n                        this.pdfiumModule.FORM_ForceToKillFocus(formHandle);\n                        this.pdfiumModule.FPDFPage_CloseAnnot(annotationPtr);\n                        this.pdfiumModule.FORM_OnBeforeClosePage(pageCtx.pagePtr, formHandle);\n                        pageCtx.release();\n                        this.pdfiumModule.PDFiumExt_ExitFormFillEnvironment(formHandle);\n                        this.pdfiumModule.PDFiumExt_CloseFormFillInfo(formFillInfoPtr);\n                        return PdfTaskHelper.reject({\n                            code: PdfErrorCode.CantSelectText,\n                            message: 'failed to select all text',\n                        });\n                    }\n                    const length = 2 * (value.text.length + 1);\n                    const textPtr = this.malloc(length);\n                    this.pdfiumModule.pdfium.stringToUTF16(value.text, textPtr, length);\n                    this.pdfiumModule.FORM_ReplaceSelection(formHandle, pageCtx.pagePtr, textPtr);\n                    this.free(textPtr);\n                }\n                break;\n            case 'selection':\n                {\n                    if (!this.pdfiumModule.FORM_SetIndexSelected(formHandle, pageCtx.pagePtr, value.index, value.isSelected)) {\n                        this.logger.debug(LOG_SOURCE, LOG_CATEGORY, 'SetFormFieldValue', 'failed to set index selected');\n                        this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `SetFormFieldValue`, 'End', `${doc.id}-${annotation.id}`);\n                        this.pdfiumModule.FORM_ForceToKillFocus(formHandle);\n                        this.pdfiumModule.FPDFPage_CloseAnnot(annotationPtr);\n                        this.pdfiumModule.FORM_OnBeforeClosePage(pageCtx.pagePtr, formHandle);\n                        pageCtx.release();\n                        this.pdfiumModule.PDFiumExt_ExitFormFillEnvironment(formHandle);\n                        this.pdfiumModule.PDFiumExt_CloseFormFillInfo(formFillInfoPtr);\n                        return PdfTaskHelper.reject({\n                            code: PdfErrorCode.CantSelectOption,\n                            message: 'failed to set index selected',\n                        });\n                    }\n                }\n                break;\n            case 'checked':\n                {\n                    const kReturn = 0x0d;\n                    if (!this.pdfiumModule.FORM_OnChar(formHandle, pageCtx.pagePtr, kReturn, 0)) {\n                        this.logger.debug(LOG_SOURCE, LOG_CATEGORY, 'SetFormFieldValue', 'failed to set field checked');\n                        this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `SetFormFieldValue`, 'End', `${doc.id}-${annotation.id}`);\n                        this.pdfiumModule.FORM_ForceToKillFocus(formHandle);\n                        this.pdfiumModule.FPDFPage_CloseAnnot(annotationPtr);\n                        this.pdfiumModule.FORM_OnBeforeClosePage(pageCtx.pagePtr, formHandle);\n                        pageCtx.release();\n                        this.pdfiumModule.PDFiumExt_ExitFormFillEnvironment(formHandle);\n                        this.pdfiumModule.PDFiumExt_CloseFormFillInfo(formFillInfoPtr);\n                        return PdfTaskHelper.reject({\n                            code: PdfErrorCode.CantCheckField,\n                            message: 'failed to set field checked',\n                        });\n                    }\n                }\n                break;\n        }\n        this.pdfiumModule.FORM_ForceToKillFocus(formHandle);\n        this.pdfiumModule.FPDFPage_CloseAnnot(annotationPtr);\n        this.pdfiumModule.FORM_OnBeforeClosePage(pageCtx.pagePtr, formHandle);\n        pageCtx.release();\n        this.pdfiumModule.PDFiumExt_ExitFormFillEnvironment(formHandle);\n        this.pdfiumModule.PDFiumExt_CloseFormFillInfo(formFillInfoPtr);\n        return PdfTaskHelper.resolve(true);\n    }\n    /**\n     * {@inheritDoc @embedpdf/models!PdfEngine.flattenPage}\n     *\n     * @public\n     */\n    flattenPage(doc, page, flag) {\n        this.logger.debug(LOG_SOURCE, LOG_CATEGORY, 'flattenPage', doc, page, flag);\n        this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `flattenPage`, 'Begin', doc.id);\n        const ctx = this.cache.getContext(doc.id);\n        if (!ctx) {\n            this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `flattenPage`, 'End', doc.id);\n            return PdfTaskHelper.reject({\n                code: PdfErrorCode.DocNotOpen,\n                message: 'document does not open',\n            });\n        }\n        const pageCtx = ctx.acquirePage(page.index);\n        const result = this.pdfiumModule.FPDFPage_Flatten(pageCtx.pagePtr, flag);\n        pageCtx.release();\n        this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `flattenPage`, 'End', doc.id);\n        return PdfTaskHelper.resolve(result);\n    }\n    /**\n     * {@inheritDoc @embedpdf/models!PdfEngine.extractPages}\n     *\n     * @public\n     */\n    extractPages(doc, pageIndexes) {\n        this.logger.debug(LOG_SOURCE, LOG_CATEGORY, 'extractPages', doc, pageIndexes);\n        this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `ExtractPages`, 'Begin', doc.id);\n        const ctx = this.cache.getContext(doc.id);\n        if (!ctx) {\n            this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `ExtractPages`, 'End', doc.id);\n            return PdfTaskHelper.reject({\n                code: PdfErrorCode.DocNotOpen,\n                message: 'document does not open',\n            });\n        }\n        const newDocPtr = this.pdfiumModule.FPDF_CreateNewDocument();\n        if (!newDocPtr) {\n            this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `ExtractPages`, 'End', doc.id);\n            return PdfTaskHelper.reject({\n                code: PdfErrorCode.CantCreateNewDoc,\n                message: 'can not create new document',\n            });\n        }\n        const pageIndexesPtr = this.malloc(pageIndexes.length * 4);\n        for (let i = 0; i < pageIndexes.length; i++) {\n            this.pdfiumModule.pdfium.setValue(pageIndexesPtr + i * 4, pageIndexes[i], 'i32');\n        }\n        if (!this.pdfiumModule.FPDF_ImportPagesByIndex(newDocPtr, ctx.docPtr, pageIndexesPtr, pageIndexes.length, 0)) {\n            this.pdfiumModule.FPDF_CloseDocument(newDocPtr);\n            this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `ExtractPages`, 'End', doc.id);\n            return PdfTaskHelper.reject({\n                code: PdfErrorCode.CantImportPages,\n                message: 'can not import pages to new document',\n            });\n        }\n        const buffer = this.saveDocument(newDocPtr);\n        this.pdfiumModule.FPDF_CloseDocument(newDocPtr);\n        this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `ExtractPages`, 'End', doc.id);\n        return PdfTaskHelper.resolve(buffer);\n    }\n    /**\n     * {@inheritDoc @embedpdf/models!PdfEngine.extractText}\n     *\n     * @public\n     */\n    extractText(doc, pageIndexes) {\n        this.logger.debug(LOG_SOURCE, LOG_CATEGORY, 'extractText', doc, pageIndexes);\n        this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `ExtractText`, 'Begin', doc.id);\n        const ctx = this.cache.getContext(doc.id);\n        if (!ctx) {\n            this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `ExtractText`, 'End', doc.id);\n            return PdfTaskHelper.reject({\n                code: PdfErrorCode.DocNotOpen,\n                message: 'document does not open',\n            });\n        }\n        const strings = [];\n        for (let i = 0; i < pageIndexes.length; i++) {\n            const pageCtx = ctx.acquirePage(pageIndexes[i]);\n            const textPagePtr = this.pdfiumModule.FPDFText_LoadPage(pageCtx.pagePtr);\n            const charCount = this.pdfiumModule.FPDFText_CountChars(textPagePtr);\n            const bufferPtr = this.malloc((charCount + 1) * 2);\n            this.pdfiumModule.FPDFText_GetText(textPagePtr, 0, charCount, bufferPtr);\n            const text = this.pdfiumModule.pdfium.UTF16ToString(bufferPtr);\n            this.free(bufferPtr);\n            strings.push(text);\n            this.pdfiumModule.FPDFText_ClosePage(textPagePtr);\n            pageCtx.release();\n        }\n        const text = strings.join('\\n\\n');\n        this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `ExtractText`, 'End', doc.id);\n        return PdfTaskHelper.resolve(text);\n    }\n    /**\n     * {@inheritDoc @embedpdf/models!PdfEngine.getTextSlices}\n     *\n     * @public\n     */\n    getTextSlices(doc, slices) {\n        this.logger.debug(LOG_SOURCE, LOG_CATEGORY, 'getTextSlices', doc, slices);\n        this.logger.perf(LOG_SOURCE, LOG_CATEGORY, 'GetTextSlices', 'Begin', doc.id);\n        /*  1  trivial case */\n        if (slices.length === 0) {\n            this.logger.perf(LOG_SOURCE, LOG_CATEGORY, 'GetTextSlices', 'End', doc.id);\n            return PdfTaskHelper.resolve([]);\n        }\n        /*  2  document must be open */\n        const ctx = this.cache.getContext(doc.id);\n        if (!ctx) {\n            this.logger.perf(LOG_SOURCE, LOG_CATEGORY, 'GetTextSlices', 'End', doc.id);\n            return PdfTaskHelper.reject({\n                code: PdfErrorCode.DocNotOpen,\n                message: 'document does not open',\n            });\n        }\n        try {\n            /* keep caller order */\n            const out = new Array(slices.length);\n            /* group  open each page once */\n            const byPage = new Map();\n            slices.forEach((s, i) => {\n                (byPage.get(s.pageIndex) ?? byPage.set(s.pageIndex, []).get(s.pageIndex)).push({\n                    slice: s,\n                    pos: i,\n                });\n            });\n            for (const [pageIdx, list] of byPage) {\n                const pageCtx = ctx.acquirePage(pageIdx);\n                const textPagePtr = pageCtx.getTextPage();\n                for (const { slice, pos } of list) {\n                    const bufPtr = this.malloc(2 * (slice.charCount + 1)); // UTF-16 + NIL\n                    this.pdfiumModule.FPDFText_GetText(textPagePtr, slice.charIndex, slice.charCount, bufPtr);\n                    out[pos] = stripPdfUnwantedMarkers(this.pdfiumModule.pdfium.UTF16ToString(bufPtr));\n                    this.free(bufPtr);\n                }\n                pageCtx.release();\n            }\n            this.logger.perf(LOG_SOURCE, LOG_CATEGORY, 'GetTextSlices', 'End', doc.id);\n            return PdfTaskHelper.resolve(out);\n        }\n        catch (e) {\n            this.logger.error(LOG_SOURCE, LOG_CATEGORY, 'getTextSlices error', e);\n            this.logger.perf(LOG_SOURCE, LOG_CATEGORY, 'GetTextSlices', 'End', doc.id);\n            return PdfTaskHelper.reject({\n                code: PdfErrorCode.Unknown,\n                message: String(e),\n            });\n        }\n    }\n    /**\n     * {@inheritDoc @embedpdf/models!PdfEngine.merge}\n     *\n     * @public\n     */\n    merge(files) {\n        this.logger.debug(LOG_SOURCE, LOG_CATEGORY, 'merge', files);\n        const fileIds = files.map((file) => file.id).join('.');\n        this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `Merge`, 'Begin', fileIds);\n        const newDocPtr = this.pdfiumModule.FPDF_CreateNewDocument();\n        if (!newDocPtr) {\n            this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `Merge`, 'End', fileIds);\n            return PdfTaskHelper.reject({\n                code: PdfErrorCode.CantCreateNewDoc,\n                message: 'can not create new document',\n            });\n        }\n        const ptrs = [];\n        for (const file of files.reverse()) {\n            const array = new Uint8Array(file.content);\n            const length = array.length;\n            const filePtr = this.malloc(length);\n            this.pdfiumModule.pdfium.HEAPU8.set(array, filePtr);\n            const docPtr = this.pdfiumModule.FPDF_LoadMemDocument(filePtr, length, '');\n            if (!docPtr) {\n                const lastError = this.pdfiumModule.FPDF_GetLastError();\n                this.logger.error(LOG_SOURCE, LOG_CATEGORY, `FPDF_LoadMemDocument failed with ${lastError}`);\n                this.free(filePtr);\n                for (const ptr of ptrs) {\n                    this.pdfiumModule.FPDF_CloseDocument(ptr.docPtr);\n                    this.free(ptr.filePtr);\n                }\n                this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `Merge`, 'End', fileIds);\n                return PdfTaskHelper.reject({\n                    code: lastError,\n                    message: `FPDF_LoadMemDocument failed`,\n                });\n            }\n            ptrs.push({ filePtr, docPtr });\n            if (!this.pdfiumModule.FPDF_ImportPages(newDocPtr, docPtr, '', 0)) {\n                this.pdfiumModule.FPDF_CloseDocument(newDocPtr);\n                for (const ptr of ptrs) {\n                    this.pdfiumModule.FPDF_CloseDocument(ptr.docPtr);\n                    this.free(ptr.filePtr);\n                }\n                this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `Merge`, 'End', fileIds);\n                return PdfTaskHelper.reject({\n                    code: PdfErrorCode.CantImportPages,\n                    message: 'can not import pages to new document',\n                });\n            }\n        }\n        const buffer = this.saveDocument(newDocPtr);\n        this.pdfiumModule.FPDF_CloseDocument(newDocPtr);\n        for (const ptr of ptrs) {\n            this.pdfiumModule.FPDF_CloseDocument(ptr.docPtr);\n            this.free(ptr.filePtr);\n        }\n        const file = {\n            id: `${Math.random()}`,\n            content: buffer,\n        };\n        this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `Merge`, 'End', fileIds);\n        return PdfTaskHelper.resolve(file);\n    }\n    /**\n     * Merges specific pages from multiple PDF documents in a custom order\n     *\n     * @param mergeConfigs Array of configurations specifying which pages to merge from which documents\n     * @returns A PdfTask that resolves with the merged PDF file\n     * @public\n     */\n    mergePages(mergeConfigs) {\n        const configIds = mergeConfigs\n            .map((config) => `${config.docId}:${config.pageIndices.join(',')}`)\n            .join('|');\n        this.logger.debug(LOG_SOURCE, LOG_CATEGORY, 'mergePages', mergeConfigs);\n        this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `MergePages`, 'Begin', configIds);\n        // Create a new document to import pages into\n        const newDocPtr = this.pdfiumModule.FPDF_CreateNewDocument();\n        if (!newDocPtr) {\n            this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `MergePages`, 'End', configIds);\n            return PdfTaskHelper.reject({\n                code: PdfErrorCode.CantCreateNewDoc,\n                message: 'Cannot create new document',\n            });\n        }\n        try {\n            // Process each merge configuration in reverse order (since we're inserting at position 0)\n            // This ensures the final document has pages in the order specified by the user\n            for (const config of [...mergeConfigs].reverse()) {\n                // Check if the document is open\n                const ctx = this.cache.getContext(config.docId);\n                if (!ctx) {\n                    this.logger.warn(LOG_SOURCE, LOG_CATEGORY, `Document ${config.docId} is not open, skipping`);\n                    continue;\n                }\n                // Get the page count for this document\n                const pageCount = this.pdfiumModule.FPDF_GetPageCount(ctx.docPtr);\n                // Filter out invalid page indices\n                const validPageIndices = config.pageIndices.filter((index) => index >= 0 && index < pageCount);\n                if (validPageIndices.length === 0) {\n                    continue; // No valid pages to import\n                }\n                // Convert 0-based indices to 1-based for PDFium and join with commas\n                const pageString = validPageIndices.map((index) => index + 1).join(',');\n                try {\n                    // Import all specified pages at once from this document\n                    if (!this.pdfiumModule.FPDF_ImportPages(newDocPtr, ctx.docPtr, pageString, 0)) {\n                        throw new Error(`Failed to import pages ${pageString} from document ${config.docId}`);\n                    }\n                }\n                finally {\n                }\n            }\n            // Save the new document to buffer\n            const buffer = this.saveDocument(newDocPtr);\n            const file = {\n                id: `${Math.random()}`,\n                content: buffer,\n            };\n            this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `MergePages`, 'End', configIds);\n            return PdfTaskHelper.resolve(file);\n        }\n        catch (error) {\n            this.logger.error(LOG_SOURCE, LOG_CATEGORY, 'mergePages failed', error);\n            this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `MergePages`, 'End', configIds);\n            return PdfTaskHelper.reject({\n                code: PdfErrorCode.CantImportPages,\n                message: error instanceof Error ? error.message : 'Failed to merge pages',\n            });\n        }\n        finally {\n            // Clean up the new document\n            if (newDocPtr) {\n                this.pdfiumModule.FPDF_CloseDocument(newDocPtr);\n            }\n        }\n    }\n    /**\n     * {@inheritDoc @embedpdf/models!PdfEngine.saveAsCopy}\n     *\n     * @public\n     */\n    saveAsCopy(doc) {\n        this.logger.debug(LOG_SOURCE, LOG_CATEGORY, 'saveAsCopy', doc);\n        this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `SaveAsCopy`, 'Begin', doc.id);\n        const ctx = this.cache.getContext(doc.id);\n        if (!ctx) {\n            this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `SaveAsCopy`, 'End', doc.id);\n            return PdfTaskHelper.reject({\n                code: PdfErrorCode.DocNotOpen,\n                message: 'document does not open',\n            });\n        }\n        const buffer = this.saveDocument(ctx.docPtr);\n        this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `SaveAsCopy`, 'End', doc.id);\n        return PdfTaskHelper.resolve(buffer);\n    }\n    /**\n     * {@inheritDoc @embedpdf/models!PdfEngine.closeDocument}\n     *\n     * @public\n     */\n    closeDocument(doc) {\n        this.logger.debug(LOG_SOURCE, LOG_CATEGORY, 'closeDocument', doc);\n        this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `CloseDocument`, 'Begin', doc.id);\n        const ctx = this.cache.getContext(doc.id);\n        if (!ctx) {\n            this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `CloseDocument`, 'End', doc.id);\n            return PdfTaskHelper.reject({\n                code: PdfErrorCode.DocNotOpen,\n                message: 'document does not open',\n            });\n        }\n        ctx.dispose();\n        this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `CloseDocument`, 'End', doc.id);\n        return PdfTaskHelper.resolve(true);\n    }\n    /**\n     * Memory allocation\n     * @param size - size of memory space\n     * @returns pointer to memory space\n     *\n     * @public\n     */\n    malloc(size) {\n        const ptr = this.pdfiumModule.pdfium.wasmExports.malloc(size);\n        for (let i = 0; i < size; i++) {\n            this.pdfiumModule.pdfium.HEAP8[ptr + i] = 0;\n        }\n        return ptr;\n    }\n    /**\n     * Free memory space\n     * @param ptr pointer to memory space\n     *\n     * @public\n     */\n    free(ptr) {\n        this.pdfiumModule.pdfium.wasmExports.free(ptr);\n    }\n    /**\n     * Set the rect of specified annotation\n     * @param page - page info that the annotation is belonged to\n     * @param pagePtr - pointer of page object\n     * @param annotationPtr - pointer to annotation object\n     * @param inkList - ink lists that added to the annotation\n     * @returns whether the ink lists is setted\n     *\n     * @private\n     */\n    addInkStroke(page, pagePtr, annotationPtr, annotation) {\n        if (!this.setBorderStyle(annotationPtr, PdfAnnotationBorderStyle.SOLID, annotation.strokeWidth)) {\n            return false;\n        }\n        if (!this.setPageAnnoRect(page, pagePtr, annotationPtr, annotation.rect)) {\n            return false;\n        }\n        if (!this.setInkList(page, annotationPtr, annotation.inkList)) {\n            return false;\n        }\n        if (!this.setAnnotString(annotationPtr, 'T', annotation.author || '')) {\n            return false;\n        }\n        if (!this.setAnnotString(annotationPtr, 'M', dateToPdfDate(annotation.modified))) {\n            return false;\n        }\n        if (!this.setAnnotationColor(annotationPtr, {\n            color: annotation.color ?? '#FFFF00',\n            opacity: annotation.opacity ?? 1,\n        }, PdfAnnotationColorType.Color)) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Add highlight content to annotation\n     * @param page - page info\n     * @param annotationPtr - pointer to highlight annotation\n     * @param annotation - highlight annotation\n     * @returns whether highlight content is added to annotation\n     *\n     * @private\n     */\n    addTextMarkupContent(page, pagePtr, annotationPtr, annotation) {\n        if (!this.setPageAnnoRect(page, pagePtr, annotationPtr, annotation.rect)) {\n            return false;\n        }\n        if (!this.syncQuadPointsAnno(page, annotationPtr, annotation.segmentRects)) {\n            return false;\n        }\n        if (!this.setAnnotString(annotationPtr, 'Contents', annotation.contents ?? '')) {\n            return false;\n        }\n        if (!this.setAnnotString(annotationPtr, 'T', annotation.author || '')) {\n            return false;\n        }\n        if (!this.setAnnotString(annotationPtr, 'M', dateToPdfDate(annotation.modified))) {\n            return false;\n        }\n        if (!this.setAnnotationColor(annotationPtr, {\n            color: annotation.color ?? '#FFFF00',\n            opacity: annotation.opacity ?? 1,\n        }, PdfAnnotationColorType.Color)) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Add contents to stamp annotation\n     * @param docPtr - pointer to pdf document object\n     * @param page - page info\n     * @param pagePtr - pointer to page object\n     * @param annotationPtr - pointer to stamp annotation\n     * @param rect - rect of stamp annotation\n     * @param contents - contents of stamp annotation\n     * @returns whether contents is added to annotation\n     *\n     * @private\n     */\n    addStampContent(docPtr, page, pagePtr, annotationPtr, rect, contents) {\n        for (const content of contents) {\n            switch (content.type) {\n                case PdfPageObjectType.IMAGE:\n                    return this.addImageObject(docPtr, page, pagePtr, annotationPtr, rect.origin, content.imageData);\n            }\n        }\n        return false;\n    }\n    /**\n     * Add image object to annotation\n     * @param docPtr - pointer to pdf document object\n     * @param page - page info\n     * @param pagePtr - pointer to page object\n     * @param annotationPtr - pointer to stamp annotation\n     * @param position - position of image\n     * @param imageData - data of image\n     * @returns whether image is added to annotation\n     *\n     * @private\n     */\n    addImageObject(docPtr, page, pagePtr, annotationPtr, position, imageData) {\n        const bytesPerPixel = 4;\n        const pixelCount = imageData.width * imageData.height;\n        const bitmapBufferPtr = this.malloc(bytesPerPixel * pixelCount);\n        if (!bitmapBufferPtr) {\n            return false;\n        }\n        for (let i = 0; i < pixelCount; i++) {\n            const red = imageData.data[i * bytesPerPixel];\n            const green = imageData.data[i * bytesPerPixel + 1];\n            const blue = imageData.data[i * bytesPerPixel + 2];\n            const alpha = imageData.data[i * bytesPerPixel + 3];\n            this.pdfiumModule.pdfium.setValue(bitmapBufferPtr + i * bytesPerPixel, blue, 'i8');\n            this.pdfiumModule.pdfium.setValue(bitmapBufferPtr + i * bytesPerPixel + 1, green, 'i8');\n            this.pdfiumModule.pdfium.setValue(bitmapBufferPtr + i * bytesPerPixel + 2, red, 'i8');\n            this.pdfiumModule.pdfium.setValue(bitmapBufferPtr + i * bytesPerPixel + 3, alpha, 'i8');\n        }\n        const format = BitmapFormat.Bitmap_BGRA;\n        const bitmapPtr = this.pdfiumModule.FPDFBitmap_CreateEx(imageData.width, imageData.height, format, bitmapBufferPtr, 0);\n        if (!bitmapPtr) {\n            this.free(bitmapBufferPtr);\n            return false;\n        }\n        const imageObjectPtr = this.pdfiumModule.FPDFPageObj_NewImageObj(docPtr);\n        if (!imageObjectPtr) {\n            this.pdfiumModule.FPDFBitmap_Destroy(bitmapPtr);\n            this.free(bitmapBufferPtr);\n            return false;\n        }\n        if (!this.pdfiumModule.FPDFImageObj_SetBitmap(pagePtr, 0, imageObjectPtr, bitmapPtr)) {\n            this.pdfiumModule.FPDFBitmap_Destroy(bitmapPtr);\n            this.pdfiumModule.FPDFPageObj_Destroy(imageObjectPtr);\n            this.free(bitmapBufferPtr);\n            return false;\n        }\n        const matrixPtr = this.malloc(6 * 4);\n        this.pdfiumModule.pdfium.setValue(matrixPtr, imageData.width, 'float');\n        this.pdfiumModule.pdfium.setValue(matrixPtr + 4, 0, 'float');\n        this.pdfiumModule.pdfium.setValue(matrixPtr + 8, 0, 'float');\n        this.pdfiumModule.pdfium.setValue(matrixPtr + 12, imageData.height, 'float');\n        this.pdfiumModule.pdfium.setValue(matrixPtr + 16, 0, 'float');\n        this.pdfiumModule.pdfium.setValue(matrixPtr + 20, 0, 'float');\n        if (!this.pdfiumModule.FPDFPageObj_SetMatrix(imageObjectPtr, matrixPtr)) {\n            this.free(matrixPtr);\n            this.pdfiumModule.FPDFBitmap_Destroy(bitmapPtr);\n            this.pdfiumModule.FPDFPageObj_Destroy(imageObjectPtr);\n            this.free(bitmapBufferPtr);\n            return false;\n        }\n        this.free(matrixPtr);\n        this.pdfiumModule.FPDFPageObj_Transform(imageObjectPtr, 1, 0, 0, 1, position.x, position.y);\n        if (!this.pdfiumModule.FPDFAnnot_AppendObject(annotationPtr, imageObjectPtr)) {\n            this.pdfiumModule.FPDFBitmap_Destroy(bitmapPtr);\n            this.pdfiumModule.FPDFPageObj_Destroy(imageObjectPtr);\n            this.free(bitmapBufferPtr);\n            return false;\n        }\n        this.pdfiumModule.FPDFPage_GenerateContent(pagePtr);\n        this.pdfiumModule.FPDFBitmap_Destroy(bitmapPtr);\n        this.free(bitmapBufferPtr);\n        return true;\n    }\n    /**\n     * Save document to array buffer\n     * @param docPtr - pointer to pdf document\n     * @returns array buffer contains the pdf content\n     *\n     * @private\n     */\n    saveDocument(docPtr) {\n        const writerPtr = this.pdfiumModule.PDFiumExt_OpenFileWriter();\n        this.pdfiumModule.PDFiumExt_SaveAsCopy(docPtr, writerPtr);\n        const size = this.pdfiumModule.PDFiumExt_GetFileWriterSize(writerPtr);\n        const dataPtr = this.malloc(size);\n        this.pdfiumModule.PDFiumExt_GetFileWriterData(writerPtr, dataPtr, size);\n        const buffer = new ArrayBuffer(size);\n        const view = new DataView(buffer);\n        for (let i = 0; i < size; i++) {\n            view.setInt8(i, this.pdfiumModule.pdfium.getValue(dataPtr + i, 'i8'));\n        }\n        this.free(dataPtr);\n        this.pdfiumModule.PDFiumExt_CloseFileWriter(writerPtr);\n        return buffer;\n    }\n    /**\n     * Read metadata from pdf document\n     * @param docPtr - pointer to pdf document\n     * @param key - key of metadata field\n     * @returns metadata value\n     *\n     * @private\n     */\n    readMetaText(docPtr, key) {\n        return readString(this.pdfiumModule.pdfium, (buffer, bufferLength) => {\n            return this.pdfiumModule.FPDF_GetMetaText(docPtr, key, buffer, bufferLength);\n        }, this.pdfiumModule.pdfium.UTF16ToString);\n    }\n    /**\n     * Read bookmarks in the pdf document\n     * @param docPtr - pointer to pdf document\n     * @param rootBookmarkPtr - pointer to root bookmark\n     * @returns bookmarks in the pdf document\n     *\n     * @private\n     */\n    readPdfBookmarks(docPtr, rootBookmarkPtr = 0) {\n        let bookmarkPtr = this.pdfiumModule.FPDFBookmark_GetFirstChild(docPtr, rootBookmarkPtr);\n        const bookmarks = [];\n        while (bookmarkPtr) {\n            const bookmark = this.readPdfBookmark(docPtr, bookmarkPtr);\n            bookmarks.push(bookmark);\n            const nextBookmarkPtr = this.pdfiumModule.FPDFBookmark_GetNextSibling(docPtr, bookmarkPtr);\n            bookmarkPtr = nextBookmarkPtr;\n        }\n        return bookmarks;\n    }\n    /**\n     * Read bookmark in the pdf document\n     * @param docPtr - pointer to pdf document\n     * @param bookmarkPtr - pointer to bookmark object\n     * @returns pdf bookmark object\n     *\n     * @private\n     */\n    readPdfBookmark(docPtr, bookmarkPtr) {\n        const title = readString(this.pdfiumModule.pdfium, (buffer, bufferLength) => {\n            return this.pdfiumModule.FPDFBookmark_GetTitle(bookmarkPtr, buffer, bufferLength);\n        }, this.pdfiumModule.pdfium.UTF16ToString);\n        const bookmarks = this.readPdfBookmarks(docPtr, bookmarkPtr);\n        const target = this.readPdfBookmarkTarget(docPtr, () => {\n            return this.pdfiumModule.FPDFBookmark_GetAction(bookmarkPtr);\n        }, () => {\n            return this.pdfiumModule.FPDFBookmark_GetDest(docPtr, bookmarkPtr);\n        });\n        return {\n            title,\n            target,\n            children: bookmarks,\n        };\n    }\n    /**\n     * Read text rects in pdf page\n     * @param page - pdf page info\n     * @param docPtr - pointer to pdf document\n     * @param pagePtr - pointer to pdf page\n     * @param textPagePtr - pointer to pdf text page\n     * @returns text rects in the pdf page\n     *\n     * @public\n     */\n    readPageTextRects(page, docPtr, pagePtr, textPagePtr) {\n        const rectsCount = this.pdfiumModule.FPDFText_CountRects(textPagePtr, 0, -1);\n        const textRects = [];\n        for (let i = 0; i < rectsCount; i++) {\n            const topPtr = this.malloc(8);\n            const leftPtr = this.malloc(8);\n            const rightPtr = this.malloc(8);\n            const bottomPtr = this.malloc(8);\n            const isSucceed = this.pdfiumModule.FPDFText_GetRect(textPagePtr, i, leftPtr, topPtr, rightPtr, bottomPtr);\n            if (!isSucceed) {\n                this.free(leftPtr);\n                this.free(topPtr);\n                this.free(rightPtr);\n                this.free(bottomPtr);\n                continue;\n            }\n            const left = this.pdfiumModule.pdfium.getValue(leftPtr, 'double');\n            const top = this.pdfiumModule.pdfium.getValue(topPtr, 'double');\n            const right = this.pdfiumModule.pdfium.getValue(rightPtr, 'double');\n            const bottom = this.pdfiumModule.pdfium.getValue(bottomPtr, 'double');\n            this.free(leftPtr);\n            this.free(topPtr);\n            this.free(rightPtr);\n            this.free(bottomPtr);\n            const deviceXPtr = this.malloc(4);\n            const deviceYPtr = this.malloc(4);\n            this.pdfiumModule.FPDF_PageToDevice(pagePtr, 0, 0, page.size.width, page.size.height, 0, left, top, deviceXPtr, deviceYPtr);\n            const x = this.pdfiumModule.pdfium.getValue(deviceXPtr, 'i32');\n            const y = this.pdfiumModule.pdfium.getValue(deviceYPtr, 'i32');\n            this.free(deviceXPtr);\n            this.free(deviceYPtr);\n            const rect = {\n                origin: {\n                    x,\n                    y,\n                },\n                size: {\n                    width: Math.ceil(Math.abs(right - left)),\n                    height: Math.ceil(Math.abs(top - bottom)),\n                },\n            };\n            const utf16Length = this.pdfiumModule.FPDFText_GetBoundedText(textPagePtr, left, top, right, bottom, 0, 0);\n            const bytesCount = (utf16Length + 1) * 2; // include NIL\n            const textBuffer = this.malloc(bytesCount);\n            this.pdfiumModule.FPDFText_GetBoundedText(textPagePtr, left, top, right, bottom, textBuffer, utf16Length);\n            const content = this.pdfiumModule.pdfium.UTF16ToString(textBuffer);\n            this.free(textBuffer);\n            const charIndex = this.pdfiumModule.FPDFText_GetCharIndexAtPos(textPagePtr, left, top, 2, 2);\n            let fontFamily = '';\n            let fontSize = rect.size.height;\n            if (charIndex >= 0) {\n                fontSize = this.pdfiumModule.FPDFText_GetFontSize(textPagePtr, charIndex);\n                const fontNameLength = this.pdfiumModule.FPDFText_GetFontInfo(textPagePtr, charIndex, 0, 0, 0);\n                const bytesCount = fontNameLength + 1; // include NIL\n                const textBufferPtr = this.malloc(bytesCount);\n                const flagsPtr = this.malloc(4);\n                this.pdfiumModule.FPDFText_GetFontInfo(textPagePtr, charIndex, textBufferPtr, bytesCount, flagsPtr);\n                fontFamily = this.pdfiumModule.pdfium.UTF8ToString(textBufferPtr);\n                this.free(textBufferPtr);\n                this.free(flagsPtr);\n            }\n            const textRect = {\n                content,\n                rect,\n                font: {\n                    family: fontFamily,\n                    size: fontSize,\n                },\n            };\n            textRects.push(textRect);\n        }\n        return textRects;\n    }\n    /**\n     * Return geometric + logical text layout for one page\n     * (glyph-only implementation, no FPDFText_GetRect).\n     *\n     * @public\n     */\n    getPageGeometry(doc, page) {\n        const label = 'getPageGeometry';\n        this.logger.perf(LOG_SOURCE, LOG_CATEGORY, label, 'Begin', doc.id);\n        /*  guards  */\n        const ctx = this.cache.getContext(doc.id);\n        if (!ctx) {\n            this.logger.perf(LOG_SOURCE, LOG_CATEGORY, label, 'End', doc.id);\n            return PdfTaskHelper.reject({\n                code: PdfErrorCode.DocNotOpen,\n                message: 'document does not open',\n            });\n        }\n        /*  native handles  */\n        const pageCtx = ctx.acquirePage(page.index);\n        const textPagePtr = pageCtx.getTextPage();\n        /*  1. read ALL glyphs in logical order  */\n        const glyphCount = this.pdfiumModule.FPDFText_CountChars(textPagePtr);\n        const glyphs = [];\n        for (let i = 0; i < glyphCount; i++) {\n            const g = this.readGlyphInfo(page, pageCtx.pagePtr, textPagePtr, i);\n            glyphs.push(g);\n        }\n        /*  2. build visual runs from glyph stream  */\n        const runs = this.buildRunsFromGlyphs(glyphs, textPagePtr);\n        /*  3. cleanup & resolve task  */\n        pageCtx.release();\n        this.logger.perf(LOG_SOURCE, LOG_CATEGORY, label, 'End', doc.id);\n        return PdfTaskHelper.resolve({ runs });\n    }\n    /**\n     * Group consecutive glyphs that belong to the same CPDF_TextObject\n     * using FPDFText_GetTextObject(), and calculate rotation from glyph positions.\n     */\n    buildRunsFromGlyphs(glyphs, textPagePtr) {\n        const runs = [];\n        let current = null;\n        let curObjPtr = null;\n        let bounds = null;\n        /**  main loop  */\n        for (let i = 0; i < glyphs.length; i++) {\n            const g = glyphs[i];\n            /* 1  find the CPDF_TextObject this glyph belongs to */\n            const objPtr = this.pdfiumModule.FPDFText_GetTextObject(textPagePtr, i);\n            /* 2  start a new run when the text object changes */\n            if (objPtr !== curObjPtr) {\n                curObjPtr = objPtr;\n                current = {\n                    rect: {\n                        x: g.origin.x,\n                        y: g.origin.y,\n                        width: g.size.width,\n                        height: g.size.height,\n                    },\n                    charStart: i,\n                    glyphs: [],\n                };\n                bounds = {\n                    minX: g.origin.x,\n                    minY: g.origin.y,\n                    maxX: g.origin.x + g.size.width,\n                    maxY: g.origin.y + g.size.height,\n                };\n                runs.push(current);\n            }\n            /* 3  append the slim glyph record */\n            current.glyphs.push({\n                x: g.origin.x,\n                y: g.origin.y,\n                width: g.size.width,\n                height: g.size.height,\n                flags: g.isEmpty ? 2 : g.isSpace ? 1 : 0,\n            });\n            /* 4  expand the run's bounding rect */\n            if (g.isEmpty) {\n                continue;\n            }\n            const right = g.origin.x + g.size.width;\n            const bottom = g.origin.y + g.size.height;\n            // Update bounds\n            bounds.minX = Math.min(bounds.minX, g.origin.x);\n            bounds.minY = Math.min(bounds.minY, g.origin.y);\n            bounds.maxX = Math.max(bounds.maxX, right);\n            bounds.maxY = Math.max(bounds.maxY, bottom);\n            // Calculate final rect from bounds\n            current.rect.x = bounds.minX;\n            current.rect.y = bounds.minY;\n            current.rect.width = bounds.maxX - bounds.minX;\n            current.rect.height = bounds.maxY - bounds.minY;\n        }\n        return runs;\n    }\n    /**\n     * Extract glyph geometry + metadata for `charIndex`\n     *\n     * Returns devicespace coordinates:\n     *   x,y   **top-left** corner (integer-pixels)\n     *   w,h   width / height (integer-pixels,  1)\n     *\n     * And two flags:\n     *   isSpace  true if the glyph's Unicode code-point is U+0020\n     */\n    readGlyphInfo(page, pagePtr, textPagePtr, charIndex) {\n        //  native stack temp pointers \n        const dx1Ptr = this.malloc(4);\n        const dy1Ptr = this.malloc(4);\n        const dx2Ptr = this.malloc(4);\n        const dy2Ptr = this.malloc(4);\n        const rectPtr = this.malloc(16); // 4 floats = 16 bytes\n        let x = 0, y = 0, width = 0, height = 0, isSpace = false;\n        //  1) raw glyph bbox in                      page-user-space\n        if (this.pdfiumModule.FPDFText_GetLooseCharBox(textPagePtr, charIndex, rectPtr)) {\n            const left = this.pdfiumModule.pdfium.getValue(rectPtr, 'float');\n            const top = this.pdfiumModule.pdfium.getValue(rectPtr + 4, 'float');\n            const right = this.pdfiumModule.pdfium.getValue(rectPtr + 8, 'float');\n            const bottom = this.pdfiumModule.pdfium.getValue(rectPtr + 12, 'float');\n            if (left === right || top === bottom) {\n                return {\n                    origin: { x: 0, y: 0 },\n                    size: { width: 0, height: 0 },\n                    isEmpty: true,\n                };\n            }\n            //  2) map 2 opposite corners to            device-space\n            this.pdfiumModule.FPDF_PageToDevice(pagePtr, 0, 0, page.size.width, page.size.height, \n            /*rotate=*/ 0, left, top, dx1Ptr, dy1Ptr);\n            this.pdfiumModule.FPDF_PageToDevice(pagePtr, 0, 0, page.size.width, page.size.height, \n            /*rotate=*/ 0, right, bottom, dx2Ptr, dy2Ptr);\n            const x1 = this.pdfiumModule.pdfium.getValue(dx1Ptr, 'i32');\n            const y1 = this.pdfiumModule.pdfium.getValue(dy1Ptr, 'i32');\n            const x2 = this.pdfiumModule.pdfium.getValue(dx2Ptr, 'i32');\n            const y2 = this.pdfiumModule.pdfium.getValue(dy2Ptr, 'i32');\n            x = Math.min(x1, x2);\n            y = Math.min(y1, y2);\n            width = Math.max(1, Math.abs(x2 - x1));\n            height = Math.max(1, Math.abs(y2 - y1));\n            //  3) extra flags \n            const uc = this.pdfiumModule.FPDFText_GetUnicode(textPagePtr, charIndex);\n            isSpace = uc === 32;\n        }\n        //  free tmps \n        [rectPtr, dx1Ptr, dy1Ptr, dx2Ptr, dy2Ptr].forEach((p) => this.free(p));\n        return {\n            origin: { x, y },\n            size: { width, height },\n            ...(isSpace && { isSpace }),\n        };\n    }\n    /**\n     * Geometry-only text extraction\n     * ------------------------------------------\n     * Returns every glyph on the requested page\n     * in the logical order delivered by PDFium.\n     *\n     * The promise resolves to an array of objects:\n     *   {\n     *     idx:     number;            // glyph index on the page (0n-1)\n     *     origin:  { x: number; y: number };\n     *     size:    { width: number;  height: number };\n     *     angle:   number;            // degrees, counter-clock-wise\n     *     isSpace: boolean;           // true   U+0020\n     *   }\n     *\n     * No Unicode is included; front-end decides whether to hydrate it.\n     */\n    getPageGlyphs(doc, page) {\n        this.logger.debug(LOG_SOURCE, LOG_CATEGORY, 'getPageGlyphs', doc, page);\n        this.logger.perf(LOG_SOURCE, LOG_CATEGORY, 'getPageGlyphs', 'Begin', doc.id);\n        //  1) safety: document handle must be alive \n        const ctx = this.cache.getContext(doc.id);\n        if (!ctx) {\n            this.logger.perf(LOG_SOURCE, LOG_CATEGORY, 'getPageGlyphs', 'End', doc.id);\n            return PdfTaskHelper.reject({\n                code: PdfErrorCode.DocNotOpen,\n                message: 'document does not open',\n            });\n        }\n        //  2) load page + text page handles \n        const pageCtx = ctx.acquirePage(page.index);\n        const textPagePtr = pageCtx.getTextPage();\n        //  3) iterate all glyphs in logical order \n        const total = this.pdfiumModule.FPDFText_CountChars(textPagePtr);\n        const glyphs = new Array(total);\n        for (let i = 0; i < total; i++) {\n            const g = this.readGlyphInfo(page, pageCtx.pagePtr, textPagePtr, i);\n            if (g.isEmpty) {\n                continue;\n            }\n            glyphs[i] = { ...g };\n        }\n        //  4) clean-up native handles \n        pageCtx.release();\n        this.logger.perf(LOG_SOURCE, LOG_CATEGORY, 'getPageGlyphs', 'End', doc.id);\n        return PdfTaskHelper.resolve(glyphs);\n    }\n    readCharBox(page, pagePtr, textPagePtr, charIndex) {\n        const topPtr = this.malloc(8);\n        const leftPtr = this.malloc(8);\n        const bottomPtr = this.malloc(8);\n        const rightPtr = this.malloc(8);\n        let x = 0;\n        let y = 0;\n        let width = 0;\n        let height = 0;\n        if (this.pdfiumModule.FPDFText_GetCharBox(textPagePtr, charIndex, leftPtr, rightPtr, bottomPtr, topPtr)) {\n            const top = this.pdfiumModule.pdfium.getValue(topPtr, 'double');\n            const left = this.pdfiumModule.pdfium.getValue(leftPtr, 'double');\n            const bottom = this.pdfiumModule.pdfium.getValue(bottomPtr, 'double');\n            const right = this.pdfiumModule.pdfium.getValue(rightPtr, 'double');\n            const deviceXPtr = this.malloc(4);\n            const deviceYPtr = this.malloc(4);\n            this.pdfiumModule.FPDF_PageToDevice(pagePtr, 0, 0, page.size.width, page.size.height, 0, left, top, deviceXPtr, deviceYPtr);\n            x = this.pdfiumModule.pdfium.getValue(deviceXPtr, 'i32');\n            y = this.pdfiumModule.pdfium.getValue(deviceYPtr, 'i32');\n            this.free(deviceXPtr);\n            this.free(deviceYPtr);\n            width = Math.ceil(Math.abs(right - left));\n            height = Math.ceil(Math.abs(top - bottom));\n        }\n        this.free(topPtr);\n        this.free(leftPtr);\n        this.free(bottomPtr);\n        this.free(rightPtr);\n        return {\n            origin: {\n                x,\n                y,\n            },\n            size: {\n                width,\n                height,\n            },\n        };\n    }\n    /**\n     * Read page annotations\n     * @param page - page info\n     * @param docPtr - pointer to pdf document\n     * @param pagePtr - pointer to pdf page\n     * @param textPagePtr - pointe to pdf text page\n     * @param scaleFactor - scale factor\n     * @param rotation - rotation angle\n     * @returns annotations on the pdf page\n     *\n     * @private\n     */\n    readPageAnnotations(ctx, page) {\n        const pageCtx = ctx.acquirePage(page.index);\n        const annotationCount = this.pdfiumModule.FPDFPage_GetAnnotCount(pageCtx.pagePtr);\n        const annotations = [];\n        for (let i = 0; i < annotationCount; i++) {\n            pageCtx.withAnnotation(i, (annotPtr) => {\n                const annotation = this.readPageAnnotation(page, pageCtx, annotPtr, i);\n                if (annotation) {\n                    annotations.push(annotation);\n                }\n            });\n        }\n        return annotations;\n    }\n    /**\n     * Read pdf annotation from pdf document\n     * @param page  - pdf page infor\n     * @param docPtr - pointer to pdf document object\n     * @param pagePtr - pointer to pdf page object\n     * @param  textPagePtr - pointer to pdf text page object\n     * @param formHandle - form handle\n     * @param index - index of annotation in the pdf page\n     * @param scaleFactor  - factor of scalling\n     * @param rotation  - rotation angle\n     * @returns pdf annotation\n     *\n     * @private\n     */\n    readPageAnnotation(page, pageCtx, annotationPtr, index) {\n        const subType = this.pdfiumModule.FPDFAnnot_GetSubtype(annotationPtr);\n        let annotation;\n        switch (subType) {\n            case PdfAnnotationSubtype.TEXT:\n                {\n                    annotation = this.readPdfTextAnno(page, pageCtx.pagePtr, annotationPtr, index);\n                }\n                break;\n            case PdfAnnotationSubtype.FREETEXT:\n                {\n                    annotation = this.readPdfFreeTextAnno(page, pageCtx.pagePtr, annotationPtr, index);\n                }\n                break;\n            case PdfAnnotationSubtype.LINK:\n                {\n                    annotation = this.readPdfLinkAnno(page, pageCtx.docPtr, pageCtx.pagePtr, pageCtx.getTextPage(), annotationPtr, index);\n                }\n                break;\n            case PdfAnnotationSubtype.WIDGET:\n                {\n                    annotation = this.readPdfWidgetAnno(page, pageCtx.pagePtr, annotationPtr, pageCtx.getFormHandle(), index);\n                }\n                break;\n            case PdfAnnotationSubtype.FILEATTACHMENT:\n                {\n                    annotation = this.readPdfFileAttachmentAnno(page, pageCtx.pagePtr, annotationPtr, index);\n                }\n                break;\n            case PdfAnnotationSubtype.INK:\n                {\n                    annotation = this.readPdfInkAnno(page, pageCtx.pagePtr, annotationPtr, index);\n                }\n                break;\n            case PdfAnnotationSubtype.POLYGON:\n                {\n                    annotation = this.readPdfPolygonAnno(page, pageCtx.pagePtr, annotationPtr, index);\n                }\n                break;\n            case PdfAnnotationSubtype.POLYLINE:\n                {\n                    annotation = this.readPdfPolylineAnno(page, pageCtx.pagePtr, annotationPtr, index);\n                }\n                break;\n            case PdfAnnotationSubtype.LINE:\n                {\n                    annotation = this.readPdfLineAnno(page, pageCtx.pagePtr, annotationPtr, index);\n                }\n                break;\n            case PdfAnnotationSubtype.HIGHLIGHT:\n                annotation = this.readPdfHighlightAnno(page, pageCtx.pagePtr, annotationPtr, index);\n                break;\n            case PdfAnnotationSubtype.STAMP:\n                {\n                    annotation = this.readPdfStampAnno(pageCtx.docPtr, page, pageCtx.pagePtr, annotationPtr, index);\n                }\n                break;\n            case PdfAnnotationSubtype.SQUARE:\n                {\n                    annotation = this.readPdfSquareAnno(page, pageCtx.pagePtr, annotationPtr, index);\n                }\n                break;\n            case PdfAnnotationSubtype.CIRCLE:\n                {\n                    annotation = this.readPdfCircleAnno(page, pageCtx.pagePtr, annotationPtr, index);\n                }\n                break;\n            case PdfAnnotationSubtype.UNDERLINE:\n                {\n                    annotation = this.readPdfUnderlineAnno(page, pageCtx.pagePtr, annotationPtr, index);\n                }\n                break;\n            case PdfAnnotationSubtype.SQUIGGLY:\n                {\n                    annotation = this.readPdfSquigglyAnno(page, pageCtx.pagePtr, annotationPtr, index);\n                }\n                break;\n            case PdfAnnotationSubtype.STRIKEOUT:\n                {\n                    annotation = this.readPdfStrikeOutAnno(page, pageCtx.pagePtr, annotationPtr, index);\n                }\n                break;\n            case PdfAnnotationSubtype.CARET:\n                {\n                    annotation = this.readPdfCaretAnno(page, pageCtx.pagePtr, annotationPtr, index);\n                }\n                break;\n            default:\n                {\n                    annotation = this.readPdfAnno(page, pageCtx.pagePtr, subType, annotationPtr, index);\n                }\n                break;\n        }\n        return annotation;\n    }\n    /**\n     * Return the colour stored directly in the annotation dictionary's `/C` entry.\n     *\n     * Most PDFs created by Acrobat, Microsoft Office, LaTeX, etc. include this entry.\n     * When the key is absent (common in macOS Preview, Chrome, Drawboard) the call\n     * fails and the function returns `undefined`.\n     *\n     * @param annotationPtr - pointer to an `FPDF_ANNOTATION`\n     * @returns An RGBA tuple (0-255 channels) or `undefined` if no `/C` entry exists\n     *\n     * @private\n     */\n    readAnnotationColor(annotationPtr, colorType = PdfAnnotationColorType.Color) {\n        const rPtr = this.malloc(4);\n        const gPtr = this.malloc(4);\n        const bPtr = this.malloc(4);\n        const aPtr = this.malloc(4);\n        // colourType 0 = \"colour\" (stroke/fill); other types are interior/border\n        const ok = this.pdfiumModule.EPDFAnnot_GetColor(annotationPtr, colorType, rPtr, gPtr, bPtr, aPtr);\n        let colour;\n        if (ok) {\n            colour = {\n                red: this.pdfiumModule.pdfium.getValue(rPtr, 'i32') & 0xff,\n                green: this.pdfiumModule.pdfium.getValue(gPtr, 'i32') & 0xff,\n                blue: this.pdfiumModule.pdfium.getValue(bPtr, 'i32') & 0xff,\n                alpha: this.pdfiumModule.pdfium.getValue(aPtr, 'i32') & 0xff, // 0 = transparent, 255 = opaque\n            };\n        }\n        this.free(rPtr);\n        this.free(gPtr);\n        this.free(bPtr);\n        this.free(aPtr);\n        return colour;\n    }\n    /* --------------------------------------------------------------------------- */\n    /**\n     * Resolve the visible fill colour for **Highlight / Underline / StrikeOut /\n     * Squiggly** markup annotations.\n     *\n     * Resolution order (first non-`undefined` wins):\n     *  1. `/C` dictionary entry  fast, present in Acrobat / Office PDFs\n     *  2. Appearance-stream objects  drills into paths & nested forms\n     *  3. Hard-coded fallback (Acrobat-style opaque yellow)\n     *\n     * @param annotationPtr - pointer to an `FPDF_ANNOTATION`\n     * @param fallback      - colour to use when the PDF stores no tint at all\n     * @returns WebAlphaColor with hex color and opacity (0-1)\n     *\n     * @private\n     */\n    resolveAnnotationColor(annotationPtr, colorType = PdfAnnotationColorType.Color, fallback = { red: 255, green: 245, blue: 155, alpha: 255 }) {\n        const pdfColor = this.readAnnotationColor(annotationPtr, colorType) ?? fallback;\n        return pdfAlphaColorToWebAlphaColor(pdfColor);\n    }\n    /**\n     * Set the fill/stroke colour for a **Highlight / Underline / StrikeOut / Squiggly** markup annotation.\n     *\n     * @param annotationPtr - pointer to the annotation whose colour is being set\n     * @param webAlphaColor - WebAlphaColor with hex color and opacity (0-1)\n     * @param shouldClearAP - whether to clear the /AP entry\n     * @param which - which colour to set (0 = fill, 1 = stroke)\n     * @returns `true` if the operation was successful\n     *\n     * @private\n     */\n    setAnnotationColor(annotationPtr, webAlphaColor, colorType = PdfAnnotationColorType.Color) {\n        const pdfAlphaColor = webAlphaColorToPdfAlphaColor(webAlphaColor);\n        return this.pdfiumModule.EPDFAnnot_SetColor(annotationPtr, colorType, pdfAlphaColor.red & 0xff, pdfAlphaColor.green & 0xff, pdfAlphaColor.blue & 0xff, (pdfAlphaColor.alpha ?? 255) & 0xff);\n    }\n    /**\n     * Borderstyle + width helper\n     *\n     * Tries the new PDFium helper `EPDFAnnot_GetBorderStyle()` (patch series\n     * 9 July 2025).\n     *\n     * @param  annotationPtr  pointer to an `FPDF_ANNOTATION`\n     * @returns `{ ok, style, width }`\n     *           `ok`      `true` when the call succeeded\n     *           `style`   `PdfAnnotationBorderStyle` enum\n     *           `width`   stroke-width in points (defaults to 0 pt)\n     */\n    getBorderStyle(annotationPtr) {\n        /* 1  allocate tmp storage for the returned width  */\n        const widthPtr = this.malloc(4);\n        let width = 0;\n        let style = PdfAnnotationBorderStyle.UNKNOWN;\n        let ok = false;\n        style = this.pdfiumModule.EPDFAnnot_GetBorderStyle(annotationPtr, widthPtr);\n        width = this.pdfiumModule.pdfium.getValue(widthPtr, 'float');\n        ok = style !== PdfAnnotationBorderStyle.UNKNOWN;\n        this.free(widthPtr);\n        return { ok, style, width };\n    }\n    setBorderStyle(annotationPtr, style, width) {\n        return this.pdfiumModule.EPDFAnnot_SetBorderStyle(annotationPtr, style, width);\n    }\n    /**\n     * Border-effect (cloudy) helper\n     *\n     * Calls the new PDFium function `EPDFAnnot_GetBorderEffect()` (July 2025).\n     *\n     * @param  annotationPtr  pointer to an `FPDF_ANNOTATION`\n     * @returns `{ ok, intensity }`\n     *           `ok`         `true` when the annotation *does* have a\n     *                          valid cloudy-border effect\n     *           `intensity`  radius/intensity value (0 when `ok` is false)\n     */\n    getBorderEffect(annotationPtr) {\n        const intensityPtr = this.malloc(4);\n        const ok = !!this.pdfiumModule.EPDFAnnot_GetBorderEffect(annotationPtr, intensityPtr);\n        const intensity = ok ? this.pdfiumModule.pdfium.getValue(intensityPtr, 'float') : 0;\n        this.free(intensityPtr);\n        return { ok, intensity };\n    }\n    /**\n     * Rectangle-differences helper ( /RD array on Square / Circle annots )\n     *\n     * Calls `EPDFAnnot_GetRectangleDifferences()` introduced in July 2025.\n     *\n     * @param  annotationPtr  pointer to an `FPDF_ANNOTATION`\n     * @returns `{ ok, left, top, right, bottom }`\n     *           `ok`      `true` when the annotation *has* an /RD entry\n     *           the four floats are 0 when `ok` is false\n     */\n    getRectangleDifferences(annotationPtr) {\n        /* tmp storage  */\n        const lPtr = this.malloc(4);\n        const tPtr = this.malloc(4);\n        const rPtr = this.malloc(4);\n        const bPtr = this.malloc(4);\n        const ok = !!this.pdfiumModule.EPDFAnnot_GetRectangleDifferences(annotationPtr, lPtr, tPtr, rPtr, bPtr);\n        const pdf = this.pdfiumModule.pdfium;\n        const left = pdf.getValue(lPtr, 'float');\n        const top = pdf.getValue(tPtr, 'float');\n        const right = pdf.getValue(rPtr, 'float');\n        const bottom = pdf.getValue(bPtr, 'float');\n        /* cleanup  */\n        this.free(lPtr);\n        this.free(tPtr);\n        this.free(rPtr);\n        this.free(bPtr);\n        return { ok, left, top, right, bottom };\n    }\n    /**\n     * Dash-pattern helper ( /BS  /D array, dashed borders only )\n     *\n     * Uses the two new PDFium helpers:\n     *    `EPDFAnnot_GetBorderDashPatternCount`\n     *    `EPDFAnnot_GetBorderDashPattern`\n     *\n     * @param  annotationPtr  pointer to an `FPDF_ANNOTATION`\n     * @returns `{ ok, pattern }`\n     *           `ok`        `true` when the annot is dashed *and* the array\n     *                          was retrieved successfully\n     *           `pattern`   numeric array of dash/space lengths (empty when `ok` is false)\n     */\n    getBorderDashPattern(annotationPtr) {\n        const count = this.pdfiumModule.EPDFAnnot_GetBorderDashPatternCount(annotationPtr);\n        if (count === 0) {\n            return { ok: false, pattern: [] };\n        }\n        /* allocate `count` floats on the WASM heap */\n        const arrPtr = this.malloc(4 * count);\n        const okNative = !!this.pdfiumModule.EPDFAnnot_GetBorderDashPattern(annotationPtr, arrPtr, count);\n        /* copy out */\n        const pattern = [];\n        if (okNative) {\n            const pdf = this.pdfiumModule.pdfium;\n            for (let i = 0; i < count; i++) {\n                pattern.push(pdf.getValue(arrPtr + 4 * i, 'float'));\n            }\n        }\n        this.free(arrPtr);\n        return { ok: okNative, pattern };\n    }\n    /**\n     * Read `/QuadPoints` from any annotation and convert each quadrilateral to\n     * device-space coordinates.\n     *\n     * The four points are returned in natural reading order:\n     *   `p1  p2` (top edge) and `p4  p3` (bottom edge).\n     * This preserves the true shape for rotated / skewed text, whereas callers\n     * that only need axis-aligned boxes can collapse each quad themselves.\n     *\n     * @param page          - logical page info object (`PdfPageObject`)\n     * @param annotationPtr - pointer to the annotation whose quads are needed\n     * @returns Array of `Rect` objects (`[]` if the annotation has no quads)\n     *\n     * @private\n     */\n    getQuadPointsAnno(page, annotationPtr) {\n        const quadCount = this.pdfiumModule.FPDFAnnot_CountAttachmentPoints(annotationPtr);\n        if (quadCount === 0)\n            return [];\n        const FS_QUADPOINTSF_SIZE = 8 * 4; // eight floats, 32 bytes\n        const quads = [];\n        for (let qi = 0; qi < quadCount; qi++) {\n            const quadPtr = this.malloc(FS_QUADPOINTSF_SIZE);\n            const ok = this.pdfiumModule.FPDFAnnot_GetAttachmentPoints(annotationPtr, qi, quadPtr);\n            if (ok) {\n                // read the eight floats\n                const xs = [];\n                const ys = [];\n                for (let i = 0; i < 4; i++) {\n                    const base = quadPtr + i * 8; // 8 bytes per point (x+y)\n                    xs.push(this.pdfiumModule.pdfium.getValue(base, 'float'));\n                    ys.push(this.pdfiumModule.pdfium.getValue(base + 4, 'float'));\n                }\n                // convert to device-space\n                const p1 = this.convertPagePointToDevicePoint(page, { x: xs[0], y: ys[0] });\n                const p2 = this.convertPagePointToDevicePoint(page, { x: xs[1], y: ys[1] });\n                const p3 = this.convertPagePointToDevicePoint(page, { x: xs[2], y: ys[2] });\n                const p4 = this.convertPagePointToDevicePoint(page, { x: xs[3], y: ys[3] });\n                quads.push({ p1, p2, p3, p4 });\n            }\n            this.free(quadPtr);\n        }\n        return quads.map(quadToRect);\n    }\n    /**\n     * Set the quadrilaterals for a **Highlight / Underline / StrikeOut / Squiggly** markup annotation.\n     *\n     * @param page          - logical page info object (`PdfPageObject`)\n     * @param annotationPtr - pointer to the annotation whose quads are needed\n     * @param rects         - array of `Rect` objects (`[]` if the annotation has no quads)\n     * @returns `true` if the operation was successful\n     *\n     * @private\n     */\n    syncQuadPointsAnno(page, annotPtr, rects) {\n        const FS_QUADPOINTSF_SIZE = 8 * 4; // eight floats, 32 bytes\n        const pdf = this.pdfiumModule.pdfium;\n        const count = this.pdfiumModule.FPDFAnnot_CountAttachmentPoints(annotPtr);\n        const buf = this.malloc(FS_QUADPOINTSF_SIZE);\n        /** write one quad into `buf` in annotation space */\n        const writeQuad = (r) => {\n            const q = rectToQuad(r); // TL, TR, BR, BL\n            const p1 = this.convertDevicePointToPagePoint(page, q.p1);\n            const p2 = this.convertDevicePointToPagePoint(page, q.p2);\n            const p3 = this.convertDevicePointToPagePoint(page, q.p3); // BR\n            const p4 = this.convertDevicePointToPagePoint(page, q.p4); // BL\n            // PDF QuadPoints order: BL, BR, TL, TR (bottom-left, bottom-right, top-left, top-right)\n            pdf.setValue(buf + 0, p1.x, 'float'); // BL (bottom-left)\n            pdf.setValue(buf + 4, p1.y, 'float');\n            pdf.setValue(buf + 8, p2.x, 'float'); // BR (bottom-right)\n            pdf.setValue(buf + 12, p2.y, 'float');\n            pdf.setValue(buf + 16, p4.x, 'float'); // TL (top-left)\n            pdf.setValue(buf + 20, p4.y, 'float');\n            pdf.setValue(buf + 24, p3.x, 'float'); // TR (top-right)\n            pdf.setValue(buf + 28, p3.y, 'float');\n        };\n        /* ----------------------------------------------------------------------- */\n        /* 1. overwrite the quads that already exist                               */\n        const min = Math.min(count, rects.length);\n        for (let i = 0; i < min; i++) {\n            writeQuad(rects[i]);\n            if (!this.pdfiumModule.FPDFAnnot_SetAttachmentPoints(annotPtr, i, buf)) {\n                this.free(buf);\n                return false;\n            }\n        }\n        /* 2. append new quads if rects.length > count                             */\n        for (let i = count; i < rects.length; i++) {\n            writeQuad(rects[i]);\n            if (!this.pdfiumModule.FPDFAnnot_AppendAttachmentPoints(annotPtr, buf)) {\n                this.free(buf);\n                return false;\n            }\n        }\n        this.free(buf);\n        return true;\n    }\n    /**\n     * Read ink list from annotation\n     * @param page  - logical page info object (`PdfPageObject`)\n     * @param annotationPtr - pointer to the annotation whose ink list is needed\n     * @returns ink list\n     */\n    getInkList(page, annotationPtr) {\n        const inkList = [];\n        const count = this.pdfiumModule.FPDFAnnot_GetInkListCount(annotationPtr);\n        for (let i = 0; i < count; i++) {\n            const points = [];\n            const pointsCount = this.pdfiumModule.FPDFAnnot_GetInkListPath(annotationPtr, i, 0, 0);\n            if (pointsCount > 0) {\n                const pointMemorySize = 8;\n                const pointsPtr = this.malloc(pointsCount * pointMemorySize);\n                this.pdfiumModule.FPDFAnnot_GetInkListPath(annotationPtr, i, pointsPtr, pointsCount);\n                for (let j = 0; j < pointsCount; j++) {\n                    const pointX = this.pdfiumModule.pdfium.getValue(pointsPtr + j * 8, 'float');\n                    const pointY = this.pdfiumModule.pdfium.getValue(pointsPtr + j * 8 + 4, 'float');\n                    const { x, y } = this.convertPagePointToDevicePoint(page, {\n                        x: pointX,\n                        y: pointY,\n                    });\n                    points.push({ x, y });\n                }\n                this.free(pointsPtr);\n            }\n            inkList.push({ points });\n        }\n        return inkList;\n    }\n    /**\n     * Add ink list to annotation\n     * @param page  - logical page info object (`PdfPageObject`)\n     * @param annotationPtr - pointer to the annotation whose ink list is needed\n     * @param annotation - annotation object (`PdfInkAnnoObject`)\n     * @returns `true` if the operation was successful\n     */\n    setInkList(page, annotationPtr, inkList) {\n        for (const inkStroke of inkList) {\n            const inkPointsCount = inkStroke.points.length;\n            const inkPointsPtr = this.malloc(inkPointsCount * 8);\n            for (let i = 0; i < inkPointsCount; i++) {\n                const point = inkStroke.points[i];\n                const { x, y } = this.convertDevicePointToPagePoint(page, point);\n                this.pdfiumModule.pdfium.setValue(inkPointsPtr + i * 8, x, 'float');\n                this.pdfiumModule.pdfium.setValue(inkPointsPtr + i * 8 + 4, y, 'float');\n            }\n            if (this.pdfiumModule.FPDFAnnot_AddInkStroke(annotationPtr, inkPointsPtr, inkPointsCount) === -1) {\n                this.free(inkPointsPtr);\n                return false;\n            }\n            this.free(inkPointsPtr);\n        }\n        return true;\n    }\n    /**\n     * Read pdf text annotation\n     * @param page  - pdf page infor\n     * @param pagePtr - pointer to pdf page object\n     * @param annotationPtr - pointer to pdf annotation\n     * @param index  - index of annotation in the pdf page\n     * @returns pdf text annotation\n     *\n     * @private\n     */\n    readPdfTextAnno(page, pagePtr, annotationPtr, index) {\n        const annoRect = this.readPageAnnoRect(annotationPtr);\n        const rect = this.convertPageRectToDeviceRect(page, pagePtr, annoRect);\n        const author = this.getAnnotString(annotationPtr, 'T');\n        const modifiedRaw = this.getAnnotString(annotationPtr, 'M');\n        const modified = pdfDateToDate(modifiedRaw);\n        const contents = this.getAnnotString(annotationPtr, 'Contents') || '';\n        const state = this.getAnnotString(annotationPtr, 'State');\n        const stateModel = this.getAnnotString(annotationPtr, 'StateModel');\n        const webAlphaColor = this.resolveAnnotationColor(annotationPtr);\n        const inReplyToId = this.getInReplyToId(pagePtr, annotationPtr);\n        return {\n            pageIndex: page.index,\n            id: index,\n            type: PdfAnnotationSubtype.TEXT,\n            contents,\n            ...webAlphaColor,\n            rect,\n            inReplyToId,\n            author,\n            modified,\n            state,\n            stateModel,\n        };\n    }\n    /**\n     * Read pdf freetext annotation\n     * @param page  - pdf page infor\n     * @param pagePtr - pointer to pdf page object\n     * @param annotationPtr - pointer to pdf annotation\n     * @param index  - index of annotation in the pdf page\n     * @returns pdf freetext annotation\n     *\n     * @private\n     */\n    readPdfFreeTextAnno(page, pagePtr, annotationPtr, index) {\n        const annoRect = this.readPageAnnoRect(annotationPtr);\n        const rect = this.convertPageRectToDeviceRect(page, pagePtr, annoRect);\n        const contents = this.getAnnotString(annotationPtr, 'Contents') || '';\n        const author = this.getAnnotString(annotationPtr, 'T');\n        const modifiedRaw = this.getAnnotString(annotationPtr, 'M');\n        const modified = pdfDateToDate(modifiedRaw);\n        const richContent = this.getAnnotRichContent(annotationPtr);\n        return {\n            pageIndex: page.index,\n            id: index,\n            type: PdfAnnotationSubtype.FREETEXT,\n            richContent,\n            contents,\n            author,\n            modified,\n            rect,\n        };\n    }\n    /**\n     * Read pdf link annotation from pdf document\n     * @param page  - pdf page infor\n     * @param docPtr - pointer to pdf document object\n     * @param pagePtr - pointer to pdf page object\n     * @param  textPagePtr - pointer to pdf text page object\n     * @param annotationPtr - pointer to pdf annotation\n     * @param index  - index of annotation in the pdf page\n     * @returns pdf link annotation\n     *\n     * @private\n     */\n    readPdfLinkAnno(page, docPtr, pagePtr, textPagePtr, annotationPtr, index) {\n        const linkPtr = this.pdfiumModule.FPDFAnnot_GetLink(annotationPtr);\n        if (!linkPtr) {\n            return;\n        }\n        const annoRect = this.readPageAnnoRect(annotationPtr);\n        const { left, top, right, bottom } = annoRect;\n        const rect = this.convertPageRectToDeviceRect(page, pagePtr, annoRect);\n        const author = this.getAnnotString(annotationPtr, 'T');\n        const modifiedRaw = this.getAnnotString(annotationPtr, 'M');\n        const modified = pdfDateToDate(modifiedRaw);\n        const utf16Length = this.pdfiumModule.FPDFText_GetBoundedText(textPagePtr, left, top, right, bottom, 0, 0);\n        const bytesCount = (utf16Length + 1) * 2; // include NIL\n        const textBufferPtr = this.malloc(bytesCount);\n        this.pdfiumModule.FPDFText_GetBoundedText(textPagePtr, left, top, right, bottom, textBufferPtr, utf16Length);\n        const text = this.pdfiumModule.pdfium.UTF16ToString(textBufferPtr);\n        this.free(textBufferPtr);\n        const target = this.readPdfLinkAnnoTarget(docPtr, () => {\n            return this.pdfiumModule.FPDFLink_GetAction(linkPtr);\n        }, () => {\n            return this.pdfiumModule.FPDFLink_GetDest(docPtr, linkPtr);\n        });\n        return {\n            pageIndex: page.index,\n            id: index,\n            type: PdfAnnotationSubtype.LINK,\n            text,\n            target,\n            rect,\n            author,\n            modified,\n        };\n    }\n    /**\n     * Read pdf widget annotation\n     * @param page  - pdf page infor\n     * @param pagePtr - pointer to pdf page object\n     * @param annotationPtr - pointer to pdf annotation\n     * @param formHandle - form handle\n     * @param index  - index of annotation in the pdf page\n     * @returns pdf widget annotation\n     *\n     * @private\n     */\n    readPdfWidgetAnno(page, pagePtr, annotationPtr, formHandle, index) {\n        const pageRect = this.readPageAnnoRect(annotationPtr);\n        const rect = this.convertPageRectToDeviceRect(page, pagePtr, pageRect);\n        const author = this.getAnnotString(annotationPtr, 'T');\n        const modifiedRaw = this.getAnnotString(annotationPtr, 'M');\n        const modified = pdfDateToDate(modifiedRaw);\n        const field = this.readPdfWidgetAnnoField(formHandle, annotationPtr);\n        return {\n            pageIndex: page.index,\n            id: index,\n            type: PdfAnnotationSubtype.WIDGET,\n            rect,\n            field,\n            author,\n            modified,\n        };\n    }\n    /**\n     * Read pdf file attachment annotation\n     * @param page  - pdf page infor\n     * @param pagePtr - pointer to pdf page object\n     * @param annotationPtr - pointer to pdf annotation\n     * @param index  - index of annotation in the pdf page\n     * @returns pdf file attachment annotation\n     *\n     * @private\n     */\n    readPdfFileAttachmentAnno(page, pagePtr, annotationPtr, index) {\n        const pageRect = this.readPageAnnoRect(annotationPtr);\n        const rect = this.convertPageRectToDeviceRect(page, pagePtr, pageRect);\n        const author = this.getAnnotString(annotationPtr, 'T');\n        const modifiedRaw = this.getAnnotString(annotationPtr, 'M');\n        const modified = pdfDateToDate(modifiedRaw);\n        return {\n            pageIndex: page.index,\n            id: index,\n            type: PdfAnnotationSubtype.FILEATTACHMENT,\n            rect,\n            author,\n            modified,\n        };\n    }\n    /**\n     * Read pdf ink annotation\n     * @param page  - pdf page infor\n     * @param pagePtr - pointer to pdf page object\n     * @param annotationPtr - pointer to pdf annotation\n     * @param index  - index of annotation in the pdf page\n     * @returns pdf ink annotation\n     *\n     * @private\n     */\n    readPdfInkAnno(page, pagePtr, annotationPtr, index) {\n        const pageRect = this.readPageAnnoRect(annotationPtr);\n        const rect = this.convertPageRectToDeviceRect(page, pagePtr, pageRect);\n        const author = this.getAnnotString(annotationPtr, 'T');\n        const modifiedRaw = this.getAnnotString(annotationPtr, 'M');\n        const modified = pdfDateToDate(modifiedRaw);\n        const webAlphaColor = this.resolveAnnotationColor(annotationPtr);\n        const { width: strokeWidth } = this.getBorderStyle(annotationPtr);\n        const inkList = this.getInkList(page, annotationPtr);\n        const blendMode = this.pdfiumModule.EPDFAnnot_GetBlendMode(annotationPtr);\n        const intent = this.getAnnotIntent(annotationPtr);\n        return {\n            pageIndex: page.index,\n            id: index,\n            type: PdfAnnotationSubtype.INK,\n            ...(intent && { intent }),\n            blendMode,\n            ...webAlphaColor,\n            strokeWidth,\n            rect,\n            inkList,\n            author,\n            modified,\n        };\n    }\n    /**\n     * Read pdf polygon annotation\n     * @param page  - pdf page infor\n     * @param pagePtr - pointer to pdf page object\n     * @param annotationPtr - pointer to pdf annotation\n     * @param index  - index of annotation in the pdf page\n     * @returns pdf polygon annotation\n     *\n     * @private\n     */\n    readPdfPolygonAnno(page, pagePtr, annotationPtr, index) {\n        const pageRect = this.readPageAnnoRect(annotationPtr);\n        const rect = this.convertPageRectToDeviceRect(page, pagePtr, pageRect);\n        const author = this.getAnnotString(annotationPtr, 'T');\n        const modifiedRaw = this.getAnnotString(annotationPtr, 'M');\n        const modified = pdfDateToDate(modifiedRaw);\n        const vertices = this.readPdfAnnoVertices(page, pagePtr, annotationPtr);\n        return {\n            pageIndex: page.index,\n            id: index,\n            type: PdfAnnotationSubtype.POLYGON,\n            rect,\n            vertices,\n            author,\n            modified,\n        };\n    }\n    /**\n     * Read pdf polyline annotation\n     * @param page  - pdf page infor\n     * @param pagePtr - pointer to pdf page object\n     * @param annotationPtr - pointer to pdf annotation\n     * @param index  - index of annotation in the pdf page\n     * @returns pdf polyline annotation\n     *\n     * @private\n     */\n    readPdfPolylineAnno(page, pagePtr, annotationPtr, index) {\n        const pageRect = this.readPageAnnoRect(annotationPtr);\n        const rect = this.convertPageRectToDeviceRect(page, pagePtr, pageRect);\n        const author = this.getAnnotString(annotationPtr, 'T');\n        const modifiedRaw = this.getAnnotString(annotationPtr, 'M');\n        const modified = pdfDateToDate(modifiedRaw);\n        const vertices = this.readPdfAnnoVertices(page, pagePtr, annotationPtr);\n        return {\n            pageIndex: page.index,\n            id: index,\n            type: PdfAnnotationSubtype.POLYLINE,\n            rect,\n            vertices,\n            author,\n            modified,\n        };\n    }\n    /**\n     * Read pdf line annotation\n     * @param page  - pdf page infor\n     * @param pagePtr - pointer to pdf page object\n     * @param annotationPtr - pointer to pdf annotation\n     * @param index  - index of annotation in the pdf page\n     * @returns pdf line annotation\n     *\n     * @private\n     */\n    readPdfLineAnno(page, pagePtr, annotationPtr, index) {\n        const pageRect = this.readPageAnnoRect(annotationPtr);\n        const rect = this.convertPageRectToDeviceRect(page, pagePtr, pageRect);\n        const author = this.getAnnotString(annotationPtr, 'T');\n        const modifiedRaw = this.getAnnotString(annotationPtr, 'M');\n        const modified = pdfDateToDate(modifiedRaw);\n        const startPointPtr = this.malloc(8);\n        const endPointPtr = this.malloc(8);\n        this.pdfiumModule.FPDFAnnot_GetLine(annotationPtr, startPointPtr, endPointPtr);\n        const startPointX = this.pdfiumModule.pdfium.getValue(startPointPtr, 'float');\n        const startPointY = this.pdfiumModule.pdfium.getValue(startPointPtr + 4, 'float');\n        const startPoint = this.convertPagePointToDevicePoint(page, {\n            x: startPointX,\n            y: startPointY,\n        });\n        const endPointX = this.pdfiumModule.pdfium.getValue(endPointPtr, 'float');\n        const endPointY = this.pdfiumModule.pdfium.getValue(endPointPtr + 4, 'float');\n        const endPoint = this.convertPagePointToDevicePoint(page, {\n            x: endPointX,\n            y: endPointY,\n        });\n        this.free(startPointPtr);\n        this.free(endPointPtr);\n        return {\n            pageIndex: page.index,\n            id: index,\n            type: PdfAnnotationSubtype.LINE,\n            rect,\n            startPoint,\n            endPoint,\n            author,\n            modified,\n        };\n    }\n    /**\n     * Read pdf highlight annotation\n     * @param page  - pdf page infor\n     * @param pagePtr - pointer to pdf page object\n     * @param annotationPtr - pointer to pdf annotation\n     * @param index  - index of annotation in the pdf page\n     * @returns pdf highlight annotation\n     *\n     * @private\n     */\n    readPdfHighlightAnno(page, pagePtr, annotationPtr, index) {\n        const pageRect = this.readPageAnnoRect(annotationPtr);\n        const rect = this.convertPageRectToDeviceRect(page, pagePtr, pageRect);\n        const segmentRects = this.getQuadPointsAnno(page, annotationPtr);\n        const webAlphaColor = this.resolveAnnotationColor(annotationPtr);\n        const blendMode = this.pdfiumModule.EPDFAnnot_GetBlendMode(annotationPtr);\n        const author = this.getAnnotString(annotationPtr, 'T');\n        const modifiedRaw = this.getAnnotString(annotationPtr, 'M');\n        const modified = pdfDateToDate(modifiedRaw);\n        const contents = this.getAnnotString(annotationPtr, 'Contents') || '';\n        return {\n            pageIndex: page.index,\n            id: index,\n            blendMode,\n            type: PdfAnnotationSubtype.HIGHLIGHT,\n            rect,\n            contents,\n            segmentRects,\n            ...webAlphaColor,\n            author,\n            modified,\n        };\n    }\n    /**\n     * Read pdf underline annotation\n     * @param page  - pdf page infor\n     * @param pagePtr - pointer to pdf page object\n     * @param annotationPtr - pointer to pdf annotation\n     * @param index  - index of annotation in the pdf page\n     * @returns pdf underline annotation\n     *\n     * @private\n     */\n    readPdfUnderlineAnno(page, pagePtr, annotationPtr, index) {\n        const pageRect = this.readPageAnnoRect(annotationPtr);\n        const rect = this.convertPageRectToDeviceRect(page, pagePtr, pageRect);\n        const author = this.getAnnotString(annotationPtr, 'T');\n        const modifiedRaw = this.getAnnotString(annotationPtr, 'M');\n        const modified = pdfDateToDate(modifiedRaw);\n        const segmentRects = this.getQuadPointsAnno(page, annotationPtr);\n        const contents = this.getAnnotString(annotationPtr, 'Contents') || '';\n        const webAlphaColor = this.resolveAnnotationColor(annotationPtr);\n        const blendMode = this.pdfiumModule.EPDFAnnot_GetBlendMode(annotationPtr);\n        return {\n            pageIndex: page.index,\n            id: index,\n            blendMode,\n            type: PdfAnnotationSubtype.UNDERLINE,\n            rect,\n            contents,\n            segmentRects,\n            ...webAlphaColor,\n            author,\n            modified,\n        };\n    }\n    /**\n     * Read strikeout annotation\n     * @param page  - pdf page infor\n     * @param pagePtr - pointer to pdf page object\n     * @param annotationPtr - pointer to pdf annotation\n     * @param index  - index of annotation in the pdf page\n     * @returns pdf strikeout annotation\n     *\n     * @private\n     */\n    readPdfStrikeOutAnno(page, pagePtr, annotationPtr, index) {\n        const pageRect = this.readPageAnnoRect(annotationPtr);\n        const rect = this.convertPageRectToDeviceRect(page, pagePtr, pageRect);\n        const author = this.getAnnotString(annotationPtr, 'T');\n        const modifiedRaw = this.getAnnotString(annotationPtr, 'M');\n        const modified = pdfDateToDate(modifiedRaw);\n        const segmentRects = this.getQuadPointsAnno(page, annotationPtr);\n        const contents = this.getAnnotString(annotationPtr, 'Contents') || '';\n        const webAlphaColor = this.resolveAnnotationColor(annotationPtr);\n        const blendMode = this.pdfiumModule.EPDFAnnot_GetBlendMode(annotationPtr);\n        return {\n            pageIndex: page.index,\n            id: index,\n            blendMode,\n            type: PdfAnnotationSubtype.STRIKEOUT,\n            rect,\n            contents,\n            segmentRects,\n            ...webAlphaColor,\n            author,\n            modified,\n        };\n    }\n    /**\n     * Read pdf squiggly annotation\n     * @param page  - pdf page infor\n     * @param pagePtr - pointer to pdf page object\n     * @param annotationPtr - pointer to pdf annotation\n     * @param index  - index of annotation in the pdf page\n     * @returns pdf squiggly annotation\n     *\n     * @private\n     */\n    readPdfSquigglyAnno(page, pagePtr, annotationPtr, index) {\n        const pageRect = this.readPageAnnoRect(annotationPtr);\n        const rect = this.convertPageRectToDeviceRect(page, pagePtr, pageRect);\n        const author = this.getAnnotString(annotationPtr, 'T');\n        const modifiedRaw = this.getAnnotString(annotationPtr, 'M');\n        const modified = pdfDateToDate(modifiedRaw);\n        const segmentRects = this.getQuadPointsAnno(page, annotationPtr);\n        const contents = this.getAnnotString(annotationPtr, 'Contents') || '';\n        const webAlphaColor = this.resolveAnnotationColor(annotationPtr);\n        const blendMode = this.pdfiumModule.EPDFAnnot_GetBlendMode(annotationPtr);\n        return {\n            pageIndex: page.index,\n            id: index,\n            blendMode,\n            type: PdfAnnotationSubtype.SQUIGGLY,\n            rect,\n            contents,\n            segmentRects,\n            ...webAlphaColor,\n            author,\n            modified,\n        };\n    }\n    /**\n     * Read pdf caret annotation\n     * @param page  - pdf page infor\n     * @param pagePtr - pointer to pdf page object\n     * @param annotationPtr - pointer to pdf annotation\n     * @param index  - index of annotation in the pdf page\n     * @returns pdf caret annotation\n     *\n     * @private\n     */\n    readPdfCaretAnno(page, pagePtr, annotationPtr, index) {\n        const pageRect = this.readPageAnnoRect(annotationPtr);\n        const rect = this.convertPageRectToDeviceRect(page, pagePtr, pageRect);\n        const author = this.getAnnotString(annotationPtr, 'T');\n        const modifiedRaw = this.getAnnotString(annotationPtr, 'M');\n        const modified = pdfDateToDate(modifiedRaw);\n        return {\n            pageIndex: page.index,\n            id: index,\n            type: PdfAnnotationSubtype.CARET,\n            rect,\n            author,\n            modified,\n        };\n    }\n    /**\n     * Read pdf stamp annotation\n     * @param docPtr - pointer to pdf document object\n     * @param page  - pdf page infor\n     * @param pagePtr - pointer to pdf page object\n     * @param annotationPtr - pointer to pdf annotation\n     * @param index  - index of annotation in the pdf page\n     * @returns pdf stamp annotation\n     *\n     * @private\n     */\n    readPdfStampAnno(docPtr, page, pagePtr, annotationPtr, index) {\n        const pageRect = this.readPageAnnoRect(annotationPtr);\n        const rect = this.convertPageRectToDeviceRect(page, pagePtr, pageRect);\n        const author = this.getAnnotString(annotationPtr, 'T');\n        const modifiedRaw = this.getAnnotString(annotationPtr, 'M');\n        const modified = pdfDateToDate(modifiedRaw);\n        const contents = [];\n        const objectCount = this.pdfiumModule.FPDFAnnot_GetObjectCount(annotationPtr);\n        for (let i = 0; i < objectCount; i++) {\n            const annotationObjectPtr = this.pdfiumModule.FPDFAnnot_GetObject(annotationPtr, i);\n            const pageObj = this.readPdfPageObject(annotationObjectPtr);\n            if (pageObj) {\n                contents.push(pageObj);\n            }\n        }\n        return {\n            pageIndex: page.index,\n            id: index,\n            type: PdfAnnotationSubtype.STAMP,\n            rect,\n            contents,\n            author,\n            modified,\n        };\n    }\n    /**\n     * Read pdf object in pdf page\n     * @param pageObjectPtr  - pointer to pdf object in page\n     * @returns pdf object in page\n     *\n     * @private\n     */\n    readPdfPageObject(pageObjectPtr) {\n        const type = this.pdfiumModule.FPDFPageObj_GetType(pageObjectPtr);\n        switch (type) {\n            case PdfPageObjectType.PATH:\n                return this.readPathObject(pageObjectPtr);\n            case PdfPageObjectType.IMAGE:\n                return this.readImageObject(pageObjectPtr);\n            case PdfPageObjectType.FORM:\n                return this.readFormObject(pageObjectPtr);\n        }\n    }\n    /**\n     * Read pdf path object\n     * @param pathObjectPtr  - pointer to pdf path object in page\n     * @returns pdf path object\n     *\n     * @private\n     */\n    readPathObject(pathObjectPtr) {\n        const segmentCount = this.pdfiumModule.FPDFPath_CountSegments(pathObjectPtr);\n        const leftPtr = this.malloc(4);\n        const bottomPtr = this.malloc(4);\n        const rightPtr = this.malloc(4);\n        const topPtr = this.malloc(4);\n        this.pdfiumModule.FPDFPageObj_GetBounds(pathObjectPtr, leftPtr, bottomPtr, rightPtr, topPtr);\n        const left = this.pdfiumModule.pdfium.getValue(leftPtr, 'float');\n        const bottom = this.pdfiumModule.pdfium.getValue(bottomPtr, 'float');\n        const right = this.pdfiumModule.pdfium.getValue(rightPtr, 'float');\n        const top = this.pdfiumModule.pdfium.getValue(topPtr, 'float');\n        const bounds = { left, bottom, right, top };\n        this.free(leftPtr);\n        this.free(bottomPtr);\n        this.free(rightPtr);\n        this.free(topPtr);\n        const segments = [];\n        for (let i = 0; i < segmentCount; i++) {\n            const segment = this.readPdfSegment(pathObjectPtr, i);\n            segments.push(segment);\n        }\n        const matrix = this.readPdfPageObjectTransformMatrix(pathObjectPtr);\n        return {\n            type: PdfPageObjectType.PATH,\n            bounds,\n            segments,\n            matrix,\n        };\n    }\n    /**\n     * Read segment of pdf path object\n     * @param annotationObjectPtr - pointer to pdf path object\n     * @param segmentIndex - index of segment\n     * @returns pdf segment in pdf path\n     *\n     * @private\n     */\n    readPdfSegment(annotationObjectPtr, segmentIndex) {\n        const segmentPtr = this.pdfiumModule.FPDFPath_GetPathSegment(annotationObjectPtr, segmentIndex);\n        const segmentType = this.pdfiumModule.FPDFPathSegment_GetType(segmentPtr);\n        const isClosed = this.pdfiumModule.FPDFPathSegment_GetClose(segmentPtr);\n        const pointXPtr = this.malloc(4);\n        const pointYPtr = this.malloc(4);\n        this.pdfiumModule.FPDFPathSegment_GetPoint(segmentPtr, pointXPtr, pointYPtr);\n        const pointX = this.pdfiumModule.pdfium.getValue(pointXPtr, 'float');\n        const pointY = this.pdfiumModule.pdfium.getValue(pointYPtr, 'float');\n        this.free(pointXPtr);\n        this.free(pointYPtr);\n        return {\n            type: segmentType,\n            point: { x: pointX, y: pointY },\n            isClosed,\n        };\n    }\n    /**\n     * Read pdf image object from pdf document\n     * @param pageObjectPtr  - pointer to pdf image object in page\n     * @returns pdf image object\n     *\n     * @private\n     */\n    readImageObject(imageObjectPtr) {\n        const bitmapPtr = this.pdfiumModule.FPDFImageObj_GetBitmap(imageObjectPtr);\n        const bitmapBufferPtr = this.pdfiumModule.FPDFBitmap_GetBuffer(bitmapPtr);\n        const bitmapWidth = this.pdfiumModule.FPDFBitmap_GetWidth(bitmapPtr);\n        const bitmapHeight = this.pdfiumModule.FPDFBitmap_GetHeight(bitmapPtr);\n        const format = this.pdfiumModule.FPDFBitmap_GetFormat(bitmapPtr);\n        const pixelCount = bitmapWidth * bitmapHeight;\n        const bytesPerPixel = 4;\n        const array = new Uint8ClampedArray(pixelCount * bytesPerPixel);\n        for (let i = 0; i < pixelCount; i++) {\n            switch (format) {\n                case BitmapFormat.Bitmap_BGR:\n                    {\n                        const blue = this.pdfiumModule.pdfium.getValue(bitmapBufferPtr + i * 3, 'i8');\n                        const green = this.pdfiumModule.pdfium.getValue(bitmapBufferPtr + i * 3 + 1, 'i8');\n                        const red = this.pdfiumModule.pdfium.getValue(bitmapBufferPtr + i * 3 + 2, 'i8');\n                        array[i * bytesPerPixel] = red;\n                        array[i * bytesPerPixel + 1] = green;\n                        array[i * bytesPerPixel + 2] = blue;\n                        array[i * bytesPerPixel + 3] = 100;\n                    }\n                    break;\n            }\n        }\n        const imageData = new ImageData(array, bitmapWidth, bitmapHeight);\n        const matrix = this.readPdfPageObjectTransformMatrix(imageObjectPtr);\n        return {\n            type: PdfPageObjectType.IMAGE,\n            imageData,\n            matrix,\n        };\n    }\n    /**\n     * Read form object from pdf document\n     * @param formObjectPtr  - pointer to pdf form object in page\n     * @returns pdf form object\n     *\n     * @private\n     */\n    readFormObject(formObjectPtr) {\n        const objectCount = this.pdfiumModule.FPDFFormObj_CountObjects(formObjectPtr);\n        const objects = [];\n        for (let i = 0; i < objectCount; i++) {\n            const pageObjectPtr = this.pdfiumModule.FPDFFormObj_GetObject(formObjectPtr, i);\n            const pageObj = this.readPdfPageObject(pageObjectPtr);\n            if (pageObj) {\n                objects.push(pageObj);\n            }\n        }\n        const matrix = this.readPdfPageObjectTransformMatrix(formObjectPtr);\n        return {\n            type: PdfPageObjectType.FORM,\n            objects,\n            matrix,\n        };\n    }\n    /**\n     * Read pdf object in pdf page\n     * @param pageObjectPtr  - pointer to pdf object in page\n     * @returns pdf object in page\n     *\n     * @private\n     */\n    readPdfPageObjectTransformMatrix(pageObjectPtr) {\n        const matrixPtr = this.malloc(4 * 6);\n        if (this.pdfiumModule.FPDFPageObj_GetMatrix(pageObjectPtr, matrixPtr)) {\n            const a = this.pdfiumModule.pdfium.getValue(matrixPtr, 'float');\n            const b = this.pdfiumModule.pdfium.getValue(matrixPtr + 4, 'float');\n            const c = this.pdfiumModule.pdfium.getValue(matrixPtr + 8, 'float');\n            const d = this.pdfiumModule.pdfium.getValue(matrixPtr + 12, 'float');\n            const e = this.pdfiumModule.pdfium.getValue(matrixPtr + 16, 'float');\n            const f = this.pdfiumModule.pdfium.getValue(matrixPtr + 20, 'float');\n            this.free(matrixPtr);\n            return { a, b, c, d, e, f };\n        }\n        this.free(matrixPtr);\n        return { a: 1, b: 0, c: 0, d: 1, e: 0, f: 0 };\n    }\n    /**\n     * Return the stroke-width declared in the annotations /Border or /BS entry.\n     * Falls back to 1 pt when nothing is defined.\n     *\n     * @param annotationPtr - pointer to pdf annotation\n     * @returns stroke-width\n     *\n     * @private\n     */\n    getStrokeWidth(annotationPtr) {\n        // FPDFAnnot_GetBorder(annot, &hRadius, &vRadius, &borderWidth)\n        const hPtr = this.malloc(4);\n        const vPtr = this.malloc(4);\n        const wPtr = this.malloc(4);\n        const ok = this.pdfiumModule.FPDFAnnot_GetBorder(annotationPtr, hPtr, vPtr, wPtr);\n        const width = ok ? this.pdfiumModule.pdfium.getValue(wPtr, 'float') : 1; // default 1 pt\n        this.free(hPtr);\n        this.free(vPtr);\n        this.free(wPtr);\n        return width;\n    }\n    /**\n     * Fetches the `/F` flag bit-field from an annotation.\n     *\n     * @param annotationPtr pointer to an `FPDF_ANNOTATION`\n     * @returns `{ raw, flags }`\n     *           `raw`    the 32-bit integer returned by PDFium\n     *           `flags`  object with individual booleans\n     */\n    getAnnotationFlags(annotationPtr) {\n        const rawFlags = this.pdfiumModule.FPDFAnnot_GetFlags(annotationPtr); // number\n        return flagsToNames(rawFlags);\n    }\n    /**\n     * Read circle annotation\n     * @param page  - pdf page infor\n     * @param pagePtr - pointer to pdf page object\n     * @param annotationPtr - pointer to pdf annotation\n     * @param index  - index of annotation in the pdf page\n     * @returns pdf circle annotation\n     *\n     * @private\n     */\n    readPdfCircleAnno(page, pagePtr, annotationPtr, index) {\n        const flags = this.getAnnotationFlags(annotationPtr);\n        const pageRect = this.readPageAnnoRect(annotationPtr);\n        const rect = this.convertPageRectToDeviceRect(page, pagePtr, pageRect);\n        const author = this.getAnnotString(annotationPtr, 'T');\n        const modifiedRaw = this.getAnnotString(annotationPtr, 'M');\n        const modified = pdfDateToDate(modifiedRaw);\n        const { color, opacity } = this.resolveAnnotationColor(annotationPtr, PdfAnnotationColorType.InteriorColor);\n        const { color: strokeColor } = this.resolveAnnotationColor(annotationPtr);\n        let { style: strokeStyle, width: strokeWidth } = this.getBorderStyle(annotationPtr);\n        let cloudyBorderIntensity;\n        let cloudyBorderInset;\n        if (strokeStyle === PdfAnnotationBorderStyle.CLOUDY ||\n            strokeStyle === PdfAnnotationBorderStyle.UNKNOWN) {\n            const { ok: hasEffect, intensity } = this.getBorderEffect(annotationPtr);\n            if (hasEffect) {\n                cloudyBorderIntensity = intensity;\n                strokeStyle = PdfAnnotationBorderStyle.CLOUDY;\n                const { ok: hasInset, left, top, right, bottom, } = this.getRectangleDifferences(annotationPtr);\n                if (hasInset)\n                    cloudyBorderInset = [left, top, right, bottom];\n            }\n        }\n        let strokeDashArray;\n        if (strokeStyle === PdfAnnotationBorderStyle.DASHED) {\n            const { ok, pattern } = this.getBorderDashPattern(annotationPtr);\n            if (ok) {\n                strokeDashArray = pattern;\n            }\n        }\n        return {\n            pageIndex: page.index,\n            id: index,\n            type: PdfAnnotationSubtype.CIRCLE,\n            flags,\n            color,\n            opacity,\n            strokeWidth,\n            strokeColor,\n            strokeStyle,\n            rect,\n            author,\n            modified,\n            ...(cloudyBorderIntensity !== undefined && { cloudyBorderIntensity }),\n            ...(cloudyBorderInset !== undefined && { cloudyBorderInset }),\n            ...(strokeDashArray !== undefined && { strokeDashArray }),\n        };\n    }\n    /**\n     * Read square annotation\n     * @param page  - pdf page infor\n     * @param pagePtr - pointer to pdf page object\n     * @param annotationPtr - pointer to pdf annotation\n     * @param index  - index of annotation in the pdf page\n     * @returns pdf square annotation\n     *\n     * @private\n     */\n    readPdfSquareAnno(page, pagePtr, annotationPtr, index) {\n        const flags = this.getAnnotationFlags(annotationPtr);\n        const pageRect = this.readPageAnnoRect(annotationPtr);\n        const rect = this.convertPageRectToDeviceRect(page, pagePtr, pageRect);\n        const author = this.getAnnotString(annotationPtr, 'T');\n        const modifiedRaw = this.getAnnotString(annotationPtr, 'M');\n        const modified = pdfDateToDate(modifiedRaw);\n        const { color, opacity } = this.resolveAnnotationColor(annotationPtr, PdfAnnotationColorType.InteriorColor);\n        const { color: strokeColor } = this.resolveAnnotationColor(annotationPtr);\n        let { style: strokeStyle, width: strokeWidth } = this.getBorderStyle(annotationPtr);\n        let cloudyBorderIntensity;\n        let cloudyBorderInset;\n        if (strokeStyle === PdfAnnotationBorderStyle.CLOUDY ||\n            strokeStyle === PdfAnnotationBorderStyle.UNKNOWN) {\n            const { ok: hasEffect, intensity } = this.getBorderEffect(annotationPtr);\n            if (hasEffect) {\n                cloudyBorderIntensity = intensity;\n                strokeStyle = PdfAnnotationBorderStyle.CLOUDY;\n                const { ok: hasInset, left, top, right, bottom, } = this.getRectangleDifferences(annotationPtr);\n                if (hasInset)\n                    cloudyBorderInset = [left, top, right, bottom];\n            }\n        }\n        let strokeDashArray;\n        if (strokeStyle === PdfAnnotationBorderStyle.DASHED) {\n            const { ok, pattern } = this.getBorderDashPattern(annotationPtr);\n            if (ok) {\n                strokeDashArray = pattern;\n            }\n        }\n        return {\n            pageIndex: page.index,\n            id: index,\n            type: PdfAnnotationSubtype.SQUARE,\n            flags,\n            color,\n            opacity,\n            strokeColor,\n            strokeWidth,\n            strokeStyle,\n            rect,\n            author,\n            modified,\n            ...(cloudyBorderIntensity !== undefined && { cloudyBorderIntensity }),\n            ...(cloudyBorderInset !== undefined && { cloudyBorderInset }),\n            ...(strokeDashArray !== undefined && { strokeDashArray }),\n        };\n    }\n    /**\n     * Read basic info of unsupported pdf annotation\n     * @param page  - pdf page infor\n     * @param pagePtr - pointer to pdf page object\n     * @param type - type of annotation\n     * @param annotationPtr - pointer to pdf annotation\n     * @param index  - index of annotation in the pdf page\n     * @returns pdf annotation\n     *\n     * @private\n     */\n    readPdfAnno(page, pagePtr, type, annotationPtr, index) {\n        const pageRect = this.readPageAnnoRect(annotationPtr);\n        const rect = this.convertPageRectToDeviceRect(page, pagePtr, pageRect);\n        const author = this.getAnnotString(annotationPtr, 'T');\n        const modifiedRaw = this.getAnnotString(annotationPtr, 'M');\n        const modified = pdfDateToDate(modifiedRaw);\n        return {\n            pageIndex: page.index,\n            id: index,\n            type,\n            rect,\n            author,\n            modified,\n        };\n    }\n    /**\n     * Resolve `/IRT`  parent-annotation index on the same page.\n     *\n     * @param pagePtr        - pointer to FPDF_PAGE\n     * @param annotationPtr  - pointer to FPDF_ANNOTATION\n     * @returns index (`0count-1`) or `undefined` when the annotation is *not* a reply\n     *\n     * @private\n     */\n    getInReplyToId(pagePtr, annotationPtr) {\n        const parentPtr = this.pdfiumModule.FPDFAnnot_GetLinkedAnnot(annotationPtr, 'IRT');\n        if (!parentPtr)\n            return;\n        // PDFium  5100  returns 1 when annot not found on page\n        const idx = this.pdfiumModule.FPDFPage_GetAnnotIndex(pagePtr, parentPtr);\n        return idx >= 0 ? idx : undefined;\n    }\n    /**\n     * Fetch a string value (`/T`, `/M`, `/State`, ) from an annotation.\n     *\n     * @returns decoded UTF-8 string or `undefined` when the key is absent\n     *\n     * @private\n     */\n    getAnnotString(annotationPtr, key) {\n        const len = this.pdfiumModule.FPDFAnnot_GetStringValue(annotationPtr, key, 0, 0);\n        if (len === 0)\n            return;\n        const bytes = (len + 1) * 2;\n        const ptr = this.malloc(bytes);\n        this.pdfiumModule.FPDFAnnot_GetStringValue(annotationPtr, key, ptr, bytes);\n        const value = this.pdfiumModule.pdfium.UTF16ToString(ptr);\n        this.free(ptr);\n        return value || undefined;\n    }\n    /**\n     * Fetches the /IT (Intent) name from an annotation as a UTF-8 JS string.\n     *\n     * Mirrors getAnnotString(): calls EPDFAnnot_GetIntent twice (length probe + copy).\n     * Returns `undefined` if no intent present.\n     */\n    getAnnotIntent(annotationPtr) {\n        const len = this.pdfiumModule.EPDFAnnot_GetIntent(annotationPtr, 0, 0);\n        if (len === 0)\n            return;\n        const codeUnits = len + 1;\n        const bytes = codeUnits * 2;\n        const ptr = this.malloc(bytes);\n        this.pdfiumModule.EPDFAnnot_GetIntent(annotationPtr, ptr, bytes);\n        const value = this.pdfiumModule.pdfium.UTF16ToString(ptr);\n        this.free(ptr);\n        return value && value !== 'undefined' ? value : undefined;\n    }\n    /**\n     * Returns the richcontent string stored in the annotations `/RC` entry.\n     *\n     * Works like `getAnnotIntent()`: first probe for length, then copy.\n     * `undefined` when the annotation has no rich content.\n     */\n    getAnnotRichContent(annotationPtr) {\n        // First call  number of UTF16 code units (excluding NUL)\n        const len = this.pdfiumModule.EPDFAnnot_GetRichContent(annotationPtr, 0, 0);\n        if (len === 0)\n            return;\n        // +1 for the implicit NUL added by PDFium  bytes = 2  code units\n        const codeUnits = len + 1;\n        const bytes = codeUnits * 2;\n        const ptr = this.malloc(bytes);\n        this.pdfiumModule.EPDFAnnot_GetRichContent(annotationPtr, ptr, bytes);\n        const value = this.pdfiumModule.pdfium.UTF16ToString(ptr);\n        this.free(ptr);\n        return value || undefined;\n    }\n    /**\n     * Set a string value (`/T`, `/M`, `/State`, ) to an annotation.\n     *\n     * @returns `true` if the operation was successful\n     *\n     * @private\n     */\n    setAnnotString(annotationPtr, key, value) {\n        const bytes = 2 * (value.length + 1);\n        const ptr = this.malloc(bytes);\n        this.pdfiumModule.pdfium.stringToUTF16(value, ptr, bytes);\n        const ok = this.pdfiumModule.FPDFAnnot_SetStringValue(annotationPtr, key, ptr);\n        this.free(ptr);\n        return ok;\n    }\n    /**\n     * Read vertices of pdf annotation\n     * @param page  - pdf page infor\n     * @param pagePtr - pointer to pdf page object\n     * @param annotationPtr - pointer to pdf annotation\n     * @returns vertices of pdf annotation\n     *\n     * @private\n     */\n    readPdfAnnoVertices(page, pagePtr, annotationPtr) {\n        const vertices = [];\n        const count = this.pdfiumModule.FPDFAnnot_GetVertices(annotationPtr, 0, 0);\n        const pointMemorySize = 8;\n        const pointsPtr = this.malloc(count * pointMemorySize);\n        this.pdfiumModule.FPDFAnnot_GetVertices(annotationPtr, pointsPtr, count);\n        for (let i = 0; i < count; i++) {\n            const pointX = this.pdfiumModule.pdfium.getValue(pointsPtr + i * pointMemorySize, 'float');\n            const pointY = this.pdfiumModule.pdfium.getValue(pointsPtr + i * pointMemorySize + 4, 'float');\n            const { x, y } = this.convertPagePointToDevicePoint(page, {\n                x: pointX,\n                y: pointY,\n            });\n            vertices.push({\n                x,\n                y,\n            });\n        }\n        this.free(pointsPtr);\n        return vertices;\n    }\n    /**\n     * Read the target of pdf bookmark\n     * @param docPtr - pointer to pdf document object\n     * @param getActionPtr - callback function to retrive the pointer of action\n     * @param getDestinationPtr - callback function to retrive the pointer of destination\n     * @returns target of pdf bookmark\n     *\n     * @private\n     */\n    readPdfBookmarkTarget(docPtr, getActionPtr, getDestinationPtr) {\n        const actionPtr = getActionPtr();\n        if (actionPtr) {\n            const action = this.readPdfAction(docPtr, actionPtr);\n            return {\n                type: 'action',\n                action,\n            };\n        }\n        else {\n            const destinationPtr = getDestinationPtr();\n            if (destinationPtr) {\n                const destination = this.readPdfDestination(docPtr, destinationPtr);\n                return {\n                    type: 'destination',\n                    destination,\n                };\n            }\n        }\n    }\n    /**\n     * Read field of pdf widget annotation\n     * @param formHandle - form handle\n     * @param annotationPtr - pointer to pdf annotation\n     * @returns field of pdf widget annotation\n     *\n     * @private\n     */\n    readPdfWidgetAnnoField(formHandle, annotationPtr) {\n        const flag = this.pdfiumModule.FPDFAnnot_GetFormFieldFlags(formHandle, annotationPtr);\n        const type = this.pdfiumModule.FPDFAnnot_GetFormFieldType(formHandle, annotationPtr);\n        const name = readString(this.pdfiumModule.pdfium, (buffer, bufferLength) => {\n            return this.pdfiumModule.FPDFAnnot_GetFormFieldName(formHandle, annotationPtr, buffer, bufferLength);\n        }, this.pdfiumModule.pdfium.UTF16ToString);\n        const alternateName = readString(this.pdfiumModule.pdfium, (buffer, bufferLength) => {\n            return this.pdfiumModule.FPDFAnnot_GetFormFieldAlternateName(formHandle, annotationPtr, buffer, bufferLength);\n        }, this.pdfiumModule.pdfium.UTF16ToString);\n        const value = readString(this.pdfiumModule.pdfium, (buffer, bufferLength) => {\n            return this.pdfiumModule.FPDFAnnot_GetFormFieldValue(formHandle, annotationPtr, buffer, bufferLength);\n        }, this.pdfiumModule.pdfium.UTF16ToString);\n        const options = [];\n        if (type === PDF_FORM_FIELD_TYPE.COMBOBOX || type === PDF_FORM_FIELD_TYPE.LISTBOX) {\n            const count = this.pdfiumModule.FPDFAnnot_GetOptionCount(formHandle, annotationPtr);\n            for (let i = 0; i < count; i++) {\n                const label = readString(this.pdfiumModule.pdfium, (buffer, bufferLength) => {\n                    return this.pdfiumModule.FPDFAnnot_GetOptionLabel(formHandle, annotationPtr, i, buffer, bufferLength);\n                }, this.pdfiumModule.pdfium.UTF16ToString);\n                const isSelected = this.pdfiumModule.FPDFAnnot_IsOptionSelected(formHandle, annotationPtr, i);\n                options.push({\n                    label,\n                    isSelected,\n                });\n            }\n        }\n        let isChecked = false;\n        if (type === PDF_FORM_FIELD_TYPE.CHECKBOX || type === PDF_FORM_FIELD_TYPE.RADIOBUTTON) {\n            isChecked = this.pdfiumModule.FPDFAnnot_IsChecked(formHandle, annotationPtr);\n        }\n        return {\n            flag,\n            type,\n            name,\n            alternateName,\n            value,\n            isChecked,\n            options,\n        };\n    }\n    /**\n     * {@inheritDoc @embedpdf/models!PdfEngine.renderAnnotation}\n     *\n     * @public\n     */\n    renderAnnotation(doc, page, annotation, scaleFactor, rotation, dpr = 1, // device-pixel-ratio (canvas)\n    mode = AppearanceMode.Normal, imageType = 'image/webp') {\n        this.logger.debug(LOG_SOURCE, LOG_CATEGORY, 'renderAnnotation', doc, page, annotation, scaleFactor, rotation, dpr, mode, imageType);\n        this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `RenderAnnotation`, 'Begin', `${doc.id}-${page.index}-${annotation.id}`);\n        const task = new Task();\n        const ctx = this.cache.getContext(doc.id);\n        if (!ctx) {\n            this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `RenderAnnotation`, 'End', `${doc.id}-${page.index}-${annotation.id}`);\n            return PdfTaskHelper.reject({\n                code: PdfErrorCode.DocNotOpen,\n                message: 'document does not open',\n            });\n        }\n        /*  1. grab native handles  */\n        const pageCtx = ctx.acquirePage(page.index);\n        const annotPtr = this.pdfiumModule.FPDFPage_GetAnnot(pageCtx.pagePtr, annotation.id);\n        if (!annotPtr) {\n            pageCtx.release();\n            this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `RenderAnnotation`, 'End', `${doc.id}-${page.index}-${annotation.id}`);\n            return PdfTaskHelper.reject({\n                code: PdfErrorCode.NotFound,\n                message: 'annotation not found',\n            });\n        }\n        const finalScale = scaleFactor * dpr;\n        /*  2. decide bitmap size (integer pixels)  */\n        const annotRect = annotation.rect;\n        const bitmapRect = toIntRect(transformRect(page.size, annotRect, rotation, finalScale));\n        const format = BitmapFormat.Bitmap_BGRA;\n        const bytesPerPixel = 4;\n        const bitmapHeapLength = bitmapRect.size.width * bitmapRect.size.height * bytesPerPixel;\n        const bitmapHeapPtr = this.malloc(bitmapHeapLength);\n        const bitmapPtr = this.pdfiumModule.FPDFBitmap_CreateEx(bitmapRect.size.width, bitmapRect.size.height, format, bitmapHeapPtr, bitmapRect.size.width * bytesPerPixel);\n        this.pdfiumModule.FPDFBitmap_FillRect(bitmapPtr, 0, 0, bitmapRect.size.width, bitmapRect.size.height, 0x00000000);\n        const matrix = makeMatrix(annotation.rect, rotation, finalScale);\n        // Allocate memory for the matrix on the wasm heap and write to it\n        const matrixSize = 6 * 4;\n        const matrixPtr = this.malloc(matrixSize);\n        const matrixView = new Float32Array(this.pdfiumModule.pdfium.HEAPF32.buffer, matrixPtr, 6);\n        matrixView.set([matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f]);\n        /*  5. call the native helper with the new matrix  */\n        const FLAGS = RenderFlag.REVERSE_BYTE_ORDER;\n        const ok = !!this.pdfiumModule.EPDF_RenderAnnotBitmap(bitmapPtr, pageCtx.pagePtr, annotPtr, mode, matrixPtr, FLAGS);\n        /*  6. tear down native resources  */\n        this.free(matrixPtr); // Free the matrix memory\n        this.pdfiumModule.FPDFBitmap_Destroy(bitmapPtr);\n        this.pdfiumModule.FPDFPage_CloseAnnot(annotPtr);\n        pageCtx.release();\n        if (!ok) {\n            this.free(bitmapHeapPtr);\n            this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `RenderAnnotation`, 'End', `${doc.id}-${page.index}-${annotation.id}`);\n            return PdfTaskHelper.reject({\n                code: PdfErrorCode.Unknown,\n                message: 'EPDF_RenderAnnotBitmap failed',\n            });\n        }\n        /*  6. copy out + convert to Blob (reuse existing converter)  */\n        const data = this.pdfiumModule.pdfium.HEAPU8.subarray(bitmapHeapPtr, bitmapHeapPtr + bitmapHeapLength);\n        const imageData = {\n            data: new Uint8ClampedArray(data),\n            width: bitmapRect.size.width,\n            height: bitmapRect.size.height,\n        };\n        this.free(bitmapHeapPtr);\n        this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `RenderAnnotation`, 'End', `${doc.id}-${page.index}-${annotation.id}`);\n        this.imageDataConverter(imageData, imageType)\n            .then((blob) => task.resolve(blob))\n            .catch((err) => task.reject({ code: PdfErrorCode.Unknown, message: String(err) }));\n        return task;\n    }\n    /**\n     * render rectangle of pdf page to image\n     * @param docPtr - pointer to pdf document object\n     * @param page  - pdf page infor\n     * @param rect - rectangle info\n     * @param scaleFactor  - factor of scalling\n     * @param rotation  - rotation angle\n     * @param options - render options\n     * @returns image data\n     *\n     * @private\n     */\n    renderPageRectToImageData(ctx, page, rect, scaleFactor, rotation, dpr, options) {\n        const format = BitmapFormat.Bitmap_BGRA;\n        const bytesPerPixel = 4;\n        // Round the transformed dimensions to whole pixels\n        const rectSize = toIntRect(transformRect(page.size, rect, rotation, scaleFactor * dpr));\n        const pageSize = toIntSize(transformSize(page.size, rotation, scaleFactor * dpr));\n        const bitmapHeapLength = rectSize.size.width * rectSize.size.height * bytesPerPixel;\n        const bitmapHeapPtr = this.malloc(bitmapHeapLength);\n        const bitmapPtr = this.pdfiumModule.FPDFBitmap_CreateEx(rectSize.size.width, rectSize.size.height, format, bitmapHeapPtr, rectSize.size.width * bytesPerPixel);\n        this.pdfiumModule.FPDFBitmap_FillRect(bitmapPtr, 0, 0, rectSize.size.width, rectSize.size.height, 0xffffffff);\n        let flags = RenderFlag.REVERSE_BYTE_ORDER;\n        if (options?.withAnnotations) {\n            flags = flags | RenderFlag.ANNOT;\n        }\n        const pageCtx = ctx.acquirePage(page.index);\n        this.pdfiumModule.FPDF_RenderPageBitmap(bitmapPtr, pageCtx.pagePtr, -rectSize.origin.x, -rectSize.origin.y, pageSize.width, pageSize.height, rotation, flags);\n        this.pdfiumModule.FPDFBitmap_Destroy(bitmapPtr);\n        pageCtx.release();\n        const data = this.pdfiumModule.pdfium.HEAPU8.subarray(bitmapHeapPtr, bitmapHeapPtr + bitmapHeapLength);\n        const imageData = {\n            data: new Uint8ClampedArray(data),\n            width: rectSize.size.width,\n            height: rectSize.size.height,\n        };\n        this.free(bitmapHeapPtr);\n        return imageData;\n    }\n    /**\n     * Read the target of pdf link annotation\n     * @param docPtr - pointer to pdf document object\n     * @param getActionPtr - callback function to retrive the pointer of action\n     * @param getDestinationPtr - callback function to retrive the pointer of destination\n     * @returns target of link\n     *\n     * @private\n     */\n    readPdfLinkAnnoTarget(docPtr, getActionPtr, getDestinationPtr) {\n        const destinationPtr = getDestinationPtr();\n        if (destinationPtr) {\n            const destination = this.readPdfDestination(docPtr, destinationPtr);\n            return {\n                type: 'destination',\n                destination,\n            };\n        }\n        else {\n            const actionPtr = getActionPtr();\n            if (actionPtr) {\n                const action = this.readPdfAction(docPtr, actionPtr);\n                return {\n                    type: 'action',\n                    action,\n                };\n            }\n        }\n    }\n    /**\n     * Read pdf action from pdf document\n     * @param docPtr - pointer to pdf document object\n     * @param actionPtr - pointer to pdf action object\n     * @returns pdf action object\n     *\n     * @private\n     */\n    readPdfAction(docPtr, actionPtr) {\n        const actionType = this.pdfiumModule.FPDFAction_GetType(actionPtr);\n        let action;\n        switch (actionType) {\n            case PdfActionType.Unsupported:\n                action = {\n                    type: PdfActionType.Unsupported,\n                };\n                break;\n            case PdfActionType.Goto:\n                {\n                    const destinationPtr = this.pdfiumModule.FPDFAction_GetDest(docPtr, actionPtr);\n                    if (destinationPtr) {\n                        const destination = this.readPdfDestination(docPtr, destinationPtr);\n                        action = {\n                            type: PdfActionType.Goto,\n                            destination,\n                        };\n                    }\n                    else {\n                        action = {\n                            type: PdfActionType.Unsupported,\n                        };\n                    }\n                }\n                break;\n            case PdfActionType.RemoteGoto:\n                {\n                    // In case of remote goto action,\n                    // the application should first use FPDFAction_GetFilePath\n                    // to get file path, then load that particular document,\n                    // and use its document handle to call this\n                    action = {\n                        type: PdfActionType.Unsupported,\n                    };\n                }\n                break;\n            case PdfActionType.URI:\n                {\n                    const uri = readString(this.pdfiumModule.pdfium, (buffer, bufferLength) => {\n                        return this.pdfiumModule.FPDFAction_GetURIPath(docPtr, actionPtr, buffer, bufferLength);\n                    }, this.pdfiumModule.pdfium.UTF8ToString);\n                    action = {\n                        type: PdfActionType.URI,\n                        uri,\n                    };\n                }\n                break;\n            case PdfActionType.LaunchAppOrOpenFile:\n                {\n                    const path = readString(this.pdfiumModule.pdfium, (buffer, bufferLength) => {\n                        return this.pdfiumModule.FPDFAction_GetFilePath(actionPtr, buffer, bufferLength);\n                    }, this.pdfiumModule.pdfium.UTF8ToString);\n                    action = {\n                        type: PdfActionType.LaunchAppOrOpenFile,\n                        path,\n                    };\n                }\n                break;\n        }\n        return action;\n    }\n    /**\n     * Read pdf destination object\n     * @param docPtr - pointer to pdf document object\n     * @param destinationPtr - pointer to pdf destination\n     * @returns pdf destination object\n     *\n     * @private\n     */\n    readPdfDestination(docPtr, destinationPtr) {\n        const pageIndex = this.pdfiumModule.FPDFDest_GetDestPageIndex(docPtr, destinationPtr);\n        // Every params is a float value\n        const maxParmamsCount = 4;\n        const paramsCountPtr = this.malloc(maxParmamsCount);\n        const paramsPtr = this.malloc(maxParmamsCount * 4);\n        const zoomMode = this.pdfiumModule.FPDFDest_GetView(destinationPtr, paramsCountPtr, paramsPtr);\n        const paramsCount = this.pdfiumModule.pdfium.getValue(paramsCountPtr, 'i32');\n        const view = [];\n        for (let i = 0; i < paramsCount; i++) {\n            const paramPtr = paramsPtr + i * 4;\n            view.push(this.pdfiumModule.pdfium.getValue(paramPtr, 'float'));\n        }\n        this.free(paramsCountPtr);\n        this.free(paramsPtr);\n        if (zoomMode === PdfZoomMode.XYZ) {\n            const hasXPtr = this.malloc(1);\n            const hasYPtr = this.malloc(1);\n            const hasZPtr = this.malloc(1);\n            const xPtr = this.malloc(4);\n            const yPtr = this.malloc(4);\n            const zPtr = this.malloc(4);\n            const isSucceed = this.pdfiumModule.FPDFDest_GetLocationInPage(destinationPtr, hasXPtr, hasYPtr, hasZPtr, xPtr, yPtr, zPtr);\n            if (isSucceed) {\n                const hasX = this.pdfiumModule.pdfium.getValue(hasXPtr, 'i8');\n                const hasY = this.pdfiumModule.pdfium.getValue(hasYPtr, 'i8');\n                const hasZ = this.pdfiumModule.pdfium.getValue(hasZPtr, 'i8');\n                const x = hasX ? this.pdfiumModule.pdfium.getValue(xPtr, 'float') : 0;\n                const y = hasY ? this.pdfiumModule.pdfium.getValue(yPtr, 'float') : 0;\n                const zoom = hasZ ? this.pdfiumModule.pdfium.getValue(zPtr, 'float') : 0;\n                this.free(hasXPtr);\n                this.free(hasYPtr);\n                this.free(hasZPtr);\n                this.free(xPtr);\n                this.free(yPtr);\n                this.free(zPtr);\n                return {\n                    pageIndex,\n                    zoom: {\n                        mode: zoomMode,\n                        params: {\n                            x,\n                            y,\n                            zoom,\n                        },\n                    },\n                    view,\n                };\n            }\n            this.free(hasXPtr);\n            this.free(hasYPtr);\n            this.free(hasZPtr);\n            this.free(xPtr);\n            this.free(yPtr);\n            this.free(zPtr);\n            return {\n                pageIndex,\n                zoom: {\n                    mode: zoomMode,\n                    params: {\n                        x: 0,\n                        y: 0,\n                        zoom: 0,\n                    },\n                },\n                view,\n            };\n        }\n        return {\n            pageIndex,\n            zoom: {\n                mode: zoomMode,\n            },\n            view,\n        };\n    }\n    /**\n     * Read attachmet from pdf document\n     * @param docPtr - pointer to pdf document object\n     * @param index - index of attachment\n     * @returns attachment content\n     *\n     * @private\n     */\n    readPdfAttachment(docPtr, index) {\n        const attachmentPtr = this.pdfiumModule.FPDFDoc_GetAttachment(docPtr, index);\n        const name = readString(this.pdfiumModule.pdfium, (buffer, bufferLength) => {\n            return this.pdfiumModule.FPDFAttachment_GetName(attachmentPtr, buffer, bufferLength);\n        }, this.pdfiumModule.pdfium.UTF16ToString);\n        const creationDate = readString(this.pdfiumModule.pdfium, (buffer, bufferLength) => {\n            return this.pdfiumModule.FPDFAttachment_GetStringValue(attachmentPtr, 'CreationDate', buffer, bufferLength);\n        }, this.pdfiumModule.pdfium.UTF16ToString);\n        const checksum = readString(this.pdfiumModule.pdfium, (buffer, bufferLength) => {\n            return this.pdfiumModule.FPDFAttachment_GetStringValue(attachmentPtr, 'Checksum', buffer, bufferLength);\n        }, this.pdfiumModule.pdfium.UTF16ToString);\n        return {\n            index,\n            name,\n            creationDate,\n            checksum,\n        };\n    }\n    /**\n     * Convert coordinate of point from device coordinate to page coordinate\n     * @param page  - pdf page infor\n     * @param position - position of point\n     * @returns converted position\n     *\n     * @private\n     */\n    convertDevicePointToPagePoint(page, position) {\n        const x = position.x;\n        const y = page.size.height - position.y;\n        return { x, y };\n    }\n    /**\n     * Convert coordinate of point from page coordinate to device coordinate\n     * @param page  - pdf page infor\n     * @param position - position of point\n     * @returns converted position\n     *\n     * @private\n     */\n    convertPagePointToDevicePoint(page, position) {\n        const x = position.x;\n        const y = page.size.height - position.y;\n        return { x, y };\n    }\n    /**\n     * Convert coordinate of rectangle from page coordinate to device coordinate\n     * @param page  - pdf page infor\n     * @param pagePtr - pointer to pdf page object\n     * @param pageRect - rectangle that needs to be converted\n     * @returns converted rectangle\n     *\n     * @private\n     */\n    convertPageRectToDeviceRect(page, pagePtr, pageRect) {\n        const { x, y } = this.convertPagePointToDevicePoint(page, {\n            x: pageRect.left,\n            y: pageRect.top,\n        });\n        const rect = {\n            origin: {\n                x,\n                y,\n            },\n            size: {\n                width: Math.abs(pageRect.right - pageRect.left),\n                height: Math.abs(pageRect.top - pageRect.bottom),\n            },\n        };\n        return rect;\n    }\n    /**\n     * Read the appearance stream of annotation\n     * @param annotationPtr - pointer to pdf annotation\n     * @param mode - appearance mode\n     * @returns appearance stream\n     *\n     * @private\n     */\n    readPageAnnoAppearanceStreams(annotationPtr) {\n        return {\n            normal: this.readPageAnnoAppearanceStream(annotationPtr, AppearanceMode.Normal),\n            rollover: this.readPageAnnoAppearanceStream(annotationPtr, AppearanceMode.Rollover),\n            down: this.readPageAnnoAppearanceStream(annotationPtr, AppearanceMode.Down),\n        };\n    }\n    /**\n     * Read the appearance stream of annotation\n     * @param annotationPtr - pointer to pdf annotation\n     * @param mode - appearance mode\n     * @returns appearance stream\n     *\n     * @private\n     */\n    readPageAnnoAppearanceStream(annotationPtr, mode = AppearanceMode.Normal) {\n        const utf16Length = this.pdfiumModule.FPDFAnnot_GetAP(annotationPtr, mode, 0, 0);\n        const bytesCount = (utf16Length + 1) * 2; // include NIL\n        const bufferPtr = this.malloc(bytesCount);\n        this.pdfiumModule.FPDFAnnot_GetAP(annotationPtr, mode, bufferPtr, bytesCount);\n        const ap = this.pdfiumModule.pdfium.UTF16ToString(bufferPtr);\n        this.free(bufferPtr);\n        return ap;\n    }\n    /**\n     * Change the visible colour (and opacity) of an existing annotation.\n     *\n     * For markup annotations (highlight / underline / strikeout / squiggly) we\n     * first clear the AP dictionary entry, otherwise the stored appearance stream\n     * will override the new tint.  For all other sub-types we keep the existing\n     * AP so custom artwork isn't lost.\n     *\n     * @param doc         logical document object\n     * @param page        logical page object\n     * @param annotation  the annotation we want to recolour\n     * @param colour      RGBA tuple (0-255 per channel)\n     * @param which       0 = stroke/fill colour  (PDFium's \"colourType\" param)\n     *\n     * @returns `true` when the operation succeeded\n     */\n    updateAnnotationColor(doc, page, annotation, color, which = 0) {\n        this.logger.debug(LOG_SOURCE, LOG_CATEGORY, 'setAnnotationColor', doc, page, annotation, color, which);\n        this.logger.perf(LOG_SOURCE, LOG_CATEGORY, 'setAnnotationColor', 'Begin', doc.id);\n        const task = PdfTaskHelper.create();\n        try {\n            /* 1  sanity & native handles  */\n            const ctx = this.cache.getContext(doc.id);\n            if (!ctx) {\n                this.logger.perf(LOG_SOURCE, LOG_CATEGORY, 'setAnnotationColor', 'End', doc.id);\n                this.logger.warn(LOG_SOURCE, LOG_CATEGORY, 'setAnnotationColor: doc closed');\n                task.resolve(false);\n                return task;\n            }\n            const pageCtx = ctx.acquirePage(page.index);\n            const annotPtr = this.pdfiumModule.FPDFPage_GetAnnot(pageCtx.pagePtr, annotation.id);\n            if (!annotPtr) {\n                this.logger.perf(LOG_SOURCE, LOG_CATEGORY, 'setAnnotationColor', 'End', doc.id);\n                this.logger.warn(LOG_SOURCE, LOG_CATEGORY, 'setAnnotationColor: annot not found');\n                pageCtx.release();\n                task.resolve(false);\n                return task;\n            }\n            const ok = this.setAnnotationColor(annotPtr, color, which);\n            /* 4  regenerate appearance & clean-up  */\n            if (ok) {\n                this.pdfiumModule.FPDFPage_GenerateContent(pageCtx.pagePtr);\n            }\n            this.pdfiumModule.FPDFPage_CloseAnnot(annotPtr);\n            pageCtx.release();\n            this.logger.perf(LOG_SOURCE, LOG_CATEGORY, 'setAnnotationColor', 'End', doc.id);\n            task.resolve(!!ok);\n        }\n        catch (error) {\n            this.logger.perf(LOG_SOURCE, LOG_CATEGORY, 'setAnnotationColor', 'End', doc.id);\n            this.logger.error(LOG_SOURCE, LOG_CATEGORY, 'setAnnotationColor: error', error);\n            task.reject({\n                code: PdfErrorCode.Unknown,\n                message: `Failed to set annotation color: ${error instanceof Error ? error.message : String(error)}`,\n            });\n        }\n        return task;\n    }\n    /**\n     * Set the rect of specified annotation\n     * @param page - page info that the annotation is belonged to\n     * @param pagePtr - pointer of page object\n     * @param annotationPtr - pointer to annotation object\n     * @param rect - target rectangle\n     * @returns whether the rect is setted\n     *\n     * @private\n     */\n    setPageAnnoRect(page, pagePtr, annotationPtr, rect) {\n        const pageXPtr = this.malloc(8);\n        const pageYPtr = this.malloc(8);\n        if (!this.pdfiumModule.FPDF_DeviceToPage(pagePtr, 0, 0, page.size.width, page.size.height, 0, rect.origin.x, rect.origin.y, pageXPtr, pageYPtr)) {\n            this.free(pageXPtr);\n            this.free(pageYPtr);\n            return false;\n        }\n        const pageX = this.pdfiumModule.pdfium.getValue(pageXPtr, 'double');\n        const pageY = this.pdfiumModule.pdfium.getValue(pageYPtr, 'double');\n        this.free(pageXPtr);\n        this.free(pageYPtr);\n        const pageRectPtr = this.malloc(4 * 4);\n        this.pdfiumModule.pdfium.setValue(pageRectPtr, pageX, 'float');\n        this.pdfiumModule.pdfium.setValue(pageRectPtr + 4, pageY, 'float');\n        this.pdfiumModule.pdfium.setValue(pageRectPtr + 8, pageX + rect.size.width, 'float');\n        this.pdfiumModule.pdfium.setValue(pageRectPtr + 12, pageY - rect.size.height, 'float');\n        if (!this.pdfiumModule.FPDFAnnot_SetRect(annotationPtr, pageRectPtr)) {\n            this.free(pageRectPtr);\n            return false;\n        }\n        this.free(pageRectPtr);\n        return true;\n    }\n    /**\n     * Read the rectangle of annotation\n     * @param annotationPtr - pointer to pdf annotation\n     * @returns rectangle of annotation\n     *\n     * @private\n     */\n    readPageAnnoRect(annotationPtr) {\n        const pageRectPtr = this.malloc(4 * 4);\n        const pageRect = {\n            left: 0,\n            top: 0,\n            right: 0,\n            bottom: 0,\n        };\n        if (this.pdfiumModule.FPDFAnnot_GetRect(annotationPtr, pageRectPtr)) {\n            pageRect.left = this.pdfiumModule.pdfium.getValue(pageRectPtr, 'float');\n            pageRect.top = this.pdfiumModule.pdfium.getValue(pageRectPtr + 4, 'float');\n            pageRect.right = this.pdfiumModule.pdfium.getValue(pageRectPtr + 8, 'float');\n            pageRect.bottom = this.pdfiumModule.pdfium.getValue(pageRectPtr + 12, 'float');\n        }\n        this.free(pageRectPtr);\n        return pageRect;\n    }\n    /**\n     * Get highlight rects for a specific character range (for search highlighting)\n     * @param page - pdf page info\n     * @param pagePtr - pointer to pdf page\n     * @param textPagePtr - pointer to pdf text page\n     * @param startIndex - starting character index\n     * @param charCount - number of characters in the range\n     * @returns array of rectangles for highlighting the specified character range\n     *\n     * @private\n     */\n    getHighlightRects(page, pagePtr, textPagePtr, startIndex, charCount) {\n        const rectsCount = this.pdfiumModule.FPDFText_CountRects(textPagePtr, startIndex, charCount);\n        const highlightRects = [];\n        for (let i = 0; i < rectsCount; i++) {\n            const topPtr = this.malloc(8);\n            const leftPtr = this.malloc(8);\n            const rightPtr = this.malloc(8);\n            const bottomPtr = this.malloc(8);\n            const isSucceed = this.pdfiumModule.FPDFText_GetRect(textPagePtr, i, leftPtr, topPtr, rightPtr, bottomPtr);\n            if (!isSucceed) {\n                this.free(leftPtr);\n                this.free(topPtr);\n                this.free(rightPtr);\n                this.free(bottomPtr);\n                continue;\n            }\n            const left = this.pdfiumModule.pdfium.getValue(leftPtr, 'double');\n            const top = this.pdfiumModule.pdfium.getValue(topPtr, 'double');\n            const right = this.pdfiumModule.pdfium.getValue(rightPtr, 'double');\n            const bottom = this.pdfiumModule.pdfium.getValue(bottomPtr, 'double');\n            this.free(leftPtr);\n            this.free(topPtr);\n            this.free(rightPtr);\n            this.free(bottomPtr);\n            const deviceXPtr = this.malloc(4);\n            const deviceYPtr = this.malloc(4);\n            this.pdfiumModule.FPDF_PageToDevice(pagePtr, 0, 0, page.size.width, page.size.height, 0, left, top, deviceXPtr, deviceYPtr);\n            const x = this.pdfiumModule.pdfium.getValue(deviceXPtr, 'i32');\n            const y = this.pdfiumModule.pdfium.getValue(deviceYPtr, 'i32');\n            this.free(deviceXPtr);\n            this.free(deviceYPtr);\n            // Convert the bottom-right coordinates to width/height\n            const width = Math.ceil(Math.abs(right - left));\n            const height = Math.ceil(Math.abs(top - bottom));\n            highlightRects.push({\n                origin: { x, y },\n                size: { width, height },\n            });\n        }\n        return highlightRects;\n    }\n    /**\n     * Search for a keyword across all pages in the document\n     * Returns all search results throughout the entire document\n     *\n     * @param doc - Pdf document object\n     * @param keyword - Search keyword\n     * @param flags - Match flags for search\n     * @returns Promise of all search results in the document\n     *\n     * @public\n     */\n    searchAllPages(doc, keyword, flags = []) {\n        this.logger.debug(LOG_SOURCE, LOG_CATEGORY, 'searchAllPages', doc, keyword, flags);\n        this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `SearchAllPages`, 'Begin', doc.id);\n        const ctx = this.cache.getContext(doc.id);\n        if (!ctx) {\n            this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `SearchAllPages`, 'End', doc.id);\n            return PdfTaskHelper.resolve({ results: [], total: 0 });\n        }\n        const length = 2 * (keyword.length + 1);\n        const keywordPtr = this.malloc(length);\n        this.pdfiumModule.pdfium.stringToUTF16(keyword, keywordPtr, length);\n        const flag = flags.reduce((flag, currFlag) => {\n            return flag | currFlag;\n        }, MatchFlag.None);\n        const results = [];\n        // Search through all pages\n        const searchAllPagesTask = PdfTaskHelper.create();\n        // Execute search in a separate function to avoid issues with resolve parameter\n        const executeSearch = async () => {\n            for (let pageIndex = 0; pageIndex < doc.pageCount; pageIndex++) {\n                // Get all results for the current page efficiently (load page only once)\n                const pageResults = this.searchAllInPage(ctx, doc.pages[pageIndex], keywordPtr, flag);\n                results.push(...pageResults);\n            }\n            this.free(keywordPtr);\n            this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `SearchAllPages`, 'End', doc.id);\n            searchAllPagesTask.resolve({\n                results,\n                total: results.length,\n            });\n        };\n        // Start the search process\n        executeSearch().catch((error) => {\n            this.free(keywordPtr);\n            this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `SearchAllPages`, 'End', doc.id);\n            searchAllPagesTask.reject({\n                code: PdfErrorCode.Unknown,\n                message: `Error searching document: ${error}`,\n            });\n        });\n        return searchAllPagesTask;\n    }\n    /**\n     * Extract word-aligned context for a search hit.\n     *\n     * @param fullText      full UTF-16 page text (fetch this once per page!)\n     * @param start         index of 1st char that matched\n     * @param count         number of chars in the match\n     * @param windowChars   minimum context chars to keep left & right\n     */\n    buildContext(fullText, start, count, windowChars = 30) {\n        const WORD_BREAK = /[\\s\\u00A0.,;:!?()\\[\\]{}<>/\\\\\\-\"'`\"\\u2013\\u2014]/;\n        // Find the start of a word moving left\n        const findWordStart = (index) => {\n            while (index > 0 && !WORD_BREAK.test(fullText[index - 1]))\n                index--;\n            return index;\n        };\n        // Find the end of a word moving right\n        const findWordEnd = (index) => {\n            while (index < fullText.length && !WORD_BREAK.test(fullText[index]))\n                index++;\n            return index;\n        };\n        // Move left to build context\n        let left = start;\n        while (left > 0 && WORD_BREAK.test(fullText[left - 1]))\n            left--; // Skip blanks\n        let collected = 0;\n        while (left > 0 && collected < windowChars) {\n            left--;\n            if (!WORD_BREAK.test(fullText[left]))\n                collected++;\n        }\n        left = findWordStart(left);\n        // Move right to build context\n        let right = start + count;\n        while (right < fullText.length && WORD_BREAK.test(fullText[right]))\n            right++; // Skip blanks\n        collected = 0;\n        while (right < fullText.length && collected < windowChars) {\n            if (!WORD_BREAK.test(fullText[right]))\n                collected++;\n            right++;\n        }\n        right = findWordEnd(right);\n        // Compose the context\n        const before = fullText.slice(left, start).replace(/\\s+/g, ' ').trimStart();\n        const match = fullText.slice(start, start + count);\n        const after = fullText\n            .slice(start + count, right)\n            .replace(/\\s+/g, ' ')\n            .trimEnd();\n        return {\n            before: this.tidy(before),\n            match: this.tidy(match),\n            after: this.tidy(after),\n            truncatedLeft: left > 0,\n            truncatedRight: right < fullText.length,\n        };\n    }\n    /**\n     * Tidy the text to remove any non-printable characters and whitespace\n     * @param s - text to tidy\n     * @returns tidied text\n     *\n     * @private\n     */\n    tidy(s) {\n        return (s\n            /* 1  join words split by hyphen + U+FFFE + whitespace */\n            .replace(/-\\uFFFE\\s*/g, '')\n            /* 2  drop any remaining U+FFFE, soft-hyphen, zero-width chars */\n            .replace(/[\\uFFFE\\u00AD\\u200B\\u2060\\uFEFF]/g, '')\n            /* 3  collapse whitespace so we stay on one line */\n            .replace(/\\s+/g, ' '));\n    }\n    /**\n     * Search for all occurrences of a keyword on a single page\n     * This method efficiently loads the page only once and finds all matches\n     *\n     * @param docPtr - pointer to pdf document\n     * @param page - pdf page object\n     * @param pageIndex - index of the page\n     * @param keywordPtr - pointer to the search keyword\n     * @param flag - search flags\n     * @returns array of search results on this page\n     *\n     * @private\n     */\n    searchAllInPage(ctx, page, keywordPtr, flag) {\n        const pageIndex = page.index;\n        // Load the page and text page only once\n        const pageCtx = ctx.acquirePage(pageIndex);\n        const textPagePtr = pageCtx.getTextPage();\n        // Load the full text of the page once\n        const total = this.pdfiumModule.FPDFText_CountChars(textPagePtr);\n        const bufPtr = this.malloc(2 * (total + 1));\n        this.pdfiumModule.FPDFText_GetText(textPagePtr, 0, total, bufPtr);\n        const fullText = this.pdfiumModule.pdfium.UTF16ToString(bufPtr);\n        this.free(bufPtr);\n        const pageResults = [];\n        // Initialize search handle once for the page\n        const searchHandle = this.pdfiumModule.FPDFText_FindStart(textPagePtr, keywordPtr, flag, 0);\n        // Call FindNext repeatedly to get all matches on the page\n        while (this.pdfiumModule.FPDFText_FindNext(searchHandle)) {\n            const charIndex = this.pdfiumModule.FPDFText_GetSchResultIndex(searchHandle);\n            const charCount = this.pdfiumModule.FPDFText_GetSchCount(searchHandle);\n            const rects = this.getHighlightRects(page, pageCtx.pagePtr, textPagePtr, charIndex, charCount);\n            const context = this.buildContext(fullText, charIndex, charCount);\n            pageResults.push({\n                pageIndex,\n                charIndex,\n                charCount,\n                rects,\n                context,\n            });\n        }\n        // Close the search handle only once after finding all results\n        this.pdfiumModule.FPDFText_FindClose(searchHandle);\n        // Close the text page and page only once\n        pageCtx.release();\n        return pageResults;\n    }\n}\n\nasync function createPdfiumEngine(wasmUrl, logger) {\n    const response = await fetch(wasmUrl);\n    const wasmBinary = await response.arrayBuffer();\n    const wasmModule = await init({ wasmBinary });\n    return new PdfiumEngine(wasmModule, logger);\n}\n\nexport { createPdfiumEngine };\n//# sourceMappingURL=pdfium-direct-engine.js.map\n"],"names":["_scriptName","createPdfium","url","async","moduleArg","moduleRtn","readyPromiseResolve","readyPromiseReject","Module","readyPromise","Promise","resolve","reject","forEach","prop","Object","getOwnPropertyDescriptor","defineProperty","get","abort","set","ENVIRONMENT_IS_WEB","window","ENVIRONMENT_IS_WORKER","importScripts","process","versions","node","type","readAsync","readBinary","ENVIRONMENT_IS_SHELL","moduleOverrides","assign","thisProgram","scriptDirectory","Error","f","readbuffer","Uint8Array","data","read","assert","setTimeout","globalThis","clearTimeout","id","print","console","log","warn","error","printErr","self","location","href","document","currentScript","src","startsWith","substr","replace","lastIndexOf","xhr","XMLHttpRequest","open","responseType","send","response","isFileURI","fetch","credentials","then","ok","arrayBuffer","status","out","bind","err","legacyModuleProp","wasmMemory","wasmBinary","WebAssembly","HEAP8","HEAPU8","HEAP16","HEAPU16","HEAP32","HEAPU32","HEAPF32","HEAPF64","ABORT","condition","text","updateMemoryViews","b","buffer","Int8Array","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","checkStackCookie","max","_emscripten_stack_get_end","cookie1","cookie2","ptrToString","undefined","prototype","subarray","__ATPRERUN__","__ATINIT__","__ATPOSTRUN__","runtimeInitialized","addOnPreRun","cb","unshift","addOnPostRun","Math","imul","fround","clz32","trunc","runDependencies","runDependencyWatcher","dependenciesFulfilled","runDependencyTracking","getUniqueRunDependency","orig","random","addRunDependency","setInterval","clearInterval","shown","dep","removeRunDependency","callback","what","e","RuntimeError","wasmBinaryFile","tempDouble","tempI64","isDataURI","filename","createExportWrapper","name","nargs","args","wasmExports","length","findWasmBinary","path","URL","getBinarySync","file","instantiateArrayBuffer","binaryFile","imports","receiver","getBinaryPromise","binary","instantiate","reason","h16","h8","newName","incoming","configurable","isExportedByForceFilesystem","hookGlobalSymbolAccess","sym","func","missingGlobal","msg","warnOnce","unexportedRuntimeSymbol","callRuntimeCallbacks","callbacks","ptr","toString","padStart","stackRestore","val","__emscripten_stack_restore","stackSave","_emscripten_stack_get_current","UTF8Decoder","TextDecoder","UTF8ArrayToString","heapOrArray","idx","maxBytesToRead","NaN","endIdx","endPtr","decode","str","u0","u1","u2","String","fromCharCode","ch","UTF8ToString","syscallGetVarargI","SYSCALLS","varargs","ret","syscallGetVarargP","PATH","isAbs","charAt","splitPath","exec","slice","normalizeArray","parts","allowAboveRoot","up","i","last","splice","normalize","isAbsolute","trailingSlash","split","filter","p","join","dirname","result","root","dir","basename","lastSlash","paths","join2","l","r","randomFill","view","initRandomFill","crypto","getRandomValues","PATH_FS","resolvedPath","resolvedAbsolute","FS","cwd","TypeError","relative","from","to","trim","arr","start","end","fromParts","toParts","min","samePartsLength","outputParts","push","concat","FS_stdin_getChar_buffer","lengthBytesUTF8","len","c","charCodeAt","stringToUTF8Array","heap","outIdx","maxBytesToWrite","startIdx","u","intArrayFromString","stringy","dontAddNull","u8array","Array","numBytesWritten","wasmTable","functionsInTableMap","TTY","ttys","init","shutdown","register","dev","ops","input","output","registerDevice","stream_ops","stream","tty","rdev","ErrnoError","seekable","close","fsync","offset","pos","get_char","bytesRead","timestamp","Date","now","write","put_char","default_tty_ops","FS_stdin_getChar","prompt","readline","shift","ioctl_tcgets","c_iflag","c_oflag","c_cflag","c_lflag","c_cc","ioctl_tcsets","optional_actions","ioctl_tiocgwinsz","default_tty1_ops","alignMemory","size","alignment","ceil","mmapAlloc","_emscripten_builtin_memalign","zeroMemory","address","fill","MEMFS","ops_table","mount","createNode","parent","mode","isBlkdev","isFIFO","getattr","node_ops","setattr","lookup","mknod","rename","unlink","rmdir","readdir","symlink","llseek","allocate","mmap","msync","link","readlink","chrdev","chrdev_stream_ops","isDir","contents","isFile","usedBytes","isLink","isChrdev","getFileDataAsTypedArray","expandFileStorage","newCapacity","prevCapacity","oldContents","resizeFileStorage","newSize","attr","ino","nlink","uid","gid","atime","mtime","ctime","blksize","blocks","genericErrors","old_node","new_dir","new_name","new_node","lookupNode","entries","key","keys","newname","oldpath","position","canOwn","ArrayBuffer","whence","prot","flags","allocated","call","byteOffset","mmapFlags","preloadPlugins","FS_getMode","canRead","canWrite","ERRNO_CODES","EPERM","ENOENT","ESRCH","EINTR","EIO","ENXIO","E2BIG","ENOEXEC","EBADF","ECHILD","EAGAIN","EWOULDBLOCK","ENOMEM","EACCES","EFAULT","ENOTBLK","EBUSY","EEXIST","EXDEV","ENODEV","ENOTDIR","EISDIR","EINVAL","ENFILE","EMFILE","ENOTTY","ETXTBSY","EFBIG","ENOSPC","ESPIPE","EROFS","EMLINK","EPIPE","EDOM","ERANGE","ENOMSG","EIDRM","ECHRNG","EL2NSYNC","EL3HLT","EL3RST","ELNRNG","EUNATCH","ENOCSI","EL2HLT","EDEADLK","ENOLCK","EBADE","EBADR","EXFULL","ENOANO","EBADRQC","EBADSLT","EDEADLOCK","EBFONT","ENOSTR","ENODATA","ETIME","ENOSR","ENONET","ENOPKG","EREMOTE","ENOLINK","EADV","ESRMNT","ECOMM","EPROTO","EMULTIHOP","EDOTDOT","EBADMSG","ENOTUNIQ","EBADFD","EREMCHG","ELIBACC","ELIBBAD","ELIBSCN","ELIBMAX","ELIBEXEC","ENOSYS","ENOTEMPTY","ENAMETOOLONG","ELOOP","EOPNOTSUPP","EPFNOSUPPORT","ECONNRESET","ENOBUFS","EAFNOSUPPORT","EPROTOTYPE","ENOTSOCK","ENOPROTOOPT","ESHUTDOWN","ECONNREFUSED","EADDRINUSE","ECONNABORTED","ENETUNREACH","ENETDOWN","ETIMEDOUT","EHOSTDOWN","EHOSTUNREACH","EINPROGRESS","EALREADY","EDESTADDRREQ","EMSGSIZE","EPROTONOSUPPORT","ESOCKTNOSUPPORT","EADDRNOTAVAIL","ENETRESET","EISCONN","ENOTCONN","ETOOMANYREFS","EUSERS","EDQUOT","ESTALE","ENOTSUP","ENOMEDIUM","EILSEQ","EOVERFLOW","ECANCELED","ENOTRECOVERABLE","EOWNERDEAD","ESTRPIPE","mounts","devices","streams","nextInode","nameTable","currentPath","initialized","ignorePermissions","constructor","errno","super","_strerror","strError","this","code","filesystems","syncFSRequests","readFiles","FSStream","shared","object","isRead","isWrite","isAppend","FSNode","mounted","readMode","writeMode","isFolder","isDevice","lookupPath","opts","follow_mount","recurse_count","current","current_path","islast","isMountpoint","follow","count","getPath","isRoot","mountpoint","hashName","parentid","hash","hashAddNode","name_next","hashRemoveNode","errCode","mayLookup","nodeName","destroyNode","isSocket","flagsToPermissionString","flag","perms","nodePermissions","includes","mayCreate","mayDelete","isdir","mayOpen","MAX_OPEN_FDS","nextfd","fd","getStreamChecked","getStream","createStream","closeStream","dupStream","origStream","dup","device","getDevice","major","minor","makedev","ma","mi","getMounts","check","m","pop","syncfs","populate","completed","doCallback","done","errored","pseudo","mountRoot","unmount","next","indexOf","create","mkdir","mkdirTree","dirs","d","mkdev","newpath","old_path","new_path","old_dir","old_dirname","new_dirname","old_name","stat","dontFollow","lstat","chmod","lchmod","fchmod","chown","lchown","fchown","truncate","ftruncate","utime","w","a","FS_modeStringToFlags","created","ungotten","isClosed","getdents","seeking","bytesWritten","ioctl","cmd","arg","readFile","encoding","buf","writeFile","actualNumBytes","isView","byteLength","chdir","createDefaultDirectories","createDefaultDevices","randomBuffer","randomLeft","randomByte","createDevice","createSpecialDirectories","proc_self","createStandardStreams","stdin","stdout","stderr","staticInit","stack","quit","_fflush","findObject","dontResolveLastLink","analyzePath","exists","parentExists","parentPath","parentObject","createPath","reverse","part","createFile","properties","createDataFile","forceLoadFile","obj","createLazyFile","LazyUint8Array","lengthKnown","chunks","chunkOffset","chunkSize","chunkNum","getter","setDataGetter","cacheLength","header","datalength","Number","getResponseHeader","hasByteServing","usesGzip","lazyArray","doXHR","setRequestHeader","overrideMimeType","responseText","_length","_chunkSize","defineProperties","writeChunks","fn","absolutePath","createFolder","createLink","joinPath","standardizePath","DEFAULT_POLLMASK","calculateAt","dirfd","allowEmpty","getStreamFromFD","doStat","abs","floor","getTime","doMsync","addr","getStr","convertI32PairToI53Checked","lo","hi","stringToUTF8","outPtr","MONTH_DAYS_LEAP_CUMULATIVE","MONTH_DAYS_REGULAR_CUMULATIVE","growMemory","pages","grow","ENV","getEnvStrings","strings","env","USER","LOGNAME","PWD","HOME","LANG","navigator","languages","_","x","wasmTableMirror","getWasmTableEntry","funcPtr","UTF16Decoder","uleb128Encode","n","target","convertJsFunctionToWasm","sig","Function","typeNames","j","parameters","results","sigToWasmTypes","typeSectionBody","generateFuncType","sigRet","sigParam","typeCodes","bytes","module","Instance","exports","getFunctionAddress","WeakMap","updateTableMap","item","freeTableIndexes","setWasmTableEntry","stackAlloc","sz","__emscripten_stack_alloc","ccall","ident","returnType","argTypes","toC","string","stringToUTF8OnStack","array","getCFunc","cArgs","converter","Boolean","convertReturnValue","onDone","createPreloadedFile","FS_createPreloadedFile","onload","onerror","dontCreateFile","preFinish","fullname","processData","byteArray","finish","FS_createDataFile","fileData","FS_handledByPreloadPlugin","Browser","handled","plugin","asyncLoad","noRunDep","wasmImports","__assert_fail","___assert_fail","line","__syscall_fcntl64","__syscall_fstat64","__syscall_ftruncate64","length_low","length_high","isNaN","__syscall_getdents64","dirp","struct_size","off","child","__syscall_ioctl","op","termios","argp","winsize","__syscall_lstat64","__syscall_newfstatat","nofollow","__syscall_openat","__syscall_rmdir","__syscall_stat64","__syscall_unlinkat","_abort_js","__abort_js","_emscripten_memcpy_js","__emscripten_memcpy_js","dest","num","copyWithin","_emscripten_throw_longjmp","__emscripten_throw_longjmp","Infinity","_gmtime_js","time_low","time_high","tmPtr","time","date","getUTCSeconds","getUTCMinutes","getUTCHours","getUTCDate","getUTCMonth","getUTCFullYear","getUTCDay","UTC","yday","_localtime_js","getSeconds","getMinutes","getHours","getDate","getMonth","getFullYear","getDay","year","ydayFromDate","getTimezoneOffset","summerOffset","winterOffset","dst","_tzset_js","__tzset_js","timezone","daylight","std_name","dst_name","currentYear","winter","summer","stdTimezoneOffset","extractZone","timezoneOffset","sign","absOffset","winterName","summerName","emscripten_date_now","_emscripten_date_now","emscripten_resize_heap","requestedSize","oldSize","maxHeapSize","cutDown","overGrownHeapSize","environ_get","_environ_get","__environ","environ_buf","bufSize","stringToAscii","environ_sizes_get","_environ_sizes_get","penviron_count","penviron_buf_size","fd_close","fd_read","iov","iovcnt","pnum","doReadv","curr","fd_seek","offset_low","offset_high","newOffset","fd_sync","fd_write","doWritev","invoke_ii","index","a1","sp","_setThrew","invoke_iii","a2","invoke_iiii","a3","invoke_iiiii","a4","invoke_v","invoke_viii","invoke_viiii","info","wasi_snapshot_preview1","receiveInstance","instance","trueModule","instantiateStreaming","catch","createWasm","calledRun","calledPrerun","_emscripten_stack_init","a0","stackCheckInit","run","preRuns","doRun","postRuns","postRun","cwrap","addFunction","rtn","getEmptyTableSlot","RangeError","wrapped","delete","value","endsWith","UTF16ToString","maxIdx","codeUnit","stringToUTF16","startPtr","numCharsToWrite","librarySymbol","runCaller","readString","wasmModule","readChars","parseChars","defaultLength","malloc","actualLength","free","readArrayBuffer","bufferSize","bufferPtr","DataView","setInt8","getValue"],"mappings":"iOAAA,IACMA,EADFC,GACED,cAA0BE,IAEvBC,eAAgBC,EAAY,IACjC,IAAIC,EAmBAC,EAAqBC,EAHrBC,EAASJ,EAITK,EAAe,IAAIC,QAAQ,CAACC,EAASC,KACvCN,EAAsBK,EACtBJ,EAAqBK,IAEvB,CACE,0BACA,gCACA,yCACA,0BACA,kCACA,uCACA,6BACA,4BACA,sBACA,uBACA,qCACA,4BACA,4BACA,sBACA,uBACA,gBACA,gBACA,0BACA,2BACA,6BACA,sBACA,yBACA,wBACA,uBACA,wBACA,wBACA,wBACA,0BACA,eACA,gBACA,kBACA,gBACA,6BACA,sBACA,oBACA,oBACA,qBACA,sBACA,oBACA,aACA,gCACA,yBACA,sBACA,wBACA,yBACA,aACA,yBACA,sBACA,kBACA,qBACA,8BACA,wBACA,uBACA,0BACA,wBACA,uBACA,qBACA,4CACA,gBACA,kCACA,iCACA,yBACA,8BACA,8BACA,0BACA,8BACA,0BACA,uBACA,oBACA,qBACA,oBACA,qBACA,2BACA,uBACA,2BACA,qBACA,sBACA,uBACA,qBACA,2BACA,4BACA,qBACA,sBACA,mCACA,0BACA,2BACA,uBACA,4BACA,0BACA,yBACA,0BACA,oBACA,2BACA,oBACA,8BACA,2BACA,qBACA,wBACA,0BACA,iBACA,gBACA,kBACA,iCACA,2BACA,qBACA,iCACA,yBACA,4BACA,yBACA,+BACA,8CACA,mCACA,mBACA,wBACA,mCACA,mCACA,yBACA,0BACA,yCACA,wCACA,2CACA,2CACA,oCACA,mCACA,0CACA,0CACA,mCACA,oCACA,oCACA,oCACA,iCACA,0CACA,wCACA,sCACA,8CACA,4BACA,8BACA,yCACA,gDACA,8CACA,iCACA,gCACA,yCACA,+BACA,8BACA,yBACA,iCACA,mCACA,8BACA,4BACA,0BACA,+BACA,oCACA,yCACA,2CACA,kCACA,sBACA,0BACA,sBACA,yBACA,+BACA,0BACA,oCACA,0BACA,mCACA,mBACA,iCACA,uBACA,sBACA,+BACA,sBACA,kCACA,uCACA,0BACA,yBACA,+CACA,iCACA,iCACA,uCACA,iCACA,qCACA,+BACA,8BACA,8BACA,+BACA,6BACA,4BACA,qBACA,qBACA,4BACA,4BACA,uBACA,4BACA,4BACA,4BACA,qBACA,4BACA,wBACA,0BACA,yBACA,iCACA,oBACA,uBACA,sCACA,8BACA,gCACA,2BACA,0BACA,mBACA,iCACA,uBACA,sBACA,sBACA,kCACA,0BACA,+BACA,qBACA,4BACA,oBACA,0BACA,0BACA,0BACA,iCACA,6BACA,+BACA,yBACA,0BACA,iCACA,oBACA,qBACA,yBACA,6BACA,wBACA,yBACA,0BACA,yBACA,qBACA,uBACA,sBACA,uBACA,wBACA,wBACA,wBACA,wBACA,uBACA,qBACA,0BACA,yBACA,wBACA,8BACA,+BACA,yBACA,wBACA,2BACA,2BACA,kCACA,+BACA,6BACA,8BACA,oBACA,yBACA,iCACA,4BACA,mCACA,yBACA,8BACA,+BACA,oCACA,uBACA,mCACA,kBACA,sBACA,4BACA,uBACA,0BACA,qBACA,wBACA,yBACA,0BACA,0BACA,2BACA,sBACA,4BACA,yBACA,4BACA,oCACA,qCACA,0BACA,yCACA,oCACA,gCACA,+BACA,oCACA,iCACA,kCACA,kCACA,6BACA,mCACA,0BACA,0BACA,gCACA,kCACA,0BACA,4BACA,uBACA,0BACA,sBACA,sBACA,qBACA,yBACA,oBACA,2BACA,iCACA,0BACA,oBACA,yBACA,mBACA,yBACA,uBACA,yBACA,wBACA,mBACA,oBACA,mCACA,4BACA,qBACA,0BACA,0BACA,sBACA,wBACA,uBACA,oCACA,wBACA,sBACA,gCACA,wBACA,iCACA,uBACA,gCACA,4BACA,2BACA,yBACA,gCACA,gBACA,wBACA,yBACA,sBACA,wBACA,uBACA,wBACA,wBACA,uBACA,4BACA,8BACA,uBACA,0BACA,6BACA,6BACA,6BACA,uBACA,yBACA,2BACA,4BACA,4BACA,4BACA,4BACA,2BACA,0BACA,2BACA,uBACA,kCACA,yBACA,gCACA,8BACA,8BACA,uBACA,+BACA,2BACA,0BACA,0BACA,4BACA,4BACA,4BACA,4BACA,2BACA,0BACA,2BACA,yBACA,8BACA,8BACA,yBACA,iCACA,0BACA,+BACA,2BACA,qCACA,oCACA,+BACA,uCACA,qCACA,+BACA,gCACA,+BACA,kCACA,qBACA,kBACA,0BACA,wBACA,2BACA,mBACA,mBACA,wBACA,4BACA,4BACA,2BACA,iCACA,gCACA,wCACA,8BACA,iCACA,4BACA,sBACA,uBACA,uBACA,sBACA,qBACA,qBACA,sBACA,2BACA,yBACA,uBACA,8BACA,sCACA,0BACA,yBACA,wBACA,wBACA,0BACA,4BACA,sBACA,oBACA,wBACA,8BACA,2BACA,oBACA,sCACA,0BACA,uBACA,+BACA,wBACA,qBACA,6BACA,qBACA,qBACA,6BACA,yBACA,oBACA,uBACA,2BACA,iCACA,uBACA,iCACA,iCACA,6BACA,+BACA,qCACA,+BACA,+BACA,kBACA,qCACA,4BACA,8BACA,wBACA,UACA,QACA,UACA,6BACA,wBACAC,QAASC,IACJC,OAAOC,yBAAyBP,EAAcK,IACjDC,OAAOE,eAAeR,EAAcK,EAAM,CACxCI,IAAKA,IACHC,EACE,mBACEL,EACA,iJAENM,IAAKA,IACHD,EACE,mBACEL,EACA,qJAUZ,IAAIO,EAAsC,iBAAVC,OAC5BC,EAAgD,mBAAjBC,cAIf,iBAAXC,SACoB,iBAApBA,QAAQC,UACiB,iBAAzBD,QAAQC,SAASC,MACxBF,QAAQG,KACV,IA2CIC,EAAWC,EA3CXC,GACDV,IAA+CE,EAwB9CS,EAAkBjB,OAAOkB,OAAO,CAAE,EAAEzB,GAGpC0B,EAAc,iBAMdC,EAAkB,GAyEf,GAAIJ,EAAsB,CAC/B,GAEmB,iBAAVT,QACiB,mBAAjBE,cAEP,MAAM,IAAIY,MACR,0LAGJN,EAAcO,IACZ,GAAyB,mBAAdC,WACT,OAAO,IAAIC,WAAWD,WAAWD,IAEnC,IAAIG,EAAOC,KAAKJ,EAAG,UAEnB,OADAK,EAAsB,iBAARF,GACPA,GAGTX,EAAaQ,GACJ,IAAI3B,QAAQ,CAACC,EAASC,KAC3B+B,WAAW,IAAMhC,EAAQmB,EAAWO,OAIxCO,WAAWC,eAAkBC,MAG7BF,WAAWD,aAAgBN,GAAmB,mBAALA,EAAkBA,IAAMlB,IA8B7C,oBAAT4B,QAETH,WAAWI,UAAoC,GAC/CA,QAAQC,IAA8DF,MACtEC,QAAQE,KAAOF,QAAQG,MACrBP,WAAWQ,UAAYL,MAGjC,KAAW,KAAI1B,IAAsBE,EA4D/B,MAAM,IAAIa,MAAM,+BA7BhB,GA3BIb,EAEFY,EAAkBkB,KAAKC,SAASC,KACJ,oBAAZC,UAA2BA,SAASC,gBAEpDtB,EAAkBqB,SAASC,cAAcC,KAIvC1D,IACFmC,EAAkBnC,GASlBmC,EADEA,EAAgBwB,WAAW,SACX,GAEAxB,EAAgByB,OAChC,EACAzB,EAAgB0B,QAAQ,SAAU,IAAIC,YAAY,KAAO,GAItC,iBAAVxC,QAA8C,mBAAjBE,cACxC,MAAM,IAAIY,MACR,0LAKEb,IACFO,EAAc5B,IACZ,IAAI6D,EAAM,IAAIC,eAId,OAHAD,EAAIE,KAAK,MAAO/D,GAAK,GACrB6D,EAAIG,aAAe,cACnBH,EAAII,KAAK,MACF,IAAI5B,WAAuCwB,EAAIK,YAI1DvC,EAAa3B,IACXwC,GAAQ2B,EAAUnE,GAAM,6CACjBoE,MAAMpE,EAAK,CAAEqE,YAAa,gBAAiBC,KAAMJ,GAClDA,EAASK,GACJL,EAASM,cAEXhE,QAAQE,OAAO,IAAIwB,MAAMgC,EAASO,OAAS,MAAQP,EAASlE,OAO/E,CAEI,IA+oB2BY,EA/oBvB8D,EAAMpE,EAAc,OAAKwC,QAAQC,IAAI4B,KAAK7B,SAC1C8B,EAAMtE,EAAiB,UAAKwC,QAAQG,MAAM0B,KAAK7B,SAGnDjC,OAAOkB,OAAOzB,EAAQwB,GAGtBA,EAAkB,KAwoBSlB,EAulIP,gBAtlIdC,OAAOC,yBAAyBR,EAAQM,IAC1CK,EACE,YAAYL,0BAA6BA,8CAnoB3CN,EAAkB,WAAgBA,EAAkB,UACxDuE,GAAiB,YAAa,cAE1BvE,EAAoB,cAAG0B,EAAc1B,EAAoB,aAC7DuE,GAAiB,cAAe,eAIhCrC,OACiD,IAAxClC,EAAmC,2BAC1C,uFAEFkC,OAC2C,IAAlClC,EAA6B,qBACpC,iFAEFkC,OAC6C,IAApClC,EAA+B,uBACtC,mFAEFkC,OAC2C,IAAlClC,EAA6B,qBACpC,iFAEFkC,OAAgC,IAAlBlC,EAAa,KAAkB,kCAC7CkC,OACgC,IAAvBlC,EAAkB,UACzB,gEAEFkC,OACiC,IAAxBlC,EAAmB,WAC1B,kEAEFkC,OACqC,IAA5BlC,EAAuB,eAC9B,uFAEFkC,OACmC,IAA1BlC,EAAqB,aAC5B,8DAEFuE,GAAiB,MAAO,eACxBA,GAAiB,YAAa,aAC9BA,GAAiB,aAAc,cAC/BA,GAAiB,iBAAkB,kBAwBnC,IASIC,EATAC,EAAazE,EAAmB,WACpCuE,GAAiB,aAAc,cAEL,iBAAfG,aACTJ,EAAI,mCAaN,IAyBEK,EAEAC,EAEAC,EAEAC,EAEAC,EAEAC,EAEAC,EAEAC,EAvCEC,GAAQ,EAYZ,SAASjD,EAAOkD,EAAWC,GACpBD,GACHzE,EAAM,oBAAsB0E,EAAO,KAAOA,EAAO,IAEzD,CA0BI,SAASC,IACP,IAAIC,EAAIf,EAAWgB,OACnBxF,EAAc,MAAI2E,EAAQ,IAAIc,UAAUF,GACxCvF,EAAe,OAAI6E,EAAS,IAAIa,WAAWH,GAC3CvF,EAAe,OAAI4E,EAAS,IAAI7C,WAAWwD,GAC3CvF,EAAgB,QAAI8E,EAAU,IAAIa,YAAYJ,GAC9CvF,EAAe,OAAI+E,EAAS,IAAIa,WAAWL,GAC3CvF,EAAgB,QAAIgF,EAAU,IAAIa,YAAYN,GAC9CvF,EAAgB,QAAIiF,EAAU,IAAIa,aAAaP,GAC/CvF,EAAgB,QAAIkF,EAAU,IAAIa,aAAaR,EACrD,CA8CI,SAASS,IACP,IAAIb,EAAJ,CACA,IAAIc,EAAMC,KAEC,GAAPD,IACFA,GAAO,GAET,IAAIE,EAAUnB,EAAQiB,GAAO,GACzBG,EAAUpB,EAASiB,EAAM,GAAM,GACpB,UAAXE,GAAoC,YAAXC,GAC3BzF,EACE,wDAAwD0F,GAAYJ,kEAAoEI,GAAYD,MAAYC,GAAYF,MAIzJ,YAAnBnB,EAAQ,IACVrE,EAAM,oFAfG,CAiBjB,CA7DIuB,GACGlC,EAAmB,WACpB,8EAGFkC,EACuB,oBAAd0D,YACmB,oBAAjBG,cAC0BO,MAAjCV,WAAWW,UAAUC,UACOF,MAA5BV,WAAWW,UAAU3F,IACvB,uDAIFsB,GACGlC,EAAmB,WACpB,wFAEFkC,GACGlC,EAAuB,eACxB,oGA2CF,IAAIyG,EAAe,GACfC,EAAa,GAEbC,EAAgB,GAEhBC,GAAqB,EAoCzB,SAASC,EAAYC,GACnBL,EAAaM,QAAQD,EAC3B,CAQI,SAASE,EAAaF,GACpBH,EAAcI,QAAQD,EAC5B,CAWI5E,EACE+E,KAAKC,KACL,+HAEFhF,EACE+E,KAAKE,OACL,iIAEFjF,EACE+E,KAAKG,MACL,gIAEFlF,EACE+E,KAAKI,MACL,gIAUF,IAAIC,EAAkB,EAClBC,EAAuB,KACvBC,EAAwB,KACxBC,EAAwB,CAAA,EAE5B,SAASC,EAAuBpF,GAE9B,IADA,IAAIqF,EAAOrF,IACD,CACR,IAAKmF,EAAsBnF,GAAK,OAAOA,EACvCA,EAAKqF,EAAOV,KAAKW,QACzB,CACA,CAEI,SAASC,EAAiBvF,GACxBgF,IAEAtH,EAA+B,yBAAIsH,GAE/BhF,GACFJ,GAAQuF,EAAsBnF,IAC9BmF,EAAsBnF,GAAM,EACC,OAAzBiF,GAAuD,oBAAfO,cAE1CP,EAAuBO,YAAY,KACjC,GAAI3C,EAGF,OAFA4C,cAAcR,QACdA,EAAuB,MAGzB,IAAIS,GAAQ,EACZ,IAAK,IAAIC,KAAOR,EACTO,IACHA,GAAQ,EACR1D,EAAI,uCAENA,EAAI,eAAe2D,KAEjBD,GACF1D,EAAI,kBAEL,OAGLA,EAAI,2CAEZ,CAEI,SAAS4D,EAAoB5F,GAW3B,GAVAgF,IAEAtH,EAA+B,yBAAIsH,GAE/BhF,GACFJ,EAAOuF,EAAsBnF,WACtBmF,EAAsBnF,IAE7BgC,EAAI,8CAEiB,GAAnBgD,IAC2B,OAAzBC,IACFQ,cAAcR,GACdA,EAAuB,MAErBC,GAAuB,CACzB,IAAIW,EAAWX,EACfA,EAAwB,KACxBW,GACV,CAEA,CAGI,SAASxH,EAAMyH,GACbpI,EAAgB,UAAIoI,GAKpB9D,EAHA8D,EAAO,WAAaA,EAAO,KAK3BjD,GAAQ,EAgBR,IAAIkD,EAAI,IAAI3D,YAAY4D,aAAaF,GAMrC,MAJArI,EAAmBsI,GAIbA,CACZ,CAMI,IA8CIE,EAiKAC,EACAC,EA1MAC,EAAaC,GAAaA,EAASxF,WANnB,yCAYhBU,EAAa8E,GAAaA,EAASxF,WAAW,WAElD,SAASyF,EAAoBC,EAAMC,GACjC,MAAO,IAAIC,KACT7G,EACE0E,EACA,qBAAqBiC,4CAEvB,IAAIhH,EAAImH,GAAYH,GAOpB,OANA3G,EAAOL,EAAG,8BAA8BgH,iBAExC3G,EACE6G,EAAKE,QAAUH,EACf,qBAAqBD,mBAAsBE,EAAKE,2BAA2BH,KAEtEjH,KAAKkH,GAEpB,CAII,SAASG,IACP,GAAIlJ,EAAmB,WAAG,CACxB,IAAI6B,EAAI,cACR,OAAK6G,EAAU7G,GAGRA,GA/oBSsH,EA6oBItH,EA5oBlB7B,EAAmB,WACdA,EAAmB,WAAEmJ,EAAMxH,GAE7BA,EAAkBwH,EA4oB/B,CAhpBI,IAAoBA,EAipBlB,OAAI5H,EAA6B,cAE1B,IAAI6H,IAAI,0BAA2B1J,KAAKqD,IACrD,CAII,SAASsG,EAAcC,GACrB,GAAIA,GAAQf,GAAkB9D,EAC5B,OAAO,IAAI1C,WAAW0C,GAExB,GAAInD,EACF,OAAOA,EAAWgI,GAEpB,KAAM,iDACZ,CAiBI,SAASC,GAAuBC,EAAYC,EAASC,GACnD,OAhBF,SAA0BF,GAExB,OAAK/E,EAUEvE,QAAQC,UAAU6D,KAAK,IAAMqF,EAAcG,IARzCnI,EAAUmI,GAAYxF,KAC1BJ,GAAa,IAAI7B,WAAuC6B,GAEzD,IAAMyF,EAAcG,GAM9B,CAGaG,CAAiBH,GACrBxF,KAAM4F,GACElF,YAAYmF,YAAYD,EAAQH,IAExCzF,KAAK0F,EAAWI,IACfxF,EAAI,0CAA0CwF,KAG1CjG,EAAU0E,IACZjE,EACE,qCAAqCiE,mMAGzC5H,EAAMmJ,IAEhB,CAmII,GARA,MACE,IAAIC,EAAM,IAAIrE,WAAW,GACrBsE,EAAK,IAAIvE,UAAUsE,EAAIvE,QAE3B,GADAuE,EAAI,GAAK,MACK,MAAVC,EAAG,IAAyB,KAAVA,EAAG,GACvB,KAAM,mGACT,EAND,GAQIhK,EAAoB,YACtB,MAAM,IAAI4B,MACR,oKAIJ,SAAS2C,GAAiBjE,EAAM2J,EAASC,GAAW,GAC7C3J,OAAOC,yBAAyBR,EAAQM,IAC3CC,OAAOE,eAAeT,EAAQM,EAAM,CAClC6J,cAAc,EACdzJ,GAAAA,GAIEC,EAAM,YAAYL,8BAAiC2J,OAHvCC,EACR,kIACA,IAEhB,GAGA,CAWI,SAASE,GAA4BvB,GACnC,MACW,kBAATA,GACS,sBAATA,GACS,2BAATA,GACS,cAATA,GACS,qBAATA,GAES,sBAATA,GACS,oBAATA,GACS,wBAATA,CAER,CAOI,SAASwB,GAAuBC,EAAKC,GACV,oBAAdnI,YAA8B7B,OAAOC,yBAAyB4B,WAAYkI,IACnF/J,OAAOE,eAAe2B,WAAYkI,EAAK,CACrCH,cAAc,EACdzJ,GAAAA,GACE6J,GAEZ,GAGA,CAEI,SAASC,GAAcF,EAAKG,GAC1BJ,GAAuBC,EAAK,KAC1BI,GAAS,KAAKJ,4CAA8CG,MAEpE,CA8BI,SAASE,GAAwBL,GAC1B/J,OAAOC,yBAAyBR,EAAQsK,IAC3C/J,OAAOE,eAAeT,EAAQsK,EAAK,CACjCH,cAAc,EACdzJ,GAAAA,GACE,IAAI+J,EAAM,IAAIH,mFACVF,GAA4BE,KAC9BG,GACE,4FAEJ9J,EAAM8J,EAClB,GAGA,CA1CID,GAAc,SAAU,gDACxBA,GAAc,MAAO,kCA4DrB,IAAII,GAAwBC,IAE1BA,EAAUxK,QAASwB,GAAMA,EAAE7B,KA+BTA,EAAsB,cAE1C,IAAIqG,GAAeyE,IACjB5I,EAAsB,iBAAR4I,GAGP,MADPA,KAAS,GACSC,SAAS,IAAIC,SAAS,EAAG,MAuCzCC,GAAgBC,GAAQC,GAA2BD,GAEnDE,GAAYA,IAAMC,KAElBX,GAAYrF,IACdqF,GAAS1C,QAAU,GACd0C,GAAS1C,MAAM3C,KAClBqF,GAAS1C,MAAM3C,GAAQ,EAEvBf,EAAIe,KAIJiG,GAAoC,oBAAfC,YAA6B,IAAIA,iBAAgBjF,EAWtEkF,GAAoBA,CAACC,EAAaC,EAAM,EAAGC,EAAiBC,OAQ9D,IAPA,IAAIC,EAASH,EAAMC,EACfG,EAASJ,EAMND,EAAYK,MAAaA,GAAUD,MAAWC,EAErD,GAAIA,EAASJ,EAAM,IAAMD,EAAYjG,QAAU8F,GAC7C,OAAOA,GAAYS,OAAON,EAAYjF,SAASkF,EAAKI,IAKtD,IAHA,IAAIE,EAAM,GAGHN,EAAMI,GAAQ,CAKnB,IAAIG,EAAKR,EAAYC,KACrB,GAAW,IAALO,EAAN,CAIA,IAAIC,EAA0B,GAArBT,EAAYC,KACrB,GAAmB,MAAT,IAALO,GAAL,CAIA,IAAIE,EAA0B,GAArBV,EAAYC,KAarB,GAZmB,MAAT,IAALO,GACHA,GAAY,GAALA,IAAY,GAAOC,GAAM,EAAKC,GAElB,MAAT,IAALF,IACHvB,GACE,8BACErE,GAAY4F,GACZ,iFAENA,GAAY,EAALA,IAAW,GAAOC,GAAM,GAAOC,GAAM,EAA2B,GAArBV,EAAYC,MAG5DO,EAAK,MACPD,GAAOI,OAAOC,aAAaJ,OACtB,CACL,IAAIK,EAAKL,EAAK,MACdD,GAAOI,OAAOC,aAAa,MAAUC,GAAM,GAAK,MAAe,KAALA,EACpE,CAnBA,MAFUN,GAAOI,OAAOC,cAAoB,GAALJ,IAAY,EAAKC,EAHxD,MAFUF,GAAOI,OAAOC,aAAaJ,EA2BrC,CACM,OAAOD,GAkBLO,GAAeA,CAACzB,EAAKa,KACvBzJ,EAAqB,iBAAP4I,EAAiB,6CAA6CA,MACrEA,EAAMU,GAAkB5G,EAAQkG,EAAKa,GAAkB,IAchE,SAASa,KACPtK,EAA2BoE,MAApBmG,GAASC,SAEhB,IAAIC,EAAM5H,GAAQ0H,GAASC,SAAW,GAEtC,OADAD,GAASC,SAAW,EACbC,CACb,CACI,IAAIC,GAAoBJ,GAEpBK,GAAO,CACTC,MAAQ3D,GAA4B,MAAnBA,EAAK4D,OAAO,GAC7BC,UAAYrE,GACQ,gEACCsE,KAAKtE,GAAUuE,MAAM,GAE1CC,eAAgBA,CAACC,EAAOC,KAGtB,IADA,IAAIC,EAAK,EACAC,EAAIH,EAAMnE,OAAS,EAAGsE,GAAK,EAAGA,IAAK,CAC1C,IAAIC,EAAOJ,EAAMG,GACJ,MAATC,EACFJ,EAAMK,OAAOF,EAAG,GACE,OAATC,GACTJ,EAAMK,OAAOF,EAAG,GAChBD,KACSA,IACTF,EAAMK,OAAOF,EAAG,GAChBD,IAEZ,CAEQ,GAAID,EACF,KAAOC,EAAIA,IACTF,EAAMrG,QAAQ,MAGlB,OAAOqG,GAETM,UAAYvE,IACV,IAAIwE,EAAad,GAAKC,MAAM3D,GAC1ByE,EAAoC,MAApBzE,EAAK/F,QAAQ,GAY/B,OAVA+F,EAAO0D,GAAKM,eACVhE,EAAK0E,MAAM,KAAKC,OAAQC,KAAQA,IAC/BJ,GACDK,KAAK,OACOL,IACZxE,EAAO,KAELA,GAAQyE,IACVzE,GAAQ,MAEFwE,EAAa,IAAM,IAAMxE,GAEnC8E,QAAU9E,IACR,IAAI+E,EAASrB,GAAKG,UAAU7D,GAC1BgF,EAAOD,EAAO,GACdE,EAAMF,EAAO,GACf,OAAKC,GAASC,GAIVA,IAEFA,EAAMA,EAAIhL,OAAO,EAAGgL,EAAInF,OAAS,IAE5BkF,EAAOC,GANL,KAQXC,SAAWlF,IAET,GAAa,MAATA,EAAc,MAAO,IAGzB,IAAImF,GADJnF,GADAA,EAAO0D,GAAKa,UAAUvE,IACV9F,QAAQ,MAAO,KACNC,YAAY,KACjC,OAAmB,IAAfgL,EAAyBnF,EACtBA,EAAK/F,OAAOkL,EAAY,IAEjCN,KAAMA,IAAIO,IAAU1B,GAAKa,UAAUa,EAAMP,KAAK,MAC9CQ,MAAOA,CAACC,EAAGC,IAAM7B,GAAKa,UAAUe,EAAI,IAAMC,IAgCxCC,GAAcC,IAERD,GA/BWE,MACnB,GAAqB,iBAAVC,QAA0D,mBAA7BA,OAAwB,gBAE9D,OAAQF,GAASE,OAAOC,gBAAgBH,GAsB1CjO,EACE,8RAKmBkO,IAAkBD,GAGrCI,GAAU,CACZ7O,QAASA,IAAI4I,KAGX,IAFA,IAAIkG,EAAe,GACjBC,GAAmB,EACZ3B,EAAIxE,EAAKE,OAAS,EAAGsE,IAAM,IAAM2B,EAAkB3B,IAAK,CAC/D,IAAIpE,EAAOoE,GAAK,EAAIxE,EAAKwE,GAAK4B,GAAGC,MAEjC,GAAmB,iBAARjG,EACT,MAAM,IAAIkG,UAAU,6CACf,IAAKlG,EACV,MAAO,GAET8F,EAAe9F,EAAO,IAAM8F,EAC5BC,EAAmBrC,GAAKC,MAAM3D,EACxC,CAOQ,OAAQ+F,EAAmB,IAAM,KAJjCD,EAAepC,GAAKM,eAClB8B,EAAapB,MAAM,KAAKC,OAAQC,KAAQA,IACvCmB,GACDlB,KAAK,OACgD,KAEzDsB,SAAUA,CAACC,EAAMC,KAGf,SAASC,EAAKC,GAEZ,IADA,IAAIC,EAAQ,EACLA,EAAQD,EAAIzG,QACE,KAAfyG,EAAIC,GADiBA,KAI3B,IADA,IAAIC,EAAMF,EAAIzG,OAAS,EAChB2G,GAAO,GACK,KAAbF,EAAIE,GADOA,KAGjB,OAAID,EAAQC,EAAY,GACjBF,EAAIxC,MAAMyC,EAAOC,EAAMD,EAAQ,EAChD,CAbQJ,EAAOP,GAAQ7O,QAAQoP,GAAMnM,OAAO,GACpCoM,EAAKR,GAAQ7O,QAAQqP,GAAIpM,OAAO,GAiBhC,IAJA,IAAIyM,EAAYJ,EAAKF,EAAK1B,MAAM,MAC5BiC,EAAUL,EAAKD,EAAG3B,MAAM,MACxB5E,EAAShC,KAAK8I,IAAIF,EAAU5G,OAAQ6G,EAAQ7G,QAC5C+G,EAAkB/G,EACbsE,EAAI,EAAGA,EAAItE,EAAQsE,IAC1B,GAAIsC,EAAUtC,KAAOuC,EAAQvC,GAAI,CAC/ByC,EAAkBzC,EAClB,KACZ,CAEQ,IAAI0C,EAAc,GAClB,IAAS1C,EAAIyC,EAAiBzC,EAAIsC,EAAU5G,OAAQsE,IAClD0C,EAAYC,KAAK,MAGnB,OADAD,EAAcA,EAAYE,OAAOL,EAAQ5C,MAAM8C,KAC5BhC,KAAK,OAIxBoC,GAA0B,GAE1BC,GAAmBrE,IAErB,IADA,IAAIsE,EAAM,EACD/C,EAAI,EAAGA,EAAIvB,EAAI/C,SAAUsE,EAAG,CAKnC,IAAIgD,EAAIvE,EAAIwE,WAAWjD,GACnBgD,GAAK,IACPD,IACSC,GAAK,KACdD,GAAO,EACEC,GAAK,OAAUA,GAAK,OAC7BD,GAAO,IACL/C,GAEF+C,GAAO,CAEjB,CACM,OAAOA,GAGLG,GAAoBA,CAACzE,EAAK0E,EAAMC,EAAQC,KAI1C,GAHA1O,EAAsB,iBAAR8J,EAAkB,kDAAkDA,QAG5E4E,EAAkB,GAAI,OAAO,EAInC,IAFA,IAAIC,EAAWF,EACX9E,EAAS8E,EAASC,EAAkB,EAC/BrD,EAAI,EAAGA,EAAIvB,EAAI/C,SAAUsE,EAAG,CAQnC,IAAIuD,EAAI9E,EAAIwE,WAAWjD,GAKvB,GAJIuD,GAAK,OAAUA,GAAK,QAEtBA,EAAK,QAAgB,KAAJA,IAAc,IAAa,KADnC9E,EAAIwE,aAAajD,IAGxBuD,GAAK,IAAM,CACb,GAAIH,GAAU9E,EAAQ,MACtB6E,EAAKC,KAAYG,CAC3B,MAAe,GAAIA,GAAK,KAAO,CACrB,GAAIH,EAAS,GAAK9E,EAAQ,MAC1B6E,EAAKC,KAAY,IAAQG,GAAK,EAC9BJ,EAAKC,KAAY,IAAY,GAAJG,CACnC,MAAe,GAAIA,GAAK,MAAQ,CACtB,GAAIH,EAAS,GAAK9E,EAAQ,MAC1B6E,EAAKC,KAAY,IAAQG,GAAK,GAC9BJ,EAAKC,KAAY,IAASG,GAAK,EAAK,GACpCJ,EAAKC,KAAY,IAAY,GAAJG,CACnC,KAAe,CACL,GAAIH,EAAS,GAAK9E,EAAQ,MACtBiF,EAAI,SACNpG,GACE,8BACErE,GAAYyK,GACZ,0IAENJ,EAAKC,KAAY,IAAQG,GAAK,GAC9BJ,EAAKC,KAAY,IAASG,GAAK,GAAM,GACrCJ,EAAKC,KAAY,IAASG,GAAK,EAAK,GACpCJ,EAAKC,KAAY,IAAY,GAAJG,CACnC,CACA,CAGM,OADAJ,EAAKC,GAAU,EACRA,EAASE,GAGlB,SAASE,GAAmBC,EAASC,EAAahI,GAChD,IAAIqH,EAAMrH,EAAS,EAAIA,EAASoH,GAAgBW,GAAW,EACvDE,EAAU,IAAIC,MAAMb,GACpBc,EAAkBX,GAAkBO,EAASE,EAAS,EAAGA,EAAQjI,QAErE,OADIgI,IAAaC,EAAQjI,OAASmI,GAC3BF,CACb,CACI,IAsrGIG,GA6LAC,GA/zGAC,GAAM,CACRC,KAAM,GACNC,IAAAA,GASC,EACDC,QAAAA,GAUC,EACDC,QAAAA,CAASC,EAAKC,GACZN,GAAIC,KAAKI,GAAO,CAAEE,MAAO,GAAIC,OAAQ,GAAIF,IAAKA,GAC9C1C,GAAG6C,eAAeJ,EAAKL,GAAIU,WAC5B,EACDA,WAAY,CACVxO,IAAAA,CAAKyO,GACH,IAAIC,EAAMZ,GAAIC,KAAKU,EAAO/Q,KAAKiR,MAC/B,IAAKD,EACH,MAAM,IAAIhD,GAAGkD,WAAW,IAE1BH,EAAOC,IAAMA,EACbD,EAAOI,UAAW,CACnB,EACDC,KAAAA,CAAML,GAEJA,EAAOC,IAAIN,IAAIW,MAAMN,EAAOC,IAC7B,EACDK,KAAAA,CAAMN,GACJA,EAAOC,IAAIN,IAAIW,MAAMN,EAAOC,IAC7B,EACDlQ,IAAAA,CAAKiQ,EAAQ1M,EAAQiN,EAAQxJ,EAAQyJ,GACnC,IAAKR,EAAOC,MAAQD,EAAOC,IAAIN,IAAIc,SACjC,MAAM,IAAIxD,GAAGkD,WAAW,IAG1B,IADA,IAAIO,EAAY,EACPrF,EAAI,EAAGA,EAAItE,EAAQsE,IAAK,CAC/B,IAAIW,EACJ,IACEA,EAASgE,EAAOC,IAAIN,IAAIc,SAAST,EAAOC,IACzC,CAAC,MAAO9J,GACP,MAAM,IAAI8G,GAAGkD,WAAW,GACtC,CACY,QAAe/L,IAAX4H,GAAsC,IAAd0E,EAC1B,MAAM,IAAIzD,GAAGkD,WAAW,GAE1B,GAAInE,QAAyC,MAC7C0E,IACApN,EAAOiN,EAASlF,GAAKW,CACjC,CAIU,OAHI0E,IACFV,EAAO/Q,KAAK0R,UAAYC,KAAKC,OAExBH,CACR,EACDI,KAAAA,CAAMd,EAAQ1M,EAAQiN,EAAQxJ,EAAQyJ,GACpC,IAAKR,EAAOC,MAAQD,EAAOC,IAAIN,IAAIoB,SACjC,MAAM,IAAI9D,GAAGkD,WAAW,IAE1B,IACE,IAAK,IAAI9E,EAAI,EAAGA,EAAItE,EAAQsE,IAC1B2E,EAAOC,IAAIN,IAAIoB,SAASf,EAAOC,IAAK3M,EAAOiN,EAASlF,GAEvD,CAAC,MAAOlF,GACP,MAAM,IAAI8G,GAAGkD,WAAW,GACpC,CAIU,OAHIpJ,IACFiJ,EAAO/Q,KAAK0R,UAAYC,KAAKC,OAExBxF,CACjB,GAEM2F,gBAAiB,CACfP,SAASR,GAzIUgB,MACrB,IAAK/C,GAAwBnH,OAAQ,CACnC,IAAIiF,EAAS,KA2Cb,GAd4B,oBAAVpN,QAAiD,mBAAjBA,OAAOsS,OAGxC,QADflF,EAASpN,OAAOsS,OAAO,cAErBlF,GAAU,MAEgB,mBAAZmF,WAEhBnF,EAASmF,cAEPnF,GAAU,OAITA,EACH,OAAO,KAETkC,GAA0BW,GAAmB7C,GAAQ,EAC7D,CACM,OAAOkC,GAAwBkD,SAwFpBH,GAETF,QAAAA,CAASd,EAAKjH,GACA,OAARA,GAAwB,KAARA,GAClB9G,EAAIoH,GAAkB2G,EAAIJ,SAC1BI,EAAIJ,OAAS,IAEF,GAAP7G,GAAUiH,EAAIJ,OAAO7B,KAAKhF,EAEjC,EACDsH,KAAAA,CAAML,GACAA,EAAIJ,QAAUI,EAAIJ,OAAO9I,OAAS,IACpC7E,EAAIoH,GAAkB2G,EAAIJ,SAC1BI,EAAIJ,OAAS,GAEhB,EACDwB,aAAapB,IAEJ,CACLqB,QAAS,MACTC,QAAS,EACTC,QAAS,IACTC,QAAS,MACTC,KAAM,CACJ,EAAM,GAAM,IAAM,GAAM,EAAM,EAAM,EAAM,EAAM,GAAM,GAAM,GAAM,EAAM,GAAM,GAC9E,GAAM,GAAM,EAAM,EAAM,EAAM,EAAM,EAAM,EAAM,EAAM,EAAM,EAAM,EAAM,EAAM,EAC9E,EAAM,EAAM,EAAM,KAIxBC,aAAYA,CAAC1B,EAAK2B,EAAkB9R,IAE3B,EAET+R,iBAAiB5B,GACR,CAAC,GAAI,KAGhB6B,iBAAkB,CAChBf,QAAAA,CAASd,EAAKjH,GACA,OAARA,GAAwB,KAARA,GAClB5G,EAAIkH,GAAkB2G,EAAIJ,SAC1BI,EAAIJ,OAAS,IAEF,GAAP7G,GAAUiH,EAAIJ,OAAO7B,KAAKhF,EAEjC,EACDsH,KAAAA,CAAML,GACAA,EAAIJ,QAAUI,EAAIJ,OAAO9I,OAAS,IACpC3E,EAAIkH,GAAkB2G,EAAIJ,SAC1BI,EAAIJ,OAAS,GAEzB,IAQQkC,GAAcA,CAACC,EAAMC,KACvBjS,EAAOiS,EAAW,kCACXlN,KAAKmN,KAAKF,EAAOC,GAAaA,GAEnCE,GAAaH,IACfA,EAAOD,GAAYC,EAAM,OACzB,IAAIpJ,EAAMwJ,GAA6B,MAAOJ,GAE9C,OADIpJ,GAXWyJ,EAACC,EAASN,KACzBtP,EAAO6P,KAAK,EAAGD,EAASA,EAAUN,IAUzBK,CAAWzJ,EAAKoJ,GAClBpJ,GAEL4J,GAAQ,CACVC,UAAW,KACXC,MAAMA,GACGF,GAAMG,WAAW,KAAM,IAAK,MAAwB,GAE7DA,UAAAA,CAAWC,EAAQjM,EAAMkM,EAAMnD,GAC7B,GAAIzC,GAAG6F,SAASD,IAAS5F,GAAG8F,OAAOF,GAEjC,MAAM,IAAI5F,GAAGkD,WAAW,IAE1BqC,GAAMC,YAAc,CAClBvG,IAAK,CACHjN,KAAM,CACJ+T,QAASR,GAAMS,SAASD,QACxBE,QAASV,GAAMS,SAASC,QACxBC,OAAQX,GAAMS,SAASE,OACvBC,MAAOZ,GAAMS,SAASG,MACtBC,OAAQb,GAAMS,SAASI,OACvBC,OAAQd,GAAMS,SAASK,OACvBC,MAAOf,GAAMS,SAASM,MACtBC,QAAShB,GAAMS,SAASO,QACxBC,QAASjB,GAAMS,SAASQ,SAE1BzD,OAAQ,CACN0D,OAAQlB,GAAMzC,WAAW2D,SAG7BtM,KAAM,CACJnI,KAAM,CACJ+T,QAASR,GAAMS,SAASD,QACxBE,QAASV,GAAMS,SAASC,SAE1BlD,OAAQ,CACN0D,OAAQlB,GAAMzC,WAAW2D,OACzB3T,KAAMyS,GAAMzC,WAAWhQ,KACvB+Q,MAAO0B,GAAMzC,WAAWe,MACxB6C,SAAUnB,GAAMzC,WAAW4D,SAC3BC,KAAMpB,GAAMzC,WAAW6D,KACvBC,MAAOrB,GAAMzC,WAAW8D,QAG5BC,KAAM,CACJ7U,KAAM,CACJ+T,QAASR,GAAMS,SAASD,QACxBE,QAASV,GAAMS,SAASC,QACxBa,SAAUvB,GAAMS,SAASc,UAE3B/D,OAAQ,CAAA,GAEVgE,OAAQ,CACN/U,KAAM,CACJ+T,QAASR,GAAMS,SAASD,QACxBE,QAASV,GAAMS,SAASC,SAE1BlD,OAAQ/C,GAAGgH,oBAGf,IAAIhV,EAAOgO,GAAG0F,WAAWC,EAAQjM,EAAMkM,EAAMnD,GA0B7C,OAzBIzC,GAAGiH,MAAMjV,EAAK4T,OAChB5T,EAAKgU,SAAWT,GAAMC,UAAUvG,IAAIjN,KACpCA,EAAK8Q,WAAayC,GAAMC,UAAUvG,IAAI8D,OACtC/Q,EAAKkV,SAAW,IACPlH,GAAGmH,OAAOnV,EAAK4T,OACxB5T,EAAKgU,SAAWT,GAAMC,UAAUrL,KAAKnI,KACrCA,EAAK8Q,WAAayC,GAAMC,UAAUrL,KAAK4I,OACvC/Q,EAAKoV,UAAY,EAIjBpV,EAAKkV,SAAW,MACPlH,GAAGqH,OAAOrV,EAAK4T,OACxB5T,EAAKgU,SAAWT,GAAMC,UAAUqB,KAAK7U,KACrCA,EAAK8Q,WAAayC,GAAMC,UAAUqB,KAAK9D,QAC9B/C,GAAGsH,SAAStV,EAAK4T,QAC1B5T,EAAKgU,SAAWT,GAAMC,UAAUuB,OAAO/U,KACvCA,EAAK8Q,WAAayC,GAAMC,UAAUuB,OAAOhE,QAE3C/Q,EAAK0R,UAAYC,KAAKC,MAElB+B,IACFA,EAAOuB,SAASxN,GAAQ1H,EACxB2T,EAAOjC,UAAY1R,EAAK0R,WAEnB1R,CACR,EACDuV,wBAAwBvV,GACjBA,EAAKkV,SACNlV,EAAKkV,SAAS7P,SAAiBrF,EAAKkV,SAAS7P,SAAS,EAAGrF,EAAKoV,WAC3D,IAAIxU,WAAWZ,EAAKkV,UAFA,IAAItU,WAAW,GAI5C4U,iBAAAA,CAAkBxV,EAAMyV,GACtB,IAAIC,EAAe1V,EAAKkV,SAAWlV,EAAKkV,SAASpN,OAAS,EAC1D,KAAI4N,GAAgBD,GAApB,CAKAA,EAAc3P,KAAKhB,IACjB2Q,EACCC,GAAgBA,EAHS,QAG8B,EAAM,SAAY,GAExD,GAAhBA,IAAmBD,EAAc3P,KAAKhB,IAAI2Q,EAAa,MAC3D,IAAIE,EAAc3V,EAAKkV,SACvBlV,EAAKkV,SAAW,IAAItU,WAAW6U,GAC3BzV,EAAKoV,UAAY,GAAGpV,EAAKkV,SAASzV,IAAIkW,EAAYtQ,SAAS,EAAGrF,EAAKoV,WAAY,EAZ3C,CAazC,EACDQ,iBAAAA,CAAkB5V,EAAM6V,GACtB,GAAI7V,EAAKoV,WAAaS,EACtB,GAAe,GAAXA,EACF7V,EAAKkV,SAAW,KAChBlV,EAAKoV,UAAY,MACZ,CACL,IAAIO,EAAc3V,EAAKkV,SACvBlV,EAAKkV,SAAW,IAAItU,WAAWiV,GAC3BF,GACF3V,EAAKkV,SAASzV,IAAIkW,EAAYtQ,SAAS,EAAGS,KAAK8I,IAAIiH,EAAS7V,EAAKoV,aAEnEpV,EAAKoV,UAAYS,CAC3B,CACO,EACD7B,SAAU,CACRD,OAAAA,CAAQ/T,GACN,IAAI8V,EAAO,CAAA,EAyBX,OAvBAA,EAAKrF,IAAMzC,GAAGsH,SAAStV,EAAK4T,MAAQ5T,EAAKmB,GAAK,EAC9C2U,EAAKC,IAAM/V,EAAKmB,GAChB2U,EAAKlC,KAAO5T,EAAK4T,KACjBkC,EAAKE,MAAQ,EACbF,EAAKG,IAAM,EACXH,EAAKI,IAAM,EACXJ,EAAK7E,KAAOjR,EAAKiR,KACbjD,GAAGiH,MAAMjV,EAAK4T,MAChBkC,EAAK/C,KAAO,KACH/E,GAAGmH,OAAOnV,EAAK4T,MACxBkC,EAAK/C,KAAO/S,EAAKoV,UACRpH,GAAGqH,OAAOrV,EAAK4T,MACxBkC,EAAK/C,KAAO/S,EAAK6U,KAAK/M,OAEtBgO,EAAK/C,KAAO,EAEd+C,EAAKK,MAAQ,IAAIxE,KAAK3R,EAAK0R,WAC3BoE,EAAKM,MAAQ,IAAIzE,KAAK3R,EAAK0R,WAC3BoE,EAAKO,MAAQ,IAAI1E,KAAK3R,EAAK0R,WAG3BoE,EAAKQ,QAAU,KACfR,EAAKS,OAASzQ,KAAKmN,KAAK6C,EAAK/C,KAAO+C,EAAKQ,SAClCR,CACR,EACD7B,OAAAA,CAAQjU,EAAM8V,QACM3Q,IAAd2Q,EAAKlC,OACP5T,EAAK4T,KAAOkC,EAAKlC,WAEIzO,IAAnB2Q,EAAKpE,YACP1R,EAAK0R,UAAYoE,EAAKpE,gBAENvM,IAAd2Q,EAAK/C,MACPQ,GAAMqC,kBAAkB5V,EAAM8V,EAAK/C,KAEtC,EACDmB,MAAAA,CAAOP,EAAQjM,GACb,MAAMsG,GAAGwI,cAAc,GACxB,EACDrC,MAAKA,CAACR,EAAQjM,EAAMkM,EAAMnD,IACjB8C,GAAMG,WAAWC,EAAQjM,EAAMkM,EAAMnD,GAE9C2D,MAAAA,CAAOqC,EAAUC,EAASC,GAExB,GAAI3I,GAAGiH,MAAMwB,EAAS7C,MAAO,CAC3B,IAAIgD,EACJ,IACEA,EAAW5I,GAAG6I,WAAWH,EAASC,GAClC,MAAOzP,GAAG,CACZ,GAAI0P,EACF,IAAK,IAAIxK,KAAKwK,EAAS1B,SACrB,MAAM,IAAIlH,GAAGkD,WAAW,GAGxC,QAEiBuF,EAAS9C,OAAOuB,SAASuB,EAAS/O,MACzC+O,EAAS9C,OAAOjC,UAAYC,KAAKC,MACjC6E,EAAS/O,KAAOiP,EAChBD,EAAQxB,SAASyB,GAAYF,EAC7BC,EAAQhF,UAAY+E,EAAS9C,OAAOjC,SACrC,EACD2C,MAAAA,CAAOV,EAAQjM,UACNiM,EAAOuB,SAASxN,GACvBiM,EAAOjC,UAAYC,KAAKC,KACzB,EACD0C,KAAAA,CAAMX,EAAQjM,GACZ,IAAI1H,EAAOgO,GAAG6I,WAAWlD,EAAQjM,GACjC,IAAK,IAAI0E,KAAKpM,EAAKkV,SACjB,MAAM,IAAIlH,GAAGkD,WAAW,WAEnByC,EAAOuB,SAASxN,GACvBiM,EAAOjC,UAAYC,KAAKC,KACzB,EACD2C,OAAAA,CAAQvU,GACN,IAAI8W,EAAU,CAAC,IAAK,MACpB,IAAK,IAAIC,KAAO3X,OAAO4X,KAAKhX,EAAKkV,UAC/B4B,EAAQ/H,KAAKgI,GAEf,OAAOD,CACR,EACDtC,OAAAA,CAAQb,EAAQsD,EAASC,GACvB,IAAIlX,EAAOuT,GAAMG,WAAWC,EAAQsD,EAAS,MAAwB,GAErE,OADAjX,EAAK6U,KAAOqC,EACLlX,CACR,EACD8U,QAAAA,CAAS9U,GACP,IAAKgO,GAAGqH,OAAOrV,EAAK4T,MAClB,MAAM,IAAI5F,GAAGkD,WAAW,IAE1B,OAAOlR,EAAK6U,IACtB,GAEM/D,WAAY,CACVhQ,IAAAA,CAAKiQ,EAAQ1M,EAAQiN,EAAQxJ,EAAQqP,GACnC,IAAIjC,EAAWnE,EAAO/Q,KAAKkV,SAC3B,GAAIiC,GAAYpG,EAAO/Q,KAAKoV,UAAW,OAAO,EAC9C,IAAIrC,EAAOjN,KAAK8I,IAAImC,EAAO/Q,KAAKoV,UAAY+B,EAAUrP,GAEtD,GADA/G,EAAOgS,GAAQ,GACXA,EAAO,GAAKmC,EAAS7P,SAEvBhB,EAAO5E,IAAIyV,EAAS7P,SAAS8R,EAAUA,EAAWpE,GAAOzB,QAEzD,IAAK,IAAIlF,EAAI,EAAGA,EAAI2G,EAAM3G,IAAK/H,EAAOiN,EAASlF,GAAK8I,EAASiC,EAAW/K,GAE1E,OAAO2G,CACR,EACDlB,KAAAA,CAAMd,EAAQ1M,EAAQiN,EAAQxJ,EAAQqP,EAAUC,GAW9C,GATArW,IAASsD,aAAkBgT,cAKvBhT,EAAOA,SAAWb,EAAMa,SAC1B+S,GAAS,IAGNtP,EAAQ,OAAO,EACpB,IAAI9H,EAAO+Q,EAAO/Q,KAGlB,GAFAA,EAAK0R,UAAYC,KAAKC,MAElBvN,EAAOgB,YAAcrF,EAAKkV,UAAYlV,EAAKkV,SAAS7P,UAAW,CAEjE,GAAI+R,EAIF,OAHArW,EAAoB,IAAboW,EAAgB,uDACvBnX,EAAKkV,SAAW7Q,EAAOgB,SAASiM,EAAQA,EAASxJ,GACjD9H,EAAKoV,UAAYtN,EACVA,EACF,GAAuB,IAAnB9H,EAAKoV,WAAgC,IAAb+B,EAIjC,OAFAnX,EAAKkV,SAAW7Q,EAAO0H,MAAMuF,EAAQA,EAASxJ,GAC9C9H,EAAKoV,UAAYtN,EACVA,EACF,GAAIqP,EAAWrP,GAAU9H,EAAKoV,UAGnC,OADApV,EAAKkV,SAASzV,IAAI4E,EAAOgB,SAASiM,EAAQA,EAASxJ,GAASqP,GACrDrP,CAErB,CAIU,GADAyL,GAAMiC,kBAAkBxV,EAAMmX,EAAWrP,GACrC9H,EAAKkV,SAAS7P,UAAYhB,EAAOgB,SAEnCrF,EAAKkV,SAASzV,IAAI4E,EAAOgB,SAASiM,EAAQA,EAASxJ,GAASqP,QAE5D,IAAK,IAAI/K,EAAI,EAAGA,EAAItE,EAAQsE,IAC1BpM,EAAKkV,SAASiC,EAAW/K,GAAK/H,EAAOiN,EAASlF,GAIlD,OADApM,EAAKoV,UAAYtP,KAAKhB,IAAI9E,EAAKoV,UAAW+B,EAAWrP,GAC9CA,CACR,EACD2M,MAAAA,CAAO1D,EAAQO,EAAQgG,GACrB,IAAIH,EAAW7F,EAQf,GAPe,IAAXgG,EACFH,GAAYpG,EAAOoG,SACC,IAAXG,GACLtJ,GAAGmH,OAAOpE,EAAO/Q,KAAK4T,QACxBuD,GAAYpG,EAAO/Q,KAAKoV,WAGxB+B,EAAW,EACb,MAAM,IAAInJ,GAAGkD,WAAW,IAE1B,OAAOiG,CACR,EACDzC,QAAAA,CAAS3D,EAAQO,EAAQxJ,GACvByL,GAAMiC,kBAAkBzE,EAAO/Q,KAAMsR,EAASxJ,GAC9CiJ,EAAO/Q,KAAKoV,UAAYtP,KAAKhB,IAAIiM,EAAO/Q,KAAKoV,UAAW9D,EAASxJ,EAClE,EACD6M,IAAAA,CAAK5D,EAAQjJ,EAAQqP,EAAUI,EAAMC,GACnC,IAAKxJ,GAAGmH,OAAOpE,EAAO/Q,KAAK4T,MACzB,MAAM,IAAI5F,GAAGkD,WAAW,IAE1B,IAAIvH,EACA8N,EACAvC,EAAWnE,EAAO/Q,KAAKkV,SAE3B,GAAc,EAARsC,IAActC,GAAYA,EAAS7Q,SAAWb,EAAMa,OAKnD,CAGL,GAFAoT,GAAY,IACZ9N,EAAMuJ,GAAUpL,IAEd,MAAM,IAAIkG,GAAGkD,WAAW,IAEtBgE,KAEEiC,EAAW,GAAKA,EAAWrP,EAASoN,EAASpN,UAE7CoN,EADEA,EAAS7P,SACA6P,EAAS7P,SAAS8R,EAAUA,EAAWrP,GAEvCkI,MAAM5K,UAAU2G,MAAM2L,KAAKxC,EAAUiC,EAAUA,EAAWrP,IAGzEtE,EAAM/D,IAAIyV,EAAUvL,GAElC,MAnBY8N,GAAY,EACZ9N,EAAMuL,EAASyC,WAmBjB,MAAO,CAAEhO,MAAK8N,YACf,EACD7C,MAAKA,CAAC7D,EAAQ1M,EAAQiN,EAAQxJ,EAAQ8P,KACpCrE,GAAMzC,WAAWe,MAAMd,EAAQ1M,EAAQ,EAAGyD,EAAQwJ,GAAQ,GAEnD,KA6BTuG,GAAiBhZ,EAAuB,gBAAK,GA0E7CiZ,GAAaA,CAACC,EAASC,KACzB,IAAIpE,EAAO,EAGX,OAFImE,IAASnE,GAAQ,KACjBoE,IAAUpE,GAAQ,KACfA,GAOLqE,GAAc,CAChBC,MAAO,GACPC,OAAQ,GACRC,MAAO,GACPC,MAAO,GACPC,IAAK,GACLC,MAAO,GACPC,MAAO,EACPC,QAAS,GACTC,MAAO,EACPC,OAAQ,GACRC,OAAQ,EACRC,YAAa,EACbC,OAAQ,GACRC,OAAQ,EACRC,OAAQ,GACRC,QAAS,IACTC,MAAO,GACPC,OAAQ,GACRC,MAAO,GACPC,OAAQ,GACRC,QAAS,GACTC,OAAQ,GACRC,OAAQ,GACRC,OAAQ,GACRC,OAAQ,GACRC,OAAQ,GACRC,QAAS,GACTC,MAAO,GACPC,OAAQ,GACRC,OAAQ,GACRC,MAAO,GACPC,OAAQ,GACRC,MAAO,GACPC,KAAM,GACNC,OAAQ,GACRC,OAAQ,GACRC,MAAO,GACPC,OAAQ,IACRC,SAAU,IACVC,OAAQ,IACRC,OAAQ,IACRC,OAAQ,IACRC,QAAS,IACTC,OAAQ,IACRC,OAAQ,IACRC,QAAS,GACTC,OAAQ,GACRC,MAAO,IACPC,MAAO,IACPC,OAAQ,IACRC,OAAQ,IACRC,QAAS,IACTC,QAAS,IACTC,UAAW,GACXC,OAAQ,IACRC,OAAQ,IACRC,QAAS,IACTC,MAAO,IACPC,MAAO,IACPC,OAAQ,IACRC,OAAQ,IACRC,QAAS,IACTC,QAAS,GACTC,KAAM,IACNC,OAAQ,IACRC,MAAO,IACPC,OAAQ,GACRC,UAAW,GACXC,QAAS,IACTC,QAAS,EACTC,SAAU,IACVC,OAAQ,IACRC,QAAS,IACTC,QAAS,IACTC,QAAS,IACTC,QAAS,IACTC,QAAS,IACTC,SAAU,IACVC,OAAQ,GACRC,UAAW,GACXC,aAAc,GACdC,MAAO,GACPC,WAAY,IACZC,aAAc,IACdC,WAAY,GACZC,QAAS,GACTC,aAAc,EACdC,WAAY,GACZC,SAAU,GACVC,YAAa,GACbC,UAAW,IACXC,aAAc,GACdC,WAAY,EACZC,aAAc,GACdC,YAAa,GACbC,SAAU,GACVC,UAAW,GACXC,UAAW,IACXC,aAAc,GACdC,YAAa,GACbC,SAAU,EACVC,aAAc,GACdC,SAAU,GACVC,gBAAiB,GACjBC,gBAAiB,IACjBC,cAAe,EACfC,UAAW,GACXC,QAAS,GACTC,SAAU,GACVC,aAAc,IACdC,OAAQ,IACRC,OAAQ,GACRC,OAAQ,GACRC,QAAS,IACTC,UAAW,IACXC,OAAQ,GACRC,UAAW,GACXC,UAAW,GACXC,gBAAiB,GACjBC,WAAY,GACZC,SAAU,KAER1R,GAAK,CACPhB,KAAM,KACN2S,OAAQ,GACRC,QAAS,CAAE,EACXC,QAAS,GACTC,UAAW,EACXC,UAAW,KACXC,YAAa,IACbC,aAAa,EACbC,mBAAmB,EACnBhP,WAAY,cAAczQ,MAOxB0f,WAAAA,CAAYC,GAMV,IAAK,IAAIrJ,KALTsJ,MAAM5a,EAjJI2a,IACPhV,GAAakV,GAAUF,IAgJCG,CAASH,GAAS,IAG7CI,KAAK9Y,KAAO,aACZ8Y,KAAKJ,MAAQA,EACGnI,GACd,GAAIA,GAAYlB,KAASqJ,EAAO,CAC9BI,KAAKC,KAAO1J,EACZ,KACd,CAEA,GAEMP,cAAe,CAAE,EACjBkK,YAAa,KACbC,eAAgB,EAChBC,UAAW,CAAE,EACbC,SAAU,MACRV,WAAAA,GAGEK,KAAKM,OAAS,EACxB,CACQ,UAAIC,GACF,OAAOP,KAAKxgB,IACtB,CACQ,UAAI+gB,CAAOhX,GACTyW,KAAKxgB,KAAO+J,CACtB,CACQ,UAAIiX,GACF,OAAkC,IAAb,QAAbR,KAAKhJ,MACvB,CACQ,WAAIyJ,GACF,SAAqB,QAAbT,KAAKhJ,MACvB,CACQ,YAAI0J,GACF,OAAoB,KAAbV,KAAKhJ,KACtB,CACQ,SAAIA,GACF,OAAOgJ,KAAKM,OAAOtJ,KAC7B,CACQ,SAAIA,CAAMzN,GACRyW,KAAKM,OAAOtJ,MAAQzN,CAC9B,CACQ,YAAIoN,GACF,OAAOqJ,KAAKM,OAAO3J,QAC7B,CACQ,YAAIA,CAASpN,GACXyW,KAAKM,OAAO3J,SAAWpN,CACjC,GAEMoX,OAAQ,MACNhB,WAAAA,CAAYxM,EAAQjM,EAAMkM,EAAM3C,GACzB0C,IACHA,EAAS6M,MAEXA,KAAK7M,OAASA,EACd6M,KAAK/M,MAAQE,EAAOF,MACpB+M,KAAKY,QAAU,KACfZ,KAAKrf,GAAK6M,GAAG8R,YACbU,KAAK9Y,KAAOA,EACZ8Y,KAAK5M,KAAOA,EACZ4M,KAAKxM,SAAW,GAChBwM,KAAK1P,WAAa,GAClB0P,KAAKvP,KAAOA,EACZuP,KAAKa,SAAW,IAChBb,KAAKc,UAAY,GAC3B,CACQ,QAAIxgB,GACF,OAAQ0f,KAAK5M,KAAO4M,KAAKa,YAAcb,KAAKa,QACtD,CACQ,QAAIvgB,CAAKiJ,GACPA,EAAOyW,KAAK5M,MAAQ4M,KAAKa,SAAab,KAAK5M,OAAS4M,KAAKa,QACnE,CACQ,SAAIxP,GACF,OAAQ2O,KAAK5M,KAAO4M,KAAKc,aAAed,KAAKc,SACvD,CACQ,SAAIzP,CAAM9H,GACRA,EAAOyW,KAAK5M,MAAQ4M,KAAKc,UAAcd,KAAK5M,OAAS4M,KAAKc,SACpE,CACQ,YAAIC,GACF,OAAOvT,GAAGiH,MAAMuL,KAAK5M,KAC/B,CACQ,YAAI4N,GACF,OAAOxT,GAAGsH,SAASkL,KAAK5M,KAClC,GAEM6N,UAAAA,CAAWzZ,EAAM0Z,EAAO,IAGtB,KAFA1Z,EAAO6F,GAAQ7O,QAAQgJ,IAEZ,MAAO,CAAEA,KAAM,GAAIhI,KAAM,MAQpC,IAFA0hB,EAAOtiB,OAAOkB,OAJC,CACbqhB,cAAc,EACdC,cAAe,GAEcF,IAEtBE,cAAgB,EAEvB,MAAM,IAAI5T,GAAGkD,WAAW,IAU1B,IANA,IAAIjF,EAAQjE,EAAK0E,MAAM,KAAKC,OAAQC,KAAQA,GAGxCiV,EAAU7T,GAAGhB,KACb8U,EAAe,IAEV1V,EAAI,EAAGA,EAAIH,EAAMnE,OAAQsE,IAAK,CACrC,IAAI2V,EAAS3V,IAAMH,EAAMnE,OAAS,EAClC,GAAIia,GAAUL,EAAK/N,OAEjB,MAeF,GAZAkO,EAAU7T,GAAG6I,WAAWgL,EAAS5V,EAAMG,IACvC0V,EAAepW,GAAK2B,MAAMyU,EAAc7V,EAAMG,IAG1C4B,GAAGgU,aAAaH,MACbE,GAAWA,GAAUL,EAAKC,gBAC7BE,EAAUA,EAAQT,QAAQpU,OAMzB+U,GAAUL,EAAKO,OAElB,IADA,IAAIC,EAAQ,EACLlU,GAAGqH,OAAOwM,EAAQjO,OAAO,CAC9B,IAAIiB,EAAO7G,GAAG8G,SAASgN,GAMvB,GALAA,EAAejU,GAAQ7O,QAAQ0M,GAAKoB,QAAQgV,GAAejN,GAG3DgN,EADa7T,GAAGyT,WAAWK,EAAc,CAAEF,cAAeF,EAAKE,cAAgB,IAC9D5hB,KAEbkiB,IAAU,GAEZ,MAAM,IAAIlU,GAAGkD,WAAW,GAExC,CAEA,CAEQ,MAAO,CAAElJ,KAAM8Z,EAAc9hB,KAAM6hB,EACpC,EACDM,OAAAA,CAAQniB,GAEN,IADA,IAAIgI,IACS,CACX,GAAIgG,GAAGoU,OAAOpiB,GAAO,CACnB,IAAIyT,EAAQzT,EAAKyT,MAAM4O,WACvB,OAAKra,EAC8B,MAA5ByL,EAAMA,EAAM3L,OAAS,GAAa,GAAG2L,KAASzL,IAASyL,EAAQzL,EADpDyL,CAE9B,CACUzL,EAAOA,EAAO,GAAGhI,EAAK0H,QAAQM,IAAShI,EAAK0H,KAC5C1H,EAAOA,EAAK2T,MACtB,CACO,EACD2O,QAAAA,CAASC,EAAU7a,GAGjB,IAFA,IAAI8a,EAAO,EAEFpW,EAAI,EAAGA,EAAI1E,EAAKI,OAAQsE,IAC/BoW,GAASA,GAAQ,GAAKA,EAAO9a,EAAK2H,WAAWjD,GAAM,EAErD,OAASmW,EAAWC,IAAU,GAAKxU,GAAG+R,UAAUjY,MACjD,EACD2a,WAAAA,CAAYziB,GACV,IAAIwiB,EAAOxU,GAAGsU,SAAStiB,EAAK2T,OAAOxS,GAAInB,EAAK0H,MAC5C1H,EAAK0iB,UAAY1U,GAAG+R,UAAUyC,GAC9BxU,GAAG+R,UAAUyC,GAAQxiB,CACtB,EACD2iB,cAAAA,CAAe3iB,GACb,IAAIwiB,EAAOxU,GAAGsU,SAAStiB,EAAK2T,OAAOxS,GAAInB,EAAK0H,MAC5C,GAAIsG,GAAG+R,UAAUyC,KAAUxiB,EACzBgO,GAAG+R,UAAUyC,GAAQxiB,EAAK0iB,eAG1B,IADA,IAAIb,EAAU7T,GAAG+R,UAAUyC,GACpBX,GAAS,CACd,GAAIA,EAAQa,YAAc1iB,EAAM,CAC9B6hB,EAAQa,UAAY1iB,EAAK0iB,UACzB,KACd,CACYb,EAAUA,EAAQa,SAC9B,CAEO,EACD7L,UAAAA,CAAWlD,EAAQjM,GACjB,IAAIkb,EAAU5U,GAAG6U,UAAUlP,GAC3B,GAAIiP,EACF,MAAM,IAAI5U,GAAGkD,WAAW0R,GAG1B,IADA,IAAIJ,EAAOxU,GAAGsU,SAAS3O,EAAOxS,GAAIuG,GACzB1H,EAAOgO,GAAG+R,UAAUyC,GAAOxiB,EAAMA,EAAOA,EAAK0iB,UAAW,CAC/D,IAAII,EAAW9iB,EAAK0H,KACpB,GAAI1H,EAAK2T,OAAOxS,KAAOwS,EAAOxS,IAAM2hB,IAAapb,EAC/C,OAAO1H,CAEnB,CAEQ,OAAOgO,GAAGkG,OAAOP,EAAQjM,EAC1B,EACDgM,UAAAA,CAAWC,EAAQjM,EAAMkM,EAAM3C,GAC7BlQ,EAAwB,iBAAV4S,GACd,IAAI3T,EAAO,IAAIgO,GAAGmT,OAAOxN,EAAQjM,EAAMkM,EAAM3C,GAI7C,OAFAjD,GAAGyU,YAAYziB,GAERA,CACR,EACD+iB,WAAAA,CAAY/iB,GACVgO,GAAG2U,eAAe3iB,EACnB,EACDoiB,OAAOpiB,GACEA,IAASA,EAAK2T,OAEvBqO,aAAahiB,KACFA,EAAKohB,QAEhBjM,OAAOvB,GACqB,QAAX,MAAPA,GAEVqB,MAAMrB,GACsB,QAAX,MAAPA,GAEVyB,OAAOzB,GACqB,QAAX,MAAPA,GAEV0B,SAAS1B,GACmB,OAAX,MAAPA,GAEVC,SAASD,GACmB,QAAX,MAAPA,GAEVE,OAAOF,GACqB,OAAX,MAAPA,GAEVoP,SAASpP,KACmB,OAAlBA,GAEVqP,uBAAAA,CAAwBC,GACtB,IAAIC,EAAQ,CAAC,IAAK,IAAK,MAAa,EAAPD,GAI7B,OAHW,IAAPA,IACFC,GAAS,KAEJA,CACR,EACDC,gBAAeA,CAACpjB,EAAMmjB,IAChBnV,GAAGkS,qBAIHiD,EAAME,SAAS,MAAsB,IAAZrjB,EAAK4T,SAEvBuP,EAAME,SAAS,MAAsB,IAAZrjB,EAAK4T,SAE9BuP,EAAME,SAAS,MAAsB,GAAZrjB,EAAK4T,MAPhC,EAIA,EAQXiP,SAAAA,CAAU5V,GACR,IAAKe,GAAGiH,MAAMhI,EAAI2G,MAAO,OAAO,GAChC,IAAIgP,EAAU5U,GAAGoV,gBAAgBnW,EAAK,KACtC,OAAI2V,IACC3V,EAAI+G,SAASE,OACX,EAD0B,EAElC,EACDoP,SAAAA,CAAUrW,EAAKvF,GACb,IAEE,OADWsG,GAAG6I,WAAW5J,EAAKvF,GACvB,GACP,MAAOR,GAAG,CACZ,OAAO8G,GAAGoV,gBAAgBnW,EAAK,KAChC,EACDsW,SAAAA,CAAUtW,EAAKvF,EAAM8b,GACnB,IAAIxjB,EACJ,IACEA,EAAOgO,GAAG6I,WAAW5J,EAAKvF,EAC3B,CAAC,MAAOR,GACP,OAAOA,EAAEkZ,KACnB,CACQ,IAAIwC,EAAU5U,GAAGoV,gBAAgBnW,EAAK,MACtC,GAAI2V,EACF,OAAOA,EAET,GAAIY,EAAO,CACT,IAAKxV,GAAGiH,MAAMjV,EAAK4T,MACjB,OAAO,GAET,GAAI5F,GAAGoU,OAAOpiB,IAASgO,GAAGmU,QAAQniB,KAAUgO,GAAGC,MAC7C,OAAO,EAEnB,MACU,GAAID,GAAGiH,MAAMjV,EAAK4T,MAChB,OAAO,GAGX,OAAO,CACR,EACD6P,QAAOA,CAACzjB,EAAMwX,IACPxX,EAGDgO,GAAGqH,OAAOrV,EAAK4T,MACV,GACE5F,GAAGiH,MAAMjV,EAAK4T,QAEiB,MAAtC5F,GAAGiV,wBAAwBzL,IACnB,IAARA,GAGO,GAGJxJ,GAAGoV,gBAAgBpjB,EAAMgO,GAAGiV,wBAAwBzL,IAblD,GAeXkM,aAAc,KACdC,MAAAA,GACE,IAAK,IAAIC,EAAK,EAAGA,GAAM5V,GAAG0V,aAAcE,IACtC,IAAK5V,GAAG6R,QAAQ+D,GACd,OAAOA,EAGX,MAAM,IAAI5V,GAAGkD,WAAW,GACzB,EACD2S,gBAAAA,CAAiBD,GACf,IAAI7S,EAAS/C,GAAG8V,UAAUF,GAC1B,IAAK7S,EACH,MAAM,IAAI/C,GAAGkD,WAAW,GAE1B,OAAOH,CACR,EACD+S,UAAYF,GAAO5V,GAAG6R,QAAQ+D,GAC9BG,aAAYA,CAAChT,EAAQ6S,GAAK,KACxB7iB,EAAO6iB,IAAO,GAGd7S,EAAS3R,OAAOkB,OAAO,IAAI0N,GAAG6S,SAAY9P,IAC/B,GAAP6S,IACFA,EAAK5V,GAAG2V,UAEV5S,EAAO6S,GAAKA,EACZ5V,GAAG6R,QAAQ+D,GAAM7S,EACVA,GAETiT,WAAAA,CAAYJ,GACV5V,GAAG6R,QAAQ+D,GAAM,IAClB,EACDK,SAAAA,CAAUC,EAAYN,GAAK,GACzB,IAAI7S,EAAS/C,GAAG+V,aAAaG,EAAYN,GAEzC,OADA7S,EAAOD,YAAYqT,MAAMpT,GAClBA,CACR,EACDiE,kBAAmB,CACjB1S,IAAAA,CAAKyO,GACH,IAAIqT,EAASpW,GAAGqW,UAAUtT,EAAO/Q,KAAKiR,MAEtCF,EAAOD,WAAasT,EAAOtT,WAE3BC,EAAOD,WAAWxO,OAAOyO,EAC1B,EACD0D,MAAAA,GACE,MAAM,IAAIzG,GAAGkD,WAAW,GAClC,GAEMoT,MAAQ7T,GAAQA,GAAO,EACvB8T,MAAQ9T,GAAc,IAANA,EAChB+T,QAASA,CAACC,EAAIC,IAAQD,GAAM,EAAKC,EACjC7T,cAAAA,CAAeJ,EAAKC,GAClB1C,GAAG4R,QAAQnP,GAAO,CAAEK,WAAYJ,EACjC,EACD2T,UAAY5T,GAAQzC,GAAG4R,QAAQnP,GAC/BkU,SAAAA,CAAUlR,GAIR,IAHA,IAAIkM,EAAS,GACTiF,EAAQ,CAACnR,GAENmR,EAAM9c,QAAQ,CACnB,IAAI+c,EAAID,EAAME,MAEdnF,EAAO5Q,KAAK8V,GAEZD,EAAM7V,QAAQ8V,EAAElF,OAC1B,CAEQ,OAAOA,CACR,EACDoF,MAAAA,CAAOC,EAAUhe,GACQ,mBAAZge,IACThe,EAAWge,EACXA,GAAW,GAGbhX,GAAG2S,iBAEC3S,GAAG2S,eAAiB,GACtBxd,EACE,YAAY6K,GAAG2S,yFAInB,IAAIhB,EAAS3R,GAAG2W,UAAU3W,GAAGhB,KAAKyG,OAC9BwR,EAAY,EAEhB,SAASC,EAAWtC,GAGlB,OAFA7hB,EAAOiN,GAAG2S,eAAiB,GAC3B3S,GAAG2S,iBACI3Z,EAAS4b,EAC1B,CAEQ,SAASuC,EAAKvC,GACZ,GAAIA,EACF,OAAKuC,EAAKC,aAIV,GAHED,EAAKC,SAAU,EACRF,EAAWtC,MAIhBqC,GAAatF,EAAO7X,QACxBod,EAAW,KAEvB,CAGQvF,EAAOzgB,QAASuU,IACd,IAAKA,EAAMxT,KAAK8kB,OACd,OAAOI,EAAK,MAEd1R,EAAMxT,KAAK8kB,OAAOtR,EAAOuR,EAAUG,IAEtC,EACD1R,KAAAA,CAAMxT,EAAMyhB,EAAMW,GAChB,GAAmB,iBAARpiB,EAGT,MAAMA,EAER,IAEID,EAFAgN,EAAsB,MAAfqV,EACPgD,GAAUhD,EAGd,GAAIrV,GAAQgB,GAAGhB,KACb,MAAM,IAAIgB,GAAGkD,WAAW,IACnB,IAAKlE,IAASqY,EAAQ,CAC3B,IAAInR,EAASlG,GAAGyT,WAAWY,EAAY,CAAEV,cAAc,IAKvD,GAHAU,EAAanO,EAAOlM,KACpBhI,EAAOkU,EAAOlU,KAEVgO,GAAGgU,aAAahiB,GAClB,MAAM,IAAIgO,GAAGkD,WAAW,IAG1B,IAAKlD,GAAGiH,MAAMjV,EAAK4T,MACjB,MAAM,IAAI5F,GAAGkD,WAAW,GAEpC,CAEQ,IAAIuC,EAAQ,CACVxT,OACAyhB,OACAW,aACA1C,OAAQ,IAIN2F,EAAYrlB,EAAKwT,MAAMA,GAgB3B,OAfA6R,EAAU7R,MAAQA,EAClBA,EAAMzG,KAAOsY,EAETtY,EACFgB,GAAGhB,KAAOsY,EACDtlB,IAETA,EAAKohB,QAAU3N,EAGXzT,EAAKyT,OACPzT,EAAKyT,MAAMkM,OAAO5Q,KAAK0E,IAIpB6R,CACR,EACDC,OAAAA,CAAQlD,GACN,IAAInO,EAASlG,GAAGyT,WAAWY,EAAY,CAAEV,cAAc,IAEvD,IAAK3T,GAAGgU,aAAa9N,EAAOlU,MAC1B,MAAM,IAAIgO,GAAGkD,WAAW,IAI1B,IAAIlR,EAAOkU,EAAOlU,KACdyT,EAAQzT,EAAKohB,QACbzB,EAAS3R,GAAG2W,UAAUlR,GAE1BrU,OAAO4X,KAAKhJ,GAAG+R,WAAW7gB,QAASsjB,IAGjC,IAFA,IAAIX,EAAU7T,GAAG+R,UAAUyC,GAEpBX,GAAS,CACd,IAAI2D,EAAO3D,EAAQa,UAEf/C,EAAO0D,SAASxB,EAAQpO,QAC1BzF,GAAG+U,YAAYlB,GAGjBA,EAAU2D,CACtB,IAIQxlB,EAAKohB,QAAU,KAGf,IAAI7W,EAAMvK,EAAKyT,MAAMkM,OAAO8F,QAAQhS,GACpC1S,GAAgB,IAATwJ,GACPvK,EAAKyT,MAAMkM,OAAOrT,OAAO/B,EAAK,EAC/B,EACD2J,OAAMA,CAACP,EAAQjM,IACNiM,EAAOK,SAASE,OAAOP,EAAQjM,GAExCyM,KAAAA,CAAMnM,EAAM4L,EAAMnD,GAChB,IACIkD,EADS3F,GAAGyT,WAAWzZ,EAAM,CAAE2L,QAAQ,IACvB3T,KAChB0H,EAAOgE,GAAKwB,SAASlF,GACzB,IAAKN,GAAiB,MAATA,GAAyB,OAATA,EAC3B,MAAM,IAAIsG,GAAGkD,WAAW,IAE1B,IAAI0R,EAAU5U,GAAGsV,UAAU3P,EAAQjM,GACnC,GAAIkb,EACF,MAAM,IAAI5U,GAAGkD,WAAW0R,GAE1B,IAAKjP,EAAOK,SAASG,MACnB,MAAM,IAAInG,GAAGkD,WAAW,IAE1B,OAAOyC,EAAOK,SAASG,MAAMR,EAAQjM,EAAMkM,EAAMnD,EAClD,EACDiV,OAAMA,CAAC1d,EAAM4L,KACXA,OAAgBzO,IAATyO,EAAqBA,EAAO,IACnCA,GAAQ,KACRA,GAAQ,MACD5F,GAAGmG,MAAMnM,EAAM4L,EAAM,IAE9B+R,MAAKA,CAAC3d,EAAM4L,KACVA,OAAgBzO,IAATyO,EAAqBA,EAAO,IACnCA,GAAQ,KACRA,GAAQ,MACD5F,GAAGmG,MAAMnM,EAAM4L,EAAM,IAE9BgS,SAAAA,CAAU5d,EAAM4L,GAGd,IAFA,IAAIiS,EAAO7d,EAAK0E,MAAM,KAClBoZ,EAAI,GACC1Z,EAAI,EAAGA,EAAIyZ,EAAK/d,SAAUsE,EACjC,GAAKyZ,EAAKzZ,GAAV,CACA0Z,GAAK,IAAMD,EAAKzZ,GAChB,IACE4B,GAAG2X,MAAMG,EAAGlS,EACb,CAAC,MAAO1M,GACP,GAAe,IAAXA,EAAEkZ,MAAa,MAAMlZ,CACrC,CANwB,CAQjB,EACD6e,MAAKA,CAAC/d,EAAM4L,EAAMnD,UACE,IAAPA,IACTA,EAAMmD,EACNA,EAAO,KAETA,GAAQ,KACD5F,GAAGmG,MAAMnM,EAAM4L,EAAMnD,IAE9B+D,OAAAA,CAAQ0C,EAAS8O,GACf,IAAKnY,GAAQ7O,QAAQkY,GACnB,MAAM,IAAIlJ,GAAGkD,WAAW,IAE1B,IACIyC,EADS3F,GAAGyT,WAAWuE,EAAS,CAAErS,QAAQ,IAC1B3T,KACpB,IAAK2T,EACH,MAAM,IAAI3F,GAAGkD,WAAW,IAE1B,IAAI+F,EAAUvL,GAAKwB,SAAS8Y,GACxBpD,EAAU5U,GAAGsV,UAAU3P,EAAQsD,GACnC,GAAI2L,EACF,MAAM,IAAI5U,GAAGkD,WAAW0R,GAE1B,IAAKjP,EAAOK,SAASQ,QACnB,MAAM,IAAIxG,GAAGkD,WAAW,IAE1B,OAAOyC,EAAOK,SAASQ,QAAQb,EAAQsD,EAASC,EACjD,EACD9C,MAAAA,CAAO6R,EAAUC,GACf,IAKYC,EAASzP,EALjB0P,EAAc1a,GAAKoB,QAAQmZ,GAC3BI,EAAc3a,GAAKoB,QAAQoZ,GAC3BI,EAAW5a,GAAKwB,SAAS+Y,GACzBtP,EAAWjL,GAAKwB,SAASgZ,GAU7B,GAJAC,EADSnY,GAAGyT,WAAWwE,EAAU,CAAEtS,QAAQ,IAC1B3T,KAEjB0W,EADS1I,GAAGyT,WAAWyE,EAAU,CAAEvS,QAAQ,IAC1B3T,MAEZmmB,IAAYzP,EAAS,MAAM,IAAI1I,GAAGkD,WAAW,IAElD,GAAIiV,EAAQ1S,QAAUiD,EAAQjD,MAC5B,MAAM,IAAIzF,GAAGkD,WAAW,IAG1B,IAYI0F,EAZAH,EAAWzI,GAAG6I,WAAWsP,EAASG,GAElCnY,EAAWN,GAAQM,SAAS8X,EAAUI,GAC1C,GAA2B,MAAvBlY,EAASvC,OAAO,GAClB,MAAM,IAAIoC,GAAGkD,WAAW,IAI1B,GAA2B,OAD3B/C,EAAWN,GAAQM,SAAS+X,EAAUE,IACzBxa,OAAO,GAClB,MAAM,IAAIoC,GAAGkD,WAAW,IAI1B,IACE0F,EAAW5I,GAAG6I,WAAWH,EAASC,EACnC,CAAC,MAAOzP,GACjB,CAGQ,GAAIuP,IAAaG,EAAjB,CAIA,IAAI4M,EAAQxV,GAAGiH,MAAMwB,EAAS7C,MAC1BgP,EAAU5U,GAAGuV,UAAU4C,EAASG,EAAU9C,GAC9C,GAAIZ,EACF,MAAM,IAAI5U,GAAGkD,WAAW0R,GAO1B,GAHAA,EAAUhM,EACN5I,GAAGuV,UAAU7M,EAASC,EAAU6M,GAChCxV,GAAGsV,UAAU5M,EAASC,GAExB,MAAM,IAAI3I,GAAGkD,WAAW0R,GAE1B,IAAKuD,EAAQnS,SAASI,OACpB,MAAM,IAAIpG,GAAGkD,WAAW,IAE1B,GAAIlD,GAAGgU,aAAavL,IAAcG,GAAY5I,GAAGgU,aAAapL,GAC5D,MAAM,IAAI5I,GAAGkD,WAAW,IAG1B,GAAIwF,IAAYyP,IACdvD,EAAU5U,GAAGoV,gBAAgB+C,EAAS,MAEpC,MAAM,IAAInY,GAAGkD,WAAW0R,GAI5B5U,GAAG2U,eAAelM,GAElB,IACE0P,EAAQnS,SAASI,OAAOqC,EAAUC,EAASC,GAG3CF,EAAS9C,OAAS+C,CACnB,CAAC,MAAOxP,GACP,MAAMA,CAChB,CAAkB,QAGR8G,GAAGyU,YAAYhM,EACzB,CA1CA,CA2CO,EACDnC,KAAAA,CAAMtM,GACJ,IACI2L,EADS3F,GAAGyT,WAAWzZ,EAAM,CAAE2L,QAAQ,IACvB3T,KAChB0H,EAAOgE,GAAKwB,SAASlF,GACrBhI,EAAOgO,GAAG6I,WAAWlD,EAAQjM,GAC7Bkb,EAAU5U,GAAGuV,UAAU5P,EAAQjM,GAAM,GACzC,GAAIkb,EACF,MAAM,IAAI5U,GAAGkD,WAAW0R,GAE1B,IAAKjP,EAAOK,SAASM,MACnB,MAAM,IAAItG,GAAGkD,WAAW,IAE1B,GAAIlD,GAAGgU,aAAahiB,GAClB,MAAM,IAAIgO,GAAGkD,WAAW,IAE1ByC,EAAOK,SAASM,MAAMX,EAAQjM,GAC9BsG,GAAG+U,YAAY/iB,EAChB,EACDuU,OAAAA,CAAQvM,GACN,IACIhI,EADSgO,GAAGyT,WAAWzZ,EAAM,CAAEia,QAAQ,IACzBjiB,KAClB,IAAKA,EAAKgU,SAASO,QACjB,MAAM,IAAIvG,GAAGkD,WAAW,IAE1B,OAAOlR,EAAKgU,SAASO,QAAQvU,EAC9B,EACDqU,MAAAA,CAAOrM,GACL,IACI2L,EADS3F,GAAGyT,WAAWzZ,EAAM,CAAE2L,QAAQ,IACvB3T,KACpB,IAAK2T,EACH,MAAM,IAAI3F,GAAGkD,WAAW,IAE1B,IAAIxJ,EAAOgE,GAAKwB,SAASlF,GACrBhI,EAAOgO,GAAG6I,WAAWlD,EAAQjM,GAC7Bkb,EAAU5U,GAAGuV,UAAU5P,EAAQjM,GAAM,GACzC,GAAIkb,EAIF,MAAM,IAAI5U,GAAGkD,WAAW0R,GAE1B,IAAKjP,EAAOK,SAASK,OACnB,MAAM,IAAIrG,GAAGkD,WAAW,IAE1B,GAAIlD,GAAGgU,aAAahiB,GAClB,MAAM,IAAIgO,GAAGkD,WAAW,IAE1ByC,EAAOK,SAASK,OAAOV,EAAQjM,GAC/BsG,GAAG+U,YAAY/iB,EAChB,EACD8U,QAAAA,CAAS9M,GACP,IACI6M,EADS7G,GAAGyT,WAAWzZ,GACThI,KAClB,IAAK6U,EACH,MAAM,IAAI7G,GAAGkD,WAAW,IAE1B,IAAK2D,EAAKb,SAASc,SACjB,MAAM,IAAI9G,GAAGkD,WAAW,IAE1B,OAAOrD,GAAQ7O,QAAQgP,GAAGmU,QAAQtN,EAAKlB,QAASkB,EAAKb,SAASc,SAASD,GACxE,EACD0R,IAAAA,CAAKve,EAAMwe,GACT,IACIxmB,EADSgO,GAAGyT,WAAWzZ,EAAM,CAAEia,QAASuE,IAC1BxmB,KAClB,IAAKA,EACH,MAAM,IAAIgO,GAAGkD,WAAW,IAE1B,IAAKlR,EAAKgU,SAASD,QACjB,MAAM,IAAI/F,GAAGkD,WAAW,IAE1B,OAAOlR,EAAKgU,SAASD,QAAQ/T,EAC9B,EACDymB,MAAMze,GACGgG,GAAGuY,KAAKve,GAAM,GAEvB0e,KAAAA,CAAM1e,EAAM4L,EAAM4S,GAChB,IAAIxmB,EAOJ,KAJEA,EAFiB,iBAARgI,EACIgG,GAAGyT,WAAWzZ,EAAM,CAAEia,QAASuE,IAC9BxmB,KAEPgI,GAECgM,SAASC,QACjB,MAAM,IAAIjG,GAAGkD,WAAW,IAE1BlR,EAAKgU,SAASC,QAAQjU,EAAM,CAC1B4T,KAAc,KAAPA,GAA4B,KAAZ5T,EAAK4T,KAC5BlC,UAAWC,KAAKC,OAEnB,EACD+U,MAAAA,CAAO3e,EAAM4L,GACX5F,GAAG0Y,MAAM1e,EAAM4L,GAAM,EACtB,EACDgT,MAAAA,CAAOhD,EAAIhQ,GACT,IAAI7C,EAAS/C,GAAG6V,iBAAiBD,GACjC5V,GAAG0Y,MAAM3V,EAAO/Q,KAAM4T,EACvB,EACDiT,KAAAA,CAAM7e,EAAMiO,EAAKC,EAAKsQ,GACpB,IAAIxmB,EAOJ,KAJEA,EAFiB,iBAARgI,EACIgG,GAAGyT,WAAWzZ,EAAM,CAAEia,QAASuE,IAC9BxmB,KAEPgI,GAECgM,SAASC,QACjB,MAAM,IAAIjG,GAAGkD,WAAW,IAE1BlR,EAAKgU,SAASC,QAAQjU,EAAM,CAC1B0R,UAAWC,KAAKC,OAGnB,EACDkV,MAAAA,CAAO9e,EAAMiO,EAAKC,GAChBlI,GAAG6Y,MAAM7e,EAAMiO,EAAKC,GAAK,EAC1B,EACD6Q,MAAAA,CAAOnD,EAAI3N,EAAKC,GACd,IAAInF,EAAS/C,GAAG6V,iBAAiBD,GACjC5V,GAAG6Y,MAAM9V,EAAO/Q,KAAMiW,EAAKC,EAC5B,EACD8Q,QAAAA,CAAShf,EAAMmH,GACb,GAAIA,EAAM,EACR,MAAM,IAAInB,GAAGkD,WAAW,IAE1B,IAAIlR,EAOJ,KAJEA,EAFiB,iBAARgI,EACIgG,GAAGyT,WAAWzZ,EAAM,CAAEia,QAAQ,IAC7BjiB,KAEPgI,GAECgM,SAASC,QACjB,MAAM,IAAIjG,GAAGkD,WAAW,IAE1B,GAAIlD,GAAGiH,MAAMjV,EAAK4T,MAChB,MAAM,IAAI5F,GAAGkD,WAAW,IAE1B,IAAKlD,GAAGmH,OAAOnV,EAAK4T,MAClB,MAAM,IAAI5F,GAAGkD,WAAW,IAE1B,IAAI0R,EAAU5U,GAAGoV,gBAAgBpjB,EAAM,KACvC,GAAI4iB,EACF,MAAM,IAAI5U,GAAGkD,WAAW0R,GAE1B5iB,EAAKgU,SAASC,QAAQjU,EAAM,CAC1B+S,KAAM5D,EACNuC,UAAWC,KAAKC,OAEnB,EACDqV,SAAAA,CAAUrD,EAAIzU,GACZ,IAAI4B,EAAS/C,GAAG6V,iBAAiBD,GACjC,KAAoB,QAAf7S,EAAOyG,OACV,MAAM,IAAIxJ,GAAGkD,WAAW,IAE1BlD,GAAGgZ,SAASjW,EAAO/Q,KAAMmP,EAC1B,EACD+X,KAAAA,CAAMlf,EAAMmO,EAAOC,GACjB,IACIpW,EADSgO,GAAGyT,WAAWzZ,EAAM,CAAEia,QAAQ,IACzBjiB,KAClBA,EAAKgU,SAASC,QAAQjU,EAAM,CAC1B0R,UAAW5L,KAAKhB,IAAIqR,EAAOC,IAE9B,EACD9T,IAAAA,CAAK0F,EAAMwP,EAAO5D,GAChB,GAAa,KAAT5L,EACF,MAAM,IAAIgG,GAAGkD,WAAW,IAS1B,IAAIlR,EACJ,GALE4T,EAFU,IADZ4D,EAAwB,iBAATA,EAn/BS3M,KAC1B,IAQI2M,EARY,CACdjK,EAAG,EACH,KAAM,EACN4Z,EAAG,IACH,KAAM,IACNC,EAAG,KACH,KAAM,MAEcvc,GACtB,QAAoB,IAAT2M,EACT,MAAM,IAAI/W,MAAM,2BAA2BoK,KAE7C,OAAO2M,GAs+B8B6P,CAAqB7P,GAASA,GAGhD,MADf5D,OAAsB,IAARA,EAAsB,IAAiBA,GAC9B,MAEhB,EAGU,iBAAR5L,EACThI,EAAOgI,MACF,CACLA,EAAO0D,GAAKa,UAAUvE,GACtB,IAIEhI,EAHagO,GAAGyT,WAAWzZ,EAAM,CAC/Bia,SAAkB,OAARzK,KAEExX,IACf,CAAC,MAAOkH,GACnB,CAEA,CAEQ,IAAIogB,GAAU,EACd,GAAY,GAAR9P,EACF,GAAIxX,GAEF,GAAY,IAARwX,EACF,MAAM,IAAIxJ,GAAGkD,WAAW,SAI1BlR,EAAOgO,GAAGmG,MAAMnM,EAAM4L,EAAM,GAC5B0T,GAAU,EAGd,IAAKtnB,EACH,MAAM,IAAIgO,GAAGkD,WAAW,IAO1B,GAJIlD,GAAGsH,SAAStV,EAAK4T,QACnB4D,IAAS,KAGC,MAARA,IAAkBxJ,GAAGiH,MAAMjV,EAAK4T,MAClC,MAAM,IAAI5F,GAAGkD,WAAW,IAK1B,IAAKoW,EAAS,CACZ,IAAI1E,EAAU5U,GAAGyV,QAAQzjB,EAAMwX,GAC/B,GAAIoL,EACF,MAAM,IAAI5U,GAAGkD,WAAW0R,EAEpC,CAEoB,IAARpL,IAAgB8P,GAClBtZ,GAAGgZ,SAAShnB,EAAM,GAGpBwX,IAAS,OAGT,IAAIzG,EAAS/C,GAAG+V,aAAa,CAC3B/jB,OACAgI,KAAMgG,GAAGmU,QAAQniB,GACjBwX,QACArG,UAAU,EACVgG,SAAU,EACVrG,WAAY9Q,EAAK8Q,WAEjByW,SAAU,GACV/lB,OAAO,IAWT,OARIuP,EAAOD,WAAWxO,MACpByO,EAAOD,WAAWxO,KAAKyO,IAErBlS,EAAqB,cAAe,EAAR2Y,GACxBxP,KAAQgG,GAAG4S,YACf5S,GAAG4S,UAAU5Y,GAAQ,GAGlB+I,CACR,EACDK,KAAAA,CAAML,GACJ,GAAI/C,GAAGwZ,SAASzW,GACd,MAAM,IAAI/C,GAAGkD,WAAW,GAEtBH,EAAO0W,WAAU1W,EAAO0W,SAAW,MACvC,IACM1W,EAAOD,WAAWM,OACpBL,EAAOD,WAAWM,MAAML,EAE3B,CAAC,MAAO7J,GACP,MAAMA,CAChB,CAAkB,QACR8G,GAAGgW,YAAYjT,EAAO6S,GAChC,CACQ7S,EAAO6S,GAAK,IACb,EACD4D,SAASzW,GACc,OAAdA,EAAO6S,GAEhBnP,MAAAA,CAAO1D,EAAQO,EAAQgG,GACrB,GAAItJ,GAAGwZ,SAASzW,GACd,MAAM,IAAI/C,GAAGkD,WAAW,GAE1B,IAAKH,EAAOI,WAAaJ,EAAOD,WAAW2D,OACzC,MAAM,IAAIzG,GAAGkD,WAAW,IAE1B,GAAc,GAAVoG,GAAyB,GAAVA,GAAyB,GAAVA,EAChC,MAAM,IAAItJ,GAAGkD,WAAW,IAI1B,OAFAH,EAAOoG,SAAWpG,EAAOD,WAAW2D,OAAO1D,EAAQO,EAAQgG,GAC3DvG,EAAOwW,SAAW,GACXxW,EAAOoG,QACf,EACDrW,IAAAA,CAAKiQ,EAAQ1M,EAAQiN,EAAQxJ,EAAQqP,GAEnC,GADApW,EAAOuQ,GAAU,GACbxJ,EAAS,GAAKqP,EAAW,EAC3B,MAAM,IAAInJ,GAAGkD,WAAW,IAE1B,GAAIlD,GAAGwZ,SAASzW,GACd,MAAM,IAAI/C,GAAGkD,WAAW,GAE1B,GAAiC,IAAb,QAAfH,EAAOyG,OACV,MAAM,IAAIxJ,GAAGkD,WAAW,GAE1B,GAAIlD,GAAGiH,MAAMlE,EAAO/Q,KAAK4T,MACvB,MAAM,IAAI5F,GAAGkD,WAAW,IAE1B,IAAKH,EAAOD,WAAWhQ,KACrB,MAAM,IAAIkN,GAAGkD,WAAW,IAE1B,IAAIwW,OAA6B,IAAZvQ,EACrB,GAAKuQ,GAEE,IAAK3W,EAAOI,SACjB,MAAM,IAAInD,GAAGkD,WAAW,SAFxBiG,EAAWpG,EAAOoG,SAIpB,IAAI1F,EAAYV,EAAOD,WAAWhQ,KAAKiQ,EAAQ1M,EAAQiN,EAAQxJ,EAAQqP,GAEvE,OADKuQ,IAAS3W,EAAOoG,UAAY1F,GAC1BA,CACR,EACDI,KAAAA,CAAMd,EAAQ1M,EAAQiN,EAAQxJ,EAAQqP,EAAUC,GAE9C,GADArW,EAAOuQ,GAAU,GACbxJ,EAAS,GAAKqP,EAAW,EAC3B,MAAM,IAAInJ,GAAGkD,WAAW,IAE1B,GAAIlD,GAAGwZ,SAASzW,GACd,MAAM,IAAI/C,GAAGkD,WAAW,GAE1B,KAAoB,QAAfH,EAAOyG,OACV,MAAM,IAAIxJ,GAAGkD,WAAW,GAE1B,GAAIlD,GAAGiH,MAAMlE,EAAO/Q,KAAK4T,MACvB,MAAM,IAAI5F,GAAGkD,WAAW,IAE1B,IAAKH,EAAOD,WAAWe,MACrB,MAAM,IAAI7D,GAAGkD,WAAW,IAEtBH,EAAOI,UAA2B,KAAfJ,EAAOyG,OAE5BxJ,GAAGyG,OAAO1D,EAAQ,EAAG,GAEvB,IAAI2W,OAA6B,IAAZvQ,EACrB,GAAKuQ,GAEE,IAAK3W,EAAOI,SACjB,MAAM,IAAInD,GAAGkD,WAAW,SAFxBiG,EAAWpG,EAAOoG,SAIpB,IAAIwQ,EAAe5W,EAAOD,WAAWe,MACnCd,EACA1M,EACAiN,EACAxJ,EACAqP,EACAC,GAGF,OADKsQ,IAAS3W,EAAOoG,UAAYwQ,GAC1BA,CACR,EACDjT,QAAAA,CAAS3D,EAAQO,EAAQxJ,GACvB,GAAIkG,GAAGwZ,SAASzW,GACd,MAAM,IAAI/C,GAAGkD,WAAW,GAE1B,GAAII,EAAS,GAAKxJ,GAAU,EAC1B,MAAM,IAAIkG,GAAGkD,WAAW,IAE1B,KAAoB,QAAfH,EAAOyG,OACV,MAAM,IAAIxJ,GAAGkD,WAAW,GAE1B,IAAKlD,GAAGmH,OAAOpE,EAAO/Q,KAAK4T,QAAU5F,GAAGiH,MAAMlE,EAAO/Q,KAAK4T,MACxD,MAAM,IAAI5F,GAAGkD,WAAW,IAE1B,IAAKH,EAAOD,WAAW4D,SACrB,MAAM,IAAI1G,GAAGkD,WAAW,KAE1BH,EAAOD,WAAW4D,SAAS3D,EAAQO,EAAQxJ,EAC5C,EACD6M,IAAAA,CAAK5D,EAAQjJ,EAAQqP,EAAUI,EAAMC,GAOnC,GAAY,EAAPD,KAA4B,EAARC,IAAiD,IAAb,QAAfzG,EAAOyG,OACnD,MAAM,IAAIxJ,GAAGkD,WAAW,GAE1B,GAAiC,IAAb,QAAfH,EAAOyG,OACV,MAAM,IAAIxJ,GAAGkD,WAAW,GAE1B,IAAKH,EAAOD,WAAW6D,KACrB,MAAM,IAAI3G,GAAGkD,WAAW,IAE1B,IAAKpJ,EACH,MAAM,IAAIkG,GAAGkD,WAAW,IAE1B,OAAOH,EAAOD,WAAW6D,KAAK5D,EAAQjJ,EAAQqP,EAAUI,EAAMC,EAC/D,EACD5C,MAAKA,CAAC7D,EAAQ1M,EAAQiN,EAAQxJ,EAAQ8P,KACpC7W,EAAOuQ,GAAU,GACZP,EAAOD,WAAW8D,MAGhB7D,EAAOD,WAAW8D,MAAM7D,EAAQ1M,EAAQiN,EAAQxJ,EAAQ8P,GAFtD,GAIXgQ,KAAAA,CAAM7W,EAAQ8W,EAAKC,GACjB,IAAK/W,EAAOD,WAAW8W,MACrB,MAAM,IAAI5Z,GAAGkD,WAAW,IAE1B,OAAOH,EAAOD,WAAW8W,MAAM7W,EAAQ8W,EAAKC,EAC7C,EACDC,QAAAA,CAAS/f,EAAM0Z,EAAO,IAGpB,GAFAA,EAAKlK,MAAQkK,EAAKlK,OAAS,EAC3BkK,EAAKsG,SAAWtG,EAAKsG,UAAY,SACX,SAAlBtG,EAAKsG,UAAyC,WAAlBtG,EAAKsG,SACnC,MAAM,IAAIvnB,MAAM,0BAA0BihB,EAAKsG,aAEjD,IAAIxc,EACAuF,EAAS/C,GAAG1L,KAAK0F,EAAM0Z,EAAKlK,OAE5B1P,EADOkG,GAAGuY,KAAKve,GACD+K,KACdkV,EAAM,IAAIrnB,WAAWkH,GAQzB,OAPAkG,GAAGlN,KAAKiQ,EAAQkX,EAAK,EAAGngB,EAAQ,GACV,SAAlB4Z,EAAKsG,SACPxc,EAAMnB,GAAkB4d,GACG,WAAlBvG,EAAKsG,WACdxc,EAAMyc,GAERja,GAAGoD,MAAML,GACFvF,CACR,EACD0c,SAAAA,CAAUlgB,EAAMnH,EAAM6gB,EAAO,CAAA,GAC3BA,EAAKlK,MAAQkK,EAAKlK,OAAS,IAC3B,IAAIzG,EAAS/C,GAAG1L,KAAK0F,EAAM0Z,EAAKlK,MAAOkK,EAAK9N,MAC5C,GAAmB,iBAAR/S,EAAkB,CAC3B,IAAIonB,EAAM,IAAIrnB,WAAWsO,GAAgBrO,GAAQ,GAC7CsnB,EAAiB7Y,GAAkBzO,EAAMonB,EAAK,EAAGA,EAAIngB,QACzDkG,GAAG6D,MAAMd,EAAQkX,EAAK,EAAGE,OAAgBhjB,EAAWuc,EAAKtK,OAC1D,KAAM,KAAIC,YAAY+Q,OAAOvnB,GAG5B,MAAM,IAAIJ,MAAM,yBAFhBuN,GAAG6D,MAAMd,EAAQlQ,EAAM,EAAGA,EAAKwnB,gBAAYljB,EAAWuc,EAAKtK,OAGrE,CACQpJ,GAAGoD,MAAML,EACV,EACD9C,IAAKA,IAAMD,GAAGgS,YACdsI,KAAAA,CAAMtgB,GACJ,IAAIkM,EAASlG,GAAGyT,WAAWzZ,EAAM,CAAEia,QAAQ,IAC3C,GAAoB,OAAhB/N,EAAOlU,KACT,MAAM,IAAIgO,GAAGkD,WAAW,IAE1B,IAAKlD,GAAGiH,MAAMf,EAAOlU,KAAK4T,MACxB,MAAM,IAAI5F,GAAGkD,WAAW,IAE1B,IAAI0R,EAAU5U,GAAGoV,gBAAgBlP,EAAOlU,KAAM,KAC9C,GAAI4iB,EACF,MAAM,IAAI5U,GAAGkD,WAAW0R,GAE1B5U,GAAGgS,YAAc9L,EAAOlM,IACzB,EACDugB,wBAAAA,GACEva,GAAG2X,MAAM,QACT3X,GAAG2X,MAAM,SACT3X,GAAG2X,MAAM,iBACV,EACD6C,oBAAAA,GAEExa,GAAG2X,MAAM,QAET3X,GAAG6C,eAAe7C,GAAGwW,QAAQ,EAAG,GAAI,CAClC1jB,KAAMA,IAAM,EACZ+Q,MAAOA,CAACd,EAAQ1M,EAAQiN,EAAQxJ,EAAQyJ,IAAQzJ,IAElDkG,GAAG+X,MAAM,YAAa/X,GAAGwW,QAAQ,EAAG,IAIpCpU,GAAII,SAASxC,GAAGwW,QAAQ,EAAG,GAAIpU,GAAI2B,iBACnC3B,GAAII,SAASxC,GAAGwW,QAAQ,EAAG,GAAIpU,GAAIyC,kBACnC7E,GAAG+X,MAAM,WAAY/X,GAAGwW,QAAQ,EAAG,IACnCxW,GAAG+X,MAAM,YAAa/X,GAAGwW,QAAQ,EAAG,IAGpC,IAAIiE,EAAe,IAAI7nB,WAAW,MAChC8nB,EAAa,EACXC,EAAaA,KACI,IAAfD,IACFA,EAAalb,GAAWib,GAAcJ,YAEjCI,IAAeC,IAExB1a,GAAG4a,aAAa,OAAQ,SAAUD,GAClC3a,GAAG4a,aAAa,OAAQ,UAAWD,GAGnC3a,GAAG2X,MAAM,YACT3X,GAAG2X,MAAM,eACV,EACDkD,wBAAAA,GAGE7a,GAAG2X,MAAM,SACT,IAAImD,EAAY9a,GAAG2X,MAAM,cACzB3X,GAAG2X,MAAM,iBACT3X,GAAGyF,MACD,CACEA,KAAAA,GACE,IAAIzT,EAAOgO,GAAG0F,WAAWoV,EAAW,KAAM,MAAwB,IAclE,OAbA9oB,EAAKgU,SAAW,CACdE,MAAAA,CAAOP,EAAQjM,GACb,IAAIkc,GAAMlc,EACNqJ,EAAS/C,GAAG6V,iBAAiBD,GAC7BpY,EAAM,CACRmI,OAAQ,KACRF,MAAO,CAAE4O,WAAY,QACrBrO,SAAU,CAAEc,SAAUA,IAAM/D,EAAO/I,OAGrC,OADAwD,EAAImI,OAASnI,EACNA,CACzB,GAEqBxL,CACrB,GAEU,CAAA,EACA,gBAEH,EACD+oB,qBAAAA,CAAsBpY,EAAOC,EAAQpP,GAS/BmP,EACF3C,GAAG4a,aAAa,OAAQ,QAASjY,GAEjC3C,GAAGwG,QAAQ,WAAY,cAErB5D,EACF5C,GAAG4a,aAAa,OAAQ,SAAU,KAAMhY,GAExC5C,GAAGwG,QAAQ,WAAY,eAErBhT,EACFwM,GAAG4a,aAAa,OAAQ,SAAU,KAAMpnB,GAExCwM,GAAGwG,QAAQ,YAAa,eAI1B,IAAIwU,EAAQhb,GAAG1L,KAAK,aAAc,GAC9B2mB,EAASjb,GAAG1L,KAAK,cAAe,GAChC4mB,EAASlb,GAAG1L,KAAK,cAAe,GACpCvB,EAAoB,IAAbioB,EAAMpF,GAAU,6BAA6BoF,EAAMpF,OAC1D7iB,EAAqB,IAAdkoB,EAAOrF,GAAU,8BAA8BqF,EAAOrF,OAC7D7iB,EAAqB,IAAdmoB,EAAOtF,GAAU,8BAA8BsF,EAAOtF,MAC9D,EACDuF,UAAAA,GAEE,CAAC,IAAIjqB,QAASuhB,IACZzS,GAAGwI,cAAciK,GAAQ,IAAIzS,GAAGkD,WAAWuP,GAC3CzS,GAAGwI,cAAciK,GAAM2I,MAAQ,8BAGjCpb,GAAG+R,UAAY,IAAI/P,MAAM,MAEzBhC,GAAGyF,MAAMF,GAAO,CAAE,EAAE,KAEpBvF,GAAGua,2BACHva,GAAGwa,uBACHxa,GAAG6a,2BAEH7a,GAAG0S,YAAc,CACfnN,MAAOA,GAEV,EACDjD,IAAAA,CAAKK,EAAOC,EAAQpP,GAClBT,GACGiN,GAAGiS,YACJ,gLAEFjS,GAAGiS,aAAc,EAGjBtP,IAAU9R,EAAc,MACxB+R,IAAW/R,EAAe,OAC1B2C,IAAU3C,EAAe,OAEzBmP,GAAG+a,sBAAsBpY,EAAOC,EAAQpP,EACzC,EACD6nB,IAAAA,GACErb,GAAGiS,aAAc,EAEjBqJ,GAAQ,GAER,IAAK,IAAIld,EAAI,EAAGA,EAAI4B,GAAG6R,QAAQ/X,OAAQsE,IAAK,CAC1C,IAAI2E,EAAS/C,GAAG6R,QAAQzT,GACnB2E,GAGL/C,GAAGoD,MAAML,EACnB,CACO,EACDwY,UAAAA,CAAWvhB,EAAMwhB,GACf,IAAIhe,EAAMwC,GAAGyb,YAAYzhB,EAAMwhB,GAC/B,OAAKhe,EAAIke,OAGFle,EAAIuV,OAFF,IAGV,EACD0I,WAAAA,CAAYzhB,EAAMwhB,GAEhB,IAEExhB,GADIkM,EAASlG,GAAGyT,WAAWzZ,EAAM,CAAEia,QAASuH,KAC9BxhB,KACd,MAAOd,GAAG,CACZ,IAAIsE,EAAM,CACR4W,QAAQ,EACRsH,QAAQ,EACRloB,MAAO,EACPkG,KAAM,KACNM,KAAM,KACN+Y,OAAQ,KACR4I,cAAc,EACdC,WAAY,KACZC,aAAc,MAEhB,IACE,IAAI3V,EAASlG,GAAGyT,WAAWzZ,EAAM,CAAE2L,QAAQ,IAC3CnI,EAAIme,cAAe,EACnBne,EAAIoe,WAAa1V,EAAOlM,KACxBwD,EAAIqe,aAAe3V,EAAOlU,KAC1BwL,EAAI9D,KAAOgE,GAAKwB,SAASlF,GACzBkM,EAASlG,GAAGyT,WAAWzZ,EAAM,CAAEia,QAASuH,IACxChe,EAAIke,QAAS,EACble,EAAIxD,KAAOkM,EAAOlM,KAClBwD,EAAIuV,OAAS7M,EAAOlU,KACpBwL,EAAI9D,KAAOwM,EAAOlU,KAAK0H,KACvB8D,EAAI4W,OAAyB,MAAhBlO,EAAOlM,IACrB,CAAC,MAAOd,GACPsE,EAAIhK,MAAQ0F,EAAEkZ,KACxB,CACQ,OAAO5U,CACR,EACDse,UAAAA,CAAWnW,EAAQ3L,EAAM+P,EAASC,GAChCrE,EAA0B,iBAAVA,EAAqBA,EAAS3F,GAAGmU,QAAQxO,GAEzD,IADA,IAAI1H,EAAQjE,EAAK0E,MAAM,KAAKqd,UACrB9d,EAAMnE,QAAQ,CACnB,IAAIkiB,EAAO/d,EAAM6Y,MACjB,GAAKkF,EAAL,CACA,IAAInI,EAAUnW,GAAK2B,MAAMsG,EAAQqW,GACjC,IACEhc,GAAG2X,MAAM9D,EACV,CAAC,MAAO3a,GACnB,CAEUyM,EAASkO,CAPE,CAQrB,CACQ,OAAOA,CACR,EACDoI,UAAAA,CAAWtW,EAAQjM,EAAMwiB,EAAYnS,EAASC,GAC5C,IAAIhQ,EAAO0D,GAAK2B,MAAuB,iBAAVsG,EAAqBA,EAAS3F,GAAGmU,QAAQxO,GAASjM,GAC3EkM,EAAOkE,GAAWC,EAASC,GAC/B,OAAOhK,GAAG0X,OAAO1d,EAAM4L,EACxB,EACDuW,cAAAA,CAAexW,EAAQjM,EAAM7G,EAAMkX,EAASC,EAAUZ,GACpD,IAAIpP,EAAON,EACPiM,IACFA,EAA0B,iBAAVA,EAAqBA,EAAS3F,GAAGmU,QAAQxO,GACzD3L,EAAON,EAAOgE,GAAK2B,MAAMsG,EAAQjM,GAAQiM,GAE3C,IAAIC,EAAOkE,GAAWC,EAASC,GAC3BhY,EAAOgO,GAAG0X,OAAO1d,EAAM4L,GAC3B,GAAI/S,EAAM,CACR,GAAmB,iBAARA,EAAkB,CAE3B,IADA,IAAI0N,EAAM,IAAIyB,MAAMnP,EAAKiH,QAChBsE,EAAI,EAAG+C,EAAMtO,EAAKiH,OAAQsE,EAAI+C,IAAO/C,EAAGmC,EAAInC,GAAKvL,EAAKwO,WAAWjD,GAC1EvL,EAAO0N,CACnB,CAEUP,GAAG0Y,MAAM1mB,EAAa,IAAP4T,GACf,IAAI7C,EAAS/C,GAAG1L,KAAKtC,EAAM,KAC3BgO,GAAG6D,MAAMd,EAAQlQ,EAAM,EAAGA,EAAKiH,OAAQ,EAAGsP,GAC1CpJ,GAAGoD,MAAML,GACT/C,GAAG0Y,MAAM1mB,EAAM4T,EACzB,CACO,EACDgV,YAAAA,CAAajV,EAAQjM,EAAMiJ,EAAOC,GAChC,IAAI5I,EAAO0D,GAAK2B,MAAuB,iBAAVsG,EAAqBA,EAAS3F,GAAGmU,QAAQxO,GAASjM,GAC3EkM,EAAOkE,KAAanH,IAASC,GACjC5C,GAAG4a,aAAatE,QAAU,GAC1B,IAAI7T,EAAMzC,GAAGwW,QAAQxW,GAAG4a,aAAatE,QAAS,GAgD9C,OA7CAtW,GAAG6C,eAAeJ,EAAK,CACrBnO,IAAAA,CAAKyO,GACHA,EAAOI,UAAW,CACnB,EACDC,KAAAA,CAAML,GAEAH,GAAQvM,QAAQyD,QAClB8I,EAAO,GAEV,EACD9P,IAAAA,CAAKiQ,EAAQ1M,EAAQiN,EAAQxJ,EAAQyJ,GAEnC,IADA,IAAIE,EAAY,EACPrF,EAAI,EAAGA,EAAItE,EAAQsE,IAAK,CAC/B,IAAIW,EACJ,IACEA,EAAS4D,GACV,CAAC,MAAOzJ,GACP,MAAM,IAAI8G,GAAGkD,WAAW,GACxC,CACc,QAAe/L,IAAX4H,GAAsC,IAAd0E,EAC1B,MAAM,IAAIzD,GAAGkD,WAAW,GAE1B,GAAInE,QAAyC,MAC7C0E,IACApN,EAAOiN,EAASlF,GAAKW,CACnC,CAIY,OAHI0E,IACFV,EAAO/Q,KAAK0R,UAAYC,KAAKC,OAExBH,CACR,EACDI,KAAAA,CAAMd,EAAQ1M,EAAQiN,EAAQxJ,EAAQyJ,GACpC,IAAK,IAAInF,EAAI,EAAGA,EAAItE,EAAQsE,IAC1B,IACEwE,EAAOvM,EAAOiN,EAASlF,GACxB,CAAC,MAAOlF,GACP,MAAM,IAAI8G,GAAGkD,WAAW,GACxC,CAKY,OAHIpJ,IACFiJ,EAAO/Q,KAAK0R,UAAYC,KAAKC,OAExBxF,CACnB,IAEe4B,GAAG+X,MAAM/d,EAAM4L,EAAMnD,EAC7B,EACD2Z,aAAAA,CAAcC,GACZ,GAAIA,EAAI7I,UAAY6I,EAAI9I,UAAY8I,EAAIxV,MAAQwV,EAAInV,SAAU,OAAO,EACrE,GAA6B,oBAAlB7S,eACT,MAAM,IAAI5B,MACR,oMAIF,IACE4pB,EAAInV,SAAW/U,EAAWkqB,EAAI9rB,KAC9B8rB,EAAIjV,UAAYiV,EAAInV,SAASpN,MAC9B,CAAC,MAAOZ,GACP,MAAM,IAAI8G,GAAGkD,WAAW,GACpC,CAEO,EACDoZ,cAAAA,CAAe3W,EAAQjM,EAAMnJ,EAAKwZ,EAASC,GAGzC,MAAMuS,EACJpK,WAAAA,GACEK,KAAKgK,aAAc,EACnBhK,KAAKiK,OAAS,EAC1B,CACUlrB,GAAAA,CAAIgL,GACF,KAAIA,EAAMiW,KAAK1Y,OAAS,GAAKyC,EAAM,GAAnC,CAGA,IAAImgB,EAAcngB,EAAMiW,KAAKmK,UACzBC,EAAYrgB,EAAMiW,KAAKmK,UAAa,EACxC,OAAOnK,KAAKqK,OAAOD,GAAUF,EAHzC,CAIA,CACUI,aAAAA,CAAcD,GACZrK,KAAKqK,OAASA,CAC1B,CACUE,WAAAA,GAEE,IAAI3oB,EAAM,IAAIC,eAGd,GAFAD,EAAIE,KAAK,OAAQ/D,GAAK,GACtB6D,EAAII,KAAK,QACFJ,EAAIY,QAAU,KAAOZ,EAAIY,OAAS,KAAuB,MAAfZ,EAAIY,QACnD,MAAM,IAAIvC,MAAM,iBAAmBlC,EAAM,aAAe6D,EAAIY,QAC9D,IACIgoB,EADAC,EAAaC,OAAO9oB,EAAI+oB,kBAAkB,mBAE1CC,GACDJ,EAAS5oB,EAAI+oB,kBAAkB,mBAAgC,UAAXH,EACnDK,GACDL,EAAS5oB,EAAI+oB,kBAAkB,sBAAmC,SAAXH,EAEtDL,EAAY,QAEXS,IAAgBT,EAAYM,GAGjC,IA0BIK,EAAY9K,KAChB8K,EAAUR,cAAeF,IACvB,IAAIpc,EAAQoc,EAAWD,EACnBlc,GAAOmc,EAAW,GAAKD,EAAY,EAKvC,GAJAlc,EAAM3I,KAAK8I,IAAIH,EAAKwc,EAAa,QACQ,IAA9BK,EAAUb,OAAOG,KAC1BU,EAAUb,OAAOG,GAhCTW,EAACnd,EAAMC,KACjB,GAAID,EAAOC,EACT,MAAM,IAAI5N,MAAM,kBAAoB2N,EAAO,KAAOC,EAAK,4BACzD,GAAIA,EAAK4c,EAAa,EACpB,MAAM,IAAIxqB,MAAM,QAAUwqB,EAAa,uCAGzC,IAAI7oB,EAAM,IAAIC,eAYd,GAXAD,EAAIE,KAAK,MAAO/D,GAAK,GACjB0sB,IAAeN,GACjBvoB,EAAIopB,iBAAiB,QAAS,SAAWpd,EAAO,IAAMC,GAGxDjM,EAAIG,aAAe,cACfH,EAAIqpB,kBACNrpB,EAAIqpB,iBAAiB,sCAGvBrpB,EAAII,KAAK,QACFJ,EAAIY,QAAU,KAAOZ,EAAIY,OAAS,KAAuB,MAAfZ,EAAIY,QACnD,MAAM,IAAIvC,MAAM,iBAAmBlC,EAAM,aAAe6D,EAAIY,QAC9D,YAAqBmC,IAAjB/C,EAAIK,SACC,IAAI7B,WAAwCwB,EAAIK,UAAY,IAE9DmN,GAAmBxN,EAAIspB,cAAgB,IAAI,IAQnBH,CAAM/c,EAAOC,SAEH,IAA9B6c,EAAUb,OAAOG,GAC1B,MAAM,IAAInqB,MAAM,iBAClB,OAAO6qB,EAAUb,OAAOG,MAGtBS,GAAaJ,IAEfN,EAAYM,EAAa,EACzBA,EAAazK,KAAKqK,OAAO,GAAG/iB,OAC5B6iB,EAAYM,EACZhoB,EAAI,gFAGNud,KAAKmL,QAAUV,EACfzK,KAAKoL,WAAajB,EAClBnK,KAAKgK,aAAc,CAC/B,CACU,UAAI1iB,GAIF,OAHK0Y,KAAKgK,aACRhK,KAAKuK,cAEAvK,KAAKmL,OACxB,CACU,aAAIhB,GAIF,OAHKnK,KAAKgK,aACRhK,KAAKuK,cAEAvK,KAAKoL,UACxB,EAGQ,GAA6B,oBAAlBvpB,eAA+B,CACxC,IAAKzC,EACH,KAAM,sHACR,IACIsqB,EAAa,CAAE1I,UAAU,EAAOtM,SADpB,IAAIqV,EAE9B,MACcL,EAAa,CAAE1I,UAAU,EAAOjjB,IAAKA,GAG3C,IAAIyB,EAAOgO,GAAGic,WAAWtW,EAAQjM,EAAMwiB,EAAYnS,EAASC,GAIxDkS,EAAWhV,SACblV,EAAKkV,SAAWgV,EAAWhV,SAClBgV,EAAW3rB,MACpByB,EAAKkV,SAAW,KAChBlV,EAAKzB,IAAM2rB,EAAW3rB,KAGxBa,OAAOysB,iBAAiB7rB,EAAM,CAC5BoV,UAAW,CACT7V,IAAK,WACH,OAAOihB,KAAKtL,SAASpN,MACnC,KAIQ,IAAIgJ,EAAa,CAAA,EASjB,SAASgb,EAAY/a,EAAQ1M,EAAQiN,EAAQxJ,EAAQqP,GACnD,IAAIjC,EAAWnE,EAAO/Q,KAAKkV,SAC3B,GAAIiC,GAAYjC,EAASpN,OAAQ,OAAO,EACxC,IAAIiL,EAAOjN,KAAK8I,IAAIsG,EAASpN,OAASqP,EAAUrP,GAEhD,GADA/G,EAAOgS,GAAQ,GACXmC,EAASnJ,MAEX,IAAK,IAAIK,EAAI,EAAGA,EAAI2G,EAAM3G,IACxB/H,EAAOiN,EAASlF,GAAK8I,EAASiC,EAAW/K,QAG3C,IAASA,EAAI,EAAGA,EAAI2G,EAAM3G,IAExB/H,EAAOiN,EAASlF,GAAK8I,EAAS3V,IAAI4X,EAAW/K,GAGjD,OAAO2G,CACjB,CAiBQ,OA1CW3T,OAAO4X,KAAKhX,EAAK8Q,YACvB5R,QAAS6X,IACZ,IAAIgV,EAAK/rB,EAAK8Q,WAAWiG,GACzBjG,EAAWiG,GAAO,IAAInP,KACpBoG,GAAGoc,cAAcpqB,GACV+rB,KAAMnkB,MAsBjBkJ,EAAWhQ,KAAO,CAACiQ,EAAQ1M,EAAQiN,EAAQxJ,EAAQqP,KACjDnJ,GAAGoc,cAAcpqB,GACV8rB,EAAY/a,EAAQ1M,EAAQiN,EAAQxJ,EAAQqP,IAGrDrG,EAAW6D,KAAO,CAAC5D,EAAQjJ,EAAQqP,EAAUI,EAAMC,KACjDxJ,GAAGoc,cAAcpqB,GACjB,IAAI2J,EAAMuJ,GAAUpL,GACpB,IAAK6B,EACH,MAAM,IAAIqE,GAAGkD,WAAW,IAG1B,OADA4a,EAAY/a,EAAQvN,EAAOmG,EAAK7B,EAAQqP,GACjC,CAAExN,MAAK8N,WAAW,IAE3BzX,EAAK8Q,WAAaA,EACX9Q,CACR,EACDgsB,YAAAA,GACExsB,EAAM,gEACP,EACDysB,YAAAA,GACEzsB,EAAM,yDACP,EACD0sB,UAAAA,GACE1sB,EAAM,yDACP,EACD2sB,QAAAA,GACE3sB,EAAM,sDACP,EACD0T,SAAAA,GACE1T,EAAM,qEACP,EACD4sB,eAAAA,GACE5sB,EAAM,kEACd,GAGQ8L,GAAW,CACb+gB,iBAAkB,EAClBC,WAAAA,CAAYC,EAAOvkB,EAAMwkB,GACvB,GAAI9gB,GAAKC,MAAM3D,GACb,OAAOA,EAGT,IAAIiF,EAOJ,GALEA,GADa,MAAXsf,EACIve,GAAGC,MAEO3C,GAASmhB,gBAAgBF,GACzBvkB,KAEC,GAAfA,EAAKF,OAAa,CACpB,IAAK0kB,EACH,MAAM,IAAIxe,GAAGkD,WAAW,IAE1B,OAAOjE,CACjB,CACQ,OAAOvB,GAAK2B,MAAMJ,EAAKjF,EACxB,EACD0kB,MAAAA,CAAOtjB,EAAMpB,EAAMigB,GACjB,IAAI1B,EAAOnd,EAAKpB,GAChBpE,EAAOqkB,GAAO,GAAK1B,EAAK9V,IACxB7M,EAAQqkB,EAAM,GAAM,GAAK1B,EAAK3S,KAC9B/P,EAASokB,EAAM,GAAM,GAAK1B,EAAKvQ,MAC/BpS,EAAQqkB,EAAM,IAAO,GAAK1B,EAAKtQ,IAC/BrS,EAAQqkB,EAAM,IAAO,GAAK1B,EAAKrQ,IAC/BtS,EAAQqkB,EAAM,IAAO,GAAK1B,EAAKtV,KAC9B3J,EAAU,CACTif,EAAKxT,OAAS,GACZ1L,EAAakf,EAAKxT,MACnBjN,KAAK6mB,IAAItlB,IAAe,EACrBA,EAAa,GACVvB,KAAK8mB,MAAMvlB,EAAa,cAAkB,KACxCvB,KAAKmN,MAAM5L,MAAiBA,IAAe,IAAM,cAAkB,EACxE,IAEHzD,EAAQqkB,EAAM,IAAO,GAAK3gB,EAAQ,GAClC1D,EAAQqkB,EAAM,IAAO,GAAK3gB,EAAQ,GACrC1D,EAAQqkB,EAAM,IAAO,GAAK,KAC1BrkB,EAAQqkB,EAAM,IAAO,GAAK1B,EAAKhQ,OAC/B,IAAIJ,EAAQoQ,EAAKpQ,MAAM0W,UACnBzW,EAAQmQ,EAAKnQ,MAAMyW,UACnBxW,EAAQkQ,EAAKlQ,MAAMwW,UAgDvB,OA/CCvlB,EAAU,CACTxB,KAAK8mB,MAAMzW,EAAQ,OAAU,GAC3B9O,EAAavB,KAAK8mB,MAAMzW,EAAQ,MACjCrQ,KAAK6mB,IAAItlB,IAAe,EACrBA,EAAa,GACVvB,KAAK8mB,MAAMvlB,EAAa,cAAkB,KACxCvB,KAAKmN,MAAM5L,MAAiBA,IAAe,IAAM,cAAkB,EACxE,IAEHzD,EAAQqkB,EAAM,IAAO,GAAK3gB,EAAQ,GAClC1D,EAAQqkB,EAAM,IAAO,GAAK3gB,EAAQ,GACrCzD,EAASokB,EAAM,IAAO,GAAM9R,EAAQ,IAAQ,IAAO,IAClD7O,EAAU,CACTxB,KAAK8mB,MAAMxW,EAAQ,OAAU,GAC3B/O,EAAavB,KAAK8mB,MAAMxW,EAAQ,MACjCtQ,KAAK6mB,IAAItlB,IAAe,EACrBA,EAAa,GACVvB,KAAK8mB,MAAMvlB,EAAa,cAAkB,KACxCvB,KAAKmN,MAAM5L,MAAiBA,IAAe,IAAM,cAAkB,EACxE,IAEHzD,EAAQqkB,EAAM,IAAO,GAAK3gB,EAAQ,GAClC1D,EAAQqkB,EAAM,IAAO,GAAK3gB,EAAQ,GACrCzD,EAASokB,EAAM,IAAO,GAAM7R,EAAQ,IAAQ,IAAO,IAClD9O,EAAU,CACTxB,KAAK8mB,MAAMvW,EAAQ,OAAU,GAC3BhP,EAAavB,KAAK8mB,MAAMvW,EAAQ,MACjCvQ,KAAK6mB,IAAItlB,IAAe,EACrBA,EAAa,GACVvB,KAAK8mB,MAAMvlB,EAAa,cAAkB,KACxCvB,KAAKmN,MAAM5L,MAAiBA,IAAe,IAAM,cAAkB,EACxE,IAEHzD,EAAQqkB,EAAM,IAAO,GAAK3gB,EAAQ,GAClC1D,EAAQqkB,EAAM,IAAO,GAAK3gB,EAAQ,GACrCzD,EAASokB,EAAM,IAAO,GAAM5R,EAAQ,IAAQ,IAAO,IAClD/O,EAAU,CACTif,EAAKxQ,MAAQ,GACX1O,EAAakf,EAAKxQ,KACnBjQ,KAAK6mB,IAAItlB,IAAe,EACrBA,EAAa,GACVvB,KAAK8mB,MAAMvlB,EAAa,cAAkB,KACxCvB,KAAKmN,MAAM5L,MAAiBA,IAAe,IAAM,cAAkB,EACxE,IAEHzD,EAAQqkB,EAAM,IAAO,GAAK3gB,EAAQ,GAClC1D,EAAQqkB,EAAM,IAAO,GAAK3gB,EAAQ,GAC9B,CACR,EACDwlB,OAAAA,CAAQC,EAAMhc,EAAQ5B,EAAKqI,EAAOlG,GAChC,IAAKtD,GAAGmH,OAAOpE,EAAO/Q,KAAK4T,MACzB,MAAM,IAAI5F,GAAGkD,WAAW,IAE1B,GAAY,EAARsG,EAEF,OAAO,EAET,IAAInT,EAASZ,EAAOsI,MAAMghB,EAAMA,EAAO5d,GACvCnB,GAAG4G,MAAM7D,EAAQ1M,EAAQiN,EAAQnC,EAAKqI,EACvC,EACDiV,gBAAgB7I,GACD5V,GAAG6V,iBAAiBD,GAGnCrY,aAASpG,EACT6nB,OAAOrjB,GACKyB,GAAazB,IA2DvBsjB,GAA6BA,CAACC,EAAIC,KACpCpsB,EAAOmsB,GAAMA,IAAO,GAAKA,IAAY,EAALA,IAChCnsB,EAAOosB,KAAa,EAALA,IACPA,EAAK,UAAc,EAAI,UAAaD,GAAMA,IAAO,GAAU,WAALC,EAAkB1iB,KAe9E2iB,GAAeA,CAACviB,EAAKwiB,EAAQ5d,KAC/B1O,EAC4B,iBAAnB0O,EACP,6HAEKH,GAAkBzE,EAAKpH,EAAQ4pB,EAAQ5d,IAuR5C6d,GAA6B,CAAC,EAAG,GAAI,GAAI,GAAI,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,KAEhFC,GAAgC,CAAC,EAAG,GAAI,GAAI,GAAI,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,KAuGnFC,GAAcza,IAChB,IAAI3O,EAAIf,EAAWgB,OACfopB,GAAU1a,EAAO3O,EAAEikB,WAAa,OAAS,MAAS,EACtD,IAIE,OAFAhlB,EAAWqqB,KAAKD,GAChBtpB,IACO,CACR,CAAC,MAAO+C,GACP/D,EACE,2CAA2CiB,EAAEikB,uBAAuBtV,2BAA8B7L,IAE5G,GA6DQymB,GAAM,CAAA,EAKNC,GAAgBA,KAClB,IAAKA,GAAcC,QAAS,CAG1B,IAKIC,EAAM,CACRC,KAAM,WACNC,QAAS,WACTtiB,KAAM,IACNuiB,IAAK,IACLC,KAAM,iBACNC,MATuB,iBAAbC,WAAyBA,UAAUC,WAAaD,UAAUC,UAAU,IAC5E,KACAnsB,QAAQ,IAAK,KAAO,SAQtBosB,EAlBG/tB,GAAe,kBAqBpB,IAAK,IAAIguB,KAAKZ,QAIGxoB,IAAXwoB,GAAIY,UAAyBT,EAAIS,GAChCT,EAAIS,GAAKZ,GAAIY,GAEpB,IAAIV,EAAU,GACd,IAAK,IAAIU,KAAKT,EACZD,EAAQ9e,KAAK,GAAGwf,KAAKT,EAAIS,MAE3BX,GAAcC,QAAUA,CAChC,CACM,OAAOD,GAAcC,SAgJnBW,GAAkB,GAIlBC,GAAqBC,IACvB,IAAItlB,EAAOolB,GAAgBE,GAS3B,OARKtlB,IACCslB,GAAWF,GAAgB1mB,SAAQ0mB,GAAgB1mB,OAAS4mB,EAAU,GAC1EF,GAAgBE,GAAWtlB,EAAO8G,GAAU3Q,IAAImvB,IAElD3tB,EACEmP,GAAU3Q,IAAImvB,IAAYtlB,EAC1B,8DAEKA,GAGLulB,GAAqC,oBAAfvkB,YAA6B,IAAIA,YAAY,iBAAcjF,EAmCjFypB,GAAgBA,CAACC,EAAGC,KACtB/tB,EAAO8tB,EAAI,OACPA,EAAI,IACNC,EAAO/f,KAAK8f,GAEZC,EAAO/f,KAAK8f,EAAI,IAAM,IAAKA,GAAK,IAwDhCE,GAA0BA,CAAC3lB,EAAM4lB,KAUnC,GATAjuB,GACGiuB,EAAI3L,SAAS,KACd,yEAOiC,mBAAxB9f,YAAY0rB,SACrB,OAAO,IAAI1rB,YAAY0rB,SA/DLD,KACpBjuB,GACGiuB,EAAI3L,SAAS,KACd,yEAcF,IAZA,IAAI6L,EAAY,CACd9iB,EAAG,MACH+iB,EAAG,MACHzuB,EAAG,MACHolB,EAAG,MACH5e,EAAG,YACH0F,EAAG,OAED3M,EAAO,CACTmvB,WAAY,GACZC,QAAmB,KAAVL,EAAI,GAAY,GAAK,CAACE,EAAUF,EAAI,MAEtC5iB,EAAI,EAAGA,EAAI4iB,EAAIlnB,SAAUsE,EAChCrL,EAAOiuB,EAAI5iB,KAAM8iB,EAAW,2BAA6BF,EAAI5iB,IAC7DnM,EAAKmvB,WAAWrgB,KAAKmgB,EAAUF,EAAI5iB,KAErC,OAAOnM,GA0C2BqvB,CAAeN,GAAM5lB,GAKvD,IAAImmB,EAAkB,CACpB,GA7CmBC,EAACR,EAAKF,KAC3B,IAAIW,EAAST,EAAIjjB,MAAM,EAAG,GACtB2jB,EAAWV,EAAIjjB,MAAM,GACrB4jB,EAAY,CACdvjB,EAAG,IACHQ,EAAG,IACHuiB,EAAG,IACHzuB,EAAG,IACHolB,EAAG,IACH5e,EAAG,KAIL4nB,EAAO/f,KAAK,IACZ6f,GAAcc,EAAS5nB,OAAQgnB,GAC/B,IAAK,IAAI1iB,EAAI,EAAGA,EAAIsjB,EAAS5nB,SAAUsE,EACrCrL,EAAO2uB,EAAStjB,KAAMujB,EAAW,2BAA6BD,EAAStjB,IACvE0iB,EAAO/f,KAAK4gB,EAAUD,EAAStjB,KAKnB,KAAVqjB,EACFX,EAAO/f,KAAK,GAEZ+f,EAAO/f,KAAK,EAAM4gB,EAAUF,KAsB9BD,CAAiBR,EAAKO,GAGtB,IAAIK,EAAQ,CACV,EACA,GACA,IACA,IACA,EACA,EACA,EACA,EACA,GAGFhB,GAAcW,EAAgBznB,OAAQ8nB,GACtCA,EAAM7gB,QAAQwgB,GAGdK,EAAM7gB,KACJ,EACA,EAEA,EACA,EACA,IACA,EACA,IACA,EACA,EACA,EACA,EAEA,EACA,EACA,IACA,EACA,GAKF,IAAI8gB,EAAS,IAAItsB,YAAY1E,OAAO,IAAI+B,WAAWgvB,IAGnD,OAFe,IAAIrsB,YAAYusB,SAASD,EAAQ,CAAE3oB,EAAG,CAAExG,EAAG0I,KAC/B2mB,QAAW,GAkBpCC,GAAsB5mB,IAEnB+G,KACHA,GAAsB,IAAI8f,QAjBTC,EAAC5e,EAAQ4Q,KAC5B,GAAI/R,GACF,IAAK,IAAI/D,EAAIkF,EAAQlF,EAAIkF,EAAS4Q,EAAO9V,IAAK,CAC5C,IAAI+jB,EAAO1B,GAAkBriB,GAEzB+jB,GACFhgB,GAAoB1Q,IAAI0wB,EAAM/jB,EAE1C,GAUQ8jB,CAAe,EAAGhgB,GAAUpI,SAEvBqI,GAAoB5Q,IAAI6J,IAAS,GAGtCgnB,GAAmB,GAmBnBC,GAAoBA,CAAC9lB,EAAKnB,KAC5B8G,GAAUzQ,IAAI8K,EAAKnB,GAInBolB,GAAgBjkB,GAAO2F,GAAU3Q,IAAIgL,IAiDnC+lB,GAAcC,GAAOC,GAAyBD,GAc9CE,GAAQA,CAACC,EAAOC,EAAYC,EAAUhpB,EAAM8Z,KAE9C,IAAImP,EAAM,CACRC,OAASjmB,IACP,IAAIW,EAAM,EAKV,OAJIX,SAA6C,IAARA,IAEvCW,EApBmBX,KACzB,IAAIkI,EAAO7D,GAAgBrE,GAAO,EAC9BW,EAAM8kB,GAAWvd,GAErB,OADAqa,GAAaviB,EAAKW,EAAKuH,GAChBvH,GAgBKulB,CAAoBlmB,IAErBW,GAETwlB,MAAQziB,IACN,IAlCoByiB,EAAO3sB,EAkCvBmH,EAAM8kB,GAAW/hB,EAAIzG,QAEzB,OApC2BzD,EAmCHmH,EAlC5BzK,GADwBiwB,EAmCDziB,GAjCfzG,QAAU,EAChB,mFAEFtE,EAAM/D,IAAIuxB,EAAO3sB,GA+BNmH,IAYPpC,EAtDUsnB,KACd,IAAItnB,EAAOvK,EAAO,IAAM6xB,GAExB,OADA3vB,EAAOqI,EAAM,gCAAkCsnB,EAAQ,8BAChDtnB,GAmDI6nB,CAASP,GAChBQ,EAAQ,GACR9H,EAAQ,EAEZ,GADAroB,EAAsB,UAAf4vB,EAAwB,sCAC3B/oB,EACF,IAAK,IAAIwE,EAAI,EAAGA,EAAIxE,EAAKE,OAAQsE,IAAK,CACpC,IAAI+kB,EAAYN,EAAID,EAASxkB,IACzB+kB,GACY,IAAV/H,IAAaA,EAAQnf,MACzBinB,EAAM9kB,GAAK+kB,EAAUvpB,EAAKwE,KAE1B8kB,EAAM9kB,GAAKxE,EAAKwE,EAE5B,CAEM,IAAIZ,EAAMpC,KAAQ8nB,GAOlB,OADA1lB,EALA,SAAgBA,GAEd,OADc,IAAV4d,GAAatf,GAAasf,GAzBhC,SAA4B5d,GAC1B,MAAmB,WAAfmlB,EACKvlB,GAAaI,GAEH,YAAfmlB,EAAiCS,QAAQ5lB,GACtCA,CACf,CAoBe6lB,CAAmB7lB,EAClC,CAEY8lB,CAAO9lB,IA0CfwC,GAAGujB,oBAt+F0BC,CAC3B7d,EACAjM,EACAnJ,EACAwZ,EACAC,EACAyZ,EACAC,EACAC,EACAva,EACAwa,KAIA,IAAIC,EAAWnqB,EAAOmG,GAAQ7O,QAAQ0M,GAAK2B,MAAMsG,EAAQjM,IAASiM,EAC9D7M,EAAMP,EAAuB,MAAMsrB,KACvC,SAASC,EAAYC,GACnB,SAASC,EAAOD,GACdH,MACKD,GAtCaM,EAACte,EAAQjM,EAAMwqB,EAAUna,EAASC,EAAUZ,KAClEpJ,GAAGmc,eAAexW,EAAQjM,EAAMwqB,EAAUna,EAASC,EAAUZ,IAsCvD6a,CAAkBte,EAAQjM,EAAMqqB,EAAWha,EAASC,EAAUZ,GAEhEqa,MACA1qB,EAAoBD,EAC9B,CAtCoCqrB,EAACJ,EAAWF,EAAUG,EAAQN,KAEtC,oBAAXU,SAAwBA,QAAQ9hB,OAE3C,IAAI+hB,GAAU,EAQd,OAPAxa,GAAe3Y,QAASozB,IAClBD,GACAC,EAAkB,UAAET,KACtBS,EAAe,OAAEP,EAAWF,EAAUG,EAAQN,GAC9CW,GAAU,KAGPA,GA4BHF,CAA0BJ,EAAWF,EAAUG,EAAQ,KACrDN,MACA3qB,EAAoBD,MAKxBkrB,EAAOD,EACf,CACMrrB,EAAiBI,GACC,iBAAPvI,EA1EGg0B,EAACh0B,EAAKkzB,EAAQC,EAASc,KACrC,IAAI1rB,EAAO0rB,EAAiD,GAAtCjsB,EAAuB,MAAMhI,KACnD2B,EAAU3B,GAAKsE,KACZE,IACChC,EAAOgC,EAAa,sBAAsBxE,+BAC1CkzB,EAAO,IAAI7wB,WAAWmC,IAClB+D,GAAKC,EAAoBD,IAE9B3D,IACC,IAAIuuB,EAGF,KAAM,sBAAsBnzB,aAF5BmzB,MAMF5qB,GAAKJ,EAAiBI,IA2DxByrB,CAAUh0B,EAAKuzB,EAAaJ,GAE5BI,EAAYvzB,IAg8FhByP,GAAGmb,aAKH,IAAIsJ,GAAc,CAEhBC,cAj0HmBC,CAAC1uB,EAAWuD,EAAUorB,EAAMxpB,KAC/C5J,EACE,qBAAqB4L,GAAanH,WAChC,CACEuD,EAAW4D,GAAa5D,GAAY,mBACpCorB,EACAxpB,EAAOgC,GAAahC,GAAQ,sBA6zHlCypB,kBAjlCF,SAA4BjP,EAAIiE,EAAKtc,GACnCD,GAASC,QAAUA,EACnB,IACE,IAAIwF,EAASzF,GAASmhB,gBAAgB7I,GACtC,OAAQiE,GACN,KAAK,EAEH,IADIC,EAAMzc,MACA,EACR,OAAQ,GAEV,KAAO2C,GAAG6R,QAAQiI,IAChBA,IAIF,OADY9Z,GAAGiW,UAAUlT,EAAQ+W,GAChBlE,GAEnB,KAAK,EACL,KAAK,EAgBL,KAAK,GACL,KAAK,GACH,OAAO,EAhBT,KAAK,EACH,OAAO7S,EAAOyG,MAChB,KAAK,EACH,IAAIsQ,EAAMzc,KAEV,OADA0F,EAAOyG,OAASsQ,EACT,EAET,KAAK,GAKH,OAJIA,EAAMrc,KAGV/H,EAAQokB,EAFK,GAEY,GAAK,EACvB,EAMX,OAAQ,EACT,CAAC,MAAO5gB,GACP,QAAiB,IAAN8G,IAAkC,eAAX9G,EAAEQ,KAAwB,MAAMR,EAClE,OAAQA,EAAEkZ,KAClB,CACA,EAwiCM0S,kBAtiCF,SAA4BlP,EAAIqE,GAC9B,IACE,IAAIlX,EAASzF,GAASmhB,gBAAgB7I,GACtC,OAAOtY,GAASohB,OAAO1e,GAAGuY,KAAMxV,EAAO/I,KAAMigB,EAC9C,CAAC,MAAO/gB,GACP,QAAiB,IAAN8G,IAAkC,eAAX9G,EAAEQ,KAAwB,MAAMR,EAClE,OAAQA,EAAEkZ,KAClB,CACA,EAgiCM2S,sBAzhCF,SAAgCnP,EAAIoP,EAAYC,GAC9C,IAAInrB,EAASmlB,GAA2B+F,EAAYC,GAEpD,IACE,OAAIC,MAAMprB,GAAgB,IAC1BkG,GAAGiZ,UAAUrD,EAAI9b,GACV,EACR,CAAC,MAAOZ,GACP,QAAiB,IAAN8G,IAAkC,eAAX9G,EAAEQ,KAAwB,MAAMR,EAClE,OAAQA,EAAEkZ,KAClB,CACA,EAghCM+S,qBAtgCF,SAA+BvP,EAAIwP,EAAMlR,GACvC,IACE,IAAInR,EAASzF,GAASmhB,gBAAgB7I,GACtC7S,EAAO0W,WAAazZ,GAAGuG,QAAQxD,EAAO/I,MAQtC,IANA,IAAIqrB,EAAc,IACd9hB,EAAM,EACN+hB,EAAMtlB,GAAGyG,OAAO1D,EAAQ,EAAG,GAE3BxG,EAAMzE,KAAK8mB,MAAM0G,EAAMD,GAEpB9oB,EAAMwG,EAAO0W,SAAS3f,QAAUyJ,EAAM8hB,GAAenR,GAAO,CACjE,IAAI/gB,EACAlB,EACAyH,EAAOqJ,EAAO0W,SAASld,GAC3B,GAAa,MAAT7C,EACFvG,EAAK4P,EAAO/Q,KAAKmB,GACjBlB,EAAO,OACF,GAAa,OAATyH,EAETvG,EADa6M,GAAGyT,WAAW1Q,EAAO/I,KAAM,CAAE2L,QAAQ,IACtC3T,KAAKmB,GACjBlB,EAAO,MACF,CACL,IAAIszB,EAAQvlB,GAAG6I,WAAW9F,EAAO/Q,KAAM0H,GACvCvG,EAAKoyB,EAAMpyB,GACXlB,EAAO+N,GAAGsH,SAASie,EAAM3f,MACrB,EACA5F,GAAGiH,MAAMse,EAAM3f,MACb,EACA5F,GAAGqH,OAAOke,EAAM3f,MACd,GACA,CACpB,CACU7S,EAAOI,GACNmG,EAAU,CACTnG,IAAO,GACLkG,EAAalG,GACd2E,KAAK6mB,IAAItlB,IAAe,EACrBA,EAAa,GACVvB,KAAK8mB,MAAMvlB,EAAa,cAAkB,KACxCvB,KAAKmN,MAAM5L,MAAiBA,IAAe,IAAM,cAAkB,EACxE,IAEHzD,EAAQwvB,EAAO7hB,GAAQ,GAAKjK,EAAQ,GACpC1D,EAAQwvB,EAAO7hB,EAAM,GAAM,GAAKjK,EAAQ,GAC1CA,EAAU,EACPiD,EAAM,GAAK8oB,IAAiB,GAC5BhsB,GAAckD,EAAM,GAAK8oB,GAC1BvtB,KAAK6mB,IAAItlB,IAAe,EACrBA,EAAa,GACVvB,KAAK8mB,MAAMvlB,EAAa,cAAkB,KACxCvB,KAAKmN,MAAM5L,MAAiBA,IAAe,IAAM,cAAkB,EACxE,IAEHzD,EAAQwvB,EAAO7hB,EAAM,GAAM,GAAKjK,EAAQ,GACxC1D,EAAQwvB,EAAO7hB,EAAM,IAAO,GAAKjK,EAAQ,GAC5C5D,EAAQ0vB,EAAO7hB,EAAM,IAAO,GAAK,IACjC/N,EAAM4vB,EAAO7hB,EAAM,IAAMtR,EACzBmtB,GAAa1lB,EAAM0rB,EAAO7hB,EAAM,GAAI,KACpCA,GAAO8hB,EACP9oB,GAAO,CACjB,CAEQ,OADAyD,GAAGyG,OAAO1D,EAAQxG,EAAM8oB,EAAa,GAC9B9hB,CACR,CAAC,MAAOrK,GACP,QAAiB,IAAN8G,IAAkC,eAAX9G,EAAEQ,KAAwB,MAAMR,EAClE,OAAQA,EAAEkZ,KAClB,CACA,EAo8BMoT,gBAl8BF,SAA0B5P,EAAI6P,EAAIloB,GAChCD,GAASC,QAAUA,EACnB,IACE,IAAIwF,EAASzF,GAASmhB,gBAAgB7I,GACtC,OAAQ6P,GACN,KAAK,MAoBL,KAAK,MACL,KAAK,MACL,KAAK,MAsDL,KAAK,MAOL,KAAK,MACH,OAAK1iB,EAAOC,IACL,GADkB,GAhF3B,KAAK,MACH,IAAKD,EAAOC,IAAK,OAAQ,GACzB,GAAID,EAAOC,IAAIN,IAAI0B,aAAc,CAC/B,IAAIshB,EAAU3iB,EAAOC,IAAIN,IAAI0B,aAAarB,GACtC4iB,EAAOloB,KACX7H,EAAO+vB,GAAQ,GAAKD,EAAQrhB,SAAW,EACvCzO,EAAQ+vB,EAAO,GAAM,GAAKD,EAAQphB,SAAW,EAC7C1O,EAAQ+vB,EAAO,GAAM,GAAKD,EAAQnhB,SAAW,EAC7C3O,EAAQ+vB,EAAO,IAAO,GAAKD,EAAQlhB,SAAW,EAC9C,IAAK,IAAIpG,EAAI,EAAGA,EAAI,GAAIA,IACtB5I,EAAMmwB,EAAOvnB,EAAI,IAAMsnB,EAAQjhB,KAAKrG,IAAM,EAE5C,OAAO,CACrB,CACY,OAAO,EAQT,KAAK,MACL,KAAK,MACL,KAAK,MACH,IAAK2E,EAAOC,IAAK,OAAQ,GACzB,GAAID,EAAOC,IAAIN,IAAIgC,aAAc,CAC3BihB,EAAOloB,KAAX,IACI4G,EAAUzO,EAAO+vB,GAAQ,GACzBrhB,EAAU1O,EAAQ+vB,EAAO,GAAM,GAC/BphB,EAAU3O,EAAQ+vB,EAAO,GAAM,GAC/BnhB,EAAU5O,EAAQ+vB,EAAO,IAAO,GAChClhB,EAAO,GACX,IAASrG,EAAI,EAAGA,EAAI,GAAIA,IACtBqG,EAAK1D,KAAKvL,EAAMmwB,EAAOvnB,EAAI,KAE7B,OAAO2E,EAAOC,IAAIN,IAAIgC,aAAa3B,EAAOC,IAAKyiB,EAAI,CACjDphB,UACAC,UACAC,UACAC,UACAC,QAEhB,CACY,OAAO,EAET,KAAK,MACH,OAAK1B,EAAOC,KACR2iB,EAAOloB,KACX7H,EAAO+vB,GAAQ,GAAK,EACb,IAHkB,GAK3B,KAAK,MACH,OAAK5iB,EAAOC,KACJ,IADiB,GAG3B,KAAK,MAEH,OADI2iB,EAAOloB,KACJuC,GAAG4Z,MAAM7W,EAAQ0iB,EAAIE,GAE9B,KAAK,MAGH,IAAK5iB,EAAOC,IAAK,OAAQ,GACzB,GAAID,EAAOC,IAAIN,IAAIkC,iBAAkB,CACnC,IAAIghB,EAAU7iB,EAAOC,IAAIN,IAAIkC,iBAAiB7B,EAAOC,KACjD2iB,EAAOloB,KACX/H,EAAOiwB,GAAQ,GAAKC,EAAQ,GAC5BlwB,EAAQiwB,EAAO,GAAM,GAAKC,EAAQ,EAChD,CACY,OAAO,EAaT,QACE,OAAQ,GAEb,CAAC,MAAO1sB,GACP,QAAiB,IAAN8G,IAAkC,eAAX9G,EAAEQ,KAAwB,MAAMR,EAClE,OAAQA,EAAEkZ,KAClB,CACA,EAi2BMyT,kBA/1BF,SAA4B7rB,EAAMigB,GAChC,IAEE,OADAjgB,EAAOsD,GAAS0hB,OAAOhlB,GAChBsD,GAASohB,OAAO1e,GAAGyY,MAAOze,EAAMigB,EACxC,CAAC,MAAO/gB,GACP,QAAiB,IAAN8G,IAAkC,eAAX9G,EAAEQ,KAAwB,MAAMR,EAClE,OAAQA,EAAEkZ,KAClB,CACA,EAy1BM0T,qBAv1BF,SAA+BvH,EAAOvkB,EAAMigB,EAAKzQ,GAC/C,IACExP,EAAOsD,GAAS0hB,OAAOhlB,GACvB,IAAI+rB,EAAmB,IAARvc,EACXgV,EAAqB,KAARhV,EAIjB,OAFAzW,IADAyW,IAAgB,MACD,0CAA0CA,KACzDxP,EAAOsD,GAASghB,YAAYC,EAAOvkB,EAAMwkB,GAClClhB,GAASohB,OAAOqH,EAAW/lB,GAAGyY,MAAQzY,GAAGuY,KAAMve,EAAMigB,EAC7D,CAAC,MAAO/gB,GACP,QAAiB,IAAN8G,IAAkC,eAAX9G,EAAEQ,KAAwB,MAAMR,EAClE,OAAQA,EAAEkZ,KAClB,CACA,EA40BM4T,iBA10BF,SAA2BzH,EAAOvkB,EAAMwP,EAAOjM,GAC7CD,GAASC,QAAUA,EACnB,IACEvD,EAAOsD,GAAS0hB,OAAOhlB,GACvBA,EAAOsD,GAASghB,YAAYC,EAAOvkB,GACnC,IAAI4L,EAAOrI,EAAUF,KAAsB,EAC3C,OAAO2C,GAAG1L,KAAK0F,EAAMwP,EAAO5D,GAAMgQ,EACnC,CAAC,MAAO1c,GACP,QAAiB,IAAN8G,IAAkC,eAAX9G,EAAEQ,KAAwB,MAAMR,EAClE,OAAQA,EAAEkZ,KAClB,CACA,EAi0BM6T,gBA/zBF,SAA0BjsB,GACxB,IAGE,OAFAA,EAAOsD,GAAS0hB,OAAOhlB,GACvBgG,GAAGsG,MAAMtM,GACF,CACR,CAAC,MAAOd,GACP,QAAiB,IAAN8G,IAAkC,eAAX9G,EAAEQ,KAAwB,MAAMR,EAClE,OAAQA,EAAEkZ,KAClB,CACA,EAwzBM8T,iBAtzBF,SAA2BlsB,EAAMigB,GAC/B,IAEE,OADAjgB,EAAOsD,GAAS0hB,OAAOhlB,GAChBsD,GAASohB,OAAO1e,GAAGuY,KAAMve,EAAMigB,EACvC,CAAC,MAAO/gB,GACP,QAAiB,IAAN8G,IAAkC,eAAX9G,EAAEQ,KAAwB,MAAMR,EAClE,OAAQA,EAAEkZ,KAClB,CACA,EAgzBM+T,mBA9yBF,SAA6B5H,EAAOvkB,EAAMwP,GACxC,IAUE,OATAxP,EAAOsD,GAAS0hB,OAAOhlB,GACvBA,EAAOsD,GAASghB,YAAYC,EAAOvkB,GACrB,IAAVwP,EACFxJ,GAAGqG,OAAOrM,GACS,MAAVwP,EACTxJ,GAAGsG,MAAMtM,GAETxI,EAAM,oCAED,CACR,CAAC,MAAO0H,GACP,QAAiB,IAAN8G,IAAkC,eAAX9G,EAAEQ,KAAwB,MAAMR,EAClE,OAAQA,EAAEkZ,KAClB,CACA,EAgyBMgU,UA9xBeC,KACf70B,EAAM,+BA+xBN80B,sBA5xB2BC,CAACC,EAAMzyB,EAAK0yB,IAAQhxB,EAAOixB,WAAWF,EAAMzyB,EAAKA,EAAM0yB,GA8xBlFE,0BA5xB+BC,KAC/B,MAAMC,KA6xBNC,WA1xBF,SAAqBC,EAAUC,EAAWC,GACxC,IAAIC,EAAOjI,GAA2B8H,EAAUC,GAE5CG,EAAO,IAAIxjB,KAAY,IAAPujB,GACpBtxB,EAAOqxB,GAAS,GAAKE,EAAKC,gBAC1BxxB,EAAQqxB,EAAQ,GAAM,GAAKE,EAAKE,gBAChCzxB,EAAQqxB,EAAQ,GAAM,GAAKE,EAAKG,cAChC1xB,EAAQqxB,EAAQ,IAAO,GAAKE,EAAKI,aACjC3xB,EAAQqxB,EAAQ,IAAO,GAAKE,EAAKK,cACjC5xB,EAAQqxB,EAAQ,IAAO,GAAKE,EAAKM,iBAAmB,KACpD7xB,EAAQqxB,EAAQ,IAAO,GAAKE,EAAKO,YACjC,IAAIlnB,EAAQmD,KAAKgkB,IAAIR,EAAKM,iBAAkB,EAAG,EAAG,EAAG,EAAG,EAAG,GACvDG,GAAST,EAAKtI,UAAYre,SAAkC,EAChE5K,EAAQqxB,EAAQ,IAAO,GAAKW,CAClC,EA8wBMC,cA/vBF,SAAwBd,EAAUC,EAAWC,GAC3C,IAAIC,EAAOjI,GAA2B8H,EAAUC,GAE5CG,EAAO,IAAIxjB,KAAY,IAAPujB,GACpBtxB,EAAOqxB,GAAS,GAAKE,EAAKW,aAC1BlyB,EAAQqxB,EAAQ,GAAM,GAAKE,EAAKY,aAChCnyB,EAAQqxB,EAAQ,GAAM,GAAKE,EAAKa,WAChCpyB,EAAQqxB,EAAQ,IAAO,GAAKE,EAAKc,UACjCryB,EAAQqxB,EAAQ,IAAO,GAAKE,EAAKe,WACjCtyB,EAAQqxB,EAAQ,IAAO,GAAKE,EAAKgB,cAAgB,KACjDvyB,EAAQqxB,EAAQ,IAAO,GAAKE,EAAKiB,SAEjC,IAAIR,EAA4B,EApBdT,KAClB,IANgBkB,EAUhB,QAVgBA,EAMMlB,EAAKgB,eANK,GAAM,GAAME,EAAO,KAAQ,GAAKA,EAAO,KAAQ,EAOjB9I,GAA7BD,IACF6H,EAAKe,YAAcf,EAAKc,UAAY,GAiBxDK,CAAanB,GACxBvxB,EAAQqxB,EAAQ,IAAO,GAAKW,EAC5BhyB,EAAQqxB,EAAQ,IAAO,IAAkC,GAA3BE,EAAKoB,oBAGnC,IAAI/nB,EAAQ,IAAImD,KAAKwjB,EAAKgB,cAAe,EAAG,GACxCK,EAAe,IAAI7kB,KAAKwjB,EAAKgB,cAAe,EAAG,GAAGI,oBAClDE,EAAejoB,EAAM+nB,oBACrBG,EAEoE,GADrEF,GAAgBC,GACftB,EAAKoB,qBAAuBzwB,KAAK8I,IAAI6nB,EAAcD,IACvD5yB,EAAQqxB,EAAQ,IAAO,GAAKyB,CAClC,EAyuBMC,UAvuBeC,CAACC,EAAUC,EAAUC,EAAUC,KAE9C,IAAIC,GAAc,IAAItlB,MAAOwkB,cACzBe,EAAS,IAAIvlB,KAAKslB,EAAa,EAAG,GAClCE,EAAS,IAAIxlB,KAAKslB,EAAa,EAAG,GAClCR,EAAeS,EAAOX,oBACtBC,EAAeW,EAAOZ,oBAQtBa,EAAoBtxB,KAAKhB,IAAI2xB,EAAcD,GAO/C3yB,EAAQgzB,GAAY,GAAyB,GAApBO,EAEzBxzB,EAAOkzB,GAAY,GAAK5L,OAAOuL,GAAgBD,GAE/C,IAAIa,EAAeC,IAGjB,IAAIC,EAAOD,GAAkB,EAAI,IAAM,IAEnCE,EAAY1xB,KAAK6mB,IAAI2K,GAIzB,MAAO,MAAMC,IAHDtsB,OAAOnF,KAAK8mB,MAAM4K,EAAY,KAAK3tB,SAAS,EAAG,OAC7CoB,OAAOusB,EAAY,IAAI3tB,SAAS,EAAG,QAK/C4tB,EAAaJ,EAAYZ,GACzBiB,EAAaL,EAAYb,GAC7Bz1B,EAAO02B,GACP12B,EAAO22B,GACP32B,EACEmO,GAAgBuoB,IAAe,GAC/B,iDAAiDA,MAEnD12B,EACEmO,GAAgBwoB,IAAe,GAC/B,iDAAiDA,MAE/ClB,EAAeC,GAEjBrJ,GAAaqK,EAAYV,EAAU,IACnC3J,GAAasK,EAAYV,EAAU,MAEnC5J,GAAaqK,EAAYT,EAAU,IACnC5J,GAAasK,EAAYX,EAAU,MAkrBrCY,oBA9qByBC,IAAMjmB,KAAKC,MAgrBpCimB,uBAvpB6BC,IAC7B,IAAIC,EAAUt0B,EAAOqE,OAKrB/G,GAHA+2B,KAAmB,GAGIC,GAqBvB,IAAIC,EA7CJ,WA8CA,GAAIF,EAAgBE,EAIlB,OAHA70B,EACE,oCAAoC20B,gDAE/B,EAMT,IAAK,IAAIG,EAAU,EAAGA,GAAW,EAAGA,GAAW,EAAG,CAChD,IAAIC,EAAoBH,GAAW,EAAI,GAAME,GAE7CC,EAAoBpyB,KAAK8I,IAAIspB,EAAmBJ,EAAgB,WAEhE,IAAIjiB,EAAU/P,KAAK8I,IACjBopB,EACAllB,GAAYhN,KAAKhB,IAAIgzB,EAAeI,GAAoB,QAI1D,GADkB1K,GAAW3X,GAE3B,OAAO,CAEjB,CAEM,OADA1S,EAAI,gCAAgC40B,cAAoBliB,gCACjD,GAmmBPsiB,YAhjBiBC,CAACC,EAAWC,KAC7B,IAAIC,EAAU,EAOd,OANA3K,KAAgB1uB,QAAQ,CAAC4xB,EAAQ1kB,KAC/B,IAAIzC,EAAM2uB,EAAcC,EACxB10B,EAASw0B,EAAgB,EAAJjsB,GAAU,GAAKzC,EAZpB6uB,EAAC3tB,EAAKxG,KACxB,IAAK,IAAI+H,EAAI,EAAGA,EAAIvB,EAAI/C,SAAUsE,EAChCrL,EAAO8J,EAAIwE,WAAWjD,MAA4B,IAApBvB,EAAIwE,WAAWjD,KAC7C5I,EAAMa,KAAYwG,EAAIwE,WAAWjD,GAGnC5I,EAAMa,GAAU,GAOdm0B,CAAc1H,EAAQnnB,GACtB4uB,GAAWzH,EAAOhpB,OAAS,IAEtB,GA0iBP2wB,kBAviBuBC,CAACC,EAAgBC,KACxC,IAAI/K,EAAUD,KACd/pB,EAAQ80B,GAAkB,GAAK9K,EAAQ/lB,OACvC,IAAIywB,EAAU,EAGd,OAFA1K,EAAQ3uB,QAAS4xB,GAAYyH,GAAWzH,EAAOhpB,OAAS,GACxDjE,EAAQ+0B,GAAqB,GAAKL,EAC3B,GAmiBPM,SAhiBF,SAAmBjV,GACjB,IACE,IAAI7S,EAASzF,GAASmhB,gBAAgB7I,GAEtC,OADA5V,GAAGoD,MAAML,GACF,CACR,CAAC,MAAO7J,GACP,QAAiB,IAAN8G,IAAkC,eAAX9G,EAAEQ,KAAwB,MAAMR,EAClE,OAAOA,EAAEkZ,KACjB,CACA,EAyhBM0Y,QArgBF,SAAkBlV,EAAImV,EAAKC,EAAQC,GACjC,IACE,IACIxE,EApBMyE,EAACnoB,EAAQgoB,EAAKC,EAAQ1nB,KAElC,IADA,IAAI9F,EAAM,EACDY,EAAI,EAAGA,EAAI4sB,EAAQ5sB,IAAK,CAC/B,IAAIzC,EAAM9F,EAAQk1B,GAAO,GACrB5pB,EAAMtL,EAASk1B,EAAM,GAAM,GAC/BA,GAAO,EACP,IAAII,EAAOnrB,GAAGlN,KAAKiQ,EAAQvN,EAAOmG,EAAKwF,EAAKmC,GAC5C,GAAI6nB,EAAO,EAAG,OAAQ,EAEtB,GADA3tB,GAAO2tB,EACHA,EAAOhqB,EAAK,WACK,IAAVmC,IACTA,GAAU6nB,EAEpB,CACM,OAAO3tB,GAMK0tB,CADG5tB,GAASmhB,gBAAgB7I,GACZmV,EAAKC,GAE/B,OADAn1B,EAAQo1B,GAAQ,GAAKxE,EACd,CACR,CAAC,MAAOvtB,GACP,QAAiB,IAAN8G,IAAkC,eAAX9G,EAAEQ,KAAwB,MAAMR,EAClE,OAAOA,EAAEkZ,KACjB,CACA,EA6fMgZ,QA3fF,SAAkBxV,EAAIyV,EAAYC,EAAahiB,EAAQiiB,GACrD,IAAIjoB,EAAS2b,GAA2BoM,EAAYC,GAEpD,IACE,GAAIpG,MAAM5hB,GAAS,OAAO,GAC1B,IAAIP,EAASzF,GAASmhB,gBAAgB7I,GActC,OAbA5V,GAAGyG,OAAO1D,EAAQO,EAAQgG,GACzBhQ,EAAU,CACTyJ,EAAOoG,WAAa,GAClB9P,EAAa0J,EAAOoG,UACrBrR,KAAK6mB,IAAItlB,IAAe,EACrBA,EAAa,GACVvB,KAAK8mB,MAAMvlB,EAAa,cAAkB,KACxCvB,KAAKmN,MAAM5L,MAAiBA,IAAe,IAAM,cAAkB,EACxE,IAEHzD,EAAO21B,GAAa,GAAKjyB,EAAQ,GACjC1D,EAAQ21B,EAAY,GAAM,GAAKjyB,EAAQ,GACtCyJ,EAAO0W,UAAuB,IAAXnW,GAA2B,IAAXgG,IAAcvG,EAAO0W,SAAW,MAChE,CACR,CAAC,MAAOvgB,GACP,QAAiB,IAAN8G,IAAkC,eAAX9G,EAAEQ,KAAwB,MAAMR,EAClE,OAAOA,EAAEkZ,KACjB,CACA,EAqeMoZ,QAneF,SAAkB5V,GAChB,IACE,IAAI7S,EAASzF,GAASmhB,gBAAgB7I,GACtC,OAAI7S,EAAOD,YAAYO,MACdN,EAAOD,WAAWO,MAAMN,GAE1B,CACR,CAAC,MAAO7J,GACP,QAAiB,IAAN8G,IAAkC,eAAX9G,EAAEQ,KAAwB,MAAMR,EAClE,OAAOA,EAAEkZ,KACjB,CACA,EA0dMqZ,SAncF,SAAmB7V,EAAImV,EAAKC,EAAQC,GAClC,IACE,IACIxE,EAvBOiF,EAAC3oB,EAAQgoB,EAAKC,EAAQ1nB,KAEnC,IADA,IAAI9F,EAAM,EACDY,EAAI,EAAGA,EAAI4sB,EAAQ5sB,IAAK,CAC/B,IAAIzC,EAAM9F,EAAQk1B,GAAO,GACrB5pB,EAAMtL,EAASk1B,EAAM,GAAM,GAC/BA,GAAO,EACP,IAAII,EAAOnrB,GAAG6D,MAAMd,EAAQvN,EAAOmG,EAAKwF,EAAKmC,GAC7C,GAAI6nB,EAAO,EAAG,OAAQ,EAEtB,GADA3tB,GAAO2tB,EACHA,EAAOhqB,EAET,WAEmB,IAAVmC,IACTA,GAAU6nB,EAEpB,CACM,OAAO3tB,GAMKkuB,CADGpuB,GAASmhB,gBAAgB7I,GACXmV,EAAKC,GAEhC,OADAn1B,EAAQo1B,GAAQ,GAAKxE,EACd,CACR,CAAC,MAAOvtB,GACP,QAAiB,IAAN8G,IAAkC,eAAX9G,EAAEQ,KAAwB,MAAMR,EAClE,OAAOA,EAAEkZ,KACjB,CACA,EA2bMuZ,UAwmDF,SAAmBC,EAAOC,GACxB,IAAIC,EAAK7vB,KACT,IACE,OAAOwkB,GAAkBmL,EAAlBnL,CAAyBoL,EACjC,CAAC,MAAO3yB,GAEP,GADA4C,GAAagwB,GACT5yB,IAAMA,EAAI,EAAG,MAAMA,EACvB6yB,GAAU,EAAG,EACrB,CACA,EA/mDMC,WAinDF,SAAoBJ,EAAOC,EAAII,GAC7B,IAAIH,EAAK7vB,KACT,IACE,OAAOwkB,GAAkBmL,EAAlBnL,CAAyBoL,EAAII,EACrC,CAAC,MAAO/yB,GAEP,GADA4C,GAAagwB,GACT5yB,IAAMA,EAAI,EAAG,MAAMA,EACvB6yB,GAAU,EAAG,EACrB,CACA,EAxnDMG,YA0nDF,SAAqBN,EAAOC,EAAII,EAAIE,GAClC,IAAIL,EAAK7vB,KACT,IACE,OAAOwkB,GAAkBmL,EAAlBnL,CAAyBoL,EAAII,EAAIE,EACzC,CAAC,MAAOjzB,GAEP,GADA4C,GAAagwB,GACT5yB,IAAMA,EAAI,EAAG,MAAMA,EACvB6yB,GAAU,EAAG,EACrB,CACA,EAjoDMK,aA8oDF,SAAsBR,EAAOC,EAAII,EAAIE,EAAIE,GACvC,IAAIP,EAAK7vB,KACT,IACE,OAAOwkB,GAAkBmL,EAAlBnL,CAAyBoL,EAAII,EAAIE,EAAIE,EAC7C,CAAC,MAAOnzB,GAEP,GADA4C,GAAagwB,GACT5yB,IAAMA,EAAI,EAAG,MAAMA,EACvB6yB,GAAU,EAAG,EACrB,CACA,EArpDMO,SAupDF,SAAkBV,GAChB,IAAIE,EAAK7vB,KACT,IACEwkB,GAAkBmL,EAAlBnL,EACD,CAAC,MAAOvnB,GAEP,GADA4C,GAAagwB,GACT5yB,IAAMA,EAAI,EAAG,MAAMA,EACvB6yB,GAAU,EAAG,EACrB,CACA,EA9pDMQ,YAmlDF,SAAqBX,EAAOC,EAAII,EAAIE,GAClC,IAAIL,EAAK7vB,KACT,IACEwkB,GAAkBmL,EAAlBnL,CAAyBoL,EAAII,EAAIE,EAClC,CAAC,MAAOjzB,GAEP,GADA4C,GAAagwB,GACT5yB,IAAMA,EAAI,EAAG,MAAMA,EACvB6yB,GAAU,EAAG,EACrB,CACA,EA1lDMS,aA6nDF,SAAsBZ,EAAOC,EAAII,EAAIE,EAAIE,GACvC,IAAIP,EAAK7vB,KACT,IACEwkB,GAAkBmL,EAAlBnL,CAAyBoL,EAAII,EAAIE,EAAIE,EACtC,CAAC,MAAOnzB,GAEP,GADA4C,GAAagwB,GACT5yB,IAAMA,EAAI,EAAG,MAAMA,EACvB6yB,GAAU,EAAG,EACrB,CACA,GApoDQlyB,GAxwIJ,WACE,IAAI4yB,EATG,CACL3M,IAAK2E,GACLiI,uBAAwBjI,IAY1B,SAASkI,EAAgBC,EAAU/K,GArSrC,IAAmBlqB,EAsTf,OAhBAkC,GAAc+yB,EAAS7K,QAEvBlxB,EAAoB,YAAIgJ,GAIxB9G,EAFAsC,EAAawE,GAAoB,OAEd,oCACnB1D,IAIApD,EAFAmP,GAAYrI,GAAuC,0BAEjC,mCAjTHlC,EAmTLkC,GAA+B,kBAlT3CtC,EAAWK,QAAQD,GAoTjBoB,EAAoB,oBACbc,EACf,CAEMnB,EAAiB,oBAMjB,IA5EwB+B,EAAQJ,EAAYC,EAAStB,EA4EjD6zB,EAAah8B,EAoBjB,GAAIA,EAAwB,gBAC1B,IACE,OAAOA,EAAwB,gBAAE47B,EAAME,EACxC,CAAC,MAAOzzB,GACP/D,EAAI,sDAAsD+D,KAE1DtI,EAAmBsI,EAC7B,CASM,OANAE,IAAmBW,KA1GKU,EA6GPnF,EA7Ge+E,EA6GHjB,EA7GekB,EA6GCmyB,EA7GQzzB,EA6ErD,SAAoC+F,GAGlChM,EACElC,IAAWg8B,EACX,oHAEFA,EAAa,KAGbF,EAAgB5tB,EAAiB,SACzC,EAtFStE,GAC0C,mBAApClF,YAAYu3B,sBAClBvzB,EAAUc,IAQK,mBAAT1F,MAmBFyF,GAAuBC,EAAYC,EAAStB,GAjB1CrE,MAAM0F,EAAY,CAAEzF,YAAa,gBAAiBC,KAAMJ,GAMhDc,YAAYu3B,qBAAqBr4B,EAAU6F,GAE1CzF,KAAKmE,EAAU,SAAU2B,GAKrC,OAFAxF,EAAI,kCAAkCwF,KACtCxF,EAAI,6CACGiF,GAAuBC,EAAYC,EAAStB,EAC/D,KAiFqF+zB,MAC7En8B,GAEK,EACb,CAmsIsBo8B,GAEKn8B,EAAwB,gBAAI4I,EAAoB,iBAAkB,GACtD5I,EAAoC,4BAAI4I,EACzE,6BACA,GAE+B5I,EAAkC,0BAAI4I,EACrE,2BACA,GAEkC5I,EAAqC,6BACvE4I,EAAoB,8BAA+B,GACjB5I,EAAqC,6BACvE4I,EAAoB,8BAA+B,GACnB5I,EAAmC,2BAAI4I,EACvE,4BACA,GAE2B5I,EAA8B,sBAAI4I,EAC7D,uBACA,GAEsB5I,EAAyB,iBAAI4I,EAAoB,kBAAmB,GACzD5I,EAAoC,4BAAI4I,EACzE,6BACA,GAEkC5I,EAAqC,6BACvE4I,EAAoB,8BAA+B,GACX5I,EAA2C,mCACnF4I,EAAoB,oCAAqC,GACnB5I,EAAyC,iCAC/E4I,EAAoB,kCAAmC,GACf5I,EAA2C,mCACnF4I,EAAoB,oCAAqC,GACnB5I,EAAyC,iCAC/E4I,EAAoB,kCAAmC,GACpB5I,EAAsC,8BACzE4I,EAAoB,+BAAgC,GACzB5I,EAA8B,sBAAI4I,EAC7D,uBACA,GAE6B5I,EAAgC,wBAAI4I,EACjE,yBACA,GAEwB5I,EAA2B,mBAAI4I,EACvD,oBACA,GAE6B5I,EAAgC,wBAAI4I,EACjE,yBACA,GAE0B5I,EAA6B,qBAAI4I,EAC3D,sBACA,GAE2B5I,EAA8B,sBAAI4I,EAC7D,uBACA,GAE2B5I,EAA8B,sBAAI4I,EAC7D,uBACA,GAEyC5I,EAA4C,oCACrF4I,EAAoB,qCAAsC,GAC7B5I,EAAgC,wBAAI4I,EACjE,yBACA,GAE6B5I,EAAgC,wBAAI4I,EACjE,yBACA,GAE8B5I,EAAiC,yBAAI4I,EACnE,0BACA,GAE6B5I,EAAgC,wBAAI4I,EACjE,yBACA,GAE+B5I,EAAkC,0BAAI4I,EACrE,2BACA,GAE0B5I,EAA6B,qBAAI4I,EAC3D,sBACA,GAE6B5I,EAAgC,wBAAI4I,EACjE,yBACA,GAEyB5I,EAA4B,oBAAI4I,EACzD,qBACA,GAEyB5I,EAA4B,oBAAI4I,EACzD,qBACA,GAEoC5I,EAAuC,+BAC3E4I,EAAoB,gCAAiC,GACjB5I,EAAuC,+BAC3E4I,EAAoB,gCAAiC,GACd5I,EAA0C,kCACjF4I,EAAoB,mCAAoC,GAClB5I,EAAyC,iCAC/E4I,EAAoB,kCAAmC,GACnB5I,EAAuC,+BAC3E4I,EAAoB,gCAAiC,GAC7B5I,EAA2B,mBAAI4I,EACvD,oBACA,GAEwB5I,EAA2B,mBAAI4I,EACvD,oBACA,GAE4B5I,EAA+B,uBAAI4I,EAC/D,wBACA,GAEgC5I,EAAmC,2BAAI4I,EACvE,4BACA,GAE+B5I,EAAkC,0BAAI4I,EACrE,2BACA,GAEwB5I,EAA2B,mBAAI4I,EACvD,oBACA,GAE0B5I,EAA6B,qBAAI4I,EAC3D,sBACA,GAE0B5I,EAA6B,qBAAI4I,EAC3D,sBACA,GAEuB5I,EAA0B,kBAAI4I,EACrD,mBACA,GAE6B5I,EAAgC,wBAAI4I,EACjE,yBACA,GAE+B5I,EAAkC,0BAAI4I,EACrE,2BACA,GAE+B5I,EAAkC,0BAAI4I,EACrE,2BACA,GAE+B5I,EAAkC,0BAAI4I,EACrE,2BACA,GAEsB5I,EAAyB,iBAAI4I,EAAoB,kBAAmB,GACpE5I,EAAyB,iBAAI4I,EAAoB,kBAAmB,GAC3D5I,EAAkC,0BAAI4I,EACrE,2BACA,GAEyB5I,EAA4B,oBAAI4I,EACzD,qBACA,GAEyB5I,EAA4B,oBAAI4I,EACzD,qBACA,GAEkC5I,EAAqC,6BACvE4I,EAAoB,8BAA+B,GACjB5I,EAAqC,6BACvE4I,EAAoB,8BAA+B,GACf5I,EAAuC,+BAC3E4I,EAAoB,gCAAiC,GACpB5I,EAAoC,4BAAI4I,EACzE,6BACA,GAEiC5I,EAAoC,4BAAI4I,EACzE,6BACA,GAEkD5I,EACL,6CAC3C4I,EAAoB,8CAA+C,GAC3B5I,EAA6C,qCACvF4I,EAAoB,sCAAuC,GACzB5I,EAAqC,6BACvE4I,EAAoB,8BAA+B,GACpB5I,EAAkC,0BAAI4I,EACrE,2BACA,GAE+B5I,EAAkC,0BAAI4I,EACrE,2BACA,GAEiC5I,EAAoC,4BAAI4I,EACzE,6BACA,GAE4B5I,EAA+B,uBAAI4I,EAC/D,wBACA,GAE6B5I,EAAgC,wBAAI4I,EACjE,yBACA,GAE6B5I,EAAgC,wBAAI4I,EACjE,yBACA,GAE0B5I,EAA6B,qBAAI4I,EAC3D,sBACA,GAEqC5I,EAAwC,gCAC7E4I,EAAoB,iCAAkC,GACZ5I,EAA6C,qCACvF4I,EAAoB,sCAAuC,GACtB5I,EAAwC,gCAC7E4I,EAAoB,iCAAkC,GAC9B5I,EAA2B,mBAAI4I,EACvD,oBACA,GAEoC5I,EAAuC,+BAC3E4I,EAAoB,gCAAiC,GACjB5I,EAAuC,+BAC3E4I,EAAoB,gCAAiC,GACb5I,EAA2C,mCACnF4I,EAAoB,oCAAqC,GAClC5I,EAA0B,kBAAI4I,EACrD,mBACA,GAEkC5I,EAAqC,6BACvE4I,EAAoB,8BAA+B,GACjB5I,EAAqC,6BACvE4I,EAAoB,8BAA+B,GAC1B5I,EAA4B,oBAAI4I,EACzD,qBACA,GAEyB5I,EAA4B,oBAAI4I,EACzD,qBACA,GAEgC5I,EAAmC,2BAAI4I,EACvE,4BACA,GAEwC5I,EAA2C,mCACnF4I,EAAoB,oCAAqC,GACf5I,EAA6C,qCACvF4I,EAAoB,sCAAuC,GACtB5I,EAAwC,gCAC7E4I,EAAoB,iCAAkC,GACvB5I,EAAkC,0BAAI4I,EACrE,2BACA,GAE+B5I,EAAkC,0BAAI4I,EACrE,2BACA,GAEmC5I,EAAsC,8BACzE4I,EAAoB,+BAAgC,GACR5I,EAA+C,uCAC3F4I,EAAoB,wCAAyC,GAChC5I,EAAgC,wBAAI4I,EACjE,yBACA,GAE0B5I,EAA6B,qBAAI4I,EAC3D,sBACA,GAE0B5I,EAA6B,qBAAI4I,EAC3D,sBACA,GAE+B5I,EAAkC,0BAAI4I,EACrE,2BACA,GAEiC5I,EAAoC,4BAAI4I,EACzE,6BACA,GAE4B5I,EAA+B,uBAAI4I,EAC/D,wBACA,GAE4B5I,EAA+B,uBAAI4I,EAC/D,wBACA,GAE+B5I,EAAkC,0BAAI4I,EACrE,2BACA,GAE6B5I,EAAgC,wBAAI4I,EACjE,yBACA,GAE4B5I,EAA+B,uBAAI4I,EAC/D,wBACA,GAEkC5I,EAAqC,6BACvE4I,EAAoB,8BAA+B,GACf5I,EAAuC,+BAC3E4I,EAAoB,gCAAiC,GACjB5I,EAAuC,+BAC3E4I,EAAoB,gCAAiC,GACxB5I,EAAgC,wBAAI4I,EACjE,yBACA,GAE6B5I,EAAgC,wBAAI4I,EACjE,yBACA,GAEgC5I,EAAmC,2BAAI4I,EACvE,4BACA,GAE2B5I,EAA8B,sBAAI4I,EAC7D,uBACA,GAE8B5I,EAAiC,yBAAI4I,EACnE,0BACA,GAEuB5I,EAA0B,kBAAI4I,EACrD,mBACA,GAEwB5I,EAA2B,mBAAI4I,EACvD,oBACA,GAE2B5I,EAA8B,sBAAI4I,EAC7D,uBACA,GAE4B5I,EAA+B,uBAAI4I,EAC/D,wBACA,GAEgC5I,EAAmC,2BAAI4I,EACvE,4BACA,GAE4B5I,EAA+B,uBAAI4I,EAC/D,wBACA,GAE4B5I,EAA+B,uBAAI4I,EAC/D,wBACA,GAE6B5I,EAAgC,wBAAI4I,EACjE,yBACA,GAEiC5I,EAAoC,4BAAI4I,EACzE,6BACA,GAEkC5I,EAAqC,6BACvE4I,EAAoB,8BAA+B,GACvB5I,EAA+B,uBAAI4I,EAC/D,wBACA,GAE4B5I,EAA+B,uBAAI4I,EAC/D,wBACA,GAEwB5I,EAA2B,mBAAI4I,EACvD,oBACA,GAE2B5I,EAA8B,sBAAI4I,EAC7D,uBACA,GAE6B5I,EAAgC,wBAAI4I,EACjE,yBACA,GAEyB5I,EAA4B,oBAAI4I,EACzD,qBACA,GAEyB5I,EAA4B,oBAAI4I,EACzD,qBACA,GAE6B5I,EAAgC,wBAAI4I,EACjE,yBACA,GAE4B5I,EAA+B,uBAAI4I,EAC/D,wBACA,GAEgC5I,EAAmC,2BAAI4I,EACvE,4BACA,GAEuB5I,EAA0B,kBAAI4I,EACrD,mBACA,GAEiC5I,EAAoC,4BAAI4I,EACzE,6BACA,GAE8B5I,EAAiC,yBAAI4I,EACnE,0BACA,GAEoC5I,EAAuC,+BAC3E4I,EAAoB,gCAAiC,GAC9B5I,EAA0B,kBAAI4I,EACrD,mBACA,GAEyB5I,EAA4B,oBAAI4I,EACzD,qBACA,GAEyB5I,EAA4B,oBAAI4I,EACzD,qBACA,GAEwB5I,EAA2B,mBAAI4I,EACvD,oBACA,GAE4B5I,EAA+B,uBAAI4I,EAC/D,wBACA,GAE+B5I,EAAkC,0BAAI4I,EACrE,2BACA,GAE6B5I,EAAgC,wBAAI4I,EACjE,yBACA,GAE0B5I,EAA6B,qBAAI4I,EAC3D,sBACA,GAE6B5I,EAAgC,wBAAI4I,EACjE,yBACA,GAEuB5I,EAA0B,kBAAI4I,EACrD,mBACA,GAEwB5I,EAA2B,mBAAI4I,EACvD,oBACA,GAE8B5I,EAAiC,yBAAI4I,EACnE,0BACA,GAEgC5I,EAAmC,2BAAI4I,EACvE,4BACA,GAEsC5I,EAAyC,iCAC/E4I,EAAoB,kCAAmC,GAC1B5I,EAAgC,wBAAI4I,EACjE,yBACA,GAE6B5I,EAAgC,wBAAI4I,EACjE,yBACA,GAE6B5I,EAAgC,wBAAI4I,EACjE,yBACA,GAEqC5I,EAAwC,gCAC7E4I,EAAoB,iCAAkC,GACf5I,EAA0C,kCACjF4I,EAAoB,mCAAoC,GACrB5I,EAAsC,8BACzE4I,EAAoB,+BAAgC,GACb5I,EAA0C,kCACjF4I,EAAoB,mCAAoC,GACtB5I,EAAqC,6BACvE4I,EAAoB,8BAA+B,GACf5I,EAAuC,+BAC3E4I,EAAoB,gCAAiC,GAChB5I,EAAwC,gCAC7E4I,EAAoB,iCAAkC,GACV5I,EAA+C,uCAC3F4I,EAAoB,wCAAyC,GAChC5I,EAAgC,wBAAI4I,EACjE,yBACA,GAEsB5I,EAAyB,iBAAI4I,EAAoB,kBAAmB,GACrE5I,EAAwB,gBAAI4I,EAAoB,iBAAkB,GACpE5I,EAAsB,cAAI4I,EAAoB,eAAgB,GACtD5I,EAA8B,sBAAI4I,EAC7D,uBACA,GAE4B5I,EAA+B,uBAAI4I,EAC/D,wBACA,GAEmC5I,EAAsC,8BACzE4I,EAAoB,+BAAgC,GACxB5I,EAA+B,uBAAI4I,EAC/D,wBACA,GAE4B5I,EAA+B,uBAAI4I,EAC/D,wBACA,GAEyB5I,EAA4B,oBAAI4I,EACzD,qBACA,GAE+B5I,EAAkC,0BAAI4I,EACrE,2BACA,GAE0B5I,EAA6B,qBAAI4I,EAC3D,sBACA,GAEqC5I,EAAwC,gCAC7E4I,EAAoB,iCAAkC,GACzB5I,EAAgC,wBAAI4I,EACjE,yBACA,GAE0B5I,EAA6B,qBAAI4I,EAC3D,sBACA,GAE0B5I,EAA6B,qBAAI4I,EAC3D,sBACA,GAE6B5I,EAAgC,wBAAI4I,EACjE,yBACA,GAE8B5I,EAAiC,yBAAI4I,EACnE,0BACA,GAEkC5I,EAAqC,6BACvE4I,EAAoB,8BAA+B,GACjB5I,EAAqC,6BACvE4I,EAAoB,8BAA+B,GACX5I,EAA2C,mCACnF4I,EAAoB,oCAAqC,GAClB5I,EAA0C,kCACjF4I,EAAoB,mCAAoC,GACd5I,EAA6C,qCACvF4I,EAAoB,sCAAuC,GACnB5I,EAA2C,mCACnF4I,EAAoB,oCAAqC,GACvB5I,EAAqC,6BACvE4I,EAAoB,8BAA+B,GACjB5I,EAAqC,6BACvE4I,EAAoB,8BAA+B,GACd5I,EAAwC,gCAC7E4I,EAAoB,iCAAkC,GACnB5I,EAAsC,8BACzE4I,EAAoB,+BAAgC,GAClB5I,EAAqC,6BACvE4I,EAAoB,8BAA+B,GACzB5I,EAA6B,qBAAI4I,EAC3D,sBACA,GAE8B5I,EAAiC,yBAAI4I,EACnE,0BACA,GAE8B5I,EAAiC,yBAAI4I,EACnE,0BACA,GAE+B5I,EAAkC,0BAAI4I,EACrE,2BACA,GAE4B5I,EAA+B,uBAAI4I,EAC/D,wBACA,GAE6B5I,EAAgC,wBAAI4I,EACjE,yBACA,GAE4B5I,EAA+B,uBAAI4I,EAC/D,wBACA,GAE4B5I,EAA+B,uBAAI4I,EAC/D,wBACA,GAE+B5I,EAAkC,0BAAI4I,EACrE,2BACA,GAE+B5I,EAAkC,0BAAI4I,EACrE,2BACA,GAE2B5I,EAA8B,sBAAI4I,EAC7D,uBACA,GAE+B5I,EAAkC,0BAAI4I,EACrE,2BACA,GAE+B5I,EAAkC,0BAAI4I,EACrE,2BACA,GAE4B5I,EAA+B,uBAAI4I,EAC/D,wBACA,GAEmC5I,EAAsC,8BACzE4I,EAAoB,+BAAgC,GACnB5I,EAAoC,4BAAI4I,EACzE,6BACA,GAEiC5I,EAAoC,4BAAI4I,EACzE,6BACA,GAEiC5I,EAAoC,4BAAI4I,EACzE,6BACA,GAEiC5I,EAAoC,4BAAI4I,EACzE,6BACA,GAE8B5I,EAAiC,yBAAI4I,EACnE,0BACA,GAE8B5I,EAAiC,yBAAI4I,EACnE,0BACA,GAE6B5I,EAAgC,wBAAI4I,EACjE,yBACA,GAE6B5I,EAAgC,wBAAI4I,EACjE,yBACA,GAE+B5I,EAAkC,0BAAI4I,EACrE,2BACA,GAE+B5I,EAAkC,0BAAI4I,EACrE,2BACA,GAE+B5I,EAAkC,0BAAI4I,EACrE,2BACA,GAE+B5I,EAAkC,0BAAI4I,EACrE,2BACA,GAE+B5I,EAAkC,0BAAI4I,EACrE,2BACA,GAE+B5I,EAAkC,0BAAI4I,EACrE,2BACA,GAE4B5I,EAA+B,uBAAI4I,EAC/D,wBACA,GAE+B5I,EAAkC,0BAAI4I,EACrE,2BACA,GAEgC5I,EAAmC,2BAAI4I,EACvE,4BACA,GAEgC5I,EAAmC,2BAAI4I,EACvE,4BACA,GAE6B5I,EAAgC,wBAAI4I,EACjE,yBACA,GAE8B5I,EAAiC,yBAAI4I,EACnE,0BACA,GAEsB5I,EAAyB,iBAAI4I,EAAoB,kBAAmB,GACpE5I,EAAyB,iBAAI4I,EAAoB,kBAAmB,GAClE5I,EAA2B,mBAAI4I,EACvD,oBACA,GAEqB5I,EAAwB,gBAAI4I,EAAoB,iBAAkB,GAC5D5I,EAA8B,sBAAI4I,EAC7D,uBACA,GAE2B5I,EAA8B,sBAAI4I,EAC7D,uBACA,GAE+B5I,EAAkC,0BAAI4I,EACrE,2BACA,GAE8B5I,EAAiC,yBAAI4I,EACnE,0BACA,GAE+B5I,EAAkC,0BAAI4I,EACrE,2BACA,GAE6B5I,EAAgC,wBAAI4I,EACjE,yBACA,GAEuB5I,EAA0B,kBAAI4I,EACrD,mBACA,GAE4B5I,EAA+B,uBAAI4I,EAC/D,wBACA,GAEwB5I,EAA2B,mBAAI4I,EACvD,oBACA,GAEgC5I,EAAmC,2BAAI4I,EACvE,4BACA,GAEgC5I,EAAmC,2BAAI4I,EACvE,4BACA,GAE8B5I,EAAiC,yBAAI4I,EACnE,0BACA,GAE0B5I,EAA6B,qBAAI4I,EAC3D,sBACA,GAEoC5I,EAAuC,+BAC3E4I,EAAoB,gCAAiC,GAChC5I,EAAwB,gBAAI4I,EAAoB,iBAAkB,GACvD5I,EAAmC,2BAAI4I,EACvE,4BACA,GAEoC5I,EAAuC,+BAC3E4I,EAAoB,gCAAiC,GACjB5I,EAAuC,+BAC3E4I,EAAoB,gCAAiC,GAC3B5I,EAA6B,qBAAI4I,EAC3D,sBACA,GAE+B5I,EAAkC,0BAAI4I,EACrE,2BACA,GAE6B5I,EAAgC,wBAAI4I,EACjE,yBACA,GAE2B5I,EAA8B,sBAAI4I,EAC7D,uBACA,GAE6B5I,EAAgC,wBAAI4I,EACjE,yBACA,GAEwB5I,EAA2B,mBAAI4I,EACvD,oBACA,GAEyB5I,EAA4B,oBAAI4I,EACzD,qBACA,GAE8B5I,EAAiC,yBAAI4I,EACnE,0BACA,GAEyB5I,EAA4B,oBAAI4I,EACzD,qBACA,GAE0B5I,EAA6B,qBAAI4I,EAC3D,sBACA,GAE6B5I,EAAgC,wBAAI4I,EACjE,yBACA,GAE4B5I,EAA+B,uBAAI4I,EAC/D,wBACA,GAEuC5I,EAA0C,kCACjF4I,EAAoB,mCAAoC,GAChB5I,EAA2C,mCACnF4I,EAAoB,oCAAqC,GAC/B5I,EAA6B,qBAAI4I,EAC3D,sBACA,GAEuB5I,EAA0B,kBAAI4I,EACrD,mBACA,GAEmC5I,EAAsC,8BACzE4I,EAAoB,+BAAgC,GACd5I,EAAyC,iCAC/E4I,EAAoB,kCAAmC,GAC1C5I,EAAgB,QAAI4I,EAAoB,SAAU,GACpD5I,EAAc,MAAI4I,EAAoB,OAAQ,GAClC5I,EAA0B,kBAAI4I,EACrD,mBACA,GAEwB5I,EAA2B,mBAAI4I,EACvD,oBACA,GAEmB5I,EAAsB,cAAI4I,EAAoB,eAAgB,GACxD5I,EAA4B,oBAAI4I,EACzD,qBACA,GAEuB5I,EAA0B,kBAAI4I,EACrD,mBACA,GAEgC5I,EAAmC,2BAAI4I,EACvE,4BACA,GAEyB5I,EAA4B,oBAAI4I,EACzD,qBACA,GAEuB5I,EAA0B,kBAAI4I,EACrD,mBACA,GAEqB5I,EAAwB,gBAAI4I,EAAoB,iBAAkB,GACpE5I,EAAsB,cAAI4I,EAAoB,eAAgB,GAC/D5I,EAAqB,aAAI4I,EAAoB,cAAe,GACpD5I,EAA6B,qBAAI4I,EAC3D,sBACA,GAE2B5I,EAA8B,sBAAI4I,EAC7D,uBACA,GAEmC5I,EAAsC,8BACzE4I,EAAoB,+BAAgC,GACxB5I,EAA+B,uBAAI4I,EAC/D,wBACA,GAEyB5I,EAA4B,oBAAI4I,EACzD,qBACA,GAEmB5I,EAAsB,cAAI4I,EAAoB,eAAgB,GAC9D5I,EAAsB,cAAI4I,EAAoB,eAAgB,GACjE5I,EAAmB,WAAI4I,EAAoB,YAAa,GACxD5I,EAAmB,WAAI4I,EAAoB,YAAa,GAC5C5I,EAA+B,uBAAI4I,EAC/D,wBACA,GAE2B5I,EAA8B,sBAAI4I,EAC7D,uBACA,GAE2B5I,EAA8B,sBAAI4I,EAC7D,uBACA,GAEmB5I,EAAsB,cAAI4I,EAAoB,eAAgB,GAC3C5I,EAAyC,iCAC/E4I,EAAoB,kCAAmC,GACjB5I,EAAyC,iCAC/E4I,EAAoB,kCAAmC,GACnB5I,EAAuC,+BAC3E4I,EAAoB,gCAAiC,GAC1B5I,EAA8B,sBAAI4I,EAC7D,uBACA,GAE6B5I,EAAgC,wBAAI4I,EACjE,yBACA,GAE8B5I,EAAiC,yBAAI4I,EACnE,0BACA,GAEgC5I,EAAmC,2BAAI4I,EACvE,4BACA,GAE6B5I,EAAgC,wBAAI4I,EACjE,yBACA,GAEyB5I,EAA4B,oBAAI4I,EACzD,qBACA,GAE4B5I,EAA+B,uBAAI4I,EAC/D,wBACA,GAE2B5I,EAA8B,sBAAI4I,EAC7D,uBACA,GAEuC5I,EAA0C,kCACjF4I,EAAoB,mCAAoC,GACtB5I,EAAqC,6BACvE4I,EAAoB,8BAA+B,GACf5I,EAAuC,+BAC3E4I,EAAoB,gCAAiC,GAClB5I,EAAsC,8BACzE4I,EAAoB,+BAAgC,GACf5I,EAAwC,gCAC7E4I,EAAoB,iCAAkC,GACxB5I,EAAiC,yBAAI4I,EACnE,0BACA,GAEuB5I,EAA0B,kBAAI4I,EACrD,mBACA,GAE6B5I,EAAgC,wBAAI4I,EACjE,yBACA,GAE8B5I,EAAiC,yBAAI4I,EACnE,0BACA,GAEwB5I,EAA2B,mBAAI4I,EACvD,oBACA,GAEoC5I,EAAuC,+BAC3E4I,EAAoB,gCAAiC,GACpB5I,EAAoC,4BAAI4I,EACzE,6BACA,GAEiD5I,EACL,4CAC1C4I,EAAoB,6CAA8C,IAClC5I,EAAqC,6BACvE4I,EAAoB,8BAA+B,GACpB5I,EAAkC,0BAAI4I,EACrE,2BACA,GAE4B5I,EAA+B,uBAAI4I,EAC/D,wBACA,GAE2B5I,EAA8B,sBAAI4I,EAC7D,uBACA,GAEyC5I,EAA4C,oCACrF4I,EAAoB,qCAAsC,GACjB5I,EAA4C,oCACrF4I,EAAoB,qCAAsC,GAC7B5I,EAAgC,wBAAI4I,EACjE,yBACA,GAE8B5I,EAAiC,yBAAI4I,EACnE,0BACA,GAEmC5I,EAAsC,8BACzE4I,EAAoB,+BAAgC,GAChB5I,EAAuC,+BAC3E4I,EAAoB,gCAAiC,GACjB5I,EAAuC,+BAC3E4I,EAAoB,gCAAiC,GACpB5I,EAAoC,4BAAI4I,EACzE,6BACA,GAE+B5I,EAAkC,0BAAI4I,EACrE,2BACA,GAE2C5I,EAA8C,sCACzF4I,EAAoB,uCAAwC,GAC3B5I,EAAoC,4BAAI4I,EACzE,6BACA,GAE4B5I,EAA+B,uBAAI4I,EAC/D,wBACA,GAEoC5I,EAAuC,+BAC3E4I,EAAoB,gCAAiC,GACf5I,EAAyC,iCAC/E4I,EAAoB,kCAAmC,GACnB5I,EAAuC,+BAC3E4I,EAAoB,gCAAiC,GACd5I,EAA0C,kCACjF4I,EAAoB,mCAAoC,GACzB5I,EAAkC,0BAAI4I,EACrE,2BACA,GAEiC5I,EAAoC,4BAAI4I,EACzE,6BACA,GAE2C5I,EAA8C,sCACzF4I,EAAoB,uCAAwC,GACf5I,EACL,wCACtC4I,EAAoB,yCAA0C,GACpB5I,EAA+C,uCAC3F4I,EAAoB,wCAAyC,GACjB5I,EAA+C,uCAC3F4I,EAAoB,wCAAyC,GAC5B5I,EAAoC,4BAAI4I,EACzE,6BACA,GAEoC5I,EAAuC,+BAC3E4I,EAAoB,gCAAiC,GACnB5I,EAAqC,6BACvE4I,EAAoB,8BAA+B,GACZ5I,EAA0C,kCACjF4I,EAAoB,mCAAoC,GACf5I,EAA4C,oCACrF4I,EAAoB,qCAAsC,GACT5I,EACL,4CAC1C4I,EAAoB,6CAA8C,GACjC5I,EAAsC,8BACzE4I,EAAoB,+BAAgC,GACb5I,EAA0C,kCACjF4I,EAAoB,mCAAoC,GAClB5I,EAAyC,iCAC/E4I,EAAoB,kCAAmC,GAChB5I,EAA0C,kCACjF4I,EAAoB,mCAAoC,GAClB5I,EAAyC,iCAC/E4I,EAAoB,kCAAmC,GACT5I,EACL,yCACvC4I,EAAoB,0CAA2C,GACpB5I,EACL,wCACtC4I,EAAoB,yCAA0C,GACnB5I,EACL,wCACtC4I,EAAoB,yCAA0C,GACrB5I,EAA8C,sCACzF4I,EAAoB,uCAAwC,GAChB5I,EAA+C,uCAC3F4I,EAAoB,wCAAyC,GACf5I,EACL,yCACvC4I,EAAoB,0CAA2C,GAChB5I,EACL,4CAC1C4I,EAAoB,6CAA8C,GACjB5I,EACL,8CAC5C4I,EAAoB,+CAAgD,GAC1C5I,EAA+B,uBAAI4I,EAC/D,wBACA,GAE6B5I,EAAgC,wBAAI4I,EACjE,yBACA,GAE4B5I,EAA+B,uBAAI4I,EAC/D,wBACA,GAEiC5I,EAAoC,4BAAI4I,EACzE,6BACA,GAEiC5I,EAAoC,4BAAI4I,EACzE,6BACA,GAEoC5I,EAAuC,+BAC3E4I,EAAoB,gCAAiC,GAChB5I,EAAwC,gCAC7E4I,EAAoB,iCAAkC,GAC9B5I,EAA2B,mBAAI4I,EACvD,oBACA,GAEyB5I,EAA4B,oBAAI4I,EACzD,qBACA,GAE0B5I,EAA6B,qBAAI4I,EAC3D,sBACA,GAE0B5I,EAA6B,qBAAI4I,EAC3D,sBACA,GAE6B5I,EAAgC,wBAAI4I,EACjE,yBACA,GAE2B5I,EAA8B,sBAAI4I,EAC7D,uBACA,GAEwB5I,EAA2B,mBAAI4I,EACvD,oBACA,GAEkC5I,EAAqC,6BACvE4I,EAAoB,8BAA+B,GACxB5I,EAA8B,sBAAI4I,EAC7D,uBACA,GAE2B5I,EAA8B,sBAAI4I,EAC7D,uBACA,GAE6B5I,EAAgC,wBAAI4I,EACjE,yBACA,GAE4B5I,EAA+B,uBAAI4I,EAC/D,wBACA,GAE8B5I,EAAiC,yBAAI4I,EACnE,0BACA,GAE4B5I,EAA+B,uBAAI4I,EAC/D,wBACA,GAE0B5I,EAA6B,qBAAI4I,EAC3D,sBACA,GAE+B5I,EAAkC,0BAAI4I,EACrE,2BACA,GAEyB5I,EAA4B,oBAAI4I,EACzD,qBACA,GAE6B5I,EAAgC,wBAAI4I,EACjE,yBACA,GAEiC5I,EAAoC,4BAAI4I,EACzE,6BACA,GAEuB5I,EAA0B,kBAAI4I,EACrD,mBACA,GAE0B5I,EAA6B,qBAAI4I,EAC3D,sBACA,GAEuB5I,EAA0B,kBAAI4I,EACrD,mBACA,GAE8B5I,EAAiC,yBAAI4I,EACnE,0BACA,GAEyB5I,EAA4B,oBAAI4I,EACzD,qBACA,GAEwB5I,EAA2B,mBAAI4I,EACvD,oBACA,GAEwB5I,EAA2B,mBAAI4I,EACvD,oBACA,GAEiC5I,EAAoC,4BAAI4I,EACzE,6BACA,GAE2B5I,EAA8B,sBAAI4I,EAC7D,uBACA,GAEyB5I,EAA4B,oBAAI4I,EACzD,qBACA,GAE4B5I,EAA+B,uBAAI4I,EAC/D,wBACA,GAE6B5I,EAAgC,wBAAI4I,EACjE,yBACA,GAEsB5I,EAAyB,iBAAI4I,EAAoB,kBAAmB,GAChE5I,EAA6B,qBAAI4I,EAC3D,sBACA,GAEuB5I,EAA0B,kBAAI4I,EACrD,mBACA,GAE4B5I,EAA+B,uBAAI4I,EAC/D,wBACA,GAE6B5I,EAAgC,wBAAI4I,EACjE,yBACA,GAEuC5I,EAA0C,kCACjF4I,EAAoB,mCAAoC,GACrB5I,EAAsC,8BACzE4I,EAAoB,+BAAgC,GAChB5I,EAAuC,+BAC3E4I,EAAoB,gCAAiC,GAC1B5I,EAA8B,sBAAI4I,EAC7D,uBACA,GAE0B5I,EAA6B,qBAAI4I,EAC3D,sBACA,GAE2B5I,EAA8B,sBAAI4I,EAC7D,uBACA,GAE0B5I,EAA6B,qBAAI4I,EAC3D,sBACA,GAEyB5I,EAA4B,oBAAI4I,EACzD,qBACA,GAE2B5I,EAA8B,sBAAI4I,EAC7D,uBACA,GAE0B5I,EAA6B,qBAAI4I,EAC3D,sBACA,GAE2B5I,EAA8B,sBAAI4I,EAC7D,uBACA,GAE0B5I,EAA6B,qBAAI4I,EAC3D,sBACA,GAEyB5I,EAA4B,oBAAI4I,EACzD,qBACA,GAEiC5I,EAAoC,4BAAI4I,EACzE,6BACA,GAEoC5I,EAAuC,+BAC3E4I,EAAoB,gCAAiC,GACvB5I,EAAiC,yBAAI4I,EACnE,0BACA,GAE8B5I,EAAiC,yBAAI4I,EACnE,0BACA,GAEqC5I,EAAwC,gCAC7E4I,EAAoB,iCAAkC,GACpB5I,EAAqC,6BACvE4I,EAAoB,8BAA+B,GACzB5I,EAA6B,qBAAI4I,EAC3D,sBACA,GAE2B5I,EAA8B,sBAAI4I,EAC7D,uBACA,GAE8B5I,EAAiC,yBAAI4I,EACnE,0BACA,GAEuB5I,EAA0B,kBAAI4I,EACrD,mBACA,GAE0B5I,EAA6B,qBAAI4I,EAC3D,sBACA,GAE4B5I,EAA+B,uBAAI4I,EAC/D,wBACA,GAEwB5I,EAA2B,mBAAI4I,EACvD,oBACA,GAEuB5I,EAA0B,kBAAI4I,EACrD,mBACA,GAEmB5I,EAAsB,cAAI4I,EAAoB,eAAgB,GACtD5I,EAA8B,sBAAI4I,EAC7D,uBACA,GAE6B5I,EAAgC,wBAAI4I,EACjE,yBACA,GAE8B5I,EAAiC,yBAAI4I,EACnE,0BACA,GAE0B5I,EAA6B,qBAAI4I,EAC3D,sBACA,GAE+C5I,EACL,0CACxC4I,EAAoB,2CAA4C,GACrC5I,EAAgC,wBAAI4I,EACjE,yBACA,GAEiC5I,EAAoC,4BAAI4I,EACzE,6BACA,GAEsC5I,EAAyC,iCAC/E4I,EAAoB,kCAAmC,GAC/B5I,EAA2B,mBAAI4I,EACvD,oBACA,GAEoB5I,EAAuB,eAAI4I,EAAoB,gBAAiB,GAC3D5I,EAA4B,oBAAI4I,EACzD,qBACA,GAEwB5I,EAA2B,mBAAI4I,EACvD,oBACA,GAE0B5I,EAA6B,qBAAI4I,EAC3D,sBACA,GAEyB5I,EAA4B,oBAAI4I,EACzD,qBACA,GAE8B5I,EAAiC,yBAAI4I,EACnE,0BACA,GAE4B5I,EAA+B,uBAAI4I,EAC/D,wBACA,GAEsC5I,EAAyC,iCAC/E4I,EAAoB,kCAAmC,GAC1B5I,EAAgC,wBAAI4I,EACjE,yBACA,GAEqB5I,EAAwB,gBAAI4I,EAAoB,iBAAkB,GAC9D5I,EAA4B,oBAAI4I,EACzD,qBACA,GAEwB5I,EAA2B,mBAAI4I,EACvD,oBACA,GAEwB5I,EAA2B,mBAAI4I,EACvD,oBACA,IAEwB5I,EAA2B,mBAAI4I,EACvD,oBACA,IAEwB5I,EAA2B,mBAAI4I,EACvD,oBACA,GAE0B5I,EAA6B,qBAAI4I,EAC3D,sBACA,GAE2B5I,EAA8B,sBAAI4I,EAC7D,uBACA,GAE0B5I,EAA6B,qBAAI4I,EAC3D,sBACA,GAE2B5I,EAA8B,sBAAI4I,EAC7D,uBACA,GAE0B5I,EAA6B,qBAAI4I,EAC3D,sBACA,GAE2B5I,EAA8B,sBAAI4I,EAC7D,uBACA,GAE2B5I,EAA8B,sBAAI4I,EAC7D,uBACA,GAEyB5I,EAA4B,oBAAI4I,EACzD,qBACA,GAE+B5I,EAAkC,0BAAI4I,EACrE,2BACA,GAE8B5I,EAAiC,yBAAI4I,EACnE,0BACA,GAEqC5I,EAAwC,gCAC7E4I,EAAoB,iCAAkC,GACpB5I,EAAqC,6BACvE4I,EAAoB,8BAA+B,GACZ5I,EAA0C,kCACjF4I,EAAoB,mCAAoC,GACZ5I,EAA+C,uCAC3F4I,EAAoB,wCAAyC,GACf5I,EACL,yCACvC4I,EAAoB,0CAA2C,GAClC5I,EAAkC,0BAAI4I,EACrE,2BACA,GAE6B5I,EAAgC,wBAAI4I,EACjE,yBACA,GAE2B5I,EAA8B,sBAAI4I,EAC7D,uBACA,GAE8B5I,EAAiC,yBAAI4I,EACnE,0BACA,GAEwB5I,EAA2B,mBAAI4I,EACvD,oBACA,GAE6B5I,EAAgC,wBAAI4I,EACjE,yBACA,GAE4B5I,EAA+B,uBAAI4I,EAC/D,wBACA,GAE+B5I,EAAkC,0BAAI4I,EACrE,2BACA,GAE0B5I,EAA6B,qBAAI4I,EAC3D,sBACA,GAEF,IAmZIwzB,GACAC,GApZA5R,GAAU7hB,EAAoB,SAAU,GACxC0L,GAA+B1L,EAAoB,8BAA+B,GAClF6Y,GAAY7Y,EAAoB,WAAY,GAC5CsyB,GAAYtyB,EAAoB,WAAY,GAE5C0zB,GAAyBA,KAC1BA,GAAyBtzB,GAAmC,yBAK3D9C,GAA4BA,KAC7BA,GAA4B8C,GAAsC,4BACjEmC,GAA8BoxB,IAC/BpxB,GAA6BnC,GAAuC,2BAAGuzB,GACtE5K,GAA4B4K,IAC7B5K,GAA2B3oB,GAAqC,yBAAGuzB,GAClElxB,GAAgCA,KACjCA,GAAgCrC,GAA0C,gCA0Y7E,SAASwzB,KAhkNT,IACMv2B,EAmkNJq2B,KAlkNAp6B,IAAc,GADV+D,EAAMC,QAKC,GAAPD,IACFA,GAAO,GAKTjB,EAAQiB,GAAO,GAAK,SACpBjB,EAASiB,EAAM,GAAM,GAAK,WAE1BjB,EAAQ,GAAU,UAwjNxB,CAEI,SAASy3B,KA5hNT,IACMC,EA4iNJ,SAASC,IAGHP,KACJA,GAAY,EACZp8B,EAAkB,UAAI,EAElBmF,IA1iNNjD,GAAQ0E,GACRA,GAAqB,EAErBZ,IAEKhG,EAAiB,UAAMmP,GAAGiS,aAAajS,GAAGsC,OAC/CtC,GAAGkS,mBAAoB,EAGvBzW,GAAqBlE,GAqiNnB5G,EAAoBE,GACpBA,EAA6B,yBAE7BkC,GACGlC,EAAc,MACf,4GAviNN,WACEgG,IAEA,IAAI42B,EAAW58B,EAAgB,QAC3B48B,IACqB,mBAAZA,IAAwBA,EAAW,CAACA,IAC/CA,EAASv8B,QAAQ2G,IAGnB4D,GAAqBjE,EAC3B,CAgiNQk2B,IACR,CApCUv1B,EAAkB,IAItBk1B,MAEKH,KACHA,GAAe,GAniNbK,EAAU18B,EAAe,UAEL,mBAAX08B,IAAuBA,EAAU,CAACA,IAC7CA,EAAQr8B,QAAQwG,IAElB+D,GAAqBnE,GAkiNfa,EAAkB,KA2BpBtH,EAAkB,WACpBA,EAAkB,UAAE,cACpBmC,WAAW,KACTA,WAAW,IAAMnC,EAAkB,UAAE,IAAK,GAC1C28B,KACC,IAEHA,IAEF32B,KACN,CA4CI,GA/ekBhG,EAAmB,WAAI4I,EAAoB,aAAc,GACxD5I,EAAoB,YAAI4I,EAAoB,cAAe,GAC1D5I,EAAqB,aAAI4I,EAAoB,eAAgB,GAC9D5I,EAAoB,YAAI4I,EAAoB,cAAe,GAC7D5I,EAAkB,UAAI4I,EAAoB,YAAa,GACrD5I,EAAoB,YAAI4I,EAAoB,cAAe,GAC3D5I,EAAoB,YAAI4I,EAAoB,cAAe,GACxD5I,EAAuB,eAAI4I,EAAoB,iBAAkB,GACnE5I,EAAqB,aAAI4I,EAAoB,eAAgB,GAC7D5I,EAAqB,aAAI4I,EAAoB,eAAgB,GAC3D5I,EAAuB,eAAI4I,EAAoB,iBAAkB,GAChE5I,EAAwB,gBAAI4I,EAAoB,kBAAmB,GAClE5I,EAAyB,iBAAI4I,EACnD,mBACA,IAEkB5I,EAAqB,aAAI4I,EAAoB,eAAgB,GAkFjF5I,EAAoB,YAAIgJ,GACxBhJ,EAAc,MAAI4xB,GAClB5xB,EAAc,MA9wDF88B,CAACjL,EAAOC,EAAYC,EAAUlP,IACjC,IAAI9Z,IAAS6oB,GAAMC,EAAOC,EAAYC,EAAUhpB,GA8wDzD/I,EAAoB,YAl4DF+8B,CAACxyB,EAAM4lB,KACvBjuB,OAAsB,IAARqI,GAGd,IAAIyyB,EAAM7L,GAAmB5mB,GAC7B,GAAIyyB,EACF,OAAOA,EAKT,IAAIrwB,EArCkBswB,MAEtB,GAAI1L,GAAiBtoB,OACnB,OAAOsoB,GAAiBtL,MAG1B,IACE5U,GAAUwd,KAAK,EAChB,CAAC,MAAOvqB,GACP,KAAMA,aAAe44B,YACnB,MAAM54B,EAER,KAAM,oDACd,CACM,OAAO+M,GAAUpI,OAAS,GAuBhBg0B,GAGV,IAEEzL,GAAkB7kB,EAAKpC,EACxB,CAAC,MAAOjG,GACP,KAAMA,aAAe+K,WACnB,MAAM/K,EAERpC,OAAqB,IAAPiuB,EAAoB,8CAAgD5lB,GAClF,IAAI4yB,EAAUjN,GAAwB3lB,EAAM4lB,GAC5CqB,GAAkB7kB,EAAKwwB,EAC/B,CAIM,OAFA7rB,GAAoB1Q,IAAI2J,EAAMoC,GAEvBA,GAu2DT3M,EAAuB,eA5wDD+6B,IACpBzpB,GAAoB8rB,OAAOxN,GAAkBmL,IAC7CvJ,GAAkBuJ,EAAO,MACzBxJ,GAAiBrhB,KAAK6qB,IA0wDxB/6B,EAAiB,SAzqLjB,SAAkB8K,EAAKuyB,EAAOj8B,EAAO,MAEnC,OADIA,EAAKk8B,SAAS,OAAMl8B,EAAO,KACvBA,GACN,IAAK,KAGL,IAAK,KACHuD,EAAMmG,GAAOuyB,EACb,MACF,IAAK,MACHx4B,EAAOiG,GAAO,GAAKuyB,EACnB,MACF,IAAK,MACHt4B,EAAO+F,GAAO,GAAKuyB,EACnB,MACF,IAAK,MACH18B,EAAM,uCACR,IAAK,QACHsE,EAAQ6F,GAAO,GAAKuyB,EACpB,MACF,IAAK,SACHn4B,EAAQ4F,GAAO,GAAKuyB,EACpB,MACF,IAAK,IACHr4B,EAAQ8F,GAAO,GAAKuyB,EACpB,MACF,QACE18B,EAAM,8BAA8BS,KAE9C,EA6oLIpB,EAAiB,SAhtLjB,SAAkB8K,EAAK1J,EAAO,MAE5B,OADIA,EAAKk8B,SAAS,OAAMl8B,EAAO,KACvBA,GACN,IAAK,KAEL,IAAK,KACH,OAAOuD,EAAMmG,GACf,IAAK,MACH,OAAOjG,EAAOiG,GAAO,GACvB,IAAK,MACH,OAAO/F,EAAO+F,GAAO,GACvB,IAAK,MACHnK,EAAM,uCACR,IAAK,QACH,OAAOsE,EAAQ6F,GAAO,GACxB,IAAK,SACH,OAAO5F,EAAQ4F,GAAO,GACxB,IAAK,IACH,OAAO9F,EAAQ8F,GAAO,GACxB,QACEnK,EAAM,8BAA8BS,KAE9C,EA2rLIpB,EAAqB,aAAIuM,GACzBvM,EAAqB,aAAIuuB,GACzBvuB,EAAsB,cA7lEFu9B,CAACzyB,EAAKa,KACxBzJ,EAAO4I,EAAM,GAAK,EAAG,iEAUrB,IATA,IAAIgB,EAAShB,EAKTY,EAAMI,GAAU,EAChB0xB,EAAS9xB,EAAMC,EAAiB,IAG3BD,GAAO8xB,IAAW14B,EAAQ4G,MAAQA,EAG3C,IAFAI,EAASJ,GAAO,GAEHZ,EAAM,IAAMglB,GACvB,OAAOA,GAAa/jB,OAAOnH,EAAO4B,SAASsE,EAAKgB,IAQlD,IALA,IAAIE,EAAM,GAKDuB,EAAI,IAAKA,GAAK5B,EAAiB,KAAM4B,EAAG,CAC/C,IAAIkwB,EAAW54B,EAAQiG,EAAU,EAAJyC,GAAU,GACvC,GAAgB,GAAZkwB,EAAe,MAGnBzxB,GAAOI,OAAOC,aAAaoxB,EACnC,CAEM,OAAOzxB,GA+jEThM,EAAsB,cA5wDF09B,CAAC1xB,EAAKwiB,EAAQ5d,KAQhC,GAPA1O,EAAOssB,EAAS,GAAK,EAAG,iEACxBtsB,EAC4B,iBAAnB0O,EACP,8HAGFA,IAAoB,WAChBA,EAAkB,EAAG,OAAO,EAIhC,IAFA,IAAI+sB,EAAWnP,EACXoP,GAFJhtB,GAAmB,GAEkC,EAAb5E,EAAI/C,OAAa2H,EAAkB,EAAI5E,EAAI/C,OAC1EsE,EAAI,EAAGA,EAAIqwB,IAAmBrwB,EAAG,CAExC,IAAIkwB,EAAWzxB,EAAIwE,WAAWjD,GAC9B1I,EAAO2pB,GAAU,GAAKiP,EACtBjP,GAAU,CAClB,CAGM,OADA3pB,EAAO2pB,GAAU,GAAK,EACfA,EAASmP,GAyvDU,CAC1B,gBACA,uBACA,yBACA,uBACA,yBACA,iBACA,iBACA,sBACA,sBACA,cACA,cACA,SACA,YACA,YACA,YACA,YACA,eACA,gBACA,gBACA,gBACA,UACA,aACA,yBACA,gBACA,eACA,UACA,kBACA,mBACA,uBACA,sBACA,mBACA,YACA,cACA,kBACA,oBACA,aACA,cACA,eACA,aACA,iBACA,SACA,SACA,SACA,eACA,mBACA,gBACA,mBACA,gBACA,gBACA,mBACA,kBACA,2BACA,yBACA,kBACA,wBACA,qBACA,6BACA,6BACA,0BACA,6BACA,iCACA,yCACA,4BACA,oCACA,oBACA,iCACA,yCACA,gCACA,wCACA,6BACA,qCACA,0BACA,mCACA,wBACA,eACA,wCACA,sBACA,iCACA,yCACA,wCACA,qBACA,gCACA,wCACA,6BACA,uBACA,+BACA,oCACA,uBACA,UACA,+BACA,uBACA,uBACA,eACA,eACA,4BACA,iBACA,yBACA,yBACA,uBACA,iBACA,sBACA,wBACA,uBACA,uBACA,sBACA,aACA,cACA,gBACA,sBACA,gBACA,oBACA,kCACA,4BACA,WACA,UACA,kBACA,mBACA,YACA,eACA,sBACA,yBACA,oBACA,sCACA,uCACA,kCACA,gCACA,wCACA,gCACA,kCACA,qBACA,gCACA,iCACA,iCACA,4BACA,0BACA,6CACA,uBACA,iCACA,+BACA,eACA,6BACA,qBACA,eACA,cACA,WACA,sBACA,qBACA,WACA,WACA,cAEoBt9B,QAh7LtB,SAA8BiK,GAC5BD,GAAuBC,EAAK,KAG1B,IAAIG,EAAM,KAAKH,mJAIXuzB,EAAgBvzB,EACfuzB,EAAc16B,WAAW,OAC5B06B,EAAgB,IAAMvzB,GAExBG,GAAO,8CAA8CozB,MACjDzzB,GAA4BE,KAC9BG,GACE,4FAEJC,GAASD,KAKXE,GAAwBL,EAC9B,GA25L4B,CACtB,MACA,cACA,YACA,eACA,YACA,eACA,mBACA,sBACA,MACA,MACA,WACA,QACA,aACA,mBACA,mBACA,6BACA,YACA,eACA,aACA,cACA,aACA,aACA,aACA,MACA,cACA,WACA,MACA,YACA,UACA,iBACA,aACA,SACA,WACA,qBACA,UACA,oBACA,YACA,cACA,YACA,YACA,gBACA,WACA,gBACA,iBACA,mBACA,0BACA,mBACA,sBACA,oBACA,iBACA,qBACA,OACA,UACA,cACA,oBACA,oBACA,kBACA,qBACA,gBACA,eACA,sBACA,qBACA,WACA,qBACA,wBACA,4BACA,0BACA,eACA,aACA,gBACA,UACA,WACA,aACA,yBACA,gBACA,kBACA,UACA,8BACA,OACA,qBACA,kBACA,gCACA,6BACA,aACA,eACA,WACA,iBACA,yBACA,uBACA,aACA,0BACA,mBACA,gBACA,kBACA,cACA,KACA,oBACA,oBACA,QACA,MACA,SACA,SACA,uBACA,4BACA,0BACA,KACA,KACA,OACA,MACA,OACA,WACA,MACA,UACA,eACA,sBACA,QACA,YAEgBjK,QAAQsK,IAK1BnD,EAAwB,SAASs2B,IAE1B1B,IAAWK,KACXL,KAAW50B,EAAwBs2B,IAyGtC99B,EAAgB,QAElB,IADgC,mBAArBA,EAAgB,UAAiBA,EAAgB,QAAI,CAACA,EAAgB,UAC1EA,EAAgB,QAAEiJ,OAAS,GAChCjJ,EAAgB,QAAEimB,KAAlBjmB,GAIJy8B,KAWA58B,EAAYI,EAOZ,IAAK,MAAMK,KAAQC,OAAO4X,KAAKnY,GACvBM,KAAQV,GACZW,OAAOE,eAAeb,EAAWU,EAAM,CACrC6J,cAAc,EACdzJ,GAAAA,GACEC,EACE,+BAA+BL,oHAE7C,IAMI,OAAOT,y64BC5nPL,SAAUk+B,EACdC,EACAC,EACAC,EACAC,EAAwB,KAExB,IAAI34B,EAASw4B,EAAWh1B,YAAYo1B,OAAOD,GAC3C,IAAK,IAAI5wB,EAAI,EAAGA,EAAI4wB,EAAe5wB,IACjCywB,EAAWr5B,MAAMa,EAAS+H,GAAK,EAEjC,MAAM8wB,EAAeJ,EAAUz4B,EAAQ24B,GACvC,IAAInyB,EACJ,GAAIqyB,EAAeF,EAAe,CAChCH,EAAWh1B,YAAYs1B,KAAK94B,GAC5BA,EAASw4B,EAAWh1B,YAAYo1B,OAAOC,GACvC,IAAK,IAAI9wB,EAAI,EAAGA,EAAI8wB,EAAc9wB,IAChCywB,EAAWr5B,MAAMa,EAAS+H,GAAK,EAEjC0wB,EAAUz4B,EAAQ64B,GAClBryB,EAAMkyB,EAAW14B,QAEjBwG,EAAMkyB,EAAW14B,GAInB,OAFAw4B,EAAWh1B,YAAYs1B,KAAK94B,GAErBwG,CACT,CASgB,SAAAuyB,EACdP,EACAC,GAEA,MAAMO,EAAaP,EAAU,EAAG,GAE1BQ,EAAYT,EAAWh1B,YAAYo1B,OAAOI,GAEhDP,EAAUQ,EAAWD,GAErB,MAAMt6B,EAAc,IAAIsU,YAAYgmB,GAC9B5vB,EAAO,IAAI8vB,SAASx6B,GAE1B,IAAK,IAAIqJ,EAAI,EAAGA,EAAIixB,EAAYjxB,IAC9BqB,EAAK+vB,QAAQpxB,EAAGywB,EAAWY,SAASH,EAAYlxB,EAAG,OAKrD,OAFAywB,EAAWh1B,YAAYs1B,KAAKG,GAErBv6B,CACT"}