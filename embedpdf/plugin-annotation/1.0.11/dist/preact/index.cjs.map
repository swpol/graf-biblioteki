{"version":3,"sources":["../../src/preact/index.ts","../../../core/src/lib/utils/dependency-resolver.ts","../../../core/src/lib/types/errors.ts","../../../core/src/lib/store/plugin-store.ts","../../../core/src/lib/store/actions.ts","../../../core/src/lib/store/store.ts","../../../models/dist/index.js","../../../core/src/lib/store/initial-state.ts","../../../core/src/lib/store/reducer.ts","../../../core/src/lib/registry/plugin-registry.ts","../../../core/src/lib/utils/math.ts","../../../core/src/preact/context.ts","../../../core/src/preact/components/embed-pdf.tsx","../../../core/src/preact/hooks/use-registry.ts","../../../core/src/preact/hooks/use-plugin.ts","../../../core/src/preact/hooks/use-capability.ts","../../../core/src/preact/hooks/use-store-state.ts","../../../core/src/preact/hooks/use-core-state.ts","../../src/lib/manifest.ts","../../../core/src/lib/utils/dependency-resolver.ts","../../../core/src/lib/types/errors.ts","../../../core/src/lib/store/plugin-store.ts","../../../core/src/lib/store/actions.ts","../../../core/src/lib/store/store.ts","../../../models/dist/index.js","../../../core/src/lib/store/initial-state.ts","../../../core/src/lib/store/reducer.ts","../../../core/src/lib/registry/plugin-registry.ts","../../../core/src/lib/utils/math.ts","../../../core/src/lib/store/selectors.ts","../../../core/src/lib/utils/plugin-helpers.ts","../../../core/src/lib/base/base-plugin.ts","../../../core/src/lib/utils/event-control.ts","../../../core/src/lib/utils/eventing.ts","../../../core/src/lib/utils/typed-object.ts","../../../models/src/geometry.ts","../../../models/src/logger.ts","../../../models/src/task.ts","../../../models/src/pdf.ts","../../../models/src/color.ts","../../../models/src/date.ts","../../../models/src/index.ts","../../src/lib/actions.ts","../../src/lib/utils.ts","../../src/lib/selectors.ts","../../src/lib/variant-key.ts","../../src/lib/annotation-plugin.ts","../../src/lib/reducer.ts","../../src/lib/index.ts","../../src/preact/hooks/use-annotation.ts","../../../models/src/geometry.ts","../../../models/src/logger.ts","../../../models/src/task.ts","../../../models/src/pdf.ts","../../../models/src/color.ts","../../../models/src/date.ts","../../../models/src/index.ts","../../../plugin-interaction-manager/src/shared/utils.ts","../../../models/dist/index.js","../../../core/dist/math-ChSRQF3r.js","../../../core/dist/index.js","../../../plugin-interaction-manager/src/lib/actions.ts","../../../plugin-interaction-manager/src/lib/helper.ts","../../../plugin-interaction-manager/src/lib/interaction-manager-plugin.ts","../../../plugin-interaction-manager/src/lib/reducer.ts","../../../core/dist/preact/index.js","../../../plugin-interaction-manager/src/preact/hooks/use-interaction-manager.ts","../../../plugin-interaction-manager/src/preact/components/global-pointer-provider.tsx","../../../plugin-interaction-manager/src/preact/components/page-pointer-provider.tsx","../../src/preact/components/annotations.tsx","../../src/preact/components/annotation-container.tsx","../../src/preact/components/text-markup/highlight.tsx","../../src/preact/components/text-markup/underline.tsx","../../src/preact/components/text-markup/strikeout.tsx","../../src/preact/components/text-markup/squiggly.tsx","../../src/preact/components/annotations/ink.tsx","../../../core/dist/math-ChSRQF3r.js","../../../core/dist/index.js","../../../models/dist/index.js","../../../plugin-selection/src/lib/actions.ts","../../../plugin-selection/src/lib/selectors.ts","../../../plugin-selection/src/lib/utils.ts","../../../plugin-selection/src/lib/selection-plugin.ts","../../../plugin-interaction-manager/dist/reducer-Dda407Go.js","../../../plugin-interaction-manager/dist/index-Q-vI1_iw.js","../../../core/dist/preact/index.js","../../../plugin-selection/src/preact/hooks/use-selection.ts","../../../plugin-interaction-manager/dist/preact/index.js","../../../plugin-selection/src/preact/components/selection-layer.tsx","../../../plugin-selection/src/preact/components/copy-to-clipboard.tsx","../../src/shared/resize-ink.ts","../../src/preact/components/text-markup.tsx","../../src/preact/components/annotations/ink-paint.tsx","../../src/preact/components/annotation-layer.tsx"],"sourcesContent":["export * from './hooks';\nexport * from './components';\n","export class DependencyResolver {\n  private dependencyGraph = new Map<string, Set<string>>();\n\n  addNode(id: string, dependencies: string[] = []) {\n    this.dependencyGraph.set(id, new Set(dependencies));\n  }\n\n  private hasCircularDependencies(): boolean {\n    const visited = new Set<string>();\n    const recursionStack = new Set<string>();\n\n    const dfs = (id: string): boolean => {\n      visited.add(id);\n      recursionStack.add(id);\n\n      const dependencies = this.dependencyGraph.get(id) || new Set();\n      for (const dep of dependencies) {\n        if (!visited.has(dep)) {\n          if (dfs(dep)) return true;\n        } else if (recursionStack.has(dep)) {\n          return true; // Circular dependency found\n        }\n      }\n\n      recursionStack.delete(id);\n      return false;\n    };\n\n    for (const id of this.dependencyGraph.keys()) {\n      if (!visited.has(id)) {\n        if (dfs(id)) return true;\n      }\n    }\n\n    return false;\n  }\n\n  resolveLoadOrder(): string[] {\n    if (this.hasCircularDependencies()) {\n      throw new Error('Circular dependencies detected');\n    }\n\n    const result: string[] = [];\n    const visited = new Set<string>();\n    const temp = new Set<string>();\n\n    const visit = (id: string) => {\n      if (temp.has(id)) throw new Error('Circular dependency');\n      if (visited.has(id)) return;\n\n      temp.add(id);\n\n      const dependencies = this.dependencyGraph.get(id) || new Set();\n      for (const dep of dependencies) {\n        visit(dep);\n      }\n\n      temp.delete(id);\n      visited.add(id);\n      result.push(id);\n    };\n\n    for (const id of this.dependencyGraph.keys()) {\n      if (!visited.has(id)) {\n        visit(id);\n      }\n    }\n\n    return result;\n  }\n}\n","export class PluginRegistrationError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'PluginRegistrationError';\n  }\n}\n\nexport class PluginNotFoundError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'PluginNotFoundError';\n  }\n}\n\nexport class CircularDependencyError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'CircularDependencyError';\n  }\n}\n\nexport class CapabilityNotFoundError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'CapabilityNotFoundError';\n  }\n}\n\n// You might also want to add:\nexport class CapabilityConflictError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'CapabilityConflictError';\n  }\n}\n\nexport class PluginInitializationError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'PluginInitializationError';\n  }\n}\n\nexport class PluginConfigurationError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'PluginConfigurationError';\n  }\n}\n","import { Store } from './store';\nimport { Action } from './types';\n\n/**\n * A type-safe store handle for plugins, providing access to plugin-specific state and actions.\n */\nexport class PluginStore<PluginState, PluginAction extends Action> {\n  private store: Store<any, any>;\n  private pluginId: string;\n\n  /**\n   * Initializes the PluginStore with the main store and plugin ID.\n   * @param store The main store instance.\n   * @param pluginId The unique identifier for the plugin.\n   */\n  constructor(store: Store<any, any>, pluginId: string) {\n    this.store = store;\n    this.pluginId = pluginId;\n  }\n\n  /**\n   * Gets the current state of the plugin.\n   * @returns The plugin's state.\n   */\n  getState(): PluginState {\n    return this.store.getState().plugins[this.pluginId] as PluginState;\n  }\n\n  /**\n   * Dispatches an action for the plugin and returns the *new* global state.\n   * If you only need the plugin’s updated state, call `getState()` afterward.\n   * @param action The action to dispatch.\n   * @returns The updated global store state (after plugin reducer).\n   */\n  dispatch(action: PluginAction): PluginState {\n    return this.store.dispatchToPlugin(this.pluginId, action);\n  }\n\n  /**\n   * Subscribes to state changes only for this specific plugin.\n   * You now receive (action, newPluginState, oldPluginState) in the callback.\n   *\n   * @param listener The callback to invoke when plugin state changes.\n   * @returns A function to unsubscribe the listener.\n   */\n  subscribeToState(\n    listener: (action: PluginAction, newState: PluginState, oldState: PluginState) => void,\n  ) {\n    return this.store.subscribeToPlugin(this.pluginId, (action, newPluginState, oldPluginState) => {\n      listener(\n        action as PluginAction,\n        newPluginState as PluginState,\n        oldPluginState as PluginState,\n      );\n    });\n  }\n\n  /**\n   * Subscribes to a specific action type for the plugin.\n   * This still uses the main store's `onAction`, so you get the *global*\n   * old/new store states there. If you specifically want old/new plugin state,\n   * use `subscribeToState` instead.\n   *\n   * @param type The action type to listen for.\n   * @param handler The callback to invoke when the action occurs.\n   * @returns A function to unsubscribe the handler.\n   */\n  onAction<T extends PluginAction['type']>(\n    type: T,\n    handler: (\n      action: Extract<PluginAction, { type: T }>,\n      state: PluginState,\n      oldState: PluginState,\n    ) => void,\n  ) {\n    return this.store.onAction(type, (action, state, oldState) => {\n      handler(\n        action as Extract<PluginAction, { type: T }>,\n        state.plugins[this.pluginId] as PluginState,\n        oldState.plugins[this.pluginId] as PluginState,\n      );\n    });\n  }\n}\n","import { PdfDocumentObject, PdfPageObject, Rotation } from '@embedpdf/models';\n\nexport const LOAD_DOCUMENT = 'LOAD_DOCUMENT';\nexport const SET_DOCUMENT = 'SET_DOCUMENT';\nexport const SET_DOCUMENT_ERROR = 'SET_DOCUMENT_ERROR';\nexport const SET_SCALE = 'SET_SCALE';\nexport const SET_ROTATION = 'SET_ROTATION';\nexport const SET_PAGES = 'SET_PAGES';\n\nexport const CORE_ACTION_TYPES = [\n  LOAD_DOCUMENT,\n  SET_DOCUMENT,\n  SET_DOCUMENT_ERROR,\n  SET_SCALE,\n  SET_ROTATION,\n  SET_PAGES,\n] as const;\n\n// Action Type Interfaces\nexport interface LoadDocumentAction {\n  type: typeof LOAD_DOCUMENT;\n}\n\nexport interface SetDocumentAction {\n  type: typeof SET_DOCUMENT;\n  payload: PdfDocumentObject;\n}\n\nexport interface SetDocumentErrorAction {\n  type: typeof SET_DOCUMENT_ERROR;\n  payload: string;\n}\n\nexport interface SetScaleAction {\n  type: typeof SET_SCALE;\n  payload: number;\n}\n\nexport interface SetRotationAction {\n  type: typeof SET_ROTATION;\n  payload: Rotation;\n}\n\nexport interface SetPagesAction {\n  type: typeof SET_PAGES;\n  payload: PdfPageObject[][];\n}\n\nexport type DocumentAction =\n  | LoadDocumentAction\n  | SetDocumentAction\n  | SetDocumentErrorAction\n  | SetScaleAction\n  | SetRotationAction\n  | SetPagesAction;\n\n// Core actions\nexport type CoreAction = DocumentAction;\n\nexport const loadDocument = (): CoreAction => ({ type: LOAD_DOCUMENT });\nexport const setDocument = (document: PdfDocumentObject): CoreAction => ({\n  type: SET_DOCUMENT,\n  payload: document,\n});\nexport const setDocumentError = (error: string): CoreAction => ({\n  type: SET_DOCUMENT_ERROR,\n  payload: error,\n});\nexport const setScale = (scale: number): CoreAction => ({ type: SET_SCALE, payload: scale });\nexport const setRotation = (rotation: Rotation): CoreAction => ({\n  type: SET_ROTATION,\n  payload: rotation,\n});\nexport const setPages = (pages: PdfPageObject[][]): CoreAction => ({\n  type: SET_PAGES,\n  payload: pages,\n});\n","import { Reducer, Action, StoreState, StoreListener, PluginListener } from './types';\nimport { PluginStore } from './plugin-store';\nimport { CORE_ACTION_TYPES } from './actions';\n\n/**\n * A generic, type-safe store class managing core and plugin states, reducers, and subscriptions.\n * @template CoreState The type of the core state.\n * @template CoreAction The type of actions handled by core reducers (extends Action).\n */\nexport class Store<CoreState, CoreAction extends Action = Action> {\n  private state: StoreState<CoreState>;\n  private coreReducer: Reducer<CoreState, CoreAction>;\n  private pluginReducers: Record<string, Reducer<any, Action>> = {};\n\n  private listeners: StoreListener<CoreState>[] = [];\n  private pluginListeners: Record<string, PluginListener[]> = {};\n\n  /**\n   * Initializes the store with the provided core state.\n   * @param reducer          The core reducer function\n   * @param initialCoreState The initial core state\n   */\n  constructor(\n    reducer: Reducer<CoreState, CoreAction>,\n    public initialCoreState: CoreState,\n  ) {\n    this.state = { core: initialCoreState, plugins: {} };\n    this.coreReducer = reducer;\n  }\n\n  /**\n   * Adds a reducer for a plugin-specific state.\n   * @param pluginId The unique identifier for the plugin.\n   * @param reducer The reducer function for the plugin state.\n   * @param initialState The initial state for the plugin.\n   */\n  addPluginReducer<PluginState>(\n    pluginId: string,\n    reducer: Reducer<PluginState, Action>,\n    initialState: PluginState,\n  ) {\n    this.state.plugins[pluginId] = initialState;\n    this.pluginReducers[pluginId] = reducer;\n  }\n\n  /**\n   * Dispatches an action *only* to the core reducer.\n   * Notifies the global store listeners with (action, newState, oldState).\n   *\n   * @param action The action to dispatch, typed as CoreAction\n   * @returns The updated *global* store state\n   */\n  dispatchToCore(action: CoreAction): StoreState<CoreState> {\n    if (!this.coreReducer) {\n      return this.getState();\n    }\n\n    const oldState = this.getState();\n    // Update core state via its reducer\n    this.state.core = this.coreReducer(this.state.core, action);\n\n    const newState = this.getState();\n    // Notify all main-store subscribers\n    this.listeners.forEach((listener) => listener(action, newState, oldState));\n\n    return newState;\n  }\n\n  /**\n   * Dispatches an action *only* to a specific plugin.\n   * Optionally notifies global store listeners if `notifyGlobal` is true.\n   * Always notifies plugin-specific listeners with (action, newPluginState, oldPluginState).\n   *\n   * @param pluginId   The plugin identifier\n   * @param action     The plugin action to dispatch\n   * @param notifyGlobal Whether to also notify global store listeners\n   * @returns The updated *global* store state\n   */\n  dispatchToPlugin<PluginAction extends Action>(\n    pluginId: string,\n    action: PluginAction,\n    notifyGlobal: boolean = true,\n  ): any {\n    const oldGlobalState = this.getState();\n\n    const reducer = this.pluginReducers[pluginId];\n    if (!reducer) {\n      // No plugin found, just return the old state\n      return oldGlobalState;\n    }\n\n    // Grab the old plugin state\n    const oldPluginState = oldGlobalState.plugins[pluginId];\n    // Reduce to new plugin state\n    const newPluginState = reducer(oldPluginState, action);\n    // Update the store's plugin slice\n    this.state.plugins[pluginId] = newPluginState;\n\n    const newGlobalState = this.getState();\n\n    // If we are notifying the main store subscribers about plugin changes\n    if (notifyGlobal) {\n      this.listeners.forEach((listener) => listener(action, newGlobalState, oldGlobalState));\n    }\n\n    // Notify plugin-specific listeners\n    if (this.pluginListeners[pluginId]) {\n      this.pluginListeners[pluginId].forEach((listener) => {\n        listener(action, newPluginState, oldPluginState);\n      });\n    }\n\n    return newPluginState;\n  }\n\n  /**\n   * Dispatches an action to update the state using:\n   * - the core reducer (if it's a CoreAction)\n   * - *all* plugin reducers (regardless of action type), with no global notify for each plugin\n   *\n   * Returns the new *global* store state after all reducers have processed the action.\n   *\n   * @param action The action to dispatch (can be CoreAction or any Action).\n   */\n  dispatch(action: CoreAction | Action): StoreState<CoreState> {\n    // Keep old state to notify global listeners *once*, after all reducers run.\n    const oldState = this.getState();\n    // 1) Apply core reducer (only if action is a CoreAction)\n    if (this.isCoreAction(action)) {\n      this.state.core = this.coreReducer(this.state.core, action);\n    }\n\n    // 2) Apply plugin reducers (without globally notifying after each plugin)\n    for (const pluginId in this.pluginReducers) {\n      const reducer = this.pluginReducers[pluginId];\n      const oldPluginState = oldState.plugins[pluginId];\n      if (reducer) {\n        this.state.plugins[pluginId] = reducer(oldPluginState, action);\n      }\n      // We do *not* notify global listeners or plugin listeners here,\n      // as that might be undesired \"fan-out\". If you want per-plugin subscription\n      // triggered on every dispatch, you can do so here, but that’s up to you.\n    }\n\n    // 3) Notify global listeners *once* with the final new state\n    const newState = this.getState();\n    this.listeners.forEach((listener) => listener(action, newState, oldState));\n\n    // 4) Return the new global store state\n    return newState;\n  }\n\n  /**\n   * Returns a shallow copy of the current state.\n   * @returns The current store state.\n   */\n  getState(): StoreState<CoreState> {\n    return {\n      core: { ...this.state.core },\n      plugins: { ...this.state.plugins },\n    };\n  }\n\n  /**\n   * Subscribes a listener to *global* state changes.\n   * The callback signature is now (action, newState, oldState).\n   *\n   * @param listener The callback to invoke on state changes\n   * @returns A function to unsubscribe the listener\n   */\n  subscribe(listener: StoreListener<CoreState>) {\n    this.listeners.push(listener);\n    return () => {\n      this.listeners = this.listeners.filter((l) => l !== listener);\n    };\n  }\n\n  /**\n   * Subscribes a listener to *plugin-specific* state changes.\n   * The callback signature is now (action, newPluginState, oldPluginState).\n   *\n   * @param pluginId The unique identifier for the plugin.\n   * @param listener The callback to invoke on plugin state changes.\n   * @returns A function to unsubscribe the listener.\n   */\n  subscribeToPlugin(pluginId: string, listener: PluginListener) {\n    if (!(pluginId in this.state.plugins)) {\n      throw new Error(\n        `Plugin state not found for plugin \"${pluginId}\". Did you forget to call addPluginReducer?`,\n      );\n    }\n\n    if (!this.pluginListeners[pluginId]) {\n      this.pluginListeners[pluginId] = [];\n    }\n    this.pluginListeners[pluginId].push(listener);\n\n    return () => {\n      this.pluginListeners[pluginId] = this.pluginListeners[pluginId].filter((l) => l !== listener);\n      if (this.pluginListeners[pluginId].length === 0) {\n        delete this.pluginListeners[pluginId];\n      }\n    };\n  }\n\n  /**\n   * Subscribes to a specific action type (only from the core's action union).\n   * The callback signature is (action, newState, oldState).\n   *\n   * @param type The action type to listen for.\n   * @param handler The callback to invoke when the action occurs.\n   * @returns A function to unsubscribe the handler.\n   */\n  onAction<T extends CoreAction['type']>(\n    type: T,\n    handler: (\n      action: Extract<CoreAction, { type: T }>,\n      state: StoreState<CoreState>,\n      oldState: StoreState<CoreState>,\n    ) => void,\n  ) {\n    return this.subscribe((action, newState, oldState) => {\n      if (action.type === type) {\n        handler(action as Extract<CoreAction, { type: T }>, newState, oldState);\n      }\n    });\n  }\n\n  /**\n   * Gets a PluginStore handle for a specific plugin.\n   * @param pluginId The unique identifier for the plugin.\n   * @returns A PluginStore instance for the plugin.\n   */\n  getPluginStore<PluginState, PluginAction extends Action>(\n    pluginId: string,\n  ): PluginStore<PluginState, PluginAction> {\n    if (!(pluginId in this.state.plugins)) {\n      throw new Error(\n        `Plugin state not found for plugin \"${pluginId}\". Did you forget to call addPluginReducer?`,\n      );\n    }\n    return new PluginStore<PluginState, PluginAction>(this, pluginId);\n  }\n\n  /**\n   * Helper method to check if an action is a CoreAction.\n   * Adjust if you have a more refined way to differentiate CoreAction vs. any other Action.\n   */\n  public isCoreAction(action: Action): action is CoreAction {\n    // In many codebases you'd do something more robust here\n    // or rely on TypeScript's narrowing logic if possible.\n    return CORE_ACTION_TYPES.includes(action.type as (typeof CORE_ACTION_TYPES)[number]);\n  }\n\n  /**\n   * Destroy the store: drop every listener and plugin reducer\n   */\n  public destroy(): void {\n    // 1. empty listener collections\n    this.listeners.length = 0;\n    for (const id in this.pluginListeners) {\n      this.pluginListeners[id]?.splice?.(0);\n    }\n    this.pluginListeners = {};\n\n    // 2. wipe plugin reducers and states\n    this.pluginReducers = {};\n    this.state.plugins = {};\n\n    // 3. reset core state to initial\n    this.state.core = { ...this.initialCoreState };\n  }\n}\n","// src/geometry.ts\nvar Rotation = /* @__PURE__ */ ((Rotation2) => {\n  Rotation2[Rotation2[\"Degree0\"] = 0] = \"Degree0\";\n  Rotation2[Rotation2[\"Degree90\"] = 1] = \"Degree90\";\n  Rotation2[Rotation2[\"Degree180\"] = 2] = \"Degree180\";\n  Rotation2[Rotation2[\"Degree270\"] = 3] = \"Degree270\";\n  return Rotation2;\n})(Rotation || {});\nfunction toIntPos(p) {\n  return { x: Math.floor(p.x), y: Math.floor(p.y) };\n}\nfunction toIntSize(s) {\n  return { width: Math.ceil(s.width), height: Math.ceil(s.height) };\n}\nfunction toIntRect(r) {\n  return {\n    origin: toIntPos(r.origin),\n    size: toIntSize(r.size)\n  };\n}\nfunction calculateDegree(rotation) {\n  switch (rotation) {\n    case 0 /* Degree0 */:\n      return 0;\n    case 1 /* Degree90 */:\n      return 90;\n    case 2 /* Degree180 */:\n      return 180;\n    case 3 /* Degree270 */:\n      return 270;\n  }\n}\nfunction calculateAngle(rotation) {\n  return calculateDegree(rotation) * Math.PI / 180;\n}\nfunction swap(size) {\n  const { width, height } = size;\n  return {\n    width: height,\n    height: width\n  };\n}\nfunction transformSize(size, rotation, scaleFactor) {\n  size = rotation % 2 === 0 ? size : swap(size);\n  return {\n    width: size.width * scaleFactor,\n    height: size.height * scaleFactor\n  };\n}\nfunction quadToRect(q) {\n  const xs = [q.p1.x, q.p2.x, q.p3.x, q.p4.x];\n  const ys = [q.p1.y, q.p2.y, q.p3.y, q.p4.y];\n  return {\n    origin: { x: Math.min(...xs), y: Math.min(...ys) },\n    size: {\n      width: Math.max(...xs) - Math.min(...xs),\n      height: Math.max(...ys) - Math.min(...ys)\n    }\n  };\n}\nfunction rectToQuad(r) {\n  return {\n    p1: { x: r.origin.x, y: r.origin.y },\n    p2: { x: r.origin.x + r.size.width, y: r.origin.y },\n    p3: { x: r.origin.x + r.size.width, y: r.origin.y + r.size.height },\n    p4: { x: r.origin.x, y: r.origin.y + r.size.height }\n  };\n}\nfunction rotatePosition(containerSize, position, rotation) {\n  let x = position.x;\n  let y = position.y;\n  switch (rotation) {\n    case 0 /* Degree0 */:\n      x = position.x;\n      y = position.y;\n      break;\n    case 1 /* Degree90 */:\n      x = containerSize.height - position.y;\n      y = position.x;\n      break;\n    case 2 /* Degree180 */:\n      x = containerSize.width - position.x;\n      y = containerSize.height - position.y;\n      break;\n    case 3 /* Degree270 */:\n      x = position.y;\n      y = containerSize.width - position.x;\n      break;\n  }\n  return {\n    x,\n    y\n  };\n}\nfunction scalePosition(position, scaleFactor) {\n  return {\n    x: position.x * scaleFactor,\n    y: position.y * scaleFactor\n  };\n}\nfunction transformPosition(containerSize, position, rotation, scaleFactor) {\n  return scalePosition(rotatePosition(containerSize, position, rotation), scaleFactor);\n}\nfunction restorePosition(containerSize, position, rotation, scaleFactor) {\n  return scalePosition(\n    rotatePosition(containerSize, position, (4 - rotation) % 4),\n    1 / scaleFactor\n  );\n}\nfunction rotateRect(containerSize, rect, rotation) {\n  let x = rect.origin.x;\n  let y = rect.origin.y;\n  let size = rect.size;\n  switch (rotation) {\n    case 0 /* Degree0 */:\n      break;\n    case 1 /* Degree90 */:\n      x = containerSize.height - rect.origin.y - rect.size.height;\n      y = rect.origin.x;\n      size = swap(rect.size);\n      break;\n    case 2 /* Degree180 */:\n      x = containerSize.width - rect.origin.x - rect.size.width;\n      y = containerSize.height - rect.origin.y - rect.size.height;\n      break;\n    case 3 /* Degree270 */:\n      x = rect.origin.y;\n      y = containerSize.width - rect.origin.x - rect.size.width;\n      size = swap(rect.size);\n      break;\n  }\n  return {\n    origin: {\n      x,\n      y\n    },\n    size: {\n      width: size.width,\n      height: size.height\n    }\n  };\n}\nfunction scaleRect(rect, scaleFactor) {\n  return {\n    origin: {\n      x: rect.origin.x * scaleFactor,\n      y: rect.origin.y * scaleFactor\n    },\n    size: {\n      width: rect.size.width * scaleFactor,\n      height: rect.size.height * scaleFactor\n    }\n  };\n}\nfunction transformRect(containerSize, rect, rotation, scaleFactor) {\n  return scaleRect(rotateRect(containerSize, rect, rotation), scaleFactor);\n}\nfunction restoreRect(containerSize, rect, rotation, scaleFactor) {\n  return scaleRect(rotateRect(containerSize, rect, (4 - rotation) % 4), 1 / scaleFactor);\n}\nfunction restoreOffset(offset, rotation, scaleFactor) {\n  let offsetX = offset.x;\n  let offsetY = offset.y;\n  switch (rotation) {\n    case 0 /* Degree0 */:\n      offsetX = offset.x / scaleFactor;\n      offsetY = offset.y / scaleFactor;\n      break;\n    case 1 /* Degree90 */:\n      offsetX = offset.y / scaleFactor;\n      offsetY = -offset.x / scaleFactor;\n      break;\n    case 2 /* Degree180 */:\n      offsetX = -offset.x / scaleFactor;\n      offsetY = -offset.y / scaleFactor;\n      break;\n    case 3 /* Degree270 */:\n      offsetX = -offset.y / scaleFactor;\n      offsetY = offset.x / scaleFactor;\n      break;\n  }\n  return {\n    x: offsetX,\n    y: offsetY\n  };\n}\nfunction boundingRect(rects) {\n  if (rects.length === 0) return null;\n  let minX = rects[0].origin.x, minY = rects[0].origin.y, maxX = rects[0].origin.x + rects[0].size.width, maxY = rects[0].origin.y + rects[0].size.height;\n  for (const r of rects) {\n    minX = Math.min(minX, r.origin.x);\n    minY = Math.min(minY, r.origin.y);\n    maxX = Math.max(maxX, r.origin.x + r.size.width);\n    maxY = Math.max(maxY, r.origin.y + r.size.height);\n  }\n  return {\n    origin: {\n      x: minX,\n      y: minY\n    },\n    size: {\n      width: maxX - minX,\n      height: maxY - minY\n    }\n  };\n}\nvar makeMatrix = (rectangle, rotation, scaleFactor) => {\n  const { width, height } = rectangle.size;\n  switch (rotation) {\n    case 0 /* Degree0 */:\n      return {\n        a: scaleFactor,\n        b: 0,\n        c: 0,\n        d: -scaleFactor,\n        e: 0,\n        f: height * scaleFactor\n      };\n    case 1 /* Degree90 */:\n      return {\n        a: 0,\n        b: scaleFactor,\n        c: scaleFactor,\n        d: 0,\n        e: 0,\n        f: 0\n      };\n    case 2 /* Degree180 */:\n      return {\n        a: -scaleFactor,\n        b: 0,\n        c: 0,\n        d: scaleFactor,\n        e: width * scaleFactor,\n        f: 0\n      };\n    case 3 /* Degree270 */:\n      return {\n        a: 0,\n        b: -scaleFactor,\n        c: -scaleFactor,\n        d: 0,\n        e: height * scaleFactor,\n        f: width * scaleFactor\n      };\n  }\n};\n\n// src/logger.ts\nvar NoopLogger = class {\n  /** {@inheritDoc Logger.debug} */\n  debug() {\n  }\n  /** {@inheritDoc Logger.info} */\n  info() {\n  }\n  /** {@inheritDoc Logger.warn} */\n  warn() {\n  }\n  /** {@inheritDoc Logger.error} */\n  error() {\n  }\n  /** {@inheritDoc Logger.perf} */\n  perf() {\n  }\n};\nvar ConsoleLogger = class {\n  /** {@inheritDoc Logger.debug} */\n  debug(source, category, ...args) {\n    console.debug(`${source}.${category}`, ...args);\n  }\n  /** {@inheritDoc Logger.info} */\n  info(source, category, ...args) {\n    console.info(`${source}.${category}`, ...args);\n  }\n  /** {@inheritDoc Logger.warn} */\n  warn(source, category, ...args) {\n    console.warn(`${source}.${category}`, ...args);\n  }\n  /** {@inheritDoc Logger.error} */\n  error(source, category, ...args) {\n    console.error(`${source}.${category}`, ...args);\n  }\n  /** {@inheritDoc Logger.perf} */\n  perf(source, category, event, phase, ...args) {\n    console.info(`${source}.${category}.${event}.${phase}`, ...args);\n  }\n};\nvar LogLevel = /* @__PURE__ */ ((LogLevel2) => {\n  LogLevel2[LogLevel2[\"Debug\"] = 0] = \"Debug\";\n  LogLevel2[LogLevel2[\"Info\"] = 1] = \"Info\";\n  LogLevel2[LogLevel2[\"Warn\"] = 2] = \"Warn\";\n  LogLevel2[LogLevel2[\"Error\"] = 3] = \"Error\";\n  return LogLevel2;\n})(LogLevel || {});\nvar LevelLogger = class {\n  /**\n   * create new LevelLogger\n   * @param logger - the original logger\n   * @param level - log level that used for filtering, all logs lower than this level will be filtered out\n   */\n  constructor(logger, level) {\n    this.logger = logger;\n    this.level = level;\n  }\n  /** {@inheritDoc Logger.debug} */\n  debug(source, category, ...args) {\n    if (this.level <= 0 /* Debug */) {\n      this.logger.debug(source, category, ...args);\n    }\n  }\n  /** {@inheritDoc Logger.info} */\n  info(source, category, ...args) {\n    if (this.level <= 1 /* Info */) {\n      this.logger.info(source, category, ...args);\n    }\n  }\n  /** {@inheritDoc Logger.warn} */\n  warn(source, category, ...args) {\n    if (this.level <= 2 /* Warn */) {\n      this.logger.warn(source, category, ...args);\n    }\n  }\n  /** {@inheritDoc Logger.error} */\n  error(source, category, ...args) {\n    if (this.level <= 3 /* Error */) {\n      this.logger.error(source, category, ...args);\n    }\n  }\n  /** {@inheritDoc Logger.perf} */\n  perf(source, category, event, phase, ...args) {\n    this.logger.perf(source, category, event, phase, ...args);\n  }\n};\nvar PerfLogger = class {\n  /**\n   * create new PerfLogger\n   */\n  constructor() {\n  }\n  /** {@inheritDoc Logger.debug} */\n  debug(source, category, ...args) {\n  }\n  /** {@inheritDoc Logger.info} */\n  info(source, category, ...args) {\n  }\n  /** {@inheritDoc Logger.warn} */\n  warn(source, category, ...args) {\n  }\n  /** {@inheritDoc Logger.error} */\n  error(source, category, ...args) {\n  }\n  /** {@inheritDoc Logger.perf} */\n  perf(source, category, event, phase, identifier, ...args) {\n    switch (phase) {\n      case \"Begin\":\n        window.performance.mark(`${source}.${category}.${event}.${phase}.${identifier}`, {\n          detail: args\n        });\n        break;\n      case \"End\":\n        window.performance.mark(`${source}.${category}.${event}.${phase}.${identifier}`, {\n          detail: args\n        });\n        window.performance.measure(\n          `${source}.${category}.${event}.Measure.${identifier}`,\n          `${source}.${category}.${event}.Begin.${identifier}`,\n          `${source}.${category}.${event}.End.${identifier}`\n        );\n        break;\n    }\n  }\n};\nvar AllLogger = class {\n  /**\n   * create new PerfLogger\n   */\n  constructor(loggers) {\n    this.loggers = loggers;\n  }\n  /** {@inheritDoc Logger.debug} */\n  debug(source, category, ...args) {\n    for (const logger of this.loggers) {\n      logger.debug(source, category, ...args);\n    }\n  }\n  /** {@inheritDoc Logger.info} */\n  info(source, category, ...args) {\n    for (const logger of this.loggers) {\n      logger.info(source, category, ...args);\n    }\n  }\n  /** {@inheritDoc Logger.warn} */\n  warn(source, category, ...args) {\n    for (const logger of this.loggers) {\n      logger.warn(source, category, ...args);\n    }\n  }\n  /** {@inheritDoc Logger.error} */\n  error(source, category, ...args) {\n    for (const logger of this.loggers) {\n      logger.error(source, category, ...args);\n    }\n  }\n  /** {@inheritDoc Logger.perf} */\n  perf(source, category, event, phase, ...args) {\n    for (const logger of this.loggers) {\n      logger.perf(source, category, event, phase, ...args);\n    }\n  }\n};\n\n// src/task.ts\nvar TaskStage = /* @__PURE__ */ ((TaskStage2) => {\n  TaskStage2[TaskStage2[\"Pending\"] = 0] = \"Pending\";\n  TaskStage2[TaskStage2[\"Resolved\"] = 1] = \"Resolved\";\n  TaskStage2[TaskStage2[\"Rejected\"] = 2] = \"Rejected\";\n  TaskStage2[TaskStage2[\"Aborted\"] = 3] = \"Aborted\";\n  return TaskStage2;\n})(TaskStage || {});\nvar TaskAbortedError = class extends Error {\n  constructor(reason) {\n    super(`Task aborted: ${JSON.stringify(reason)}`);\n    this.name = \"TaskAbortedError\";\n  }\n};\nvar TaskRejectedError = class extends Error {\n  constructor(reason) {\n    super(`Task rejected: ${JSON.stringify(reason)}`);\n    this.name = \"TaskRejectedError\";\n  }\n};\nvar Task = class _Task {\n  constructor() {\n    this.state = {\n      stage: 0 /* Pending */\n    };\n    /**\n     * callbacks that will be executed when task is resolved\n     */\n    this.resolvedCallbacks = [];\n    /**\n     * callbacks that will be executed when task is rejected\n     */\n    this.rejectedCallbacks = [];\n    /**\n     * Promise that will be resolved when task is settled\n     */\n    this._promise = null;\n  }\n  /**\n   * Convert task to promise\n   * @returns promise that will be resolved when task is settled\n   */\n  toPromise() {\n    if (!this._promise) {\n      this._promise = new Promise((resolve, reject) => {\n        this.wait(\n          (result) => resolve(result),\n          (error) => {\n            if (error.type === \"abort\") {\n              reject(new TaskAbortedError(error.reason));\n            } else {\n              reject(new TaskRejectedError(error.reason));\n            }\n          }\n        );\n      });\n    }\n    return this._promise;\n  }\n  /**\n   * wait for task to be settled\n   * @param resolvedCallback - callback for resolved value\n   * @param rejectedCallback - callback for rejected value\n   */\n  wait(resolvedCallback, rejectedCallback) {\n    switch (this.state.stage) {\n      case 0 /* Pending */:\n        this.resolvedCallbacks.push(resolvedCallback);\n        this.rejectedCallbacks.push(rejectedCallback);\n        break;\n      case 1 /* Resolved */:\n        resolvedCallback(this.state.result);\n        break;\n      case 2 /* Rejected */:\n        rejectedCallback({\n          type: \"reject\",\n          reason: this.state.reason\n        });\n        break;\n      case 3 /* Aborted */:\n        rejectedCallback({\n          type: \"abort\",\n          reason: this.state.reason\n        });\n        break;\n    }\n  }\n  /**\n   * resolve task with specific result\n   * @param result - result value\n   */\n  resolve(result) {\n    if (this.state.stage === 0 /* Pending */) {\n      this.state = {\n        stage: 1 /* Resolved */,\n        result\n      };\n      for (const resolvedCallback of this.resolvedCallbacks) {\n        try {\n          resolvedCallback(result);\n        } catch (e) {\n        }\n      }\n      this.resolvedCallbacks = [];\n      this.rejectedCallbacks = [];\n    }\n  }\n  /**\n   * reject task with specific reason\n   * @param reason - abort reason\n   *\n   */\n  reject(reason) {\n    if (this.state.stage === 0 /* Pending */) {\n      this.state = {\n        stage: 2 /* Rejected */,\n        reason\n      };\n      for (const rejectedCallback of this.rejectedCallbacks) {\n        try {\n          rejectedCallback({\n            type: \"reject\",\n            reason\n          });\n        } catch (e) {\n        }\n      }\n      this.resolvedCallbacks = [];\n      this.rejectedCallbacks = [];\n    }\n  }\n  /**\n   * abort task with specific reason\n   * @param reason - abort reason\n   */\n  abort(reason) {\n    if (this.state.stage === 0 /* Pending */) {\n      this.state = {\n        stage: 3 /* Aborted */,\n        reason\n      };\n      for (const rejectedCallback of this.rejectedCallbacks) {\n        try {\n          rejectedCallback({\n            type: \"abort\",\n            reason\n          });\n        } catch (e) {\n        }\n      }\n      this.resolvedCallbacks = [];\n      this.rejectedCallbacks = [];\n    }\n  }\n  /**\n   * fail task with a TaskError from another task\n   * This is a convenience method for error propagation between tasks\n   * @param error - TaskError from another task\n   */\n  fail(error) {\n    if (error.type === \"abort\") {\n      this.abort(error.reason);\n    } else {\n      this.reject(error.reason);\n    }\n  }\n  /**\n   * Static method to wait for all tasks to resolve\n   * Returns a new task that resolves with an array of all results\n   * Rejects immediately if any task fails\n   *\n   * @param tasks - array of tasks to wait for\n   * @returns new task that resolves when all input tasks resolve\n   * @public\n   */\n  static all(tasks) {\n    const combinedTask = new _Task();\n    if (tasks.length === 0) {\n      combinedTask.resolve([]);\n      return combinedTask;\n    }\n    const results = new Array(tasks.length);\n    let resolvedCount = 0;\n    let isSettled = false;\n    tasks.forEach((task, index) => {\n      task.wait(\n        (result) => {\n          if (isSettled) return;\n          results[index] = result;\n          resolvedCount++;\n          if (resolvedCount === tasks.length) {\n            isSettled = true;\n            combinedTask.resolve(results);\n          }\n        },\n        (error) => {\n          if (isSettled) return;\n          isSettled = true;\n          if (error.type === \"abort\") {\n            combinedTask.abort(error.reason);\n          } else {\n            combinedTask.reject(error.reason);\n          }\n        }\n      );\n    });\n    return combinedTask;\n  }\n  /**\n   * Static method to wait for all tasks to settle (resolve, reject, or abort)\n   * Always resolves with an array of settlement results\n   *\n   * @param tasks - array of tasks to wait for\n   * @returns new task that resolves when all input tasks settle\n   * @public\n   */\n  static allSettled(tasks) {\n    const combinedTask = new _Task();\n    if (tasks.length === 0) {\n      combinedTask.resolve([]);\n      return combinedTask;\n    }\n    const results = new Array(tasks.length);\n    let settledCount = 0;\n    tasks.forEach((task, index) => {\n      task.wait(\n        (result) => {\n          results[index] = { status: \"resolved\", value: result };\n          settledCount++;\n          if (settledCount === tasks.length) {\n            combinedTask.resolve(results);\n          }\n        },\n        (error) => {\n          results[index] = {\n            status: error.type === \"abort\" ? \"aborted\" : \"rejected\",\n            reason: error.reason\n          };\n          settledCount++;\n          if (settledCount === tasks.length) {\n            combinedTask.resolve(results);\n          }\n        }\n      );\n    });\n    return combinedTask;\n  }\n  /**\n   * Static method that resolves/rejects with the first task that settles\n   *\n   * @param tasks - array of tasks to race\n   * @returns new task that settles with the first input task that settles\n   * @public\n   */\n  static race(tasks) {\n    const combinedTask = new _Task();\n    if (tasks.length === 0) {\n      combinedTask.reject(\"No tasks provided\");\n      return combinedTask;\n    }\n    let isSettled = false;\n    tasks.forEach((task) => {\n      task.wait(\n        (result) => {\n          if (isSettled) return;\n          isSettled = true;\n          combinedTask.resolve(result);\n        },\n        (error) => {\n          if (isSettled) return;\n          isSettled = true;\n          if (error.type === \"abort\") {\n            combinedTask.abort(error.reason);\n          } else {\n            combinedTask.reject(error.reason);\n          }\n        }\n      );\n    });\n    return combinedTask;\n  }\n  /**\n   * Utility to track progress of multiple tasks\n   *\n   * @param tasks - array of tasks to track\n   * @param onProgress - callback called when any task completes\n   * @returns new task that resolves when all input tasks resolve\n   * @public\n   */\n  static withProgress(tasks, onProgress) {\n    const combinedTask = _Task.all(tasks);\n    if (onProgress) {\n      let completedCount = 0;\n      tasks.forEach((task) => {\n        task.wait(\n          () => {\n            completedCount++;\n            onProgress(completedCount, tasks.length);\n          },\n          () => {\n            completedCount++;\n            onProgress(completedCount, tasks.length);\n          }\n        );\n      });\n    }\n    return combinedTask;\n  }\n};\n\n// src/pdf.ts\nvar PdfSoftHyphenMarker = \"\\xAD\";\nvar PdfZeroWidthSpace = \"\\u200B\";\nvar PdfWordJoiner = \"\\u2060\";\nvar PdfBomOrZwnbsp = \"\\uFEFF\";\nvar PdfNonCharacterFFFE = \"\\uFFFE\";\nvar PdfNonCharacterFFFF = \"\\uFFFF\";\nvar PdfUnwantedTextMarkers = Object.freeze([\n  PdfSoftHyphenMarker,\n  PdfZeroWidthSpace,\n  PdfWordJoiner,\n  PdfBomOrZwnbsp,\n  PdfNonCharacterFFFE,\n  PdfNonCharacterFFFF\n]);\nvar PdfUnwantedTextRegex = new RegExp(`[${PdfUnwantedTextMarkers.join(\"\")}]`, \"g\");\nfunction stripPdfUnwantedMarkers(text) {\n  return text.replace(PdfUnwantedTextRegex, \"\");\n}\nvar PdfZoomMode = /* @__PURE__ */ ((PdfZoomMode2) => {\n  PdfZoomMode2[PdfZoomMode2[\"Unknown\"] = 0] = \"Unknown\";\n  PdfZoomMode2[PdfZoomMode2[\"XYZ\"] = 1] = \"XYZ\";\n  PdfZoomMode2[PdfZoomMode2[\"FitPage\"] = 2] = \"FitPage\";\n  PdfZoomMode2[PdfZoomMode2[\"FitHorizontal\"] = 3] = \"FitHorizontal\";\n  PdfZoomMode2[PdfZoomMode2[\"FitVertical\"] = 4] = \"FitVertical\";\n  PdfZoomMode2[PdfZoomMode2[\"FitRectangle\"] = 5] = \"FitRectangle\";\n  return PdfZoomMode2;\n})(PdfZoomMode || {});\nvar PdfBlendMode = /* @__PURE__ */ ((PdfBlendMode2) => {\n  PdfBlendMode2[PdfBlendMode2[\"Normal\"] = 0] = \"Normal\";\n  PdfBlendMode2[PdfBlendMode2[\"Multiply\"] = 1] = \"Multiply\";\n  PdfBlendMode2[PdfBlendMode2[\"Screen\"] = 2] = \"Screen\";\n  PdfBlendMode2[PdfBlendMode2[\"Overlay\"] = 3] = \"Overlay\";\n  PdfBlendMode2[PdfBlendMode2[\"Darken\"] = 4] = \"Darken\";\n  PdfBlendMode2[PdfBlendMode2[\"Lighten\"] = 5] = \"Lighten\";\n  PdfBlendMode2[PdfBlendMode2[\"ColorDodge\"] = 6] = \"ColorDodge\";\n  PdfBlendMode2[PdfBlendMode2[\"ColorBurn\"] = 7] = \"ColorBurn\";\n  PdfBlendMode2[PdfBlendMode2[\"HardLight\"] = 8] = \"HardLight\";\n  PdfBlendMode2[PdfBlendMode2[\"SoftLight\"] = 9] = \"SoftLight\";\n  PdfBlendMode2[PdfBlendMode2[\"Difference\"] = 10] = \"Difference\";\n  PdfBlendMode2[PdfBlendMode2[\"Exclusion\"] = 11] = \"Exclusion\";\n  PdfBlendMode2[PdfBlendMode2[\"Hue\"] = 12] = \"Hue\";\n  PdfBlendMode2[PdfBlendMode2[\"Saturation\"] = 13] = \"Saturation\";\n  PdfBlendMode2[PdfBlendMode2[\"Color\"] = 14] = \"Color\";\n  PdfBlendMode2[PdfBlendMode2[\"Luminosity\"] = 15] = \"Luminosity\";\n  return PdfBlendMode2;\n})(PdfBlendMode || {});\nvar MixedBlendMode = Symbol(\"mixed\");\nvar BLEND_MODE_INFOS = Object.freeze([\n  { id: 0 /* Normal */, label: \"Normal\", css: \"normal\" },\n  { id: 1 /* Multiply */, label: \"Multiply\", css: \"multiply\" },\n  { id: 2 /* Screen */, label: \"Screen\", css: \"screen\" },\n  { id: 3 /* Overlay */, label: \"Overlay\", css: \"overlay\" },\n  { id: 4 /* Darken */, label: \"Darken\", css: \"darken\" },\n  { id: 5 /* Lighten */, label: \"Lighten\", css: \"lighten\" },\n  { id: 6 /* ColorDodge */, label: \"Color Dodge\", css: \"color-dodge\" },\n  { id: 7 /* ColorBurn */, label: \"Color Burn\", css: \"color-burn\" },\n  { id: 8 /* HardLight */, label: \"Hard Light\", css: \"hard-light\" },\n  { id: 9 /* SoftLight */, label: \"Soft Light\", css: \"soft-light\" },\n  { id: 10 /* Difference */, label: \"Difference\", css: \"difference\" },\n  { id: 11 /* Exclusion */, label: \"Exclusion\", css: \"exclusion\" },\n  { id: 12 /* Hue */, label: \"Hue\", css: \"hue\" },\n  { id: 13 /* Saturation */, label: \"Saturation\", css: \"saturation\" },\n  { id: 14 /* Color */, label: \"Color\", css: \"color\" },\n  { id: 15 /* Luminosity */, label: \"Luminosity\", css: \"luminosity\" }\n]);\nvar enumToInfo = BLEND_MODE_INFOS.reduce(\n  (m, info) => {\n    m[info.id] = info;\n    return m;\n  },\n  {}\n);\nvar cssToEnum = BLEND_MODE_INFOS.reduce((m, info) => {\n  m[info.css] = info.id;\n  return m;\n}, {});\nfunction getBlendModeInfo(mode) {\n  return enumToInfo[mode] ?? enumToInfo[0 /* Normal */];\n}\nfunction blendModeToCss(mode) {\n  return getBlendModeInfo(mode).css;\n}\nfunction cssToBlendMode(value) {\n  return cssToEnum[value];\n}\nfunction blendModeLabel(mode) {\n  return getBlendModeInfo(mode).label;\n}\nfunction reduceBlendModes(modes) {\n  if (!modes.length) return 0 /* Normal */;\n  const first = modes[0];\n  return modes.every((m) => m === first) ? first : MixedBlendMode;\n}\nvar blendModeSelectOptions = BLEND_MODE_INFOS.map((info) => ({\n  value: info.id,\n  label: info.label\n}));\nfunction uiBlendModeDisplay(value) {\n  return value === MixedBlendMode ? \"(mixed)\" : blendModeLabel(value);\n}\nvar PdfActionType = /* @__PURE__ */ ((PdfActionType2) => {\n  PdfActionType2[PdfActionType2[\"Unsupported\"] = 0] = \"Unsupported\";\n  PdfActionType2[PdfActionType2[\"Goto\"] = 1] = \"Goto\";\n  PdfActionType2[PdfActionType2[\"RemoteGoto\"] = 2] = \"RemoteGoto\";\n  PdfActionType2[PdfActionType2[\"URI\"] = 3] = \"URI\";\n  PdfActionType2[PdfActionType2[\"LaunchAppOrOpenFile\"] = 4] = \"LaunchAppOrOpenFile\";\n  return PdfActionType2;\n})(PdfActionType || {});\nvar PdfAnnotationSubtype = /* @__PURE__ */ ((PdfAnnotationSubtype2) => {\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"TEXT\"] = 1] = \"TEXT\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"LINK\"] = 2] = \"LINK\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"FREETEXT\"] = 3] = \"FREETEXT\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"LINE\"] = 4] = \"LINE\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"SQUARE\"] = 5] = \"SQUARE\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"CIRCLE\"] = 6] = \"CIRCLE\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"POLYGON\"] = 7] = \"POLYGON\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"POLYLINE\"] = 8] = \"POLYLINE\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"HIGHLIGHT\"] = 9] = \"HIGHLIGHT\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"UNDERLINE\"] = 10] = \"UNDERLINE\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"SQUIGGLY\"] = 11] = \"SQUIGGLY\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"STRIKEOUT\"] = 12] = \"STRIKEOUT\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"STAMP\"] = 13] = \"STAMP\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"CARET\"] = 14] = \"CARET\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"INK\"] = 15] = \"INK\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"POPUP\"] = 16] = \"POPUP\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"FILEATTACHMENT\"] = 17] = \"FILEATTACHMENT\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"SOUND\"] = 18] = \"SOUND\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"MOVIE\"] = 19] = \"MOVIE\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"WIDGET\"] = 20] = \"WIDGET\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"SCREEN\"] = 21] = \"SCREEN\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"PRINTERMARK\"] = 22] = \"PRINTERMARK\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"TRAPNET\"] = 23] = \"TRAPNET\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"WATERMARK\"] = 24] = \"WATERMARK\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"THREED\"] = 25] = \"THREED\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"RICHMEDIA\"] = 26] = \"RICHMEDIA\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"XFAWIDGET\"] = 27] = \"XFAWIDGET\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"REDACT\"] = 28] = \"REDACT\";\n  return PdfAnnotationSubtype2;\n})(PdfAnnotationSubtype || {});\nvar PdfAnnotationSubtypeName = {\n  [0 /* UNKNOWN */]: \"unknow\",\n  [1 /* TEXT */]: \"text\",\n  [2 /* LINK */]: \"link\",\n  [3 /* FREETEXT */]: \"freetext\",\n  [4 /* LINE */]: \"line\",\n  [5 /* SQUARE */]: \"square\",\n  [6 /* CIRCLE */]: \"circle\",\n  [7 /* POLYGON */]: \"polygon\",\n  [8 /* POLYLINE */]: \"polyline\",\n  [9 /* HIGHLIGHT */]: \"highlight\",\n  [10 /* UNDERLINE */]: \"underline\",\n  [11 /* SQUIGGLY */]: \"squiggly\",\n  [12 /* STRIKEOUT */]: \"strikeout\",\n  [13 /* STAMP */]: \"stamp\",\n  [14 /* CARET */]: \"caret\",\n  [15 /* INK */]: \"ink\",\n  [16 /* POPUP */]: \"popup\",\n  [17 /* FILEATTACHMENT */]: \"fileattachment\",\n  [18 /* SOUND */]: \"sound\",\n  [19 /* MOVIE */]: \"movie\",\n  [20 /* WIDGET */]: \"widget\",\n  [21 /* SCREEN */]: \"screen\",\n  [22 /* PRINTERMARK */]: \"printermark\",\n  [23 /* TRAPNET */]: \"trapnet\",\n  [24 /* WATERMARK */]: \"watermark\",\n  [25 /* THREED */]: \"threed\",\n  [26 /* RICHMEDIA */]: \"richmedia\",\n  [27 /* XFAWIDGET */]: \"xfawidget\",\n  [28 /* REDACT */]: \"redact\"\n};\nvar PdfAnnotationObjectStatus = /* @__PURE__ */ ((PdfAnnotationObjectStatus2) => {\n  PdfAnnotationObjectStatus2[PdfAnnotationObjectStatus2[\"Created\"] = 0] = \"Created\";\n  PdfAnnotationObjectStatus2[PdfAnnotationObjectStatus2[\"Committed\"] = 1] = \"Committed\";\n  return PdfAnnotationObjectStatus2;\n})(PdfAnnotationObjectStatus || {});\nvar AppearanceMode = /* @__PURE__ */ ((AppearanceMode2) => {\n  AppearanceMode2[AppearanceMode2[\"Normal\"] = 0] = \"Normal\";\n  AppearanceMode2[AppearanceMode2[\"Rollover\"] = 1] = \"Rollover\";\n  AppearanceMode2[AppearanceMode2[\"Down\"] = 2] = \"Down\";\n  return AppearanceMode2;\n})(AppearanceMode || {});\nvar PdfAnnotationState = /* @__PURE__ */ ((PdfAnnotationState2) => {\n  PdfAnnotationState2[\"Marked\"] = \"Marked\";\n  PdfAnnotationState2[\"Unmarked\"] = \"Unmarked\";\n  PdfAnnotationState2[\"Accepted\"] = \"Accepted\";\n  PdfAnnotationState2[\"Rejected\"] = \"Rejected\";\n  PdfAnnotationState2[\"Complete\"] = \"Complete\";\n  PdfAnnotationState2[\"Cancelled\"] = \"Cancelled\";\n  PdfAnnotationState2[\"None\"] = \"None\";\n  return PdfAnnotationState2;\n})(PdfAnnotationState || {});\nvar PdfAnnotationStateModel = /* @__PURE__ */ ((PdfAnnotationStateModel2) => {\n  PdfAnnotationStateModel2[\"Marked\"] = \"Marked\";\n  PdfAnnotationStateModel2[\"Reviewed\"] = \"Reviewed\";\n  return PdfAnnotationStateModel2;\n})(PdfAnnotationStateModel || {});\nvar PDF_FORM_FIELD_TYPE = /* @__PURE__ */ ((PDF_FORM_FIELD_TYPE2) => {\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"PUSHBUTTON\"] = 1] = \"PUSHBUTTON\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"CHECKBOX\"] = 2] = \"CHECKBOX\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"RADIOBUTTON\"] = 3] = \"RADIOBUTTON\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"COMBOBOX\"] = 4] = \"COMBOBOX\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"LISTBOX\"] = 5] = \"LISTBOX\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"TEXTFIELD\"] = 6] = \"TEXTFIELD\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"SIGNATURE\"] = 7] = \"SIGNATURE\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"XFA\"] = 8] = \"XFA\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"XFA_CHECKBOX\"] = 9] = \"XFA_CHECKBOX\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"XFA_COMBOBOX\"] = 10] = \"XFA_COMBOBOX\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"XFA_IMAGEFIELD\"] = 11] = \"XFA_IMAGEFIELD\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"XFA_LISTBOX\"] = 12] = \"XFA_LISTBOX\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"XFA_PUSHBUTTON\"] = 13] = \"XFA_PUSHBUTTON\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"XFA_SIGNATURE\"] = 14] = \"XFA_SIGNATURE\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"XFA_TEXTFIELD\"] = 15] = \"XFA_TEXTFIELD\";\n  return PDF_FORM_FIELD_TYPE2;\n})(PDF_FORM_FIELD_TYPE || {});\nvar PdfAnnotationColorType = /* @__PURE__ */ ((PdfAnnotationColorType2) => {\n  PdfAnnotationColorType2[PdfAnnotationColorType2[\"Color\"] = 0] = \"Color\";\n  PdfAnnotationColorType2[PdfAnnotationColorType2[\"InteriorColor\"] = 1] = \"InteriorColor\";\n  return PdfAnnotationColorType2;\n})(PdfAnnotationColorType || {});\nvar PdfAnnotationBorderStyle = /* @__PURE__ */ ((PdfAnnotationBorderStyle2) => {\n  PdfAnnotationBorderStyle2[PdfAnnotationBorderStyle2[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n  PdfAnnotationBorderStyle2[PdfAnnotationBorderStyle2[\"SOLID\"] = 1] = \"SOLID\";\n  PdfAnnotationBorderStyle2[PdfAnnotationBorderStyle2[\"DASHED\"] = 2] = \"DASHED\";\n  PdfAnnotationBorderStyle2[PdfAnnotationBorderStyle2[\"BEVELED\"] = 3] = \"BEVELED\";\n  PdfAnnotationBorderStyle2[PdfAnnotationBorderStyle2[\"INSET\"] = 4] = \"INSET\";\n  PdfAnnotationBorderStyle2[PdfAnnotationBorderStyle2[\"UNDERLINE\"] = 5] = \"UNDERLINE\";\n  PdfAnnotationBorderStyle2[PdfAnnotationBorderStyle2[\"CLOUDY\"] = 6] = \"CLOUDY\";\n  return PdfAnnotationBorderStyle2;\n})(PdfAnnotationBorderStyle || {});\nvar PdfAnnotationFlags = /* @__PURE__ */ ((PdfAnnotationFlags2) => {\n  PdfAnnotationFlags2[PdfAnnotationFlags2[\"NONE\"] = 0] = \"NONE\";\n  PdfAnnotationFlags2[PdfAnnotationFlags2[\"INVISIBLE\"] = 1] = \"INVISIBLE\";\n  PdfAnnotationFlags2[PdfAnnotationFlags2[\"HIDDEN\"] = 2] = \"HIDDEN\";\n  PdfAnnotationFlags2[PdfAnnotationFlags2[\"PRINT\"] = 4] = \"PRINT\";\n  PdfAnnotationFlags2[PdfAnnotationFlags2[\"NO_ZOOM\"] = 8] = \"NO_ZOOM\";\n  PdfAnnotationFlags2[PdfAnnotationFlags2[\"NO_ROTATE\"] = 16] = \"NO_ROTATE\";\n  PdfAnnotationFlags2[PdfAnnotationFlags2[\"NO_VIEW\"] = 32] = \"NO_VIEW\";\n  PdfAnnotationFlags2[PdfAnnotationFlags2[\"READ_ONLY\"] = 64] = \"READ_ONLY\";\n  PdfAnnotationFlags2[PdfAnnotationFlags2[\"LOCKED\"] = 128] = \"LOCKED\";\n  PdfAnnotationFlags2[PdfAnnotationFlags2[\"TOGGLE_NOVIEW\"] = 256] = \"TOGGLE_NOVIEW\";\n  return PdfAnnotationFlags2;\n})(PdfAnnotationFlags || {});\nvar PDF_FORM_FIELD_FLAG = /* @__PURE__ */ ((PDF_FORM_FIELD_FLAG2) => {\n  PDF_FORM_FIELD_FLAG2[PDF_FORM_FIELD_FLAG2[\"NONE\"] = 0] = \"NONE\";\n  PDF_FORM_FIELD_FLAG2[PDF_FORM_FIELD_FLAG2[\"READONLY\"] = 1] = \"READONLY\";\n  PDF_FORM_FIELD_FLAG2[PDF_FORM_FIELD_FLAG2[\"REQUIRED\"] = 2] = \"REQUIRED\";\n  PDF_FORM_FIELD_FLAG2[PDF_FORM_FIELD_FLAG2[\"NOEXPORT\"] = 4] = \"NOEXPORT\";\n  PDF_FORM_FIELD_FLAG2[PDF_FORM_FIELD_FLAG2[\"TEXT_MULTIPLINE\"] = 4096] = \"TEXT_MULTIPLINE\";\n  PDF_FORM_FIELD_FLAG2[PDF_FORM_FIELD_FLAG2[\"TEXT_PASSWORD\"] = 8192] = \"TEXT_PASSWORD\";\n  PDF_FORM_FIELD_FLAG2[PDF_FORM_FIELD_FLAG2[\"CHOICE_COMBO\"] = 131072] = \"CHOICE_COMBO\";\n  PDF_FORM_FIELD_FLAG2[PDF_FORM_FIELD_FLAG2[\"CHOICE_EDIT\"] = 262144] = \"CHOICE_EDIT\";\n  PDF_FORM_FIELD_FLAG2[PDF_FORM_FIELD_FLAG2[\"CHOICE_MULTL_SELECT\"] = 2097152] = \"CHOICE_MULTL_SELECT\";\n  return PDF_FORM_FIELD_FLAG2;\n})(PDF_FORM_FIELD_FLAG || {});\nvar PdfPageObjectType = /* @__PURE__ */ ((PdfPageObjectType2) => {\n  PdfPageObjectType2[PdfPageObjectType2[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n  PdfPageObjectType2[PdfPageObjectType2[\"TEXT\"] = 1] = \"TEXT\";\n  PdfPageObjectType2[PdfPageObjectType2[\"PATH\"] = 2] = \"PATH\";\n  PdfPageObjectType2[PdfPageObjectType2[\"IMAGE\"] = 3] = \"IMAGE\";\n  PdfPageObjectType2[PdfPageObjectType2[\"SHADING\"] = 4] = \"SHADING\";\n  PdfPageObjectType2[PdfPageObjectType2[\"FORM\"] = 5] = \"FORM\";\n  return PdfPageObjectType2;\n})(PdfPageObjectType || {});\nvar PdfAnnotationFlagName = Object.freeze({\n  [1 /* INVISIBLE */]: \"invisible\",\n  [2 /* HIDDEN */]: \"hidden\",\n  [4 /* PRINT */]: \"print\",\n  [8 /* NO_ZOOM */]: \"noZoom\",\n  [16 /* NO_ROTATE */]: \"noRotate\",\n  [32 /* NO_VIEW */]: \"noView\",\n  [64 /* READ_ONLY */]: \"readOnly\",\n  [128 /* LOCKED */]: \"locked\",\n  [256 /* TOGGLE_NOVIEW */]: \"toggleNoView\"\n});\nvar PdfAnnotationFlagValue = Object.entries(\n  PdfAnnotationFlagName\n).reduce(\n  (acc, [bit, name]) => {\n    acc[name] = Number(bit);\n    return acc;\n  },\n  {}\n);\nfunction flagsToNames(raw) {\n  return Object.keys(PdfAnnotationFlagName).filter((flag) => (raw & flag) !== 0).map((flag) => PdfAnnotationFlagName[flag]);\n}\nfunction namesToFlags(names) {\n  return names.reduce(\n    (mask, name) => mask | PdfAnnotationFlagValue[name],\n    0 /* NONE */\n  );\n}\nvar PdfSegmentObjectType = /* @__PURE__ */ ((PdfSegmentObjectType2) => {\n  PdfSegmentObjectType2[PdfSegmentObjectType2[\"UNKNOWN\"] = -1] = \"UNKNOWN\";\n  PdfSegmentObjectType2[PdfSegmentObjectType2[\"LINETO\"] = 0] = \"LINETO\";\n  PdfSegmentObjectType2[PdfSegmentObjectType2[\"BEZIERTO\"] = 1] = \"BEZIERTO\";\n  PdfSegmentObjectType2[PdfSegmentObjectType2[\"MOVETO\"] = 2] = \"MOVETO\";\n  return PdfSegmentObjectType2;\n})(PdfSegmentObjectType || {});\nvar PdfEngineFeature = /* @__PURE__ */ ((PdfEngineFeature2) => {\n  PdfEngineFeature2[PdfEngineFeature2[\"RenderPage\"] = 0] = \"RenderPage\";\n  PdfEngineFeature2[PdfEngineFeature2[\"RenderPageRect\"] = 1] = \"RenderPageRect\";\n  PdfEngineFeature2[PdfEngineFeature2[\"Thumbnails\"] = 2] = \"Thumbnails\";\n  PdfEngineFeature2[PdfEngineFeature2[\"Bookmarks\"] = 3] = \"Bookmarks\";\n  PdfEngineFeature2[PdfEngineFeature2[\"Annotations\"] = 4] = \"Annotations\";\n  return PdfEngineFeature2;\n})(PdfEngineFeature || {});\nvar PdfEngineOperation = /* @__PURE__ */ ((PdfEngineOperation2) => {\n  PdfEngineOperation2[PdfEngineOperation2[\"Create\"] = 0] = \"Create\";\n  PdfEngineOperation2[PdfEngineOperation2[\"Read\"] = 1] = \"Read\";\n  PdfEngineOperation2[PdfEngineOperation2[\"Update\"] = 2] = \"Update\";\n  PdfEngineOperation2[PdfEngineOperation2[\"Delete\"] = 3] = \"Delete\";\n  return PdfEngineOperation2;\n})(PdfEngineOperation || {});\nvar MatchFlag = /* @__PURE__ */ ((MatchFlag2) => {\n  MatchFlag2[MatchFlag2[\"None\"] = 0] = \"None\";\n  MatchFlag2[MatchFlag2[\"MatchCase\"] = 1] = \"MatchCase\";\n  MatchFlag2[MatchFlag2[\"MatchWholeWord\"] = 2] = \"MatchWholeWord\";\n  MatchFlag2[MatchFlag2[\"MatchConsecutive\"] = 4] = \"MatchConsecutive\";\n  return MatchFlag2;\n})(MatchFlag || {});\nfunction unionFlags(flags) {\n  return flags.reduce((flag, currFlag) => {\n    return flag | currFlag;\n  }, 0 /* None */);\n}\nfunction compareSearchTarget(targetA, targetB) {\n  const flagA = unionFlags(targetA.flags);\n  const flagB = unionFlags(targetB.flags);\n  return flagA === flagB && targetA.keyword === targetB.keyword;\n}\nvar PdfPermission = /* @__PURE__ */ ((PdfPermission2) => {\n  PdfPermission2[PdfPermission2[\"PrintDocument\"] = 8] = \"PrintDocument\";\n  PdfPermission2[PdfPermission2[\"ModifyContent\"] = 16] = \"ModifyContent\";\n  PdfPermission2[PdfPermission2[\"CopyOrExtract\"] = 32] = \"CopyOrExtract\";\n  PdfPermission2[PdfPermission2[\"AddOrModifyTextAnnot\"] = 64] = \"AddOrModifyTextAnnot\";\n  PdfPermission2[PdfPermission2[\"FillInExistingForm\"] = 512] = \"FillInExistingForm\";\n  PdfPermission2[PdfPermission2[\"ExtractTextOrGraphics\"] = 1024] = \"ExtractTextOrGraphics\";\n  PdfPermission2[PdfPermission2[\"AssembleDocument\"] = 2048] = \"AssembleDocument\";\n  PdfPermission2[PdfPermission2[\"PrintHighQuality\"] = 4096] = \"PrintHighQuality\";\n  return PdfPermission2;\n})(PdfPermission || {});\nvar PdfPageFlattenFlag = /* @__PURE__ */ ((PdfPageFlattenFlag2) => {\n  PdfPageFlattenFlag2[PdfPageFlattenFlag2[\"Display\"] = 0] = \"Display\";\n  PdfPageFlattenFlag2[PdfPageFlattenFlag2[\"Print\"] = 1] = \"Print\";\n  return PdfPageFlattenFlag2;\n})(PdfPageFlattenFlag || {});\nvar PdfPageFlattenResult = /* @__PURE__ */ ((PdfPageFlattenResult2) => {\n  PdfPageFlattenResult2[PdfPageFlattenResult2[\"Fail\"] = 0] = \"Fail\";\n  PdfPageFlattenResult2[PdfPageFlattenResult2[\"Success\"] = 1] = \"Success\";\n  PdfPageFlattenResult2[PdfPageFlattenResult2[\"NothingToDo\"] = 2] = \"NothingToDo\";\n  return PdfPageFlattenResult2;\n})(PdfPageFlattenResult || {});\nvar PdfErrorCode = /* @__PURE__ */ ((PdfErrorCode2) => {\n  PdfErrorCode2[PdfErrorCode2[\"Ok\"] = 0] = \"Ok\";\n  PdfErrorCode2[PdfErrorCode2[\"Unknown\"] = 1] = \"Unknown\";\n  PdfErrorCode2[PdfErrorCode2[\"NotFound\"] = 2] = \"NotFound\";\n  PdfErrorCode2[PdfErrorCode2[\"WrongFormat\"] = 3] = \"WrongFormat\";\n  PdfErrorCode2[PdfErrorCode2[\"Password\"] = 4] = \"Password\";\n  PdfErrorCode2[PdfErrorCode2[\"Security\"] = 5] = \"Security\";\n  PdfErrorCode2[PdfErrorCode2[\"PageError\"] = 6] = \"PageError\";\n  PdfErrorCode2[PdfErrorCode2[\"XFALoad\"] = 7] = \"XFALoad\";\n  PdfErrorCode2[PdfErrorCode2[\"XFALayout\"] = 8] = \"XFALayout\";\n  PdfErrorCode2[PdfErrorCode2[\"Cancelled\"] = 9] = \"Cancelled\";\n  PdfErrorCode2[PdfErrorCode2[\"Initialization\"] = 10] = \"Initialization\";\n  PdfErrorCode2[PdfErrorCode2[\"NotReady\"] = 11] = \"NotReady\";\n  PdfErrorCode2[PdfErrorCode2[\"NotSupport\"] = 12] = \"NotSupport\";\n  PdfErrorCode2[PdfErrorCode2[\"LoadDoc\"] = 13] = \"LoadDoc\";\n  PdfErrorCode2[PdfErrorCode2[\"DocNotOpen\"] = 14] = \"DocNotOpen\";\n  PdfErrorCode2[PdfErrorCode2[\"CantCloseDoc\"] = 15] = \"CantCloseDoc\";\n  PdfErrorCode2[PdfErrorCode2[\"CantCreateNewDoc\"] = 16] = \"CantCreateNewDoc\";\n  PdfErrorCode2[PdfErrorCode2[\"CantImportPages\"] = 17] = \"CantImportPages\";\n  PdfErrorCode2[PdfErrorCode2[\"CantCreateAnnot\"] = 18] = \"CantCreateAnnot\";\n  PdfErrorCode2[PdfErrorCode2[\"CantSetAnnotRect\"] = 19] = \"CantSetAnnotRect\";\n  PdfErrorCode2[PdfErrorCode2[\"CantSetAnnotContent\"] = 20] = \"CantSetAnnotContent\";\n  PdfErrorCode2[PdfErrorCode2[\"CantRemoveInkList\"] = 21] = \"CantRemoveInkList\";\n  PdfErrorCode2[PdfErrorCode2[\"CantAddInkStoke\"] = 22] = \"CantAddInkStoke\";\n  PdfErrorCode2[PdfErrorCode2[\"CantReadAttachmentSize\"] = 23] = \"CantReadAttachmentSize\";\n  PdfErrorCode2[PdfErrorCode2[\"CantReadAttachmentContent\"] = 24] = \"CantReadAttachmentContent\";\n  PdfErrorCode2[PdfErrorCode2[\"CantFocusAnnot\"] = 25] = \"CantFocusAnnot\";\n  PdfErrorCode2[PdfErrorCode2[\"CantSelectText\"] = 26] = \"CantSelectText\";\n  PdfErrorCode2[PdfErrorCode2[\"CantSelectOption\"] = 27] = \"CantSelectOption\";\n  PdfErrorCode2[PdfErrorCode2[\"CantCheckField\"] = 28] = \"CantCheckField\";\n  return PdfErrorCode2;\n})(PdfErrorCode || {});\nvar PdfTaskHelper = class {\n  /**\n   * Create a task\n   * @returns new task\n   */\n  static create() {\n    return new Task();\n  }\n  /**\n   * Create a task that has been resolved with value\n   * @param result - resolved value\n   * @returns resolved task\n   */\n  static resolve(result) {\n    const task = new Task();\n    task.resolve(result);\n    return task;\n  }\n  /**\n   * Create a task that has been rejected with error\n   * @param reason - rejected error\n   * @returns rejected task\n   */\n  static reject(reason) {\n    const task = new Task();\n    task.reject(reason);\n    return task;\n  }\n  /**\n   * Create a task that has been aborted with error\n   * @param reason - aborted error\n   * @returns aborted task\n   */\n  static abort(reason) {\n    const task = new Task();\n    task.reject(reason);\n    return task;\n  }\n};\n\n// src/color.ts\nfunction pdfAlphaColorToWebAlphaColor(c) {\n  const clamp = (n) => Math.max(0, Math.min(255, n));\n  const toHex = (n) => clamp(n).toString(16).padStart(2, \"0\");\n  const color = `#${toHex(c.red)}${toHex(c.green)}${toHex(c.blue)}`;\n  const opacity = clamp(c.alpha) / 255;\n  return { color, opacity };\n}\nfunction webAlphaColorToPdfAlphaColor({ color, opacity }) {\n  if (/^#?[0-9a-f]{3}$/i.test(color)) {\n    color = color.replace(/^#?([0-9a-f])([0-9a-f])([0-9a-f])$/i, \"#$1$1$2$2$3$3\").toLowerCase();\n  }\n  const [, r, g, b] = /^#?([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$/i.exec(color) ?? (() => {\n    throw new Error(`Invalid hex colour: \\u201C${color}\\u201D`);\n  })();\n  const clamp = (n, hi = 255) => Math.max(0, Math.min(hi, n));\n  return {\n    red: parseInt(r, 16),\n    green: parseInt(g, 16),\n    blue: parseInt(b, 16),\n    alpha: clamp(Math.round(opacity * 255))\n  };\n}\n\n// src/date.ts\nfunction pdfDateToDate(pdf) {\n  if (!pdf?.startsWith(\"D:\") || pdf.length < 16) return;\n  const y = +pdf.slice(2, 6);\n  const mo = +pdf.slice(6, 8) - 1;\n  const d = +pdf.slice(8, 10);\n  const H = +pdf.slice(10, 12);\n  const M = +pdf.slice(12, 14);\n  const S = +pdf.slice(14, 16);\n  return new Date(Date.UTC(y, mo, d, H, M, S));\n}\nfunction dateToPdfDate(date = /* @__PURE__ */ new Date()) {\n  const z = (n, len = 2) => n.toString().padStart(len, \"0\");\n  const YYYY = date.getUTCFullYear();\n  const MM = z(date.getUTCMonth() + 1);\n  const DD = z(date.getUTCDate());\n  const HH = z(date.getUTCHours());\n  const mm = z(date.getUTCMinutes());\n  const SS = z(date.getUTCSeconds());\n  return `D:${YYYY}${MM}${DD}${HH}${mm}${SS}`;\n}\n\n// src/index.ts\nfunction ignore() {\n}\nexport {\n  AllLogger,\n  AppearanceMode,\n  ConsoleLogger,\n  LevelLogger,\n  LogLevel,\n  MatchFlag,\n  MixedBlendMode,\n  NoopLogger,\n  PDF_FORM_FIELD_FLAG,\n  PDF_FORM_FIELD_TYPE,\n  PdfActionType,\n  PdfAnnotationBorderStyle,\n  PdfAnnotationColorType,\n  PdfAnnotationFlagName,\n  PdfAnnotationFlags,\n  PdfAnnotationObjectStatus,\n  PdfAnnotationState,\n  PdfAnnotationStateModel,\n  PdfAnnotationSubtype,\n  PdfAnnotationSubtypeName,\n  PdfBlendMode,\n  PdfBomOrZwnbsp,\n  PdfEngineFeature,\n  PdfEngineOperation,\n  PdfErrorCode,\n  PdfNonCharacterFFFE,\n  PdfNonCharacterFFFF,\n  PdfPageFlattenFlag,\n  PdfPageFlattenResult,\n  PdfPageObjectType,\n  PdfPermission,\n  PdfSegmentObjectType,\n  PdfSoftHyphenMarker,\n  PdfTaskHelper,\n  PdfUnwantedTextMarkers,\n  PdfUnwantedTextRegex,\n  PdfWordJoiner,\n  PdfZeroWidthSpace,\n  PdfZoomMode,\n  PerfLogger,\n  Rotation,\n  Task,\n  TaskAbortedError,\n  TaskRejectedError,\n  TaskStage,\n  blendModeLabel,\n  blendModeSelectOptions,\n  blendModeToCss,\n  boundingRect,\n  calculateAngle,\n  calculateDegree,\n  compareSearchTarget,\n  cssToBlendMode,\n  dateToPdfDate,\n  flagsToNames,\n  getBlendModeInfo,\n  ignore,\n  makeMatrix,\n  namesToFlags,\n  pdfAlphaColorToWebAlphaColor,\n  pdfDateToDate,\n  quadToRect,\n  rectToQuad,\n  reduceBlendModes,\n  restoreOffset,\n  restorePosition,\n  restoreRect,\n  rotatePosition,\n  rotateRect,\n  scalePosition,\n  scaleRect,\n  stripPdfUnwantedMarkers,\n  swap,\n  toIntPos,\n  toIntRect,\n  toIntSize,\n  transformPosition,\n  transformRect,\n  transformSize,\n  uiBlendModeDisplay,\n  unionFlags,\n  webAlphaColorToPdfAlphaColor\n};\n//# sourceMappingURL=index.js.map","import { PdfDocumentObject, PdfPageObject, Rotation } from '@embedpdf/models';\nimport { PluginRegistryConfig } from '../types/plugin';\n\nexport interface CoreState {\n  scale: number;\n  rotation: Rotation;\n  document: PdfDocumentObject | null;\n  pages: PdfPageObject[][];\n  loading: boolean;\n  error: string | null;\n}\n\nexport const initialCoreState: (config?: PluginRegistryConfig) => CoreState = (config) => ({\n  scale: config?.scale ?? 1,\n  rotation: config?.rotation ?? Rotation.Degree0,\n  document: null,\n  pages: [],\n  loading: false,\n  error: null,\n});\n","import { Reducer } from './types';\nimport { CoreState } from './initial-state';\nimport {\n  CoreAction,\n  LOAD_DOCUMENT,\n  SET_DOCUMENT,\n  SET_DOCUMENT_ERROR,\n  SET_PAGES,\n  SET_ROTATION,\n  SET_SCALE,\n} from './actions';\n\nexport const coreReducer: Reducer<CoreState, CoreAction> = (state, action): CoreState => {\n  switch (action.type) {\n    case LOAD_DOCUMENT:\n      return {\n        ...state,\n        loading: true,\n        error: null,\n      };\n\n    case SET_DOCUMENT:\n      return {\n        ...state,\n        document: action.payload,\n        pages: action.payload.pages.map((page) => [page]),\n        loading: false,\n        error: null,\n      };\n\n    case SET_ROTATION:\n      return {\n        ...state,\n        rotation: action.payload,\n      };\n\n    case SET_PAGES:\n      return {\n        ...state,\n        pages: action.payload,\n      };\n\n    case SET_DOCUMENT_ERROR:\n      return {\n        ...state,\n        loading: false,\n        error: action.payload,\n      };\n\n    case SET_SCALE:\n      return {\n        ...state,\n        scale: action.payload,\n      };\n\n    default:\n      return state;\n  }\n};\n","import { DependencyResolver } from '../utils/dependency-resolver';\nimport {\n  IPlugin,\n  PluginBatchRegistration,\n  PluginManifest,\n  PluginStatus,\n  PluginPackage,\n  PluginRegistryConfig,\n} from '../types/plugin';\nimport {\n  PluginRegistrationError,\n  PluginNotFoundError,\n  CircularDependencyError,\n  CapabilityNotFoundError,\n  PluginConfigurationError,\n} from '../types/errors';\nimport { ignore, PdfEngine, Rotation } from '@embedpdf/models';\nimport { Action, CoreState, Store, initialCoreState, Reducer } from '../store';\nimport { CoreAction } from '../store/actions';\nimport { coreReducer } from '../store/reducer';\n\n// Define a more flexible generic type for plugin registrations\ninterface PluginRegistration {\n  // Use existential types for the plugin package to allow accepting any plugin type\n  package: PluginPackage<any, any, any, any>;\n  config?: any;\n}\n\nexport class PluginRegistry {\n  private plugins: Map<string, IPlugin> = new Map();\n  private manifests: Map<string, PluginManifest> = new Map();\n  private capabilities: Map<string, string> = new Map(); // capability -> pluginId\n  private status: Map<string, PluginStatus> = new Map();\n  private resolver: DependencyResolver;\n  private configurations: Map<string, unknown> = new Map();\n  private engine: PdfEngine;\n  private engineInitialized = false;\n  private store: Store<CoreState, CoreAction>;\n  private initPromise: Promise<void> | null = null;\n\n  private pendingRegistrations: PluginRegistration[] = [];\n  private processingRegistrations: PluginRegistration[] = [];\n  private initialized = false;\n  private isInitializing = false;\n  private initialCoreState: CoreState;\n  private pluginsReadyPromise: Promise<void> | null = null;\n  private destroyed = false;\n\n  constructor(engine: PdfEngine, config?: PluginRegistryConfig) {\n    this.resolver = new DependencyResolver();\n    this.engine = engine;\n    this.initialCoreState = initialCoreState(config);\n    this.store = new Store<CoreState, CoreAction>(coreReducer, this.initialCoreState);\n  }\n\n  /**\n   * Ensure engine is initialized before proceeding\n   */\n  private async ensureEngineInitialized(): Promise<void> {\n    if (this.engineInitialized) {\n      return;\n    }\n\n    if (this.engine.initialize) {\n      const task = this.engine.initialize();\n      await task.toPromise();\n      this.engineInitialized = true;\n    } else {\n      this.engineInitialized = true;\n    }\n  }\n\n  /**\n   * Register a plugin without initializing it\n   */\n  registerPlugin<\n    TPlugin extends IPlugin<TConfig>,\n    TConfig = unknown,\n    TState = unknown,\n    TAction extends Action = Action,\n  >(\n    pluginPackage: PluginPackage<TPlugin, TConfig, TState, TAction>,\n    config?: Partial<TConfig>,\n  ): void {\n    if (this.initialized && !this.isInitializing) {\n      throw new PluginRegistrationError('Cannot register plugins after initialization');\n    }\n\n    this.validateManifest(pluginPackage.manifest);\n\n    // Use appropriate typing for store methods\n    this.store.addPluginReducer(\n      pluginPackage.manifest.id,\n      // We need one type assertion here since we can't fully reconcile TAction with Action\n      // due to TypeScript's type system limitations with generic variance\n      pluginPackage.reducer as Reducer<TState, Action>,\n      'function' === typeof pluginPackage.initialState\n        ? (pluginPackage.initialState as (coreState: CoreState, config: TConfig) => TState)(\n            this.initialCoreState,\n            {\n              ...pluginPackage.manifest.defaultConfig,\n              ...config,\n            },\n          )\n        : pluginPackage.initialState,\n    );\n\n    this.pendingRegistrations.push({\n      package: pluginPackage,\n      config,\n    });\n  }\n\n  /**\n   * Get the central store instance\n   */\n  getStore(): Store<CoreState, CoreAction> {\n    return this.store;\n  }\n\n  /**\n   * Get the engine instance\n   */\n  getEngine(): PdfEngine {\n    return this.engine;\n  }\n\n  /**\n   * Get a promise that resolves when all plugins are ready\n   */\n  public pluginsReady(): Promise<void> {\n    // Re-use the same promise every time it’s asked for\n    if (this.pluginsReadyPromise) {\n      return this.pluginsReadyPromise;\n    }\n\n    // Build the promise the *first* time it’s requested\n    this.pluginsReadyPromise = (async () => {\n      // 1. Wait until the registry itself has finished initialising\n      if (!this.initialized) {\n        await this.initialize();\n      }\n\n      // 2. Wait for every plugin’s ready() promise (if it has one)\n      const readyPromises = Array.from(this.plugins.values()).map((p) =>\n        typeof p.ready === 'function' ? p.ready() : Promise.resolve(),\n      );\n\n      await Promise.all(readyPromises); // resolves when the slowest is done\n    })();\n\n    return this.pluginsReadyPromise;\n  }\n\n  /**\n   * INITIALISE THE REGISTRY – runs once no-matter-how-many calls   *\n   */\n  async initialize(): Promise<void> {\n    if (this.destroyed) {\n      throw new PluginRegistrationError('Registry has been destroyed');\n    }\n\n    // If an initialisation is already in-flight (or finished)\n    // return the very same promise so callers can await it.\n    if (this.initPromise) {\n      return this.initPromise;\n    }\n\n    // Wrap your existing body in a single promise and cache it\n    this.initPromise = (async () => {\n      if (this.initialized) {\n        throw new PluginRegistrationError('Registry is already initialized');\n      }\n\n      this.isInitializing = true;\n\n      try {\n        /* ---------------- original body starts ------------------ */\n        await this.ensureEngineInitialized();\n        // Check if destroyed after engine initialization\n        if (this.destroyed) {\n          return;\n        }\n\n        while (this.pendingRegistrations.length > 0) {\n          // Check if destroyed before processing each batch\n          if (this.destroyed) {\n            return;\n          }\n          this.processingRegistrations = [...this.pendingRegistrations];\n          this.pendingRegistrations = [];\n\n          for (const reg of this.processingRegistrations) {\n            const dependsOn = new Set<string>();\n            const allDeps = [...reg.package.manifest.requires, ...reg.package.manifest.optional];\n            for (const cap of allDeps) {\n              const provider = this.processingRegistrations.find((r) =>\n                r.package.manifest.provides.includes(cap),\n              );\n              if (provider) dependsOn.add(provider.package.manifest.id);\n            }\n            this.resolver.addNode(reg.package.manifest.id, [...dependsOn]);\n          }\n\n          const loadOrder = this.resolver.resolveLoadOrder();\n          for (const id of loadOrder) {\n            const reg = this.processingRegistrations.find((r) => r.package.manifest.id === id)!;\n            await this.initializePlugin(reg.package.manifest, reg.package.create, reg.config);\n          }\n\n          this.processingRegistrations = [];\n          this.resolver = new DependencyResolver();\n        }\n\n        for (const plugin of this.plugins.values()) {\n          await plugin.postInitialize?.().catch((e) => {\n            console.error(`Error in postInitialize for plugin ${plugin.id}`, e);\n            this.status.set(plugin.id, 'error');\n          });\n        }\n\n        this.initialized = true;\n        /* ----------------- original body ends ------------------- */\n      } catch (err) {\n        if (err instanceof Error) {\n          throw new CircularDependencyError(\n            `Failed to resolve plugin dependencies: ${err.message}`,\n          );\n        }\n        throw err;\n      } finally {\n        this.isInitializing = false;\n      }\n    })();\n\n    return this.initPromise;\n  }\n\n  /**\n   * Initialize a single plugin with all necessary checks\n   */\n  private async initializePlugin<TConfig>(\n    manifest: PluginManifest<TConfig>,\n    packageCreator: (\n      registry: PluginRegistry,\n      engine: PdfEngine,\n      config?: TConfig,\n    ) => IPlugin<TConfig>,\n    config?: Partial<TConfig>,\n  ): Promise<void> {\n    const finalConfig = {\n      ...manifest.defaultConfig,\n      ...config,\n    };\n\n    this.validateConfig(manifest.id, finalConfig, manifest.defaultConfig);\n\n    // Create plugin instance during initialization\n    const plugin = packageCreator(this, this.engine, finalConfig);\n    this.validatePlugin(plugin);\n\n    // Verify all required capabilities are available\n    for (const capability of manifest.requires) {\n      if (!this.capabilities.has(capability)) {\n        throw new PluginRegistrationError(\n          `Missing required capability: ${capability} for plugin ${manifest.id}`,\n        );\n      }\n    }\n\n    // Optional capabilities can be null, so we don't throw errors for them\n    for (const capability of manifest.optional) {\n      if (this.capabilities.has(capability)) {\n        // Optional capability is available, but we don't require it\n        console.debug(`Optional capability ${capability} is available for plugin ${manifest.id}`);\n      }\n    }\n\n    console.log('initializePlugin', manifest.id, manifest.provides);\n\n    // Register provided capabilities\n    for (const capability of manifest.provides) {\n      if (this.capabilities.has(capability)) {\n        throw new PluginRegistrationError(\n          `Capability ${capability} is already provided by plugin ${this.capabilities.get(capability)}`,\n        );\n      }\n      this.capabilities.set(capability, manifest.id);\n    }\n\n    // Store plugin and manifest\n    this.plugins.set(manifest.id, plugin);\n    this.manifests.set(manifest.id, manifest);\n    this.status.set(manifest.id, 'registered');\n    this.configurations.set(manifest.id, finalConfig);\n\n    try {\n      if (plugin.initialize) {\n        await plugin.initialize(finalConfig);\n      }\n      this.status.set(manifest.id, 'active');\n    } catch (error) {\n      // Cleanup on initialization failure\n      this.plugins.delete(manifest.id);\n      this.manifests.delete(manifest.id);\n      console.log('initializePlugin failed', manifest.id, manifest.provides);\n      manifest.provides.forEach((cap) => this.capabilities.delete(cap));\n      throw error;\n    }\n  }\n\n  getPluginConfig<TConfig>(pluginId: string): TConfig {\n    const config = this.configurations.get(pluginId);\n    if (!config) {\n      throw new PluginNotFoundError(`Configuration for plugin ${pluginId} not found`);\n    }\n    return config as TConfig;\n  }\n\n  private validateConfig(pluginId: string, config: unknown, defaultConfig: unknown): void {\n    // Check all required fields exist\n    const requiredKeys = Object.keys(defaultConfig as object);\n    const missingKeys = requiredKeys.filter((key) => !(config as object).hasOwnProperty(key));\n\n    if (missingKeys.length > 0) {\n      throw new PluginConfigurationError(\n        `Missing required configuration keys for plugin ${pluginId}: ${missingKeys.join(', ')}`,\n      );\n    }\n\n    // You could add more validation here:\n    // - Type checking\n    // - Value range validation\n    // - Format validation\n    // etc.\n  }\n\n  async updatePluginConfig<TConfig>(pluginId: string, config: Partial<TConfig>): Promise<void> {\n    const plugin = this.getPlugin(pluginId);\n\n    if (!plugin) {\n      throw new PluginNotFoundError(`Plugin ${pluginId} not found`);\n    }\n\n    const manifest = this.manifests.get(pluginId);\n    const currentConfig = this.configurations.get(pluginId);\n\n    if (!manifest || !currentConfig) {\n      throw new PluginNotFoundError(`Plugin ${pluginId} not found`);\n    }\n\n    // Merge new config with current\n    const newConfig = {\n      ...currentConfig,\n      ...config,\n    };\n\n    // Validate new configuration\n    this.validateConfig(pluginId, newConfig, manifest.defaultConfig);\n\n    // Store new configuration\n    this.configurations.set(pluginId, newConfig);\n\n    // Reinitialize plugin if needed\n    if (plugin.initialize) {\n      await plugin.initialize(newConfig);\n    }\n  }\n\n  /**\n   * Register multiple plugins at once\n   */\n  registerPluginBatch(registrations: PluginBatchRegistration<IPlugin<any>, any, any, any>[]): void {\n    for (const reg of registrations) {\n      this.registerPlugin(reg.package, reg.config);\n    }\n  }\n\n  /**\n   * Unregister a plugin\n   */\n  async unregisterPlugin(pluginId: string): Promise<void> {\n    const plugin = this.plugins.get(pluginId);\n    if (!plugin) {\n      throw new PluginNotFoundError(`Plugin ${pluginId} is not registered`);\n    }\n\n    const manifest = this.manifests.get(pluginId);\n    if (!manifest) {\n      throw new PluginNotFoundError(`Manifest for plugin ${pluginId} not found`);\n    }\n\n    // Check if any other plugins depend on this one\n    for (const [otherId, otherManifest] of this.manifests.entries()) {\n      if (otherId === pluginId) continue;\n\n      const dependsOnThis = [...otherManifest.requires, ...otherManifest.optional].some((cap) =>\n        manifest.provides.includes(cap),\n      );\n\n      if (dependsOnThis) {\n        throw new PluginRegistrationError(\n          `Cannot unregister plugin ${pluginId}: plugin ${otherId} depends on it`,\n        );\n      }\n    }\n\n    // Cleanup plugin\n    try {\n      if (plugin.destroy) {\n        await plugin.destroy();\n      }\n\n      // Remove capabilities\n      for (const capability of manifest.provides) {\n        this.capabilities.delete(capability);\n      }\n\n      // Remove plugin and manifest\n      this.plugins.delete(pluginId);\n      this.manifests.delete(pluginId);\n      this.status.delete(pluginId);\n    } catch (error) {\n      if (error instanceof Error) {\n        throw new Error(`Failed to unregister plugin ${pluginId}: ${error.message}`);\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Get a plugin instance\n   * @param pluginId The ID of the plugin to get\n   * @returns The plugin instance or null if not found\n   */\n  getPlugin<T extends IPlugin>(pluginId: string): T | null {\n    const plugin = this.plugins.get(pluginId);\n    if (!plugin) {\n      return null;\n    }\n    return plugin as T;\n  }\n\n  /**\n   * Get a plugin that provides a specific capability\n   * @param capability The capability to get a provider for\n   * @returns The plugin providing the capability or null if not found\n   */\n  getCapabilityProvider(capability: string): IPlugin | null {\n    const pluginId = this.capabilities.get(capability);\n    if (!pluginId) {\n      return null;\n    }\n    return this.getPlugin(pluginId);\n  }\n\n  /**\n   * Check if a capability is available\n   */\n  hasCapability(capability: string): boolean {\n    return this.capabilities.has(capability);\n  }\n\n  /**\n   * Get all registered plugins\n   */\n  getAllPlugins(): IPlugin[] {\n    return Array.from(this.plugins.values());\n  }\n\n  /**\n   * Get plugin status\n   */\n  getPluginStatus(pluginId: string): PluginStatus {\n    const status = this.status.get(pluginId);\n    if (!status) {\n      throw new PluginNotFoundError(`Plugin ${pluginId} not found`);\n    }\n    return status;\n  }\n\n  /**\n   * Validate plugin object\n   */\n  private validatePlugin(plugin: IPlugin): void {\n    if (!plugin.id) {\n      throw new PluginRegistrationError('Plugin must have an id');\n    }\n  }\n\n  /**\n   * Validate plugin manifest\n   */\n  private validateManifest(manifest: PluginManifest): void {\n    if (!manifest.id) {\n      throw new PluginRegistrationError('Manifest must have an id');\n    }\n    if (!manifest.name) {\n      throw new PluginRegistrationError('Manifest must have a name');\n    }\n    if (!manifest.version) {\n      throw new PluginRegistrationError('Manifest must have a version');\n    }\n    if (!Array.isArray(manifest.provides)) {\n      throw new PluginRegistrationError('Manifest must have a provides array');\n    }\n    if (!Array.isArray(manifest.requires)) {\n      throw new PluginRegistrationError('Manifest must have a requires array');\n    }\n    if (!Array.isArray(manifest.optional)) {\n      throw new PluginRegistrationError('Manifest must have an optional array');\n    }\n  }\n\n  isDestroyed(): boolean {\n    return this.destroyed;\n  }\n\n  /**\n   * DESTROY EVERYTHING – waits for any ongoing initialise(), once  *\n   */\n  async destroy(): Promise<void> {\n    if (this.destroyed) throw new PluginRegistrationError('Registry has already been destroyed');\n    this.destroyed = true;\n\n    // If initialisation is still underway, wait (success OR failure)\n    try {\n      await this.initPromise;\n    } catch {\n      /* ignore – still need to clean up */\n    }\n\n    /* ------- original teardown, unchanged except the guard ------ */\n    for (const plugin of Array.from(this.plugins.values()).reverse()) {\n      await plugin.destroy?.();\n    }\n\n    this.store.destroy();\n\n    this.plugins.clear();\n    this.manifests.clear();\n    this.capabilities.clear();\n    this.status.clear();\n    this.pendingRegistrations.length = 0;\n    this.processingRegistrations.length = 0;\n  }\n}\n","/**\n * Restrict a numeric value to the inclusive range [min, max].\n *\n * @example\n *   clamp( 5, 0, 10)  // 5\n *   clamp(-3, 0, 10)  // 0\n *   clamp(17, 0, 10)  // 10\n */\nexport function clamp(value: number, min: number, max: number): number {\n  return value < min ? min : value > max ? max : value;\n}\n\n/**\n * Deeply compares two values (objects, arrays, primitives)\n * with the following rules:\n *  - Objects are compared ignoring property order.\n *  - Arrays are compared ignoring element order (multiset comparison).\n *  - Primitives are compared by strict equality.\n *  - null/undefined are treated as normal primitives.\n *\n * @param a First value\n * @param b Second value\n * @param visited Used internally to detect cycles\n */\nexport function arePropsEqual(a: any, b: any, visited?: Set<any>): boolean {\n  // Quick path for reference equality or same primitive\n  if (a === b) {\n    return true;\n  }\n\n  // Handle null/undefined mismatch\n  if (a == null || b == null) {\n    // If one is null/undefined and the other isn't, no match\n    return a === b;\n  }\n\n  // Check types\n  const aType = typeof a;\n  const bType = typeof b;\n  if (aType !== bType) return false;\n\n  // If they are both objects or arrays, handle recursively\n  if (aType === 'object') {\n    // Optionally handle cyclical references\n    if (!visited) visited = new Set();\n    const pairId = getPairId(a, b);\n    if (visited.has(pairId)) {\n      // Already compared these two objects => assume true to avoid infinite recursion\n      // or return false if you want to treat cycles as inequality\n      return true;\n    }\n    visited.add(pairId);\n\n    const aIsArray = Array.isArray(a);\n    const bIsArray = Array.isArray(b);\n    if (aIsArray && bIsArray) {\n      // Compare as arrays ignoring order\n      return arraysEqualUnordered(a, b, visited);\n    } else if (!aIsArray && !bIsArray) {\n      // Compare as plain objects (order of properties doesn't matter)\n      return objectsEqual(a, b, visited);\n    } else {\n      // One is array, the other is object => not equal\n      return false;\n    }\n  }\n\n  // If both are function, symbol, etc. - typically we might say false\n  // But you can decide your own logic for function or symbol equality\n  return false;\n}\n\nfunction getPairId(a: any, b: any) {\n  // Could do something more advanced. This is a cheap approach:\n  // e.g. use the memory reference or an object identity approach\n  return `${objectId(a)}__${objectId(b)}`;\n}\n\n/**\n * If you want stable object IDs, you'd need a WeakMap to store them.\n * This simplistic approach just calls toString on the object.\n */\nlet objectIdCounter = 0;\nconst objectIds = new WeakMap<object, number>();\n\nfunction objectId(obj: object): number {\n  if (!objectIds.has(obj)) {\n    objectIds.set(obj, ++objectIdCounter);\n  }\n  return objectIds.get(obj)!;\n}\n\nfunction arraysEqualUnordered(a: any[], b: any[], visited?: Set<any>): boolean {\n  if (a.length !== b.length) return false;\n\n  const used = new Array<boolean>(b.length).fill(false);\n\n  // For each element in a, find an unused matching element in b\n  outer: for (let i = 0; i < a.length; i++) {\n    const elemA = a[i];\n    for (let j = 0; j < b.length; j++) {\n      if (used[j]) continue; // already used that slot\n      if (arePropsEqual(elemA, b[j], visited)) {\n        used[j] = true;\n        continue outer; // found match for a[i], proceed\n      }\n    }\n    // If we never found a match\n    return false;\n  }\n\n  return true;\n}\n\nfunction objectsEqual(a: object, b: object, visited?: Set<any>): boolean {\n  // Get all prop keys\n  const aKeys = Object.keys(a).sort();\n  const bKeys = Object.keys(b).sort();\n  if (aKeys.length !== bKeys.length) return false;\n\n  // Compare each property name\n  for (let i = 0; i < aKeys.length; i++) {\n    if (aKeys[i] !== bKeys[i]) return false;\n  }\n\n  // Compare each property value\n  for (const key of aKeys) {\n    // @ts-ignore\n    const valA = a[key];\n    // @ts-ignore\n    const valB = b[key];\n    if (!arePropsEqual(valA, valB, visited)) {\n      return false;\n    }\n  }\n  return true;\n}\n","import { createContext } from 'preact';\nimport type { PluginRegistry } from '@embedpdf/core';\n\nexport interface PDFContextState {\n  registry: PluginRegistry | null;\n  isInitializing: boolean;\n  pluginsReady: boolean;\n}\n\nexport const PDFContext = createContext<PDFContextState>({\n  registry: null,\n  isInitializing: true,\n  pluginsReady: false,\n});\n","/** @jsxImportSource preact */\nimport { h, ComponentChildren } from 'preact';\nimport { useState, useEffect, useRef } from 'preact/hooks';\nimport { PdfEngine } from '@embedpdf/models';\nimport { PluginRegistry } from '@embedpdf/core';\nimport type { IPlugin, PluginBatchRegistration } from '@embedpdf/core';\n\nimport { PDFContext, PDFContextState } from '../context';\n\ninterface EmbedPDFProps {\n  engine: PdfEngine;\n  onInitialized?: (registry: PluginRegistry) => Promise<void>;\n  plugins: PluginBatchRegistration<IPlugin<any>, any>[];\n  children: ComponentChildren | ((state: PDFContextState) => ComponentChildren);\n}\n\nexport function EmbedPDF({ engine, onInitialized, plugins, children }: EmbedPDFProps) {\n  const [registry, setRegistry] = useState<PluginRegistry | null>(null);\n  const [isInitializing, setIsInitializing] = useState<boolean>(true);\n  const [pluginsReady, setPluginsReady] = useState<boolean>(false);\n  const initRef = useRef<EmbedPDFProps['onInitialized']>(onInitialized);\n\n  useEffect(() => {\n    initRef.current = onInitialized; // update without triggering re-runs\n  }, [onInitialized]);\n\n  useEffect(() => {\n    const pdfViewer = new PluginRegistry(engine);\n    pdfViewer.registerPluginBatch(plugins);\n\n    const initialize = async () => {\n      await pdfViewer.initialize();\n      // if the registry is destroyed, don't do anything\n      if (pdfViewer.isDestroyed()) {\n        return;\n      }\n      await initRef.current?.(pdfViewer);\n      // if the registry is destroyed, don't do anything\n      if (pdfViewer.isDestroyed()) {\n        return;\n      }\n\n      pdfViewer.pluginsReady().then(() => {\n        if (!pdfViewer.isDestroyed()) {\n          setPluginsReady(true);\n        }\n      });\n\n      // Provide the registry to children via context\n      setRegistry(pdfViewer);\n      setIsInitializing(false);\n    };\n\n    initialize().catch(console.error);\n\n    return () => {\n      pdfViewer.destroy();\n      setRegistry(null);\n      setIsInitializing(true);\n      setPluginsReady(false);\n    };\n  }, [engine, plugins]);\n\n  return (\n    <PDFContext.Provider value={{ registry, isInitializing, pluginsReady }}>\n      {typeof children === 'function'\n        ? children({ registry, isInitializing, pluginsReady })\n        : children}\n    </PDFContext.Provider>\n  );\n}\n","import { useContext } from 'preact/hooks';\nimport { PDFContext, PDFContextState } from '../context';\n\n/**\n * Hook to access the PDF registry.\n * @returns The PDF registry or null during initialization\n */\nexport function useRegistry(): PDFContextState {\n  const contextValue = useContext(PDFContext);\n\n  // Error if used outside of context\n  if (contextValue === undefined) {\n    throw new Error('useCapability must be used within a PDFContext.Provider');\n  }\n\n  const { registry, isInitializing } = contextValue;\n\n  // During initialization, return null instead of throwing an error\n  if (isInitializing) {\n    return contextValue;\n  }\n\n  // At this point, initialization is complete but registry is still null, which is unexpected\n  if (registry === null) {\n    throw new Error('PDF registry failed to initialize properly');\n  }\n\n  return contextValue;\n}\n","import type { BasePlugin } from '@embedpdf/core';\nimport { useRegistry } from './use-registry';\n\ntype PluginState<T extends BasePlugin> = {\n  plugin: T | null;\n  isLoading: boolean;\n  ready: Promise<void>;\n};\n\n/**\n * Hook to access a plugin.\n * @param pluginId The ID of the plugin to access\n * @returns The plugin or null during initialization\n * @example\n * // Get zoom plugin\n * const zoom = usePlugin<ZoomPlugin>(ZoomPlugin.id);\n */\nexport function usePlugin<T extends BasePlugin>(pluginId: T['id']): PluginState<T> {\n  const { registry } = useRegistry();\n\n  if (registry === null) {\n    return {\n      plugin: null,\n      isLoading: true,\n      ready: new Promise(() => {}),\n    };\n  }\n\n  const plugin = registry.getPlugin<T>(pluginId);\n\n  if (!plugin) {\n    throw new Error(`Plugin ${pluginId} not found`);\n  }\n\n  return {\n    plugin,\n    isLoading: false,\n    ready: plugin.ready(),\n  };\n}\n","import type { BasePlugin } from '@embedpdf/core';\nimport { usePlugin } from './use-plugin';\n\ntype CapabilityState<T extends BasePlugin> = {\n  provides: ReturnType<NonNullable<T['provides']>> | null;\n  isLoading: boolean;\n  ready: Promise<void>;\n};\n\n/**\n * Hook to access a plugin's capability.\n * @param pluginId The ID of the plugin to access\n * @returns The capability provided by the plugin or null during initialization\n * @example\n * // Get zoom capability\n * const zoom = useCapability<ZoomPlugin>(ZoomPlugin.id);\n */\nexport function useCapability<T extends BasePlugin>(pluginId: T['id']): CapabilityState<T> {\n  const { plugin, isLoading, ready } = usePlugin<T>(pluginId);\n\n  if (!plugin) {\n    return {\n      provides: null,\n      isLoading,\n      ready,\n    };\n  }\n\n  if (!plugin.provides) {\n    throw new Error(`Plugin ${pluginId} does not provide a capability`);\n  }\n\n  return {\n    provides: plugin.provides() as ReturnType<NonNullable<T['provides']>>,\n    isLoading,\n    ready,\n  };\n}\n","import { useState, useEffect } from 'preact/hooks';\nimport { CoreState, StoreState } from '@embedpdf/core';\nimport { useRegistry } from './use-registry';\n\n/**\n * Hook that provides access to the current global store state\n * and re-renders the component when the state changes\n */\nexport function useStoreState<T = CoreState>(): StoreState<T> | null {\n  const { registry } = useRegistry();\n  const [state, setState] = useState<StoreState<T> | null>(null);\n\n  useEffect(() => {\n    if (!registry) return;\n\n    // Get initial state\n    setState(registry.getStore().getState() as StoreState<T>);\n\n    // Subscribe to store changes\n    const unsubscribe = registry.getStore().subscribe((_action, newState) => {\n      setState(newState as StoreState<T>);\n    });\n\n    return () => unsubscribe();\n  }, [registry]);\n\n  return state;\n}\n","import { useState, useEffect } from 'preact/hooks';\nimport { CoreState, arePropsEqual } from '@embedpdf/core';\nimport { useRegistry } from './use-registry';\n\n/**\n * Hook that provides access to the current core state\n * and re-renders the component only when the core state changes\n */\nexport function useCoreState(): CoreState | null {\n  const { registry } = useRegistry();\n  const [coreState, setCoreState] = useState<CoreState | null>(null);\n\n  useEffect(() => {\n    if (!registry) return;\n\n    const store = registry.getStore();\n\n    // Get initial core state\n    setCoreState(store.getState().core);\n\n    // Create a single subscription that handles all core actions\n    const unsubscribe = store.subscribe((action, newState, oldState) => {\n      // Only update if it's a core action and the core state changed\n      if (store.isCoreAction(action) && !arePropsEqual(newState.core, oldState.core)) {\n        setCoreState(newState.core);\n      }\n    });\n\n    return () => unsubscribe();\n  }, [registry]);\n\n  return coreState;\n}\n","import { PluginManifest } from '@embedpdf/core';\nimport { AnnotationPluginConfig } from './types';\n\nexport const ANNOTATION_PLUGIN_ID = 'annotation';\n\nexport const manifest: PluginManifest<AnnotationPluginConfig> = {\n  id: ANNOTATION_PLUGIN_ID,\n  name: 'Annotation Plugin',\n  version: '1.0.0',\n  provides: ['annotation'],\n  requires: ['interaction-manager', 'selection'],\n  optional: ['history'],\n  defaultConfig: {\n    enabled: true,\n    autoCommit: true,\n  },\n};\n","export class DependencyResolver {\n  private dependencyGraph = new Map<string, Set<string>>();\n\n  addNode(id: string, dependencies: string[] = []) {\n    this.dependencyGraph.set(id, new Set(dependencies));\n  }\n\n  private hasCircularDependencies(): boolean {\n    const visited = new Set<string>();\n    const recursionStack = new Set<string>();\n\n    const dfs = (id: string): boolean => {\n      visited.add(id);\n      recursionStack.add(id);\n\n      const dependencies = this.dependencyGraph.get(id) || new Set();\n      for (const dep of dependencies) {\n        if (!visited.has(dep)) {\n          if (dfs(dep)) return true;\n        } else if (recursionStack.has(dep)) {\n          return true; // Circular dependency found\n        }\n      }\n\n      recursionStack.delete(id);\n      return false;\n    };\n\n    for (const id of this.dependencyGraph.keys()) {\n      if (!visited.has(id)) {\n        if (dfs(id)) return true;\n      }\n    }\n\n    return false;\n  }\n\n  resolveLoadOrder(): string[] {\n    if (this.hasCircularDependencies()) {\n      throw new Error('Circular dependencies detected');\n    }\n\n    const result: string[] = [];\n    const visited = new Set<string>();\n    const temp = new Set<string>();\n\n    const visit = (id: string) => {\n      if (temp.has(id)) throw new Error('Circular dependency');\n      if (visited.has(id)) return;\n\n      temp.add(id);\n\n      const dependencies = this.dependencyGraph.get(id) || new Set();\n      for (const dep of dependencies) {\n        visit(dep);\n      }\n\n      temp.delete(id);\n      visited.add(id);\n      result.push(id);\n    };\n\n    for (const id of this.dependencyGraph.keys()) {\n      if (!visited.has(id)) {\n        visit(id);\n      }\n    }\n\n    return result;\n  }\n}\n","export class PluginRegistrationError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'PluginRegistrationError';\n  }\n}\n\nexport class PluginNotFoundError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'PluginNotFoundError';\n  }\n}\n\nexport class CircularDependencyError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'CircularDependencyError';\n  }\n}\n\nexport class CapabilityNotFoundError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'CapabilityNotFoundError';\n  }\n}\n\n// You might also want to add:\nexport class CapabilityConflictError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'CapabilityConflictError';\n  }\n}\n\nexport class PluginInitializationError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'PluginInitializationError';\n  }\n}\n\nexport class PluginConfigurationError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'PluginConfigurationError';\n  }\n}\n","import { Store } from './store';\nimport { Action } from './types';\n\n/**\n * A type-safe store handle for plugins, providing access to plugin-specific state and actions.\n */\nexport class PluginStore<PluginState, PluginAction extends Action> {\n  private store: Store<any, any>;\n  private pluginId: string;\n\n  /**\n   * Initializes the PluginStore with the main store and plugin ID.\n   * @param store The main store instance.\n   * @param pluginId The unique identifier for the plugin.\n   */\n  constructor(store: Store<any, any>, pluginId: string) {\n    this.store = store;\n    this.pluginId = pluginId;\n  }\n\n  /**\n   * Gets the current state of the plugin.\n   * @returns The plugin's state.\n   */\n  getState(): PluginState {\n    return this.store.getState().plugins[this.pluginId] as PluginState;\n  }\n\n  /**\n   * Dispatches an action for the plugin and returns the *new* global state.\n   * If you only need the plugin’s updated state, call `getState()` afterward.\n   * @param action The action to dispatch.\n   * @returns The updated global store state (after plugin reducer).\n   */\n  dispatch(action: PluginAction): PluginState {\n    return this.store.dispatchToPlugin(this.pluginId, action);\n  }\n\n  /**\n   * Subscribes to state changes only for this specific plugin.\n   * You now receive (action, newPluginState, oldPluginState) in the callback.\n   *\n   * @param listener The callback to invoke when plugin state changes.\n   * @returns A function to unsubscribe the listener.\n   */\n  subscribeToState(\n    listener: (action: PluginAction, newState: PluginState, oldState: PluginState) => void,\n  ) {\n    return this.store.subscribeToPlugin(this.pluginId, (action, newPluginState, oldPluginState) => {\n      listener(\n        action as PluginAction,\n        newPluginState as PluginState,\n        oldPluginState as PluginState,\n      );\n    });\n  }\n\n  /**\n   * Subscribes to a specific action type for the plugin.\n   * This still uses the main store's `onAction`, so you get the *global*\n   * old/new store states there. If you specifically want old/new plugin state,\n   * use `subscribeToState` instead.\n   *\n   * @param type The action type to listen for.\n   * @param handler The callback to invoke when the action occurs.\n   * @returns A function to unsubscribe the handler.\n   */\n  onAction<T extends PluginAction['type']>(\n    type: T,\n    handler: (\n      action: Extract<PluginAction, { type: T }>,\n      state: PluginState,\n      oldState: PluginState,\n    ) => void,\n  ) {\n    return this.store.onAction(type, (action, state, oldState) => {\n      handler(\n        action as Extract<PluginAction, { type: T }>,\n        state.plugins[this.pluginId] as PluginState,\n        oldState.plugins[this.pluginId] as PluginState,\n      );\n    });\n  }\n}\n","import { PdfDocumentObject, PdfPageObject, Rotation } from '@embedpdf/models';\n\nexport const LOAD_DOCUMENT = 'LOAD_DOCUMENT';\nexport const SET_DOCUMENT = 'SET_DOCUMENT';\nexport const SET_DOCUMENT_ERROR = 'SET_DOCUMENT_ERROR';\nexport const SET_SCALE = 'SET_SCALE';\nexport const SET_ROTATION = 'SET_ROTATION';\nexport const SET_PAGES = 'SET_PAGES';\n\nexport const CORE_ACTION_TYPES = [\n  LOAD_DOCUMENT,\n  SET_DOCUMENT,\n  SET_DOCUMENT_ERROR,\n  SET_SCALE,\n  SET_ROTATION,\n  SET_PAGES,\n] as const;\n\n// Action Type Interfaces\nexport interface LoadDocumentAction {\n  type: typeof LOAD_DOCUMENT;\n}\n\nexport interface SetDocumentAction {\n  type: typeof SET_DOCUMENT;\n  payload: PdfDocumentObject;\n}\n\nexport interface SetDocumentErrorAction {\n  type: typeof SET_DOCUMENT_ERROR;\n  payload: string;\n}\n\nexport interface SetScaleAction {\n  type: typeof SET_SCALE;\n  payload: number;\n}\n\nexport interface SetRotationAction {\n  type: typeof SET_ROTATION;\n  payload: Rotation;\n}\n\nexport interface SetPagesAction {\n  type: typeof SET_PAGES;\n  payload: PdfPageObject[][];\n}\n\nexport type DocumentAction =\n  | LoadDocumentAction\n  | SetDocumentAction\n  | SetDocumentErrorAction\n  | SetScaleAction\n  | SetRotationAction\n  | SetPagesAction;\n\n// Core actions\nexport type CoreAction = DocumentAction;\n\nexport const loadDocument = (): CoreAction => ({ type: LOAD_DOCUMENT });\nexport const setDocument = (document: PdfDocumentObject): CoreAction => ({\n  type: SET_DOCUMENT,\n  payload: document,\n});\nexport const setDocumentError = (error: string): CoreAction => ({\n  type: SET_DOCUMENT_ERROR,\n  payload: error,\n});\nexport const setScale = (scale: number): CoreAction => ({ type: SET_SCALE, payload: scale });\nexport const setRotation = (rotation: Rotation): CoreAction => ({\n  type: SET_ROTATION,\n  payload: rotation,\n});\nexport const setPages = (pages: PdfPageObject[][]): CoreAction => ({\n  type: SET_PAGES,\n  payload: pages,\n});\n","import { Reducer, Action, StoreState, StoreListener, PluginListener } from './types';\nimport { PluginStore } from './plugin-store';\nimport { CORE_ACTION_TYPES } from './actions';\n\n/**\n * A generic, type-safe store class managing core and plugin states, reducers, and subscriptions.\n * @template CoreState The type of the core state.\n * @template CoreAction The type of actions handled by core reducers (extends Action).\n */\nexport class Store<CoreState, CoreAction extends Action = Action> {\n  private state: StoreState<CoreState>;\n  private coreReducer: Reducer<CoreState, CoreAction>;\n  private pluginReducers: Record<string, Reducer<any, Action>> = {};\n\n  private listeners: StoreListener<CoreState>[] = [];\n  private pluginListeners: Record<string, PluginListener[]> = {};\n\n  /**\n   * Initializes the store with the provided core state.\n   * @param reducer          The core reducer function\n   * @param initialCoreState The initial core state\n   */\n  constructor(\n    reducer: Reducer<CoreState, CoreAction>,\n    public initialCoreState: CoreState,\n  ) {\n    this.state = { core: initialCoreState, plugins: {} };\n    this.coreReducer = reducer;\n  }\n\n  /**\n   * Adds a reducer for a plugin-specific state.\n   * @param pluginId The unique identifier for the plugin.\n   * @param reducer The reducer function for the plugin state.\n   * @param initialState The initial state for the plugin.\n   */\n  addPluginReducer<PluginState>(\n    pluginId: string,\n    reducer: Reducer<PluginState, Action>,\n    initialState: PluginState,\n  ) {\n    this.state.plugins[pluginId] = initialState;\n    this.pluginReducers[pluginId] = reducer;\n  }\n\n  /**\n   * Dispatches an action *only* to the core reducer.\n   * Notifies the global store listeners with (action, newState, oldState).\n   *\n   * @param action The action to dispatch, typed as CoreAction\n   * @returns The updated *global* store state\n   */\n  dispatchToCore(action: CoreAction): StoreState<CoreState> {\n    if (!this.coreReducer) {\n      return this.getState();\n    }\n\n    const oldState = this.getState();\n    // Update core state via its reducer\n    this.state.core = this.coreReducer(this.state.core, action);\n\n    const newState = this.getState();\n    // Notify all main-store subscribers\n    this.listeners.forEach((listener) => listener(action, newState, oldState));\n\n    return newState;\n  }\n\n  /**\n   * Dispatches an action *only* to a specific plugin.\n   * Optionally notifies global store listeners if `notifyGlobal` is true.\n   * Always notifies plugin-specific listeners with (action, newPluginState, oldPluginState).\n   *\n   * @param pluginId   The plugin identifier\n   * @param action     The plugin action to dispatch\n   * @param notifyGlobal Whether to also notify global store listeners\n   * @returns The updated *global* store state\n   */\n  dispatchToPlugin<PluginAction extends Action>(\n    pluginId: string,\n    action: PluginAction,\n    notifyGlobal: boolean = true,\n  ): any {\n    const oldGlobalState = this.getState();\n\n    const reducer = this.pluginReducers[pluginId];\n    if (!reducer) {\n      // No plugin found, just return the old state\n      return oldGlobalState;\n    }\n\n    // Grab the old plugin state\n    const oldPluginState = oldGlobalState.plugins[pluginId];\n    // Reduce to new plugin state\n    const newPluginState = reducer(oldPluginState, action);\n    // Update the store's plugin slice\n    this.state.plugins[pluginId] = newPluginState;\n\n    const newGlobalState = this.getState();\n\n    // If we are notifying the main store subscribers about plugin changes\n    if (notifyGlobal) {\n      this.listeners.forEach((listener) => listener(action, newGlobalState, oldGlobalState));\n    }\n\n    // Notify plugin-specific listeners\n    if (this.pluginListeners[pluginId]) {\n      this.pluginListeners[pluginId].forEach((listener) => {\n        listener(action, newPluginState, oldPluginState);\n      });\n    }\n\n    return newPluginState;\n  }\n\n  /**\n   * Dispatches an action to update the state using:\n   * - the core reducer (if it's a CoreAction)\n   * - *all* plugin reducers (regardless of action type), with no global notify for each plugin\n   *\n   * Returns the new *global* store state after all reducers have processed the action.\n   *\n   * @param action The action to dispatch (can be CoreAction or any Action).\n   */\n  dispatch(action: CoreAction | Action): StoreState<CoreState> {\n    // Keep old state to notify global listeners *once*, after all reducers run.\n    const oldState = this.getState();\n    // 1) Apply core reducer (only if action is a CoreAction)\n    if (this.isCoreAction(action)) {\n      this.state.core = this.coreReducer(this.state.core, action);\n    }\n\n    // 2) Apply plugin reducers (without globally notifying after each plugin)\n    for (const pluginId in this.pluginReducers) {\n      const reducer = this.pluginReducers[pluginId];\n      const oldPluginState = oldState.plugins[pluginId];\n      if (reducer) {\n        this.state.plugins[pluginId] = reducer(oldPluginState, action);\n      }\n      // We do *not* notify global listeners or plugin listeners here,\n      // as that might be undesired \"fan-out\". If you want per-plugin subscription\n      // triggered on every dispatch, you can do so here, but that’s up to you.\n    }\n\n    // 3) Notify global listeners *once* with the final new state\n    const newState = this.getState();\n    this.listeners.forEach((listener) => listener(action, newState, oldState));\n\n    // 4) Return the new global store state\n    return newState;\n  }\n\n  /**\n   * Returns a shallow copy of the current state.\n   * @returns The current store state.\n   */\n  getState(): StoreState<CoreState> {\n    return {\n      core: { ...this.state.core },\n      plugins: { ...this.state.plugins },\n    };\n  }\n\n  /**\n   * Subscribes a listener to *global* state changes.\n   * The callback signature is now (action, newState, oldState).\n   *\n   * @param listener The callback to invoke on state changes\n   * @returns A function to unsubscribe the listener\n   */\n  subscribe(listener: StoreListener<CoreState>) {\n    this.listeners.push(listener);\n    return () => {\n      this.listeners = this.listeners.filter((l) => l !== listener);\n    };\n  }\n\n  /**\n   * Subscribes a listener to *plugin-specific* state changes.\n   * The callback signature is now (action, newPluginState, oldPluginState).\n   *\n   * @param pluginId The unique identifier for the plugin.\n   * @param listener The callback to invoke on plugin state changes.\n   * @returns A function to unsubscribe the listener.\n   */\n  subscribeToPlugin(pluginId: string, listener: PluginListener) {\n    if (!(pluginId in this.state.plugins)) {\n      throw new Error(\n        `Plugin state not found for plugin \"${pluginId}\". Did you forget to call addPluginReducer?`,\n      );\n    }\n\n    if (!this.pluginListeners[pluginId]) {\n      this.pluginListeners[pluginId] = [];\n    }\n    this.pluginListeners[pluginId].push(listener);\n\n    return () => {\n      this.pluginListeners[pluginId] = this.pluginListeners[pluginId].filter((l) => l !== listener);\n      if (this.pluginListeners[pluginId].length === 0) {\n        delete this.pluginListeners[pluginId];\n      }\n    };\n  }\n\n  /**\n   * Subscribes to a specific action type (only from the core's action union).\n   * The callback signature is (action, newState, oldState).\n   *\n   * @param type The action type to listen for.\n   * @param handler The callback to invoke when the action occurs.\n   * @returns A function to unsubscribe the handler.\n   */\n  onAction<T extends CoreAction['type']>(\n    type: T,\n    handler: (\n      action: Extract<CoreAction, { type: T }>,\n      state: StoreState<CoreState>,\n      oldState: StoreState<CoreState>,\n    ) => void,\n  ) {\n    return this.subscribe((action, newState, oldState) => {\n      if (action.type === type) {\n        handler(action as Extract<CoreAction, { type: T }>, newState, oldState);\n      }\n    });\n  }\n\n  /**\n   * Gets a PluginStore handle for a specific plugin.\n   * @param pluginId The unique identifier for the plugin.\n   * @returns A PluginStore instance for the plugin.\n   */\n  getPluginStore<PluginState, PluginAction extends Action>(\n    pluginId: string,\n  ): PluginStore<PluginState, PluginAction> {\n    if (!(pluginId in this.state.plugins)) {\n      throw new Error(\n        `Plugin state not found for plugin \"${pluginId}\". Did you forget to call addPluginReducer?`,\n      );\n    }\n    return new PluginStore<PluginState, PluginAction>(this, pluginId);\n  }\n\n  /**\n   * Helper method to check if an action is a CoreAction.\n   * Adjust if you have a more refined way to differentiate CoreAction vs. any other Action.\n   */\n  public isCoreAction(action: Action): action is CoreAction {\n    // In many codebases you'd do something more robust here\n    // or rely on TypeScript's narrowing logic if possible.\n    return CORE_ACTION_TYPES.includes(action.type as (typeof CORE_ACTION_TYPES)[number]);\n  }\n\n  /**\n   * Destroy the store: drop every listener and plugin reducer\n   */\n  public destroy(): void {\n    // 1. empty listener collections\n    this.listeners.length = 0;\n    for (const id in this.pluginListeners) {\n      this.pluginListeners[id]?.splice?.(0);\n    }\n    this.pluginListeners = {};\n\n    // 2. wipe plugin reducers and states\n    this.pluginReducers = {};\n    this.state.plugins = {};\n\n    // 3. reset core state to initial\n    this.state.core = { ...this.initialCoreState };\n  }\n}\n","// src/geometry.ts\nvar Rotation = /* @__PURE__ */ ((Rotation2) => {\n  Rotation2[Rotation2[\"Degree0\"] = 0] = \"Degree0\";\n  Rotation2[Rotation2[\"Degree90\"] = 1] = \"Degree90\";\n  Rotation2[Rotation2[\"Degree180\"] = 2] = \"Degree180\";\n  Rotation2[Rotation2[\"Degree270\"] = 3] = \"Degree270\";\n  return Rotation2;\n})(Rotation || {});\nfunction toIntPos(p) {\n  return { x: Math.floor(p.x), y: Math.floor(p.y) };\n}\nfunction toIntSize(s) {\n  return { width: Math.ceil(s.width), height: Math.ceil(s.height) };\n}\nfunction toIntRect(r) {\n  return {\n    origin: toIntPos(r.origin),\n    size: toIntSize(r.size)\n  };\n}\nfunction calculateDegree(rotation) {\n  switch (rotation) {\n    case 0 /* Degree0 */:\n      return 0;\n    case 1 /* Degree90 */:\n      return 90;\n    case 2 /* Degree180 */:\n      return 180;\n    case 3 /* Degree270 */:\n      return 270;\n  }\n}\nfunction calculateAngle(rotation) {\n  return calculateDegree(rotation) * Math.PI / 180;\n}\nfunction swap(size) {\n  const { width, height } = size;\n  return {\n    width: height,\n    height: width\n  };\n}\nfunction transformSize(size, rotation, scaleFactor) {\n  size = rotation % 2 === 0 ? size : swap(size);\n  return {\n    width: size.width * scaleFactor,\n    height: size.height * scaleFactor\n  };\n}\nfunction quadToRect(q) {\n  const xs = [q.p1.x, q.p2.x, q.p3.x, q.p4.x];\n  const ys = [q.p1.y, q.p2.y, q.p3.y, q.p4.y];\n  return {\n    origin: { x: Math.min(...xs), y: Math.min(...ys) },\n    size: {\n      width: Math.max(...xs) - Math.min(...xs),\n      height: Math.max(...ys) - Math.min(...ys)\n    }\n  };\n}\nfunction rectToQuad(r) {\n  return {\n    p1: { x: r.origin.x, y: r.origin.y },\n    p2: { x: r.origin.x + r.size.width, y: r.origin.y },\n    p3: { x: r.origin.x + r.size.width, y: r.origin.y + r.size.height },\n    p4: { x: r.origin.x, y: r.origin.y + r.size.height }\n  };\n}\nfunction rotatePosition(containerSize, position, rotation) {\n  let x = position.x;\n  let y = position.y;\n  switch (rotation) {\n    case 0 /* Degree0 */:\n      x = position.x;\n      y = position.y;\n      break;\n    case 1 /* Degree90 */:\n      x = containerSize.height - position.y;\n      y = position.x;\n      break;\n    case 2 /* Degree180 */:\n      x = containerSize.width - position.x;\n      y = containerSize.height - position.y;\n      break;\n    case 3 /* Degree270 */:\n      x = position.y;\n      y = containerSize.width - position.x;\n      break;\n  }\n  return {\n    x,\n    y\n  };\n}\nfunction scalePosition(position, scaleFactor) {\n  return {\n    x: position.x * scaleFactor,\n    y: position.y * scaleFactor\n  };\n}\nfunction transformPosition(containerSize, position, rotation, scaleFactor) {\n  return scalePosition(rotatePosition(containerSize, position, rotation), scaleFactor);\n}\nfunction restorePosition(containerSize, position, rotation, scaleFactor) {\n  return scalePosition(\n    rotatePosition(containerSize, position, (4 - rotation) % 4),\n    1 / scaleFactor\n  );\n}\nfunction rotateRect(containerSize, rect, rotation) {\n  let x = rect.origin.x;\n  let y = rect.origin.y;\n  let size = rect.size;\n  switch (rotation) {\n    case 0 /* Degree0 */:\n      break;\n    case 1 /* Degree90 */:\n      x = containerSize.height - rect.origin.y - rect.size.height;\n      y = rect.origin.x;\n      size = swap(rect.size);\n      break;\n    case 2 /* Degree180 */:\n      x = containerSize.width - rect.origin.x - rect.size.width;\n      y = containerSize.height - rect.origin.y - rect.size.height;\n      break;\n    case 3 /* Degree270 */:\n      x = rect.origin.y;\n      y = containerSize.width - rect.origin.x - rect.size.width;\n      size = swap(rect.size);\n      break;\n  }\n  return {\n    origin: {\n      x,\n      y\n    },\n    size: {\n      width: size.width,\n      height: size.height\n    }\n  };\n}\nfunction scaleRect(rect, scaleFactor) {\n  return {\n    origin: {\n      x: rect.origin.x * scaleFactor,\n      y: rect.origin.y * scaleFactor\n    },\n    size: {\n      width: rect.size.width * scaleFactor,\n      height: rect.size.height * scaleFactor\n    }\n  };\n}\nfunction transformRect(containerSize, rect, rotation, scaleFactor) {\n  return scaleRect(rotateRect(containerSize, rect, rotation), scaleFactor);\n}\nfunction restoreRect(containerSize, rect, rotation, scaleFactor) {\n  return scaleRect(rotateRect(containerSize, rect, (4 - rotation) % 4), 1 / scaleFactor);\n}\nfunction restoreOffset(offset, rotation, scaleFactor) {\n  let offsetX = offset.x;\n  let offsetY = offset.y;\n  switch (rotation) {\n    case 0 /* Degree0 */:\n      offsetX = offset.x / scaleFactor;\n      offsetY = offset.y / scaleFactor;\n      break;\n    case 1 /* Degree90 */:\n      offsetX = offset.y / scaleFactor;\n      offsetY = -offset.x / scaleFactor;\n      break;\n    case 2 /* Degree180 */:\n      offsetX = -offset.x / scaleFactor;\n      offsetY = -offset.y / scaleFactor;\n      break;\n    case 3 /* Degree270 */:\n      offsetX = -offset.y / scaleFactor;\n      offsetY = offset.x / scaleFactor;\n      break;\n  }\n  return {\n    x: offsetX,\n    y: offsetY\n  };\n}\nfunction boundingRect(rects) {\n  if (rects.length === 0) return null;\n  let minX = rects[0].origin.x, minY = rects[0].origin.y, maxX = rects[0].origin.x + rects[0].size.width, maxY = rects[0].origin.y + rects[0].size.height;\n  for (const r of rects) {\n    minX = Math.min(minX, r.origin.x);\n    minY = Math.min(minY, r.origin.y);\n    maxX = Math.max(maxX, r.origin.x + r.size.width);\n    maxY = Math.max(maxY, r.origin.y + r.size.height);\n  }\n  return {\n    origin: {\n      x: minX,\n      y: minY\n    },\n    size: {\n      width: maxX - minX,\n      height: maxY - minY\n    }\n  };\n}\nvar makeMatrix = (rectangle, rotation, scaleFactor) => {\n  const { width, height } = rectangle.size;\n  switch (rotation) {\n    case 0 /* Degree0 */:\n      return {\n        a: scaleFactor,\n        b: 0,\n        c: 0,\n        d: -scaleFactor,\n        e: 0,\n        f: height * scaleFactor\n      };\n    case 1 /* Degree90 */:\n      return {\n        a: 0,\n        b: scaleFactor,\n        c: scaleFactor,\n        d: 0,\n        e: 0,\n        f: 0\n      };\n    case 2 /* Degree180 */:\n      return {\n        a: -scaleFactor,\n        b: 0,\n        c: 0,\n        d: scaleFactor,\n        e: width * scaleFactor,\n        f: 0\n      };\n    case 3 /* Degree270 */:\n      return {\n        a: 0,\n        b: -scaleFactor,\n        c: -scaleFactor,\n        d: 0,\n        e: height * scaleFactor,\n        f: width * scaleFactor\n      };\n  }\n};\n\n// src/logger.ts\nvar NoopLogger = class {\n  /** {@inheritDoc Logger.debug} */\n  debug() {\n  }\n  /** {@inheritDoc Logger.info} */\n  info() {\n  }\n  /** {@inheritDoc Logger.warn} */\n  warn() {\n  }\n  /** {@inheritDoc Logger.error} */\n  error() {\n  }\n  /** {@inheritDoc Logger.perf} */\n  perf() {\n  }\n};\nvar ConsoleLogger = class {\n  /** {@inheritDoc Logger.debug} */\n  debug(source, category, ...args) {\n    console.debug(`${source}.${category}`, ...args);\n  }\n  /** {@inheritDoc Logger.info} */\n  info(source, category, ...args) {\n    console.info(`${source}.${category}`, ...args);\n  }\n  /** {@inheritDoc Logger.warn} */\n  warn(source, category, ...args) {\n    console.warn(`${source}.${category}`, ...args);\n  }\n  /** {@inheritDoc Logger.error} */\n  error(source, category, ...args) {\n    console.error(`${source}.${category}`, ...args);\n  }\n  /** {@inheritDoc Logger.perf} */\n  perf(source, category, event, phase, ...args) {\n    console.info(`${source}.${category}.${event}.${phase}`, ...args);\n  }\n};\nvar LogLevel = /* @__PURE__ */ ((LogLevel2) => {\n  LogLevel2[LogLevel2[\"Debug\"] = 0] = \"Debug\";\n  LogLevel2[LogLevel2[\"Info\"] = 1] = \"Info\";\n  LogLevel2[LogLevel2[\"Warn\"] = 2] = \"Warn\";\n  LogLevel2[LogLevel2[\"Error\"] = 3] = \"Error\";\n  return LogLevel2;\n})(LogLevel || {});\nvar LevelLogger = class {\n  /**\n   * create new LevelLogger\n   * @param logger - the original logger\n   * @param level - log level that used for filtering, all logs lower than this level will be filtered out\n   */\n  constructor(logger, level) {\n    this.logger = logger;\n    this.level = level;\n  }\n  /** {@inheritDoc Logger.debug} */\n  debug(source, category, ...args) {\n    if (this.level <= 0 /* Debug */) {\n      this.logger.debug(source, category, ...args);\n    }\n  }\n  /** {@inheritDoc Logger.info} */\n  info(source, category, ...args) {\n    if (this.level <= 1 /* Info */) {\n      this.logger.info(source, category, ...args);\n    }\n  }\n  /** {@inheritDoc Logger.warn} */\n  warn(source, category, ...args) {\n    if (this.level <= 2 /* Warn */) {\n      this.logger.warn(source, category, ...args);\n    }\n  }\n  /** {@inheritDoc Logger.error} */\n  error(source, category, ...args) {\n    if (this.level <= 3 /* Error */) {\n      this.logger.error(source, category, ...args);\n    }\n  }\n  /** {@inheritDoc Logger.perf} */\n  perf(source, category, event, phase, ...args) {\n    this.logger.perf(source, category, event, phase, ...args);\n  }\n};\nvar PerfLogger = class {\n  /**\n   * create new PerfLogger\n   */\n  constructor() {\n  }\n  /** {@inheritDoc Logger.debug} */\n  debug(source, category, ...args) {\n  }\n  /** {@inheritDoc Logger.info} */\n  info(source, category, ...args) {\n  }\n  /** {@inheritDoc Logger.warn} */\n  warn(source, category, ...args) {\n  }\n  /** {@inheritDoc Logger.error} */\n  error(source, category, ...args) {\n  }\n  /** {@inheritDoc Logger.perf} */\n  perf(source, category, event, phase, identifier, ...args) {\n    switch (phase) {\n      case \"Begin\":\n        window.performance.mark(`${source}.${category}.${event}.${phase}.${identifier}`, {\n          detail: args\n        });\n        break;\n      case \"End\":\n        window.performance.mark(`${source}.${category}.${event}.${phase}.${identifier}`, {\n          detail: args\n        });\n        window.performance.measure(\n          `${source}.${category}.${event}.Measure.${identifier}`,\n          `${source}.${category}.${event}.Begin.${identifier}`,\n          `${source}.${category}.${event}.End.${identifier}`\n        );\n        break;\n    }\n  }\n};\nvar AllLogger = class {\n  /**\n   * create new PerfLogger\n   */\n  constructor(loggers) {\n    this.loggers = loggers;\n  }\n  /** {@inheritDoc Logger.debug} */\n  debug(source, category, ...args) {\n    for (const logger of this.loggers) {\n      logger.debug(source, category, ...args);\n    }\n  }\n  /** {@inheritDoc Logger.info} */\n  info(source, category, ...args) {\n    for (const logger of this.loggers) {\n      logger.info(source, category, ...args);\n    }\n  }\n  /** {@inheritDoc Logger.warn} */\n  warn(source, category, ...args) {\n    for (const logger of this.loggers) {\n      logger.warn(source, category, ...args);\n    }\n  }\n  /** {@inheritDoc Logger.error} */\n  error(source, category, ...args) {\n    for (const logger of this.loggers) {\n      logger.error(source, category, ...args);\n    }\n  }\n  /** {@inheritDoc Logger.perf} */\n  perf(source, category, event, phase, ...args) {\n    for (const logger of this.loggers) {\n      logger.perf(source, category, event, phase, ...args);\n    }\n  }\n};\n\n// src/task.ts\nvar TaskStage = /* @__PURE__ */ ((TaskStage2) => {\n  TaskStage2[TaskStage2[\"Pending\"] = 0] = \"Pending\";\n  TaskStage2[TaskStage2[\"Resolved\"] = 1] = \"Resolved\";\n  TaskStage2[TaskStage2[\"Rejected\"] = 2] = \"Rejected\";\n  TaskStage2[TaskStage2[\"Aborted\"] = 3] = \"Aborted\";\n  return TaskStage2;\n})(TaskStage || {});\nvar TaskAbortedError = class extends Error {\n  constructor(reason) {\n    super(`Task aborted: ${JSON.stringify(reason)}`);\n    this.name = \"TaskAbortedError\";\n  }\n};\nvar TaskRejectedError = class extends Error {\n  constructor(reason) {\n    super(`Task rejected: ${JSON.stringify(reason)}`);\n    this.name = \"TaskRejectedError\";\n  }\n};\nvar Task = class _Task {\n  constructor() {\n    this.state = {\n      stage: 0 /* Pending */\n    };\n    /**\n     * callbacks that will be executed when task is resolved\n     */\n    this.resolvedCallbacks = [];\n    /**\n     * callbacks that will be executed when task is rejected\n     */\n    this.rejectedCallbacks = [];\n    /**\n     * Promise that will be resolved when task is settled\n     */\n    this._promise = null;\n  }\n  /**\n   * Convert task to promise\n   * @returns promise that will be resolved when task is settled\n   */\n  toPromise() {\n    if (!this._promise) {\n      this._promise = new Promise((resolve, reject) => {\n        this.wait(\n          (result) => resolve(result),\n          (error) => {\n            if (error.type === \"abort\") {\n              reject(new TaskAbortedError(error.reason));\n            } else {\n              reject(new TaskRejectedError(error.reason));\n            }\n          }\n        );\n      });\n    }\n    return this._promise;\n  }\n  /**\n   * wait for task to be settled\n   * @param resolvedCallback - callback for resolved value\n   * @param rejectedCallback - callback for rejected value\n   */\n  wait(resolvedCallback, rejectedCallback) {\n    switch (this.state.stage) {\n      case 0 /* Pending */:\n        this.resolvedCallbacks.push(resolvedCallback);\n        this.rejectedCallbacks.push(rejectedCallback);\n        break;\n      case 1 /* Resolved */:\n        resolvedCallback(this.state.result);\n        break;\n      case 2 /* Rejected */:\n        rejectedCallback({\n          type: \"reject\",\n          reason: this.state.reason\n        });\n        break;\n      case 3 /* Aborted */:\n        rejectedCallback({\n          type: \"abort\",\n          reason: this.state.reason\n        });\n        break;\n    }\n  }\n  /**\n   * resolve task with specific result\n   * @param result - result value\n   */\n  resolve(result) {\n    if (this.state.stage === 0 /* Pending */) {\n      this.state = {\n        stage: 1 /* Resolved */,\n        result\n      };\n      for (const resolvedCallback of this.resolvedCallbacks) {\n        try {\n          resolvedCallback(result);\n        } catch (e) {\n        }\n      }\n      this.resolvedCallbacks = [];\n      this.rejectedCallbacks = [];\n    }\n  }\n  /**\n   * reject task with specific reason\n   * @param reason - abort reason\n   *\n   */\n  reject(reason) {\n    if (this.state.stage === 0 /* Pending */) {\n      this.state = {\n        stage: 2 /* Rejected */,\n        reason\n      };\n      for (const rejectedCallback of this.rejectedCallbacks) {\n        try {\n          rejectedCallback({\n            type: \"reject\",\n            reason\n          });\n        } catch (e) {\n        }\n      }\n      this.resolvedCallbacks = [];\n      this.rejectedCallbacks = [];\n    }\n  }\n  /**\n   * abort task with specific reason\n   * @param reason - abort reason\n   */\n  abort(reason) {\n    if (this.state.stage === 0 /* Pending */) {\n      this.state = {\n        stage: 3 /* Aborted */,\n        reason\n      };\n      for (const rejectedCallback of this.rejectedCallbacks) {\n        try {\n          rejectedCallback({\n            type: \"abort\",\n            reason\n          });\n        } catch (e) {\n        }\n      }\n      this.resolvedCallbacks = [];\n      this.rejectedCallbacks = [];\n    }\n  }\n  /**\n   * fail task with a TaskError from another task\n   * This is a convenience method for error propagation between tasks\n   * @param error - TaskError from another task\n   */\n  fail(error) {\n    if (error.type === \"abort\") {\n      this.abort(error.reason);\n    } else {\n      this.reject(error.reason);\n    }\n  }\n  /**\n   * Static method to wait for all tasks to resolve\n   * Returns a new task that resolves with an array of all results\n   * Rejects immediately if any task fails\n   *\n   * @param tasks - array of tasks to wait for\n   * @returns new task that resolves when all input tasks resolve\n   * @public\n   */\n  static all(tasks) {\n    const combinedTask = new _Task();\n    if (tasks.length === 0) {\n      combinedTask.resolve([]);\n      return combinedTask;\n    }\n    const results = new Array(tasks.length);\n    let resolvedCount = 0;\n    let isSettled = false;\n    tasks.forEach((task, index) => {\n      task.wait(\n        (result) => {\n          if (isSettled) return;\n          results[index] = result;\n          resolvedCount++;\n          if (resolvedCount === tasks.length) {\n            isSettled = true;\n            combinedTask.resolve(results);\n          }\n        },\n        (error) => {\n          if (isSettled) return;\n          isSettled = true;\n          if (error.type === \"abort\") {\n            combinedTask.abort(error.reason);\n          } else {\n            combinedTask.reject(error.reason);\n          }\n        }\n      );\n    });\n    return combinedTask;\n  }\n  /**\n   * Static method to wait for all tasks to settle (resolve, reject, or abort)\n   * Always resolves with an array of settlement results\n   *\n   * @param tasks - array of tasks to wait for\n   * @returns new task that resolves when all input tasks settle\n   * @public\n   */\n  static allSettled(tasks) {\n    const combinedTask = new _Task();\n    if (tasks.length === 0) {\n      combinedTask.resolve([]);\n      return combinedTask;\n    }\n    const results = new Array(tasks.length);\n    let settledCount = 0;\n    tasks.forEach((task, index) => {\n      task.wait(\n        (result) => {\n          results[index] = { status: \"resolved\", value: result };\n          settledCount++;\n          if (settledCount === tasks.length) {\n            combinedTask.resolve(results);\n          }\n        },\n        (error) => {\n          results[index] = {\n            status: error.type === \"abort\" ? \"aborted\" : \"rejected\",\n            reason: error.reason\n          };\n          settledCount++;\n          if (settledCount === tasks.length) {\n            combinedTask.resolve(results);\n          }\n        }\n      );\n    });\n    return combinedTask;\n  }\n  /**\n   * Static method that resolves/rejects with the first task that settles\n   *\n   * @param tasks - array of tasks to race\n   * @returns new task that settles with the first input task that settles\n   * @public\n   */\n  static race(tasks) {\n    const combinedTask = new _Task();\n    if (tasks.length === 0) {\n      combinedTask.reject(\"No tasks provided\");\n      return combinedTask;\n    }\n    let isSettled = false;\n    tasks.forEach((task) => {\n      task.wait(\n        (result) => {\n          if (isSettled) return;\n          isSettled = true;\n          combinedTask.resolve(result);\n        },\n        (error) => {\n          if (isSettled) return;\n          isSettled = true;\n          if (error.type === \"abort\") {\n            combinedTask.abort(error.reason);\n          } else {\n            combinedTask.reject(error.reason);\n          }\n        }\n      );\n    });\n    return combinedTask;\n  }\n  /**\n   * Utility to track progress of multiple tasks\n   *\n   * @param tasks - array of tasks to track\n   * @param onProgress - callback called when any task completes\n   * @returns new task that resolves when all input tasks resolve\n   * @public\n   */\n  static withProgress(tasks, onProgress) {\n    const combinedTask = _Task.all(tasks);\n    if (onProgress) {\n      let completedCount = 0;\n      tasks.forEach((task) => {\n        task.wait(\n          () => {\n            completedCount++;\n            onProgress(completedCount, tasks.length);\n          },\n          () => {\n            completedCount++;\n            onProgress(completedCount, tasks.length);\n          }\n        );\n      });\n    }\n    return combinedTask;\n  }\n};\n\n// src/pdf.ts\nvar PdfSoftHyphenMarker = \"\\xAD\";\nvar PdfZeroWidthSpace = \"\\u200B\";\nvar PdfWordJoiner = \"\\u2060\";\nvar PdfBomOrZwnbsp = \"\\uFEFF\";\nvar PdfNonCharacterFFFE = \"\\uFFFE\";\nvar PdfNonCharacterFFFF = \"\\uFFFF\";\nvar PdfUnwantedTextMarkers = Object.freeze([\n  PdfSoftHyphenMarker,\n  PdfZeroWidthSpace,\n  PdfWordJoiner,\n  PdfBomOrZwnbsp,\n  PdfNonCharacterFFFE,\n  PdfNonCharacterFFFF\n]);\nvar PdfUnwantedTextRegex = new RegExp(`[${PdfUnwantedTextMarkers.join(\"\")}]`, \"g\");\nfunction stripPdfUnwantedMarkers(text) {\n  return text.replace(PdfUnwantedTextRegex, \"\");\n}\nvar PdfZoomMode = /* @__PURE__ */ ((PdfZoomMode2) => {\n  PdfZoomMode2[PdfZoomMode2[\"Unknown\"] = 0] = \"Unknown\";\n  PdfZoomMode2[PdfZoomMode2[\"XYZ\"] = 1] = \"XYZ\";\n  PdfZoomMode2[PdfZoomMode2[\"FitPage\"] = 2] = \"FitPage\";\n  PdfZoomMode2[PdfZoomMode2[\"FitHorizontal\"] = 3] = \"FitHorizontal\";\n  PdfZoomMode2[PdfZoomMode2[\"FitVertical\"] = 4] = \"FitVertical\";\n  PdfZoomMode2[PdfZoomMode2[\"FitRectangle\"] = 5] = \"FitRectangle\";\n  return PdfZoomMode2;\n})(PdfZoomMode || {});\nvar PdfBlendMode = /* @__PURE__ */ ((PdfBlendMode2) => {\n  PdfBlendMode2[PdfBlendMode2[\"Normal\"] = 0] = \"Normal\";\n  PdfBlendMode2[PdfBlendMode2[\"Multiply\"] = 1] = \"Multiply\";\n  PdfBlendMode2[PdfBlendMode2[\"Screen\"] = 2] = \"Screen\";\n  PdfBlendMode2[PdfBlendMode2[\"Overlay\"] = 3] = \"Overlay\";\n  PdfBlendMode2[PdfBlendMode2[\"Darken\"] = 4] = \"Darken\";\n  PdfBlendMode2[PdfBlendMode2[\"Lighten\"] = 5] = \"Lighten\";\n  PdfBlendMode2[PdfBlendMode2[\"ColorDodge\"] = 6] = \"ColorDodge\";\n  PdfBlendMode2[PdfBlendMode2[\"ColorBurn\"] = 7] = \"ColorBurn\";\n  PdfBlendMode2[PdfBlendMode2[\"HardLight\"] = 8] = \"HardLight\";\n  PdfBlendMode2[PdfBlendMode2[\"SoftLight\"] = 9] = \"SoftLight\";\n  PdfBlendMode2[PdfBlendMode2[\"Difference\"] = 10] = \"Difference\";\n  PdfBlendMode2[PdfBlendMode2[\"Exclusion\"] = 11] = \"Exclusion\";\n  PdfBlendMode2[PdfBlendMode2[\"Hue\"] = 12] = \"Hue\";\n  PdfBlendMode2[PdfBlendMode2[\"Saturation\"] = 13] = \"Saturation\";\n  PdfBlendMode2[PdfBlendMode2[\"Color\"] = 14] = \"Color\";\n  PdfBlendMode2[PdfBlendMode2[\"Luminosity\"] = 15] = \"Luminosity\";\n  return PdfBlendMode2;\n})(PdfBlendMode || {});\nvar MixedBlendMode = Symbol(\"mixed\");\nvar BLEND_MODE_INFOS = Object.freeze([\n  { id: 0 /* Normal */, label: \"Normal\", css: \"normal\" },\n  { id: 1 /* Multiply */, label: \"Multiply\", css: \"multiply\" },\n  { id: 2 /* Screen */, label: \"Screen\", css: \"screen\" },\n  { id: 3 /* Overlay */, label: \"Overlay\", css: \"overlay\" },\n  { id: 4 /* Darken */, label: \"Darken\", css: \"darken\" },\n  { id: 5 /* Lighten */, label: \"Lighten\", css: \"lighten\" },\n  { id: 6 /* ColorDodge */, label: \"Color Dodge\", css: \"color-dodge\" },\n  { id: 7 /* ColorBurn */, label: \"Color Burn\", css: \"color-burn\" },\n  { id: 8 /* HardLight */, label: \"Hard Light\", css: \"hard-light\" },\n  { id: 9 /* SoftLight */, label: \"Soft Light\", css: \"soft-light\" },\n  { id: 10 /* Difference */, label: \"Difference\", css: \"difference\" },\n  { id: 11 /* Exclusion */, label: \"Exclusion\", css: \"exclusion\" },\n  { id: 12 /* Hue */, label: \"Hue\", css: \"hue\" },\n  { id: 13 /* Saturation */, label: \"Saturation\", css: \"saturation\" },\n  { id: 14 /* Color */, label: \"Color\", css: \"color\" },\n  { id: 15 /* Luminosity */, label: \"Luminosity\", css: \"luminosity\" }\n]);\nvar enumToInfo = BLEND_MODE_INFOS.reduce(\n  (m, info) => {\n    m[info.id] = info;\n    return m;\n  },\n  {}\n);\nvar cssToEnum = BLEND_MODE_INFOS.reduce((m, info) => {\n  m[info.css] = info.id;\n  return m;\n}, {});\nfunction getBlendModeInfo(mode) {\n  return enumToInfo[mode] ?? enumToInfo[0 /* Normal */];\n}\nfunction blendModeToCss(mode) {\n  return getBlendModeInfo(mode).css;\n}\nfunction cssToBlendMode(value) {\n  return cssToEnum[value];\n}\nfunction blendModeLabel(mode) {\n  return getBlendModeInfo(mode).label;\n}\nfunction reduceBlendModes(modes) {\n  if (!modes.length) return 0 /* Normal */;\n  const first = modes[0];\n  return modes.every((m) => m === first) ? first : MixedBlendMode;\n}\nvar blendModeSelectOptions = BLEND_MODE_INFOS.map((info) => ({\n  value: info.id,\n  label: info.label\n}));\nfunction uiBlendModeDisplay(value) {\n  return value === MixedBlendMode ? \"(mixed)\" : blendModeLabel(value);\n}\nvar PdfActionType = /* @__PURE__ */ ((PdfActionType2) => {\n  PdfActionType2[PdfActionType2[\"Unsupported\"] = 0] = \"Unsupported\";\n  PdfActionType2[PdfActionType2[\"Goto\"] = 1] = \"Goto\";\n  PdfActionType2[PdfActionType2[\"RemoteGoto\"] = 2] = \"RemoteGoto\";\n  PdfActionType2[PdfActionType2[\"URI\"] = 3] = \"URI\";\n  PdfActionType2[PdfActionType2[\"LaunchAppOrOpenFile\"] = 4] = \"LaunchAppOrOpenFile\";\n  return PdfActionType2;\n})(PdfActionType || {});\nvar PdfAnnotationSubtype = /* @__PURE__ */ ((PdfAnnotationSubtype2) => {\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"TEXT\"] = 1] = \"TEXT\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"LINK\"] = 2] = \"LINK\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"FREETEXT\"] = 3] = \"FREETEXT\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"LINE\"] = 4] = \"LINE\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"SQUARE\"] = 5] = \"SQUARE\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"CIRCLE\"] = 6] = \"CIRCLE\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"POLYGON\"] = 7] = \"POLYGON\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"POLYLINE\"] = 8] = \"POLYLINE\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"HIGHLIGHT\"] = 9] = \"HIGHLIGHT\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"UNDERLINE\"] = 10] = \"UNDERLINE\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"SQUIGGLY\"] = 11] = \"SQUIGGLY\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"STRIKEOUT\"] = 12] = \"STRIKEOUT\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"STAMP\"] = 13] = \"STAMP\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"CARET\"] = 14] = \"CARET\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"INK\"] = 15] = \"INK\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"POPUP\"] = 16] = \"POPUP\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"FILEATTACHMENT\"] = 17] = \"FILEATTACHMENT\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"SOUND\"] = 18] = \"SOUND\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"MOVIE\"] = 19] = \"MOVIE\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"WIDGET\"] = 20] = \"WIDGET\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"SCREEN\"] = 21] = \"SCREEN\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"PRINTERMARK\"] = 22] = \"PRINTERMARK\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"TRAPNET\"] = 23] = \"TRAPNET\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"WATERMARK\"] = 24] = \"WATERMARK\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"THREED\"] = 25] = \"THREED\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"RICHMEDIA\"] = 26] = \"RICHMEDIA\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"XFAWIDGET\"] = 27] = \"XFAWIDGET\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"REDACT\"] = 28] = \"REDACT\";\n  return PdfAnnotationSubtype2;\n})(PdfAnnotationSubtype || {});\nvar PdfAnnotationSubtypeName = {\n  [0 /* UNKNOWN */]: \"unknow\",\n  [1 /* TEXT */]: \"text\",\n  [2 /* LINK */]: \"link\",\n  [3 /* FREETEXT */]: \"freetext\",\n  [4 /* LINE */]: \"line\",\n  [5 /* SQUARE */]: \"square\",\n  [6 /* CIRCLE */]: \"circle\",\n  [7 /* POLYGON */]: \"polygon\",\n  [8 /* POLYLINE */]: \"polyline\",\n  [9 /* HIGHLIGHT */]: \"highlight\",\n  [10 /* UNDERLINE */]: \"underline\",\n  [11 /* SQUIGGLY */]: \"squiggly\",\n  [12 /* STRIKEOUT */]: \"strikeout\",\n  [13 /* STAMP */]: \"stamp\",\n  [14 /* CARET */]: \"caret\",\n  [15 /* INK */]: \"ink\",\n  [16 /* POPUP */]: \"popup\",\n  [17 /* FILEATTACHMENT */]: \"fileattachment\",\n  [18 /* SOUND */]: \"sound\",\n  [19 /* MOVIE */]: \"movie\",\n  [20 /* WIDGET */]: \"widget\",\n  [21 /* SCREEN */]: \"screen\",\n  [22 /* PRINTERMARK */]: \"printermark\",\n  [23 /* TRAPNET */]: \"trapnet\",\n  [24 /* WATERMARK */]: \"watermark\",\n  [25 /* THREED */]: \"threed\",\n  [26 /* RICHMEDIA */]: \"richmedia\",\n  [27 /* XFAWIDGET */]: \"xfawidget\",\n  [28 /* REDACT */]: \"redact\"\n};\nvar PdfAnnotationObjectStatus = /* @__PURE__ */ ((PdfAnnotationObjectStatus2) => {\n  PdfAnnotationObjectStatus2[PdfAnnotationObjectStatus2[\"Created\"] = 0] = \"Created\";\n  PdfAnnotationObjectStatus2[PdfAnnotationObjectStatus2[\"Committed\"] = 1] = \"Committed\";\n  return PdfAnnotationObjectStatus2;\n})(PdfAnnotationObjectStatus || {});\nvar AppearanceMode = /* @__PURE__ */ ((AppearanceMode2) => {\n  AppearanceMode2[AppearanceMode2[\"Normal\"] = 0] = \"Normal\";\n  AppearanceMode2[AppearanceMode2[\"Rollover\"] = 1] = \"Rollover\";\n  AppearanceMode2[AppearanceMode2[\"Down\"] = 2] = \"Down\";\n  return AppearanceMode2;\n})(AppearanceMode || {});\nvar PdfAnnotationState = /* @__PURE__ */ ((PdfAnnotationState2) => {\n  PdfAnnotationState2[\"Marked\"] = \"Marked\";\n  PdfAnnotationState2[\"Unmarked\"] = \"Unmarked\";\n  PdfAnnotationState2[\"Accepted\"] = \"Accepted\";\n  PdfAnnotationState2[\"Rejected\"] = \"Rejected\";\n  PdfAnnotationState2[\"Complete\"] = \"Complete\";\n  PdfAnnotationState2[\"Cancelled\"] = \"Cancelled\";\n  PdfAnnotationState2[\"None\"] = \"None\";\n  return PdfAnnotationState2;\n})(PdfAnnotationState || {});\nvar PdfAnnotationStateModel = /* @__PURE__ */ ((PdfAnnotationStateModel2) => {\n  PdfAnnotationStateModel2[\"Marked\"] = \"Marked\";\n  PdfAnnotationStateModel2[\"Reviewed\"] = \"Reviewed\";\n  return PdfAnnotationStateModel2;\n})(PdfAnnotationStateModel || {});\nvar PDF_FORM_FIELD_TYPE = /* @__PURE__ */ ((PDF_FORM_FIELD_TYPE2) => {\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"PUSHBUTTON\"] = 1] = \"PUSHBUTTON\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"CHECKBOX\"] = 2] = \"CHECKBOX\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"RADIOBUTTON\"] = 3] = \"RADIOBUTTON\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"COMBOBOX\"] = 4] = \"COMBOBOX\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"LISTBOX\"] = 5] = \"LISTBOX\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"TEXTFIELD\"] = 6] = \"TEXTFIELD\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"SIGNATURE\"] = 7] = \"SIGNATURE\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"XFA\"] = 8] = \"XFA\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"XFA_CHECKBOX\"] = 9] = \"XFA_CHECKBOX\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"XFA_COMBOBOX\"] = 10] = \"XFA_COMBOBOX\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"XFA_IMAGEFIELD\"] = 11] = \"XFA_IMAGEFIELD\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"XFA_LISTBOX\"] = 12] = \"XFA_LISTBOX\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"XFA_PUSHBUTTON\"] = 13] = \"XFA_PUSHBUTTON\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"XFA_SIGNATURE\"] = 14] = \"XFA_SIGNATURE\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"XFA_TEXTFIELD\"] = 15] = \"XFA_TEXTFIELD\";\n  return PDF_FORM_FIELD_TYPE2;\n})(PDF_FORM_FIELD_TYPE || {});\nvar PdfAnnotationColorType = /* @__PURE__ */ ((PdfAnnotationColorType2) => {\n  PdfAnnotationColorType2[PdfAnnotationColorType2[\"Color\"] = 0] = \"Color\";\n  PdfAnnotationColorType2[PdfAnnotationColorType2[\"InteriorColor\"] = 1] = \"InteriorColor\";\n  return PdfAnnotationColorType2;\n})(PdfAnnotationColorType || {});\nvar PdfAnnotationBorderStyle = /* @__PURE__ */ ((PdfAnnotationBorderStyle2) => {\n  PdfAnnotationBorderStyle2[PdfAnnotationBorderStyle2[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n  PdfAnnotationBorderStyle2[PdfAnnotationBorderStyle2[\"SOLID\"] = 1] = \"SOLID\";\n  PdfAnnotationBorderStyle2[PdfAnnotationBorderStyle2[\"DASHED\"] = 2] = \"DASHED\";\n  PdfAnnotationBorderStyle2[PdfAnnotationBorderStyle2[\"BEVELED\"] = 3] = \"BEVELED\";\n  PdfAnnotationBorderStyle2[PdfAnnotationBorderStyle2[\"INSET\"] = 4] = \"INSET\";\n  PdfAnnotationBorderStyle2[PdfAnnotationBorderStyle2[\"UNDERLINE\"] = 5] = \"UNDERLINE\";\n  PdfAnnotationBorderStyle2[PdfAnnotationBorderStyle2[\"CLOUDY\"] = 6] = \"CLOUDY\";\n  return PdfAnnotationBorderStyle2;\n})(PdfAnnotationBorderStyle || {});\nvar PdfAnnotationFlags = /* @__PURE__ */ ((PdfAnnotationFlags2) => {\n  PdfAnnotationFlags2[PdfAnnotationFlags2[\"NONE\"] = 0] = \"NONE\";\n  PdfAnnotationFlags2[PdfAnnotationFlags2[\"INVISIBLE\"] = 1] = \"INVISIBLE\";\n  PdfAnnotationFlags2[PdfAnnotationFlags2[\"HIDDEN\"] = 2] = \"HIDDEN\";\n  PdfAnnotationFlags2[PdfAnnotationFlags2[\"PRINT\"] = 4] = \"PRINT\";\n  PdfAnnotationFlags2[PdfAnnotationFlags2[\"NO_ZOOM\"] = 8] = \"NO_ZOOM\";\n  PdfAnnotationFlags2[PdfAnnotationFlags2[\"NO_ROTATE\"] = 16] = \"NO_ROTATE\";\n  PdfAnnotationFlags2[PdfAnnotationFlags2[\"NO_VIEW\"] = 32] = \"NO_VIEW\";\n  PdfAnnotationFlags2[PdfAnnotationFlags2[\"READ_ONLY\"] = 64] = \"READ_ONLY\";\n  PdfAnnotationFlags2[PdfAnnotationFlags2[\"LOCKED\"] = 128] = \"LOCKED\";\n  PdfAnnotationFlags2[PdfAnnotationFlags2[\"TOGGLE_NOVIEW\"] = 256] = \"TOGGLE_NOVIEW\";\n  return PdfAnnotationFlags2;\n})(PdfAnnotationFlags || {});\nvar PDF_FORM_FIELD_FLAG = /* @__PURE__ */ ((PDF_FORM_FIELD_FLAG2) => {\n  PDF_FORM_FIELD_FLAG2[PDF_FORM_FIELD_FLAG2[\"NONE\"] = 0] = \"NONE\";\n  PDF_FORM_FIELD_FLAG2[PDF_FORM_FIELD_FLAG2[\"READONLY\"] = 1] = \"READONLY\";\n  PDF_FORM_FIELD_FLAG2[PDF_FORM_FIELD_FLAG2[\"REQUIRED\"] = 2] = \"REQUIRED\";\n  PDF_FORM_FIELD_FLAG2[PDF_FORM_FIELD_FLAG2[\"NOEXPORT\"] = 4] = \"NOEXPORT\";\n  PDF_FORM_FIELD_FLAG2[PDF_FORM_FIELD_FLAG2[\"TEXT_MULTIPLINE\"] = 4096] = \"TEXT_MULTIPLINE\";\n  PDF_FORM_FIELD_FLAG2[PDF_FORM_FIELD_FLAG2[\"TEXT_PASSWORD\"] = 8192] = \"TEXT_PASSWORD\";\n  PDF_FORM_FIELD_FLAG2[PDF_FORM_FIELD_FLAG2[\"CHOICE_COMBO\"] = 131072] = \"CHOICE_COMBO\";\n  PDF_FORM_FIELD_FLAG2[PDF_FORM_FIELD_FLAG2[\"CHOICE_EDIT\"] = 262144] = \"CHOICE_EDIT\";\n  PDF_FORM_FIELD_FLAG2[PDF_FORM_FIELD_FLAG2[\"CHOICE_MULTL_SELECT\"] = 2097152] = \"CHOICE_MULTL_SELECT\";\n  return PDF_FORM_FIELD_FLAG2;\n})(PDF_FORM_FIELD_FLAG || {});\nvar PdfPageObjectType = /* @__PURE__ */ ((PdfPageObjectType2) => {\n  PdfPageObjectType2[PdfPageObjectType2[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n  PdfPageObjectType2[PdfPageObjectType2[\"TEXT\"] = 1] = \"TEXT\";\n  PdfPageObjectType2[PdfPageObjectType2[\"PATH\"] = 2] = \"PATH\";\n  PdfPageObjectType2[PdfPageObjectType2[\"IMAGE\"] = 3] = \"IMAGE\";\n  PdfPageObjectType2[PdfPageObjectType2[\"SHADING\"] = 4] = \"SHADING\";\n  PdfPageObjectType2[PdfPageObjectType2[\"FORM\"] = 5] = \"FORM\";\n  return PdfPageObjectType2;\n})(PdfPageObjectType || {});\nvar PdfAnnotationFlagName = Object.freeze({\n  [1 /* INVISIBLE */]: \"invisible\",\n  [2 /* HIDDEN */]: \"hidden\",\n  [4 /* PRINT */]: \"print\",\n  [8 /* NO_ZOOM */]: \"noZoom\",\n  [16 /* NO_ROTATE */]: \"noRotate\",\n  [32 /* NO_VIEW */]: \"noView\",\n  [64 /* READ_ONLY */]: \"readOnly\",\n  [128 /* LOCKED */]: \"locked\",\n  [256 /* TOGGLE_NOVIEW */]: \"toggleNoView\"\n});\nvar PdfAnnotationFlagValue = Object.entries(\n  PdfAnnotationFlagName\n).reduce(\n  (acc, [bit, name]) => {\n    acc[name] = Number(bit);\n    return acc;\n  },\n  {}\n);\nfunction flagsToNames(raw) {\n  return Object.keys(PdfAnnotationFlagName).filter((flag) => (raw & flag) !== 0).map((flag) => PdfAnnotationFlagName[flag]);\n}\nfunction namesToFlags(names) {\n  return names.reduce(\n    (mask, name) => mask | PdfAnnotationFlagValue[name],\n    0 /* NONE */\n  );\n}\nvar PdfSegmentObjectType = /* @__PURE__ */ ((PdfSegmentObjectType2) => {\n  PdfSegmentObjectType2[PdfSegmentObjectType2[\"UNKNOWN\"] = -1] = \"UNKNOWN\";\n  PdfSegmentObjectType2[PdfSegmentObjectType2[\"LINETO\"] = 0] = \"LINETO\";\n  PdfSegmentObjectType2[PdfSegmentObjectType2[\"BEZIERTO\"] = 1] = \"BEZIERTO\";\n  PdfSegmentObjectType2[PdfSegmentObjectType2[\"MOVETO\"] = 2] = \"MOVETO\";\n  return PdfSegmentObjectType2;\n})(PdfSegmentObjectType || {});\nvar PdfEngineFeature = /* @__PURE__ */ ((PdfEngineFeature2) => {\n  PdfEngineFeature2[PdfEngineFeature2[\"RenderPage\"] = 0] = \"RenderPage\";\n  PdfEngineFeature2[PdfEngineFeature2[\"RenderPageRect\"] = 1] = \"RenderPageRect\";\n  PdfEngineFeature2[PdfEngineFeature2[\"Thumbnails\"] = 2] = \"Thumbnails\";\n  PdfEngineFeature2[PdfEngineFeature2[\"Bookmarks\"] = 3] = \"Bookmarks\";\n  PdfEngineFeature2[PdfEngineFeature2[\"Annotations\"] = 4] = \"Annotations\";\n  return PdfEngineFeature2;\n})(PdfEngineFeature || {});\nvar PdfEngineOperation = /* @__PURE__ */ ((PdfEngineOperation2) => {\n  PdfEngineOperation2[PdfEngineOperation2[\"Create\"] = 0] = \"Create\";\n  PdfEngineOperation2[PdfEngineOperation2[\"Read\"] = 1] = \"Read\";\n  PdfEngineOperation2[PdfEngineOperation2[\"Update\"] = 2] = \"Update\";\n  PdfEngineOperation2[PdfEngineOperation2[\"Delete\"] = 3] = \"Delete\";\n  return PdfEngineOperation2;\n})(PdfEngineOperation || {});\nvar MatchFlag = /* @__PURE__ */ ((MatchFlag2) => {\n  MatchFlag2[MatchFlag2[\"None\"] = 0] = \"None\";\n  MatchFlag2[MatchFlag2[\"MatchCase\"] = 1] = \"MatchCase\";\n  MatchFlag2[MatchFlag2[\"MatchWholeWord\"] = 2] = \"MatchWholeWord\";\n  MatchFlag2[MatchFlag2[\"MatchConsecutive\"] = 4] = \"MatchConsecutive\";\n  return MatchFlag2;\n})(MatchFlag || {});\nfunction unionFlags(flags) {\n  return flags.reduce((flag, currFlag) => {\n    return flag | currFlag;\n  }, 0 /* None */);\n}\nfunction compareSearchTarget(targetA, targetB) {\n  const flagA = unionFlags(targetA.flags);\n  const flagB = unionFlags(targetB.flags);\n  return flagA === flagB && targetA.keyword === targetB.keyword;\n}\nvar PdfPermission = /* @__PURE__ */ ((PdfPermission2) => {\n  PdfPermission2[PdfPermission2[\"PrintDocument\"] = 8] = \"PrintDocument\";\n  PdfPermission2[PdfPermission2[\"ModifyContent\"] = 16] = \"ModifyContent\";\n  PdfPermission2[PdfPermission2[\"CopyOrExtract\"] = 32] = \"CopyOrExtract\";\n  PdfPermission2[PdfPermission2[\"AddOrModifyTextAnnot\"] = 64] = \"AddOrModifyTextAnnot\";\n  PdfPermission2[PdfPermission2[\"FillInExistingForm\"] = 512] = \"FillInExistingForm\";\n  PdfPermission2[PdfPermission2[\"ExtractTextOrGraphics\"] = 1024] = \"ExtractTextOrGraphics\";\n  PdfPermission2[PdfPermission2[\"AssembleDocument\"] = 2048] = \"AssembleDocument\";\n  PdfPermission2[PdfPermission2[\"PrintHighQuality\"] = 4096] = \"PrintHighQuality\";\n  return PdfPermission2;\n})(PdfPermission || {});\nvar PdfPageFlattenFlag = /* @__PURE__ */ ((PdfPageFlattenFlag2) => {\n  PdfPageFlattenFlag2[PdfPageFlattenFlag2[\"Display\"] = 0] = \"Display\";\n  PdfPageFlattenFlag2[PdfPageFlattenFlag2[\"Print\"] = 1] = \"Print\";\n  return PdfPageFlattenFlag2;\n})(PdfPageFlattenFlag || {});\nvar PdfPageFlattenResult = /* @__PURE__ */ ((PdfPageFlattenResult2) => {\n  PdfPageFlattenResult2[PdfPageFlattenResult2[\"Fail\"] = 0] = \"Fail\";\n  PdfPageFlattenResult2[PdfPageFlattenResult2[\"Success\"] = 1] = \"Success\";\n  PdfPageFlattenResult2[PdfPageFlattenResult2[\"NothingToDo\"] = 2] = \"NothingToDo\";\n  return PdfPageFlattenResult2;\n})(PdfPageFlattenResult || {});\nvar PdfErrorCode = /* @__PURE__ */ ((PdfErrorCode2) => {\n  PdfErrorCode2[PdfErrorCode2[\"Ok\"] = 0] = \"Ok\";\n  PdfErrorCode2[PdfErrorCode2[\"Unknown\"] = 1] = \"Unknown\";\n  PdfErrorCode2[PdfErrorCode2[\"NotFound\"] = 2] = \"NotFound\";\n  PdfErrorCode2[PdfErrorCode2[\"WrongFormat\"] = 3] = \"WrongFormat\";\n  PdfErrorCode2[PdfErrorCode2[\"Password\"] = 4] = \"Password\";\n  PdfErrorCode2[PdfErrorCode2[\"Security\"] = 5] = \"Security\";\n  PdfErrorCode2[PdfErrorCode2[\"PageError\"] = 6] = \"PageError\";\n  PdfErrorCode2[PdfErrorCode2[\"XFALoad\"] = 7] = \"XFALoad\";\n  PdfErrorCode2[PdfErrorCode2[\"XFALayout\"] = 8] = \"XFALayout\";\n  PdfErrorCode2[PdfErrorCode2[\"Cancelled\"] = 9] = \"Cancelled\";\n  PdfErrorCode2[PdfErrorCode2[\"Initialization\"] = 10] = \"Initialization\";\n  PdfErrorCode2[PdfErrorCode2[\"NotReady\"] = 11] = \"NotReady\";\n  PdfErrorCode2[PdfErrorCode2[\"NotSupport\"] = 12] = \"NotSupport\";\n  PdfErrorCode2[PdfErrorCode2[\"LoadDoc\"] = 13] = \"LoadDoc\";\n  PdfErrorCode2[PdfErrorCode2[\"DocNotOpen\"] = 14] = \"DocNotOpen\";\n  PdfErrorCode2[PdfErrorCode2[\"CantCloseDoc\"] = 15] = \"CantCloseDoc\";\n  PdfErrorCode2[PdfErrorCode2[\"CantCreateNewDoc\"] = 16] = \"CantCreateNewDoc\";\n  PdfErrorCode2[PdfErrorCode2[\"CantImportPages\"] = 17] = \"CantImportPages\";\n  PdfErrorCode2[PdfErrorCode2[\"CantCreateAnnot\"] = 18] = \"CantCreateAnnot\";\n  PdfErrorCode2[PdfErrorCode2[\"CantSetAnnotRect\"] = 19] = \"CantSetAnnotRect\";\n  PdfErrorCode2[PdfErrorCode2[\"CantSetAnnotContent\"] = 20] = \"CantSetAnnotContent\";\n  PdfErrorCode2[PdfErrorCode2[\"CantRemoveInkList\"] = 21] = \"CantRemoveInkList\";\n  PdfErrorCode2[PdfErrorCode2[\"CantAddInkStoke\"] = 22] = \"CantAddInkStoke\";\n  PdfErrorCode2[PdfErrorCode2[\"CantReadAttachmentSize\"] = 23] = \"CantReadAttachmentSize\";\n  PdfErrorCode2[PdfErrorCode2[\"CantReadAttachmentContent\"] = 24] = \"CantReadAttachmentContent\";\n  PdfErrorCode2[PdfErrorCode2[\"CantFocusAnnot\"] = 25] = \"CantFocusAnnot\";\n  PdfErrorCode2[PdfErrorCode2[\"CantSelectText\"] = 26] = \"CantSelectText\";\n  PdfErrorCode2[PdfErrorCode2[\"CantSelectOption\"] = 27] = \"CantSelectOption\";\n  PdfErrorCode2[PdfErrorCode2[\"CantCheckField\"] = 28] = \"CantCheckField\";\n  return PdfErrorCode2;\n})(PdfErrorCode || {});\nvar PdfTaskHelper = class {\n  /**\n   * Create a task\n   * @returns new task\n   */\n  static create() {\n    return new Task();\n  }\n  /**\n   * Create a task that has been resolved with value\n   * @param result - resolved value\n   * @returns resolved task\n   */\n  static resolve(result) {\n    const task = new Task();\n    task.resolve(result);\n    return task;\n  }\n  /**\n   * Create a task that has been rejected with error\n   * @param reason - rejected error\n   * @returns rejected task\n   */\n  static reject(reason) {\n    const task = new Task();\n    task.reject(reason);\n    return task;\n  }\n  /**\n   * Create a task that has been aborted with error\n   * @param reason - aborted error\n   * @returns aborted task\n   */\n  static abort(reason) {\n    const task = new Task();\n    task.reject(reason);\n    return task;\n  }\n};\n\n// src/color.ts\nfunction pdfAlphaColorToWebAlphaColor(c) {\n  const clamp = (n) => Math.max(0, Math.min(255, n));\n  const toHex = (n) => clamp(n).toString(16).padStart(2, \"0\");\n  const color = `#${toHex(c.red)}${toHex(c.green)}${toHex(c.blue)}`;\n  const opacity = clamp(c.alpha) / 255;\n  return { color, opacity };\n}\nfunction webAlphaColorToPdfAlphaColor({ color, opacity }) {\n  if (/^#?[0-9a-f]{3}$/i.test(color)) {\n    color = color.replace(/^#?([0-9a-f])([0-9a-f])([0-9a-f])$/i, \"#$1$1$2$2$3$3\").toLowerCase();\n  }\n  const [, r, g, b] = /^#?([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$/i.exec(color) ?? (() => {\n    throw new Error(`Invalid hex colour: \\u201C${color}\\u201D`);\n  })();\n  const clamp = (n, hi = 255) => Math.max(0, Math.min(hi, n));\n  return {\n    red: parseInt(r, 16),\n    green: parseInt(g, 16),\n    blue: parseInt(b, 16),\n    alpha: clamp(Math.round(opacity * 255))\n  };\n}\n\n// src/date.ts\nfunction pdfDateToDate(pdf) {\n  if (!pdf?.startsWith(\"D:\") || pdf.length < 16) return;\n  const y = +pdf.slice(2, 6);\n  const mo = +pdf.slice(6, 8) - 1;\n  const d = +pdf.slice(8, 10);\n  const H = +pdf.slice(10, 12);\n  const M = +pdf.slice(12, 14);\n  const S = +pdf.slice(14, 16);\n  return new Date(Date.UTC(y, mo, d, H, M, S));\n}\nfunction dateToPdfDate(date = /* @__PURE__ */ new Date()) {\n  const z = (n, len = 2) => n.toString().padStart(len, \"0\");\n  const YYYY = date.getUTCFullYear();\n  const MM = z(date.getUTCMonth() + 1);\n  const DD = z(date.getUTCDate());\n  const HH = z(date.getUTCHours());\n  const mm = z(date.getUTCMinutes());\n  const SS = z(date.getUTCSeconds());\n  return `D:${YYYY}${MM}${DD}${HH}${mm}${SS}`;\n}\n\n// src/index.ts\nfunction ignore() {\n}\nexport {\n  AllLogger,\n  AppearanceMode,\n  ConsoleLogger,\n  LevelLogger,\n  LogLevel,\n  MatchFlag,\n  MixedBlendMode,\n  NoopLogger,\n  PDF_FORM_FIELD_FLAG,\n  PDF_FORM_FIELD_TYPE,\n  PdfActionType,\n  PdfAnnotationBorderStyle,\n  PdfAnnotationColorType,\n  PdfAnnotationFlagName,\n  PdfAnnotationFlags,\n  PdfAnnotationObjectStatus,\n  PdfAnnotationState,\n  PdfAnnotationStateModel,\n  PdfAnnotationSubtype,\n  PdfAnnotationSubtypeName,\n  PdfBlendMode,\n  PdfBomOrZwnbsp,\n  PdfEngineFeature,\n  PdfEngineOperation,\n  PdfErrorCode,\n  PdfNonCharacterFFFE,\n  PdfNonCharacterFFFF,\n  PdfPageFlattenFlag,\n  PdfPageFlattenResult,\n  PdfPageObjectType,\n  PdfPermission,\n  PdfSegmentObjectType,\n  PdfSoftHyphenMarker,\n  PdfTaskHelper,\n  PdfUnwantedTextMarkers,\n  PdfUnwantedTextRegex,\n  PdfWordJoiner,\n  PdfZeroWidthSpace,\n  PdfZoomMode,\n  PerfLogger,\n  Rotation,\n  Task,\n  TaskAbortedError,\n  TaskRejectedError,\n  TaskStage,\n  blendModeLabel,\n  blendModeSelectOptions,\n  blendModeToCss,\n  boundingRect,\n  calculateAngle,\n  calculateDegree,\n  compareSearchTarget,\n  cssToBlendMode,\n  dateToPdfDate,\n  flagsToNames,\n  getBlendModeInfo,\n  ignore,\n  makeMatrix,\n  namesToFlags,\n  pdfAlphaColorToWebAlphaColor,\n  pdfDateToDate,\n  quadToRect,\n  rectToQuad,\n  reduceBlendModes,\n  restoreOffset,\n  restorePosition,\n  restoreRect,\n  rotatePosition,\n  rotateRect,\n  scalePosition,\n  scaleRect,\n  stripPdfUnwantedMarkers,\n  swap,\n  toIntPos,\n  toIntRect,\n  toIntSize,\n  transformPosition,\n  transformRect,\n  transformSize,\n  uiBlendModeDisplay,\n  unionFlags,\n  webAlphaColorToPdfAlphaColor\n};\n//# sourceMappingURL=index.js.map","import { PdfDocumentObject, PdfPageObject, Rotation } from '@embedpdf/models';\nimport { PluginRegistryConfig } from '../types/plugin';\n\nexport interface CoreState {\n  scale: number;\n  rotation: Rotation;\n  document: PdfDocumentObject | null;\n  pages: PdfPageObject[][];\n  loading: boolean;\n  error: string | null;\n}\n\nexport const initialCoreState: (config?: PluginRegistryConfig) => CoreState = (config) => ({\n  scale: config?.scale ?? 1,\n  rotation: config?.rotation ?? Rotation.Degree0,\n  document: null,\n  pages: [],\n  loading: false,\n  error: null,\n});\n","import { Reducer } from './types';\nimport { CoreState } from './initial-state';\nimport {\n  CoreAction,\n  LOAD_DOCUMENT,\n  SET_DOCUMENT,\n  SET_DOCUMENT_ERROR,\n  SET_PAGES,\n  SET_ROTATION,\n  SET_SCALE,\n} from './actions';\n\nexport const coreReducer: Reducer<CoreState, CoreAction> = (state, action): CoreState => {\n  switch (action.type) {\n    case LOAD_DOCUMENT:\n      return {\n        ...state,\n        loading: true,\n        error: null,\n      };\n\n    case SET_DOCUMENT:\n      return {\n        ...state,\n        document: action.payload,\n        pages: action.payload.pages.map((page) => [page]),\n        loading: false,\n        error: null,\n      };\n\n    case SET_ROTATION:\n      return {\n        ...state,\n        rotation: action.payload,\n      };\n\n    case SET_PAGES:\n      return {\n        ...state,\n        pages: action.payload,\n      };\n\n    case SET_DOCUMENT_ERROR:\n      return {\n        ...state,\n        loading: false,\n        error: action.payload,\n      };\n\n    case SET_SCALE:\n      return {\n        ...state,\n        scale: action.payload,\n      };\n\n    default:\n      return state;\n  }\n};\n","import { DependencyResolver } from '../utils/dependency-resolver';\nimport {\n  IPlugin,\n  PluginBatchRegistration,\n  PluginManifest,\n  PluginStatus,\n  PluginPackage,\n  PluginRegistryConfig,\n} from '../types/plugin';\nimport {\n  PluginRegistrationError,\n  PluginNotFoundError,\n  CircularDependencyError,\n  CapabilityNotFoundError,\n  PluginConfigurationError,\n} from '../types/errors';\nimport { ignore, PdfEngine, Rotation } from '@embedpdf/models';\nimport { Action, CoreState, Store, initialCoreState, Reducer } from '../store';\nimport { CoreAction } from '../store/actions';\nimport { coreReducer } from '../store/reducer';\n\n// Define a more flexible generic type for plugin registrations\ninterface PluginRegistration {\n  // Use existential types for the plugin package to allow accepting any plugin type\n  package: PluginPackage<any, any, any, any>;\n  config?: any;\n}\n\nexport class PluginRegistry {\n  private plugins: Map<string, IPlugin> = new Map();\n  private manifests: Map<string, PluginManifest> = new Map();\n  private capabilities: Map<string, string> = new Map(); // capability -> pluginId\n  private status: Map<string, PluginStatus> = new Map();\n  private resolver: DependencyResolver;\n  private configurations: Map<string, unknown> = new Map();\n  private engine: PdfEngine;\n  private engineInitialized = false;\n  private store: Store<CoreState, CoreAction>;\n  private initPromise: Promise<void> | null = null;\n\n  private pendingRegistrations: PluginRegistration[] = [];\n  private processingRegistrations: PluginRegistration[] = [];\n  private initialized = false;\n  private isInitializing = false;\n  private initialCoreState: CoreState;\n  private pluginsReadyPromise: Promise<void> | null = null;\n  private destroyed = false;\n\n  constructor(engine: PdfEngine, config?: PluginRegistryConfig) {\n    this.resolver = new DependencyResolver();\n    this.engine = engine;\n    this.initialCoreState = initialCoreState(config);\n    this.store = new Store<CoreState, CoreAction>(coreReducer, this.initialCoreState);\n  }\n\n  /**\n   * Ensure engine is initialized before proceeding\n   */\n  private async ensureEngineInitialized(): Promise<void> {\n    if (this.engineInitialized) {\n      return;\n    }\n\n    if (this.engine.initialize) {\n      const task = this.engine.initialize();\n      await task.toPromise();\n      this.engineInitialized = true;\n    } else {\n      this.engineInitialized = true;\n    }\n  }\n\n  /**\n   * Register a plugin without initializing it\n   */\n  registerPlugin<\n    TPlugin extends IPlugin<TConfig>,\n    TConfig = unknown,\n    TState = unknown,\n    TAction extends Action = Action,\n  >(\n    pluginPackage: PluginPackage<TPlugin, TConfig, TState, TAction>,\n    config?: Partial<TConfig>,\n  ): void {\n    if (this.initialized && !this.isInitializing) {\n      throw new PluginRegistrationError('Cannot register plugins after initialization');\n    }\n\n    this.validateManifest(pluginPackage.manifest);\n\n    // Use appropriate typing for store methods\n    this.store.addPluginReducer(\n      pluginPackage.manifest.id,\n      // We need one type assertion here since we can't fully reconcile TAction with Action\n      // due to TypeScript's type system limitations with generic variance\n      pluginPackage.reducer as Reducer<TState, Action>,\n      'function' === typeof pluginPackage.initialState\n        ? (pluginPackage.initialState as (coreState: CoreState, config: TConfig) => TState)(\n            this.initialCoreState,\n            {\n              ...pluginPackage.manifest.defaultConfig,\n              ...config,\n            },\n          )\n        : pluginPackage.initialState,\n    );\n\n    this.pendingRegistrations.push({\n      package: pluginPackage,\n      config,\n    });\n  }\n\n  /**\n   * Get the central store instance\n   */\n  getStore(): Store<CoreState, CoreAction> {\n    return this.store;\n  }\n\n  /**\n   * Get the engine instance\n   */\n  getEngine(): PdfEngine {\n    return this.engine;\n  }\n\n  /**\n   * Get a promise that resolves when all plugins are ready\n   */\n  public pluginsReady(): Promise<void> {\n    // Re-use the same promise every time it’s asked for\n    if (this.pluginsReadyPromise) {\n      return this.pluginsReadyPromise;\n    }\n\n    // Build the promise the *first* time it’s requested\n    this.pluginsReadyPromise = (async () => {\n      // 1. Wait until the registry itself has finished initialising\n      if (!this.initialized) {\n        await this.initialize();\n      }\n\n      // 2. Wait for every plugin’s ready() promise (if it has one)\n      const readyPromises = Array.from(this.plugins.values()).map((p) =>\n        typeof p.ready === 'function' ? p.ready() : Promise.resolve(),\n      );\n\n      await Promise.all(readyPromises); // resolves when the slowest is done\n    })();\n\n    return this.pluginsReadyPromise;\n  }\n\n  /**\n   * INITIALISE THE REGISTRY – runs once no-matter-how-many calls   *\n   */\n  async initialize(): Promise<void> {\n    if (this.destroyed) {\n      throw new PluginRegistrationError('Registry has been destroyed');\n    }\n\n    // If an initialisation is already in-flight (or finished)\n    // return the very same promise so callers can await it.\n    if (this.initPromise) {\n      return this.initPromise;\n    }\n\n    // Wrap your existing body in a single promise and cache it\n    this.initPromise = (async () => {\n      if (this.initialized) {\n        throw new PluginRegistrationError('Registry is already initialized');\n      }\n\n      this.isInitializing = true;\n\n      try {\n        /* ---------------- original body starts ------------------ */\n        await this.ensureEngineInitialized();\n        // Check if destroyed after engine initialization\n        if (this.destroyed) {\n          return;\n        }\n\n        while (this.pendingRegistrations.length > 0) {\n          // Check if destroyed before processing each batch\n          if (this.destroyed) {\n            return;\n          }\n          this.processingRegistrations = [...this.pendingRegistrations];\n          this.pendingRegistrations = [];\n\n          for (const reg of this.processingRegistrations) {\n            const dependsOn = new Set<string>();\n            const allDeps = [...reg.package.manifest.requires, ...reg.package.manifest.optional];\n            for (const cap of allDeps) {\n              const provider = this.processingRegistrations.find((r) =>\n                r.package.manifest.provides.includes(cap),\n              );\n              if (provider) dependsOn.add(provider.package.manifest.id);\n            }\n            this.resolver.addNode(reg.package.manifest.id, [...dependsOn]);\n          }\n\n          const loadOrder = this.resolver.resolveLoadOrder();\n          for (const id of loadOrder) {\n            const reg = this.processingRegistrations.find((r) => r.package.manifest.id === id)!;\n            await this.initializePlugin(reg.package.manifest, reg.package.create, reg.config);\n          }\n\n          this.processingRegistrations = [];\n          this.resolver = new DependencyResolver();\n        }\n\n        for (const plugin of this.plugins.values()) {\n          await plugin.postInitialize?.().catch((e) => {\n            console.error(`Error in postInitialize for plugin ${plugin.id}`, e);\n            this.status.set(plugin.id, 'error');\n          });\n        }\n\n        this.initialized = true;\n        /* ----------------- original body ends ------------------- */\n      } catch (err) {\n        if (err instanceof Error) {\n          throw new CircularDependencyError(\n            `Failed to resolve plugin dependencies: ${err.message}`,\n          );\n        }\n        throw err;\n      } finally {\n        this.isInitializing = false;\n      }\n    })();\n\n    return this.initPromise;\n  }\n\n  /**\n   * Initialize a single plugin with all necessary checks\n   */\n  private async initializePlugin<TConfig>(\n    manifest: PluginManifest<TConfig>,\n    packageCreator: (\n      registry: PluginRegistry,\n      engine: PdfEngine,\n      config?: TConfig,\n    ) => IPlugin<TConfig>,\n    config?: Partial<TConfig>,\n  ): Promise<void> {\n    const finalConfig = {\n      ...manifest.defaultConfig,\n      ...config,\n    };\n\n    this.validateConfig(manifest.id, finalConfig, manifest.defaultConfig);\n\n    // Create plugin instance during initialization\n    const plugin = packageCreator(this, this.engine, finalConfig);\n    this.validatePlugin(plugin);\n\n    // Verify all required capabilities are available\n    for (const capability of manifest.requires) {\n      if (!this.capabilities.has(capability)) {\n        throw new PluginRegistrationError(\n          `Missing required capability: ${capability} for plugin ${manifest.id}`,\n        );\n      }\n    }\n\n    // Optional capabilities can be null, so we don't throw errors for them\n    for (const capability of manifest.optional) {\n      if (this.capabilities.has(capability)) {\n        // Optional capability is available, but we don't require it\n        console.debug(`Optional capability ${capability} is available for plugin ${manifest.id}`);\n      }\n    }\n\n    console.log('initializePlugin', manifest.id, manifest.provides);\n\n    // Register provided capabilities\n    for (const capability of manifest.provides) {\n      if (this.capabilities.has(capability)) {\n        throw new PluginRegistrationError(\n          `Capability ${capability} is already provided by plugin ${this.capabilities.get(capability)}`,\n        );\n      }\n      this.capabilities.set(capability, manifest.id);\n    }\n\n    // Store plugin and manifest\n    this.plugins.set(manifest.id, plugin);\n    this.manifests.set(manifest.id, manifest);\n    this.status.set(manifest.id, 'registered');\n    this.configurations.set(manifest.id, finalConfig);\n\n    try {\n      if (plugin.initialize) {\n        await plugin.initialize(finalConfig);\n      }\n      this.status.set(manifest.id, 'active');\n    } catch (error) {\n      // Cleanup on initialization failure\n      this.plugins.delete(manifest.id);\n      this.manifests.delete(manifest.id);\n      console.log('initializePlugin failed', manifest.id, manifest.provides);\n      manifest.provides.forEach((cap) => this.capabilities.delete(cap));\n      throw error;\n    }\n  }\n\n  getPluginConfig<TConfig>(pluginId: string): TConfig {\n    const config = this.configurations.get(pluginId);\n    if (!config) {\n      throw new PluginNotFoundError(`Configuration for plugin ${pluginId} not found`);\n    }\n    return config as TConfig;\n  }\n\n  private validateConfig(pluginId: string, config: unknown, defaultConfig: unknown): void {\n    // Check all required fields exist\n    const requiredKeys = Object.keys(defaultConfig as object);\n    const missingKeys = requiredKeys.filter((key) => !(config as object).hasOwnProperty(key));\n\n    if (missingKeys.length > 0) {\n      throw new PluginConfigurationError(\n        `Missing required configuration keys for plugin ${pluginId}: ${missingKeys.join(', ')}`,\n      );\n    }\n\n    // You could add more validation here:\n    // - Type checking\n    // - Value range validation\n    // - Format validation\n    // etc.\n  }\n\n  async updatePluginConfig<TConfig>(pluginId: string, config: Partial<TConfig>): Promise<void> {\n    const plugin = this.getPlugin(pluginId);\n\n    if (!plugin) {\n      throw new PluginNotFoundError(`Plugin ${pluginId} not found`);\n    }\n\n    const manifest = this.manifests.get(pluginId);\n    const currentConfig = this.configurations.get(pluginId);\n\n    if (!manifest || !currentConfig) {\n      throw new PluginNotFoundError(`Plugin ${pluginId} not found`);\n    }\n\n    // Merge new config with current\n    const newConfig = {\n      ...currentConfig,\n      ...config,\n    };\n\n    // Validate new configuration\n    this.validateConfig(pluginId, newConfig, manifest.defaultConfig);\n\n    // Store new configuration\n    this.configurations.set(pluginId, newConfig);\n\n    // Reinitialize plugin if needed\n    if (plugin.initialize) {\n      await plugin.initialize(newConfig);\n    }\n  }\n\n  /**\n   * Register multiple plugins at once\n   */\n  registerPluginBatch(registrations: PluginBatchRegistration<IPlugin<any>, any, any, any>[]): void {\n    for (const reg of registrations) {\n      this.registerPlugin(reg.package, reg.config);\n    }\n  }\n\n  /**\n   * Unregister a plugin\n   */\n  async unregisterPlugin(pluginId: string): Promise<void> {\n    const plugin = this.plugins.get(pluginId);\n    if (!plugin) {\n      throw new PluginNotFoundError(`Plugin ${pluginId} is not registered`);\n    }\n\n    const manifest = this.manifests.get(pluginId);\n    if (!manifest) {\n      throw new PluginNotFoundError(`Manifest for plugin ${pluginId} not found`);\n    }\n\n    // Check if any other plugins depend on this one\n    for (const [otherId, otherManifest] of this.manifests.entries()) {\n      if (otherId === pluginId) continue;\n\n      const dependsOnThis = [...otherManifest.requires, ...otherManifest.optional].some((cap) =>\n        manifest.provides.includes(cap),\n      );\n\n      if (dependsOnThis) {\n        throw new PluginRegistrationError(\n          `Cannot unregister plugin ${pluginId}: plugin ${otherId} depends on it`,\n        );\n      }\n    }\n\n    // Cleanup plugin\n    try {\n      if (plugin.destroy) {\n        await plugin.destroy();\n      }\n\n      // Remove capabilities\n      for (const capability of manifest.provides) {\n        this.capabilities.delete(capability);\n      }\n\n      // Remove plugin and manifest\n      this.plugins.delete(pluginId);\n      this.manifests.delete(pluginId);\n      this.status.delete(pluginId);\n    } catch (error) {\n      if (error instanceof Error) {\n        throw new Error(`Failed to unregister plugin ${pluginId}: ${error.message}`);\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Get a plugin instance\n   * @param pluginId The ID of the plugin to get\n   * @returns The plugin instance or null if not found\n   */\n  getPlugin<T extends IPlugin>(pluginId: string): T | null {\n    const plugin = this.plugins.get(pluginId);\n    if (!plugin) {\n      return null;\n    }\n    return plugin as T;\n  }\n\n  /**\n   * Get a plugin that provides a specific capability\n   * @param capability The capability to get a provider for\n   * @returns The plugin providing the capability or null if not found\n   */\n  getCapabilityProvider(capability: string): IPlugin | null {\n    const pluginId = this.capabilities.get(capability);\n    if (!pluginId) {\n      return null;\n    }\n    return this.getPlugin(pluginId);\n  }\n\n  /**\n   * Check if a capability is available\n   */\n  hasCapability(capability: string): boolean {\n    return this.capabilities.has(capability);\n  }\n\n  /**\n   * Get all registered plugins\n   */\n  getAllPlugins(): IPlugin[] {\n    return Array.from(this.plugins.values());\n  }\n\n  /**\n   * Get plugin status\n   */\n  getPluginStatus(pluginId: string): PluginStatus {\n    const status = this.status.get(pluginId);\n    if (!status) {\n      throw new PluginNotFoundError(`Plugin ${pluginId} not found`);\n    }\n    return status;\n  }\n\n  /**\n   * Validate plugin object\n   */\n  private validatePlugin(plugin: IPlugin): void {\n    if (!plugin.id) {\n      throw new PluginRegistrationError('Plugin must have an id');\n    }\n  }\n\n  /**\n   * Validate plugin manifest\n   */\n  private validateManifest(manifest: PluginManifest): void {\n    if (!manifest.id) {\n      throw new PluginRegistrationError('Manifest must have an id');\n    }\n    if (!manifest.name) {\n      throw new PluginRegistrationError('Manifest must have a name');\n    }\n    if (!manifest.version) {\n      throw new PluginRegistrationError('Manifest must have a version');\n    }\n    if (!Array.isArray(manifest.provides)) {\n      throw new PluginRegistrationError('Manifest must have a provides array');\n    }\n    if (!Array.isArray(manifest.requires)) {\n      throw new PluginRegistrationError('Manifest must have a requires array');\n    }\n    if (!Array.isArray(manifest.optional)) {\n      throw new PluginRegistrationError('Manifest must have an optional array');\n    }\n  }\n\n  isDestroyed(): boolean {\n    return this.destroyed;\n  }\n\n  /**\n   * DESTROY EVERYTHING – waits for any ongoing initialise(), once  *\n   */\n  async destroy(): Promise<void> {\n    if (this.destroyed) throw new PluginRegistrationError('Registry has already been destroyed');\n    this.destroyed = true;\n\n    // If initialisation is still underway, wait (success OR failure)\n    try {\n      await this.initPromise;\n    } catch {\n      /* ignore – still need to clean up */\n    }\n\n    /* ------- original teardown, unchanged except the guard ------ */\n    for (const plugin of Array.from(this.plugins.values()).reverse()) {\n      await plugin.destroy?.();\n    }\n\n    this.store.destroy();\n\n    this.plugins.clear();\n    this.manifests.clear();\n    this.capabilities.clear();\n    this.status.clear();\n    this.pendingRegistrations.length = 0;\n    this.processingRegistrations.length = 0;\n  }\n}\n","/**\n * Restrict a numeric value to the inclusive range [min, max].\n *\n * @example\n *   clamp( 5, 0, 10)  // 5\n *   clamp(-3, 0, 10)  // 0\n *   clamp(17, 0, 10)  // 10\n */\nexport function clamp(value: number, min: number, max: number): number {\n  return value < min ? min : value > max ? max : value;\n}\n\n/**\n * Deeply compares two values (objects, arrays, primitives)\n * with the following rules:\n *  - Objects are compared ignoring property order.\n *  - Arrays are compared ignoring element order (multiset comparison).\n *  - Primitives are compared by strict equality.\n *  - null/undefined are treated as normal primitives.\n *\n * @param a First value\n * @param b Second value\n * @param visited Used internally to detect cycles\n */\nexport function arePropsEqual(a: any, b: any, visited?: Set<any>): boolean {\n  // Quick path for reference equality or same primitive\n  if (a === b) {\n    return true;\n  }\n\n  // Handle null/undefined mismatch\n  if (a == null || b == null) {\n    // If one is null/undefined and the other isn't, no match\n    return a === b;\n  }\n\n  // Check types\n  const aType = typeof a;\n  const bType = typeof b;\n  if (aType !== bType) return false;\n\n  // If they are both objects or arrays, handle recursively\n  if (aType === 'object') {\n    // Optionally handle cyclical references\n    if (!visited) visited = new Set();\n    const pairId = getPairId(a, b);\n    if (visited.has(pairId)) {\n      // Already compared these two objects => assume true to avoid infinite recursion\n      // or return false if you want to treat cycles as inequality\n      return true;\n    }\n    visited.add(pairId);\n\n    const aIsArray = Array.isArray(a);\n    const bIsArray = Array.isArray(b);\n    if (aIsArray && bIsArray) {\n      // Compare as arrays ignoring order\n      return arraysEqualUnordered(a, b, visited);\n    } else if (!aIsArray && !bIsArray) {\n      // Compare as plain objects (order of properties doesn't matter)\n      return objectsEqual(a, b, visited);\n    } else {\n      // One is array, the other is object => not equal\n      return false;\n    }\n  }\n\n  // If both are function, symbol, etc. - typically we might say false\n  // But you can decide your own logic for function or symbol equality\n  return false;\n}\n\nfunction getPairId(a: any, b: any) {\n  // Could do something more advanced. This is a cheap approach:\n  // e.g. use the memory reference or an object identity approach\n  return `${objectId(a)}__${objectId(b)}`;\n}\n\n/**\n * If you want stable object IDs, you'd need a WeakMap to store them.\n * This simplistic approach just calls toString on the object.\n */\nlet objectIdCounter = 0;\nconst objectIds = new WeakMap<object, number>();\n\nfunction objectId(obj: object): number {\n  if (!objectIds.has(obj)) {\n    objectIds.set(obj, ++objectIdCounter);\n  }\n  return objectIds.get(obj)!;\n}\n\nfunction arraysEqualUnordered(a: any[], b: any[], visited?: Set<any>): boolean {\n  if (a.length !== b.length) return false;\n\n  const used = new Array<boolean>(b.length).fill(false);\n\n  // For each element in a, find an unused matching element in b\n  outer: for (let i = 0; i < a.length; i++) {\n    const elemA = a[i];\n    for (let j = 0; j < b.length; j++) {\n      if (used[j]) continue; // already used that slot\n      if (arePropsEqual(elemA, b[j], visited)) {\n        used[j] = true;\n        continue outer; // found match for a[i], proceed\n      }\n    }\n    // If we never found a match\n    return false;\n  }\n\n  return true;\n}\n\nfunction objectsEqual(a: object, b: object, visited?: Set<any>): boolean {\n  // Get all prop keys\n  const aKeys = Object.keys(a).sort();\n  const bKeys = Object.keys(b).sort();\n  if (aKeys.length !== bKeys.length) return false;\n\n  // Compare each property name\n  for (let i = 0; i < aKeys.length; i++) {\n    if (aKeys[i] !== bKeys[i]) return false;\n  }\n\n  // Compare each property value\n  for (const key of aKeys) {\n    // @ts-ignore\n    const valA = a[key];\n    // @ts-ignore\n    const valB = b[key];\n    if (!arePropsEqual(valA, valB, visited)) {\n      return false;\n    }\n  }\n  return true;\n}\n","import { CoreState } from './initial-state';\nimport { transformSize, PdfPageObjectWithRotatedSize } from '@embedpdf/models';\n\nexport const getPagesWithRotatedSize = (state: CoreState): PdfPageObjectWithRotatedSize[][] => {\n  return state.pages.map((page) =>\n    page.map((p) => ({\n      ...p,\n      rotatedSize: transformSize(p.size, state.rotation, 1),\n    })),\n  );\n};\n","import { Action } from '../store';\nimport { IPlugin, PluginBatchRegistration, PluginPackage } from '../types/plugin';\n\n/**\n * Helper function to create a properly typed plugin registration\n */\nexport function createPluginRegistration<\n  T extends IPlugin<TConfig>,\n  TConfig,\n  TState,\n  TAction extends Action,\n>(\n  pluginPackage: PluginPackage<T, TConfig, TState, TAction>,\n  config?: Partial<TConfig>,\n): PluginBatchRegistration<T, TConfig, any, any> {\n  return {\n    package: pluginPackage,\n    config,\n  };\n}\n","import { IPlugin } from '../types/plugin';\nimport { PluginRegistry } from '../registry/plugin-registry';\nimport { Action, CoreAction, CoreState, PluginStore, Store, StoreState } from '../store';\n\nexport interface StateChangeHandler<TState> {\n  (state: TState): void;\n}\n\nexport abstract class BasePlugin<\n  TConfig = unknown,\n  TCapability = unknown,\n  TState = unknown,\n  TAction extends Action = Action,\n> implements IPlugin<TConfig>\n{\n  static readonly id: string;\n\n  protected pluginStore: PluginStore<TState, TAction>;\n  protected coreStore: Store<CoreState, CoreAction>;\n  // Track debounced actions\n  private debouncedActions: Record<string, number> = {};\n  private unsubscribeFromState: (() => void) | null = null;\n  private unsubscribeFromCoreStore: (() => void) | null = null;\n\n  private _capability?: Readonly<TCapability>;\n\n  private readyPromise: Promise<void>;\n  private readyResolve!: () => void;\n\n  constructor(\n    public readonly id: string,\n    protected registry: PluginRegistry,\n  ) {\n    if (id !== (this.constructor as typeof BasePlugin).id) {\n      throw new Error(\n        `Plugin ID mismatch: ${id} !== ${(this.constructor as typeof BasePlugin).id}`,\n      );\n    }\n    this.coreStore = this.registry.getStore();\n    this.pluginStore = this.coreStore.getPluginStore<TState, TAction>(this.id);\n    this.unsubscribeFromState = this.pluginStore.subscribeToState((action, newState, oldState) => {\n      this.onStoreUpdated(oldState, newState);\n    });\n    this.unsubscribeFromCoreStore = this.coreStore.subscribe((action, newState, oldState) => {\n      this.onCoreStoreUpdated(oldState, newState);\n    });\n\n    // Initialize ready state\n    this.readyPromise = new Promise((resolve) => {\n      this.readyResolve = resolve;\n    });\n    // By default, plugins are ready immediately\n    this.readyResolve();\n  }\n\n  /** Construct the public capability (called once & cached). */\n  protected abstract buildCapability(): TCapability;\n\n  public provides(): Readonly<TCapability> {\n    if (!this._capability) {\n      const cap = this.buildCapability();\n\n      this._capability = Object.freeze(cap);\n    }\n    return this._capability;\n  }\n\n  /**\n   * Initialize plugin with config\n   */\n  abstract initialize(config: TConfig): Promise<void>;\n\n  /**\n   *  Get a copy of the current state\n   */\n  protected get state(): Readonly<TState> {\n    return this.pluginStore.getState();\n  }\n\n  /**\n   *  Get a copy of the current core state\n   */\n  protected get coreState(): Readonly<StoreState<CoreState>> {\n    return this.coreStore.getState();\n  }\n\n  /**\n   * @deprecated  use `this.state` Get a copy of the current state\n   */\n  protected getState(): TState {\n    return this.pluginStore.getState();\n  }\n\n  /**\n   * @deprecated  use `this.coreState` Get a copy of the current core state\n   */\n  protected getCoreState(): StoreState<CoreState> {\n    return this.coreStore.getState();\n  }\n\n  /**\n   * Core Dispatch\n   */\n  protected dispatchCoreAction(action: CoreAction): StoreState<CoreState> {\n    return this.coreStore.dispatchToCore(action);\n  }\n\n  /**\n   * Dispatch an action to all plugins\n   */\n  protected dispatchToAllPlugins(action: TAction): StoreState<CoreState> {\n    return this.coreStore.dispatch(action);\n  }\n\n  /**\n   * Dispatch an action\n   */\n  protected dispatch(action: TAction): TState {\n    return this.pluginStore.dispatch(action);\n  }\n\n  /**\n   * Dispatch an action with debouncing to prevent rapid repeated calls\n   * @param action The action to dispatch\n   * @param debounceTime Time in ms to debounce (default: 100ms)\n   * @returns boolean indicating whether the action was dispatched or debounced\n   */\n  protected debouncedDispatch(action: TAction, debounceTime: number = 100): boolean {\n    const now = Date.now();\n    const lastActionTime = this.debouncedActions[action.type] || 0;\n\n    if (now - lastActionTime >= debounceTime) {\n      this.debouncedActions[action.type] = now;\n      this.dispatch(action);\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Subscribe to state changes\n   */\n  protected subscribe(listener: (action: TAction, state: TState) => void): () => void {\n    return this.pluginStore.subscribeToState(listener);\n  }\n\n  /**\n   * Subscribe to core store changes\n   */\n  protected subscribeToCoreStore(\n    listener: (action: Action, state: StoreState<CoreState>) => void,\n  ): () => void {\n    return this.coreStore.subscribe(listener);\n  }\n\n  /**\n   * Called when the plugin store state is updated\n   * @param oldState Previous state\n   * @param newState New state\n   */\n  protected onStoreUpdated(oldState: TState, newState: TState): void {\n    // Default implementation does nothing - can be overridden by plugins\n  }\n\n  /**\n   * Called when the core store state is updated\n   * @param oldState Previous state\n   * @param newState New state\n   */\n  protected onCoreStoreUpdated(\n    oldState: StoreState<CoreState>,\n    newState: StoreState<CoreState>,\n  ): void {\n    // Default implementation does nothing - can be overridden by plugins\n  }\n\n  /**\n   * Cleanup method to be called when plugin is being destroyed\n   */\n  public destroy(): void {\n    if (this.unsubscribeFromState) {\n      this.unsubscribeFromState();\n      this.unsubscribeFromState = null;\n    }\n    if (this.unsubscribeFromCoreStore) {\n      this.unsubscribeFromCoreStore();\n      this.unsubscribeFromCoreStore = null;\n    }\n  }\n\n  /**\n   * Returns a promise that resolves when the plugin is ready\n   */\n  public ready(): Promise<void> {\n    return this.readyPromise;\n  }\n\n  /**\n   * Mark the plugin as ready\n   */\n  protected markReady(): void {\n    this.readyResolve();\n  }\n\n  /**\n   * Reset the ready state (useful for plugins that need to reinitialize)\n   */\n  protected resetReady(): void {\n    this.readyPromise = new Promise((resolve) => {\n      this.readyResolve = resolve;\n    });\n  }\n}\n","export type EventHandler<T> = (data: T) => void;\n\nexport interface BaseEventControlOptions {\n  wait: number;\n}\n\nexport interface DebounceOptions extends BaseEventControlOptions {\n  mode: 'debounce';\n}\n\nexport interface ThrottleOptions extends BaseEventControlOptions {\n  mode: 'throttle';\n  throttleMode?: 'leading-trailing' | 'trailing';\n}\n\nexport type EventControlOptions = DebounceOptions | ThrottleOptions;\n\nexport class EventControl<T> {\n  private timeoutId?: number;\n  private lastRun: number = 0;\n\n  constructor(\n    private handler: EventHandler<T>,\n    private options: EventControlOptions,\n  ) {}\n\n  handle = (data: T): void => {\n    if (this.options.mode === 'debounce') {\n      this.debounce(data);\n    } else {\n      this.throttle(data);\n    }\n  };\n\n  private debounce(data: T): void {\n    if (this.timeoutId) {\n      window.clearTimeout(this.timeoutId);\n    }\n\n    this.timeoutId = window.setTimeout(() => {\n      this.handler(data);\n      this.timeoutId = undefined;\n    }, this.options.wait);\n  }\n\n  private throttle(data: T): void {\n    if (this.options.mode === 'debounce') return;\n\n    const now = Date.now();\n    const throttleMode = this.options.throttleMode || 'leading-trailing';\n\n    if (now - this.lastRun >= this.options.wait) {\n      if (throttleMode === 'leading-trailing') {\n        this.handler(data);\n      }\n      this.lastRun = now;\n    }\n\n    // Always schedule the trailing execution\n    if (this.timeoutId) {\n      window.clearTimeout(this.timeoutId);\n    }\n\n    this.timeoutId = window.setTimeout(\n      () => {\n        this.handler(data);\n        this.lastRun = Date.now();\n        this.timeoutId = undefined;\n      },\n      this.options.wait - (now - this.lastRun),\n    );\n  }\n\n  destroy(): void {\n    if (this.timeoutId) {\n      window.clearTimeout(this.timeoutId);\n    }\n  }\n}\n","import { EventControl, EventControlOptions } from './event-control';\nimport { arePropsEqual } from './math';\n\n/* ------------------------------------------------------------------ */\n/* basic types                                                        */\n/* ------------------------------------------------------------------ */\nexport type Listener<T = any> = (value: T) => void;\nexport type Unsubscribe = () => void;\n\n/* ------------------------------------------------------------------ */\n/* EventListener                                                      */\n/* ------------------------------------------------------------------ */\nexport type EventListener<T> =\n  | ((listener: Listener<T>) => Unsubscribe)\n  | ((listener: Listener<T>, options?: EventControlOptions) => Unsubscribe);\n\n/* ------------------------------------------------------------ */\n/* helpers for typing `.on()` with an optional second argument  */\n/* ------------------------------------------------------------ */\nexport type EventHook<T = any> = EventListener<T>;\n/* ------------------------------------------------------------------ */\n/* minimal “dumb” emitter (no value cache, no equality)               */\n/* ------------------------------------------------------------------ */\nexport interface Emitter<T = any> {\n  emit(value?: T): void;\n  on(listener: Listener<T>): Unsubscribe;\n  off(listener: Listener<T>): void;\n  clear(): void;\n}\n\nexport function createEmitter<T = any>(): Emitter<T> {\n  const listeners = new Set<Listener<T>>();\n\n  const on: EventHook<T> = (l: Listener<T>) => {\n    listeners.add(l);\n    return () => listeners.delete(l);\n  };\n\n  return {\n    emit: (v = undefined as T) => listeners.forEach((l) => l(v)),\n    on,\n    off: (l) => listeners.delete(l),\n    clear: () => listeners.clear(),\n  };\n}\n\n/* ------------------------------------------------------------ */\n/* public interface                                              */\n/* ------------------------------------------------------------ */\nexport interface BehaviorEmitter<T = any> extends Omit<Emitter<T>, 'on' | 'off'> {\n  readonly value?: T;\n  on: EventHook<T>;\n  off(listener: Listener<T>): void;\n  select<U>(selector: (v: T) => U, equality?: (a: U, b: U) => boolean): EventHook<U>;\n}\n\n/* ------------------------------------------------------------ */\n/* implementation                                               */\n/* ------------------------------------------------------------ */\nexport function createBehaviorEmitter<T = any>(\n  initial?: T,\n  equality: (a: T, b: T) => boolean = arePropsEqual,\n): BehaviorEmitter<T> {\n  const listeners = new Set<Listener<T>>();\n  const proxyMap = new Map<Listener<T>, { wrapped: Listener<T>; destroy: () => void }>();\n  let _value = initial; // cached value\n\n  /* -------------- helpers ----------------------------------- */\n  const notify = (v: T) => listeners.forEach((l) => l(v));\n\n  const baseOn: EventHook<T> = (listener: Listener<T>, options?: EventControlOptions) => {\n    /* wrap & remember if we have control options ------------------ */\n    let realListener = listener;\n    let destroy = () => {};\n\n    if (options) {\n      const ctl = new EventControl(listener, options);\n      realListener = ctl.handle as Listener<T>;\n      destroy = () => ctl.destroy();\n      proxyMap.set(listener, { wrapped: realListener, destroy });\n    }\n\n    /* immediate replay of last value ------------------------------ */\n    if (_value !== undefined) realListener(_value);\n\n    listeners.add(realListener);\n\n    return () => {\n      listeners.delete(realListener);\n      destroy();\n      proxyMap.delete(listener);\n    };\n  };\n\n  /* -------------- public object ------------------------------ */\n  return {\n    /* emitter behaviour ---------------------------------------- */\n    get value() {\n      return _value;\n    },\n\n    emit(v = undefined as T) {\n      if (_value === undefined || !equality(_value, v)) {\n        _value = v;\n        notify(v);\n      }\n    },\n\n    on: baseOn,\n    off(listener: Listener<T>) {\n      /* did we wrap this listener? */\n      const proxy = proxyMap.get(listener);\n      if (proxy) {\n        listeners.delete(proxy.wrapped);\n        proxy.destroy();\n        proxyMap.delete(listener);\n      } else {\n        listeners.delete(listener);\n      }\n    },\n\n    clear() {\n      listeners.clear();\n      proxyMap.forEach((p) => p.destroy());\n      proxyMap.clear();\n    },\n\n    /* derived hook --------------------------------------------- */\n    select<U>(selector: (v: T) => U, eq: (a: U, b: U) => boolean = arePropsEqual): EventHook<U> {\n      return (listener: Listener<U>, options?: EventControlOptions) => {\n        let prev: U | undefined;\n\n        /* replay */\n        if (_value !== undefined) {\n          const mapped = selector(_value);\n          prev = mapped;\n          listener(mapped);\n        }\n\n        /* subscribe to parent */\n        return baseOn(\n          (next) => {\n            const mapped = selector(next);\n            if (prev === undefined || !eq(prev, mapped)) {\n              prev = mapped;\n              listener(mapped);\n            }\n          },\n          options as EventControlOptions | undefined,\n        ); // pass control opts straight through\n      };\n    },\n  };\n}\n","/* ------------------------------------------------------------------ */\n/*  enumEntries – iterate over enum-keyed Records with strong typing  */\n/* ------------------------------------------------------------------ */\n\ntype EnumKey = string | number;\n\n/**\n * Iterate over a Record whose keys are enum members (numeric or string),\n * getting back a fully-typed `[key, value]` tuple array.\n *\n * Usage:\n *   for (const [subtype, defaults] of enumEntries(this.state.toolDefaults)) {\n *     // subtype is inferred as keyof ToolDefaultsBySubtype\n *   }\n */\nexport function enumEntries<E extends EnumKey, V>(record: Record<E, V>): Array<[E, V]> {\n  // Tell TS the values are V (not unknown) *before* we map.\n  return (Object.entries(record) as [string, V][]).map(([k, v]) => {\n    // Numeric enums come out of Object.entries as \"0\", \"1\", …  → convert.\n    const maybeNum = Number(k);\n    const typedKey: E =\n      Number.isFinite(maybeNum) && k.trim() !== '' // looks like a number?\n        ? (maybeNum as unknown as E) // numeric enum key\n        : (k as unknown as E); // string enum key\n\n    return [typedKey, v]; // v is already typed as V\n  });\n}\n","/**\n * Clockwise direction\n * @public\n */\nexport enum Rotation {\n  Degree0 = 0,\n  Degree90 = 1,\n  Degree180 = 2,\n  Degree270 = 3,\n}\n\n/** Clamp a Position to device-pixel integers (floor) */\nexport function toIntPos(p: Position): Position {\n  return { x: Math.floor(p.x), y: Math.floor(p.y) };\n}\n\n/** Clamp a Size so it never truncates right / bottom (ceil) */\nexport function toIntSize(s: Size): Size {\n  return { width: Math.ceil(s.width), height: Math.ceil(s.height) };\n}\n\n/** Apply both rules to a Rect */\nexport function toIntRect(r: Rect): Rect {\n  return {\n    origin: toIntPos(r.origin),\n    size: toIntSize(r.size),\n  };\n}\n\n/**\n * Calculate degree that match the rotation type\n * @param rotation - type of rotation\n * @returns rotated degree\n *\n * @public\n */\nexport function calculateDegree(rotation: Rotation) {\n  switch (rotation) {\n    case Rotation.Degree0:\n      return 0;\n    case Rotation.Degree90:\n      return 90;\n    case Rotation.Degree180:\n      return 180;\n    case Rotation.Degree270:\n      return 270;\n  }\n}\n\n/**\n * Calculate angle that match the rotation type\n * @param rotation - type of rotation\n * @returns rotated angle\n *\n * @public\n */\nexport function calculateAngle(rotation: Rotation) {\n  return (calculateDegree(rotation) * Math.PI) / 180;\n}\n\n/**\n * Represent the size of object\n *\n * @public\n */\nexport interface Size {\n  /**\n   * width of the object\n   */\n  width: number;\n\n  /**\n   * height of the object\n   */\n  height: number;\n}\n\n/**\n * Represents a rectangle defined by its left, top, right, and bottom edges\n *\n * @public\n */\nexport interface Box {\n  /**\n   * The x-coordinate of the left edge\n   */\n  left: number;\n\n  /**\n   * The y-coordinate of the top edge\n   */\n  top: number;\n\n  /**\n   * The x-coordinate of the right edge\n   */\n  right: number;\n\n  /**\n   * The y-coordinate of the bottom edge\n   */\n  bottom: number;\n}\n\n/**\n * Swap the width and height of the size object\n * @param size - the original size\n * @returns swapped size\n *\n * @public\n */\nexport function swap(size: Size): Size {\n  const { width, height } = size;\n\n  return {\n    width: height,\n    height: width,\n  };\n}\n\n/**\n * Transform size with specified rotation angle and scale factor\n * @param size - orignal size of rect\n * @param rotation - rotation angle\n * @param scaleFactor - - scale factor\n * @returns size that has been transformed\n *\n * @public\n */\nexport function transformSize(size: Size, rotation: Rotation, scaleFactor: number): Size {\n  size = rotation % 2 === 0 ? size : swap(size);\n\n  return {\n    width: size.width * scaleFactor,\n    height: size.height * scaleFactor,\n  };\n}\n\n/**\n * position of point\n *\n * @public\n */\nexport interface Position {\n  /**\n   * x coordinate\n   */\n  x: number;\n\n  /**\n   * y coordinate\n   */\n  y: number;\n}\n\n/**\n * Quadrilateral\n *\n * @public\n */\nexport interface Quad {\n  p1: Position;\n  p2: Position;\n  p3: Position;\n  p4: Position;\n}\n\n/**\n * Convert quadrilateral to rectangle\n * @param q - quadrilateral\n * @returns rectangle\n *\n * @public\n */\nexport function quadToRect(q: Quad): Rect {\n  const xs = [q.p1.x, q.p2.x, q.p3.x, q.p4.x];\n  const ys = [q.p1.y, q.p2.y, q.p3.y, q.p4.y];\n\n  return {\n    origin: { x: Math.min(...xs), y: Math.min(...ys) },\n    size: {\n      width: Math.max(...xs) - Math.min(...xs),\n      height: Math.max(...ys) - Math.min(...ys),\n    },\n  };\n}\n\n/**\n * Convert rectangle to quadrilateral\n * @param r - rectangle\n * @returns quadrilateral\n *\n * @public\n */\nexport function rectToQuad(r: Rect): Quad {\n  return {\n    p1: { x: r.origin.x, y: r.origin.y },\n    p2: { x: r.origin.x + r.size.width, y: r.origin.y },\n    p3: { x: r.origin.x + r.size.width, y: r.origin.y + r.size.height },\n    p4: { x: r.origin.x, y: r.origin.y + r.size.height },\n  };\n}\n\n/**\n * Rotate the container and calculate the new position for a point\n * in specified position\n * @param containerSize - size of the container\n * @param position - position of the point\n * @param rotation - rotated angle\n * @returns new position of the point\n *\n * @public\n */\nexport function rotatePosition(\n  containerSize: Size,\n  position: Position,\n  rotation: Rotation,\n): Position {\n  let x = position.x;\n  let y = position.y;\n\n  switch (rotation) {\n    case Rotation.Degree0:\n      x = position.x;\n      y = position.y;\n      break;\n    case Rotation.Degree90:\n      x = containerSize.height - position.y;\n      y = position.x;\n      break;\n    case Rotation.Degree180:\n      x = containerSize.width - position.x;\n      y = containerSize.height - position.y;\n      break;\n    case Rotation.Degree270:\n      x = position.y;\n      y = containerSize.width - position.x;\n      break;\n  }\n\n  return {\n    x,\n    y,\n  };\n}\n\n/**\n * Calculate the position of point by scaling the container\n * @param position - position of the point\n * @param scaleFactor - factor of scaling\n * @returns new position of point\n *\n * @public\n */\nexport function scalePosition(position: Position, scaleFactor: number): Position {\n  return {\n    x: position.x * scaleFactor,\n    y: position.y * scaleFactor,\n  };\n}\n\n/**\n * Calculate the position of the point by applying the specified transformation\n * @param containerSize - size of container\n * @param position - position of the point\n * @param rotation - rotated angle\n * @param scaleFactor - factor of scaling\n * @returns new position of point\n *\n * @public\n */\nexport function transformPosition(\n  containerSize: Size,\n  position: Position,\n  rotation: Rotation,\n  scaleFactor: number,\n): Position {\n  return scalePosition(rotatePosition(containerSize, position, rotation), scaleFactor);\n}\n\n/**\n * Restore the position in a transformed cotainer\n * @param containerSize - size of the container\n * @param position - position of the point\n * @param rotation - rotated angle\n * @param scaleFactor - factor of scaling\n * @returns the original position of the point\n *\n * @public\n */\nexport function restorePosition(\n  containerSize: Size,\n  position: Position,\n  rotation: Rotation,\n  scaleFactor: number,\n): Position {\n  return scalePosition(\n    rotatePosition(containerSize, position, (4 - rotation) % 4),\n    1 / scaleFactor,\n  );\n}\n\n/**\n * representation of rectangle\n *\n * @public\n */\nexport interface Rect {\n  /**\n   * origin of the rectangle\n   */\n  origin: Position;\n\n  /**\n   * size of the rectangle\n   */\n  size: Size;\n}\n\n/**\n * Calculate the rect after rotated the container\n * @param containerSize - size of container\n * @param rect - target rect\n * @param rotation - rotation angle\n * @returns rotated rect\n *\n * @public\n */\nexport function rotateRect(containerSize: Size, rect: Rect, rotation: Rotation): Rect {\n  let x = rect.origin.x;\n  let y = rect.origin.y;\n  let size = rect.size;\n\n  switch (rotation) {\n    case Rotation.Degree0:\n      break;\n    case Rotation.Degree90:\n      x = containerSize.height - rect.origin.y - rect.size.height;\n      y = rect.origin.x;\n      size = swap(rect.size);\n      break;\n    case Rotation.Degree180:\n      x = containerSize.width - rect.origin.x - rect.size.width;\n      y = containerSize.height - rect.origin.y - rect.size.height;\n      break;\n    case Rotation.Degree270:\n      x = rect.origin.y;\n      y = containerSize.width - rect.origin.x - rect.size.width;\n      size = swap(rect.size);\n      break;\n  }\n\n  return {\n    origin: {\n      x,\n      y,\n    },\n    size: {\n      width: size.width,\n      height: size.height,\n    },\n  };\n}\n\n/**\n * Scale the rectangle\n * @param rect - rectangle\n * @param scaleFactor - factor of scaling\n * @returns new rectangle\n *\n * @public\n */\nexport function scaleRect(rect: Rect, scaleFactor: number): Rect {\n  return {\n    origin: {\n      x: rect.origin.x * scaleFactor,\n      y: rect.origin.y * scaleFactor,\n    },\n    size: {\n      width: rect.size.width * scaleFactor,\n      height: rect.size.height * scaleFactor,\n    },\n  };\n}\n\n/**\n * Calculate new rectangle after transforming the container\n * @param containerSize - size of the container\n * @param rect - the target rectangle\n * @param rotation - rotated angle\n * @param scaleFactor - factor of scaling\n * @returns new rectangle after transformation\n *\n * @public\n */\nexport function transformRect(\n  containerSize: Size,\n  rect: Rect,\n  rotation: Rotation,\n  scaleFactor: number,\n): Rect {\n  return scaleRect(rotateRect(containerSize, rect, rotation), scaleFactor);\n}\n\n/**\n * Calculate new rectangle before transforming the container\n * @param containerSize - size of the container\n * @param rect - the target rectangle\n * @param rotation - rotated angle\n * @param scaleFactor - factor of scaling\n * @returns original rectangle before transformation\n *\n * @public\n */\nexport function restoreRect(\n  containerSize: Size,\n  rect: Rect,\n  rotation: Rotation,\n  scaleFactor: number,\n): Rect {\n  return scaleRect(rotateRect(containerSize, rect, (4 - rotation) % 4), 1 / scaleFactor);\n}\n\n/**\n * Calculate the original offset in a transformed container\n * @param offset - position of the point\n * @param rotation - rotated angle\n * @param scaleFactor - factor of scaling\n * @returns original position of the point\n *\n * @public\n */\nexport function restoreOffset(offset: Position, rotation: Rotation, scaleFactor: number): Position {\n  let offsetX = offset.x;\n  let offsetY = offset.y;\n  switch (rotation) {\n    case Rotation.Degree0:\n      offsetX = offset.x / scaleFactor;\n      offsetY = offset.y / scaleFactor;\n      break;\n    case Rotation.Degree90:\n      offsetX = offset.y / scaleFactor;\n      offsetY = -offset.x / scaleFactor;\n      break;\n    case Rotation.Degree180:\n      offsetX = -offset.x / scaleFactor;\n      offsetY = -offset.y / scaleFactor;\n      break;\n    case Rotation.Degree270:\n      offsetX = -offset.y / scaleFactor;\n      offsetY = offset.x / scaleFactor;\n      break;\n  }\n\n  return {\n    x: offsetX,\n    y: offsetY,\n  };\n}\n\n/**\n * Return the smallest rectangle that encloses *all* `rects`.\n * If the array is empty, returns `null`.\n *\n * @param rects - array of rectangles\n * @returns smallest rectangle that encloses all the rectangles\n *\n * @public\n */\nexport function boundingRect(rects: Rect[]): Rect | null {\n  if (rects.length === 0) return null;\n\n  let minX = rects[0].origin.x,\n    minY = rects[0].origin.y,\n    maxX = rects[0].origin.x + rects[0].size.width,\n    maxY = rects[0].origin.y + rects[0].size.height;\n\n  for (const r of rects) {\n    minX = Math.min(minX, r.origin.x);\n    minY = Math.min(minY, r.origin.y);\n    maxX = Math.max(maxX, r.origin.x + r.size.width);\n    maxY = Math.max(maxY, r.origin.y + r.size.height);\n  }\n\n  return {\n    origin: {\n      x: minX,\n      y: minY,\n    },\n    size: {\n      width: maxX - minX,\n      height: maxY - minY,\n    },\n  };\n}\n\nexport interface Matrix {\n  a: number;\n  b: number;\n  c: number;\n  d: number;\n  e: number;\n  f: number;\n}\n\n/**\n * Build a CTM that maps *PDF-space* inside the annotation\n * → *device-space* inside the bitmap, honouring\n * zoom (scaleFactor × dpr) **and** page-rotation.\n */\n/** build the CTM for any page-rotation */\nexport const makeMatrix = (rectangle: Rect, rotation: Rotation, scaleFactor: number): Matrix => {\n  const { width, height } = rectangle.size;\n\n  switch (rotation) {\n    case Rotation.Degree0: // normal\n      return {\n        a: scaleFactor,\n        b: 0,\n        c: 0,\n        d: -scaleFactor,\n        e: 0,\n        f: height * scaleFactor,\n      };\n\n    case Rotation.Degree90: // +90° CW\n      //  matrix =   [ 0  s ]   after flip-Y → no extra translation needed\n      //              [ s  0 ]\n      return {\n        a: 0,\n        b: scaleFactor,\n        c: scaleFactor,\n        d: 0,\n        e: 0,\n        f: 0,\n      };\n\n    case Rotation.Degree180: // +180°\n      return {\n        a: -scaleFactor,\n        b: 0,\n        c: 0,\n        d: scaleFactor,\n        e: width * scaleFactor,\n        f: 0,\n      };\n\n    case Rotation.Degree270: // +270° CW  (= 90° CCW)\n      //  flips the other way, so we nudge it back inside the bitmap\n      return {\n        a: 0,\n        b: -scaleFactor,\n        c: -scaleFactor,\n        d: 0,\n        e: height * scaleFactor,\n        f: width * scaleFactor,\n      };\n  }\n};\n","/**\n * logger for logging\n *\n * @public\n */\nexport interface Logger {\n  /**\n   * Log debug message\n   * @param source - source of log\n   * @param category - category of log\n   * @param args - parameters of log\n   * @returns\n   *\n   * @public\n   */\n  debug: (source: string, category: string, ...args: any) => void;\n\n  /**\n   * Log infor message\n   * @param source - source of log\n   * @param category - category of log\n   * @param args - parameters of log\n   * @returns\n   *\n   * @public\n   */\n  info: (source: string, category: string, ...args: any) => void;\n\n  /**\n   * Log warning message\n   * @param source - source of log\n   * @param category - category of log\n   * @param args - parameters of log\n   * @returns\n   *\n   * @public\n   */\n  warn: (source: string, category: string, ...args: any) => void;\n  /**\n   * Log error message\n   * @param source - source of log\n   * @param category - category of log\n   * @param args - parameters of log\n   * @returns\n   *\n   * @public\n   */\n  error: (source: string, category: string, ...args: any) => void;\n\n  /**\n   * Log performance log\n   * @param source - source of log\n   * @param category - category of log\n   * @param event - event of log\n   * @param phase - event phase of log\n   * @param args - parameters of log\n   * @returns\n   *\n   * @public\n   */\n  perf: (\n    source: string,\n    category: string,\n    event: string,\n    phase: 'Begin' | 'End',\n    ...args: any\n  ) => void;\n}\n\n/**\n * Logger that log nothing, it will ignore all the logs\n *\n * @public\n */\nexport class NoopLogger implements Logger {\n  /** {@inheritDoc Logger.debug} */\n  debug() {}\n  /** {@inheritDoc Logger.info} */\n  info() {}\n  /** {@inheritDoc Logger.warn} */\n  warn() {}\n  /** {@inheritDoc Logger.error} */\n  error() {}\n  /** {@inheritDoc Logger.perf} */\n  perf() {}\n}\n\n/**\n * Logger that use console as the output\n *\n * @public\n */\nexport class ConsoleLogger implements Logger {\n  /** {@inheritDoc Logger.debug} */\n  debug(source: string, category: string, ...args: any) {\n    console.debug(`${source}.${category}`, ...args);\n  }\n\n  /** {@inheritDoc Logger.info} */\n  info(source: string, category: string, ...args: any) {\n    console.info(`${source}.${category}`, ...args);\n  }\n\n  /** {@inheritDoc Logger.warn} */\n  warn(source: string, category: string, ...args: any) {\n    console.warn(`${source}.${category}`, ...args);\n  }\n\n  /** {@inheritDoc Logger.error} */\n  error(source: string, category: string, ...args: any) {\n    console.error(`${source}.${category}`, ...args);\n  }\n\n  /** {@inheritDoc Logger.perf} */\n  perf(source: string, category: string, event: string, phase: 'Begin' | 'End', ...args: any) {\n    console.info(`${source}.${category}.${event}.${phase}`, ...args);\n  }\n}\n\n/**\n * Level of log\n *\n * @public\n */\nexport enum LogLevel {\n  Debug = 0,\n  Info,\n  Warn,\n  Error,\n}\n\n/**\n * Logger that support filtering by log level\n *\n * @public\n */\nexport class LevelLogger implements Logger {\n  /**\n   * create new LevelLogger\n   * @param logger - the original logger\n   * @param level - log level that used for filtering, all logs lower than this level will be filtered out\n   */\n  constructor(\n    private logger: Logger,\n    private level: LogLevel,\n  ) {}\n\n  /** {@inheritDoc Logger.debug} */\n  debug(source: string, category: string, ...args: any) {\n    if (this.level <= LogLevel.Debug) {\n      this.logger.debug(source, category, ...args);\n    }\n  }\n\n  /** {@inheritDoc Logger.info} */\n  info(source: string, category: string, ...args: any) {\n    if (this.level <= LogLevel.Info) {\n      this.logger.info(source, category, ...args);\n    }\n  }\n\n  /** {@inheritDoc Logger.warn} */\n  warn(source: string, category: string, ...args: any) {\n    if (this.level <= LogLevel.Warn) {\n      this.logger.warn(source, category, ...args);\n    }\n  }\n\n  /** {@inheritDoc Logger.error} */\n  error(source: string, category: string, ...args: any) {\n    if (this.level <= LogLevel.Error) {\n      this.logger.error(source, category, ...args);\n    }\n  }\n\n  /** {@inheritDoc Logger.perf} */\n  perf(source: string, category: string, event: string, phase: 'Begin' | 'End', ...args: any) {\n    this.logger.perf(source, category, event, phase, ...args);\n  }\n}\n\n/**\n * Logger for performance tracking\n *\n * @public\n */\nexport class PerfLogger implements Logger {\n  /**\n   * create new PerfLogger\n   */\n  constructor() {}\n\n  /** {@inheritDoc Logger.debug} */\n  debug(source: string, category: string, ...args: any) {}\n\n  /** {@inheritDoc Logger.info} */\n  info(source: string, category: string, ...args: any) {}\n\n  /** {@inheritDoc Logger.warn} */\n  warn(source: string, category: string, ...args: any) {}\n\n  /** {@inheritDoc Logger.error} */\n  error(source: string, category: string, ...args: any) {}\n\n  /** {@inheritDoc Logger.perf} */\n  perf(\n    source: string,\n    category: string,\n    event: string,\n    phase: 'Begin' | 'End',\n    identifier: string,\n    ...args: any\n  ) {\n    switch (phase) {\n      case 'Begin':\n        window.performance.mark(`${source}.${category}.${event}.${phase}.${identifier}`, {\n          detail: args,\n        });\n        break;\n      case 'End':\n        window.performance.mark(`${source}.${category}.${event}.${phase}.${identifier}`, {\n          detail: args,\n        });\n        window.performance.measure(\n          `${source}.${category}.${event}.Measure.${identifier}`,\n          `${source}.${category}.${event}.Begin.${identifier}`,\n          `${source}.${category}.${event}.End.${identifier}`,\n        );\n        break;\n    }\n  }\n}\n\n/**\n * Logger that will track and call child loggers\n *\n * @public\n */\nexport class AllLogger implements Logger {\n  /**\n   * create new PerfLogger\n   */\n  constructor(private loggers: Logger[]) {}\n\n  /** {@inheritDoc Logger.debug} */\n  debug(source: string, category: string, ...args: any) {\n    for (const logger of this.loggers) {\n      logger.debug(source, category, ...args);\n    }\n  }\n\n  /** {@inheritDoc Logger.info} */\n  info(source: string, category: string, ...args: any) {\n    for (const logger of this.loggers) {\n      logger.info(source, category, ...args);\n    }\n  }\n\n  /** {@inheritDoc Logger.warn} */\n  warn(source: string, category: string, ...args: any) {\n    for (const logger of this.loggers) {\n      logger.warn(source, category, ...args);\n    }\n  }\n\n  /** {@inheritDoc Logger.error} */\n  error(source: string, category: string, ...args: any) {\n    for (const logger of this.loggers) {\n      logger.error(source, category, ...args);\n    }\n  }\n\n  /** {@inheritDoc Logger.perf} */\n  perf(source: string, category: string, event: string, phase: 'Begin' | 'End', ...args: any) {\n    for (const logger of this.loggers) {\n      logger.perf(source, category, event, phase, ...args);\n    }\n  }\n}\n","/**\n * Stage of task\n *\n * @public\n */\nexport enum TaskStage {\n  /**\n   * Task is pending, means it just start executing\n   */\n  Pending = 0,\n  /**\n   * Task is succeed\n   */\n  Resolved = 1,\n  /**\n   * Task is failed\n   */\n  Rejected = 2,\n  /**\n   * Task is aborted\n   */\n  Aborted = 3,\n}\n\nexport interface TaskError<D> {\n  /**\n   * task error type\n   */\n  type: 'reject' | 'abort';\n  /**\n   * task error\n   */\n  reason: D;\n}\n\n/**\n * callback that will be called when task is resolved\n *\n * @public\n */\nexport type ResolvedCallback<R> = (r: R) => void;\n\n/**\n * callback that will be called when task is rejected\n *\n * @public\n */\nexport type RejectedCallback<D> = (e: TaskError<D>) => void;\n\n/**\n * Task state in different stage\n *\n * @public\n */\nexport type TaskState<R, D> =\n  | {\n      stage: TaskStage.Pending;\n    }\n  | {\n      stage: TaskStage.Resolved;\n      result: R;\n    }\n  | {\n      stage: TaskStage.Rejected;\n      reason: D;\n    }\n  | {\n      stage: TaskStage.Aborted;\n      reason: D;\n    };\n\n/**\n * Result type for allSettled\n *\n * @public\n */\nexport type TaskSettledResult<R, D> =\n  | { status: 'resolved'; value: R }\n  | { status: 'rejected'; reason: D }\n  | { status: 'aborted'; reason: D };\n\nexport class TaskAbortedError<D> extends Error {\n  constructor(reason: D) {\n    super(`Task aborted: ${JSON.stringify(reason)}`);\n    this.name = 'TaskAbortedError';\n  }\n}\n\nexport class TaskRejectedError<D> extends Error {\n  constructor(reason: D) {\n    super(`Task rejected: ${JSON.stringify(reason)}`);\n    this.name = 'TaskRejectedError';\n  }\n}\n\n/**\n * Base class of task\n *\n * @public\n */\nexport class Task<R, D> {\n  state: TaskState<R, D> = {\n    stage: TaskStage.Pending,\n  };\n  /**\n   * callbacks that will be executed when task is resolved\n   */\n  resolvedCallbacks: ResolvedCallback<R>[] = [];\n  /**\n   * callbacks that will be executed when task is rejected\n   */\n  rejectedCallbacks: RejectedCallback<D>[] = [];\n\n  /**\n   * Promise that will be resolved when task is settled\n   */\n  private _promise: Promise<R> | null = null;\n\n  /**\n   * Convert task to promise\n   * @returns promise that will be resolved when task is settled\n   */\n  toPromise(): Promise<R> {\n    if (!this._promise) {\n      this._promise = new Promise((resolve, reject) => {\n        this.wait(\n          (result) => resolve(result),\n          (error) => {\n            if (error.type === 'abort') {\n              reject(new TaskAbortedError(error.reason));\n            } else {\n              reject(new TaskRejectedError(error.reason));\n            }\n          },\n        );\n      });\n    }\n    return this._promise;\n  }\n\n  /**\n   * wait for task to be settled\n   * @param resolvedCallback - callback for resolved value\n   * @param rejectedCallback - callback for rejected value\n   */\n  wait(resolvedCallback: ResolvedCallback<R>, rejectedCallback: RejectedCallback<D>) {\n    switch (this.state.stage) {\n      case TaskStage.Pending:\n        this.resolvedCallbacks.push(resolvedCallback);\n        this.rejectedCallbacks.push(rejectedCallback);\n        break;\n      case TaskStage.Resolved:\n        resolvedCallback(this.state.result);\n        break;\n      case TaskStage.Rejected:\n        rejectedCallback({\n          type: 'reject',\n          reason: this.state.reason,\n        });\n        break;\n      case TaskStage.Aborted:\n        rejectedCallback({\n          type: 'abort',\n          reason: this.state.reason,\n        });\n        break;\n    }\n  }\n\n  /**\n   * resolve task with specific result\n   * @param result - result value\n   */\n  resolve(result: R) {\n    if (this.state.stage === TaskStage.Pending) {\n      this.state = {\n        stage: TaskStage.Resolved,\n        result,\n      };\n      for (const resolvedCallback of this.resolvedCallbacks) {\n        try {\n          resolvedCallback(result);\n        } catch (e) {\n          /* ignore */\n        }\n      }\n      this.resolvedCallbacks = [];\n      this.rejectedCallbacks = [];\n    }\n  }\n\n  /**\n   * reject task with specific reason\n   * @param reason - abort reason\n   *\n   */\n  reject(reason: D) {\n    if (this.state.stage === TaskStage.Pending) {\n      this.state = {\n        stage: TaskStage.Rejected,\n        reason,\n      };\n      for (const rejectedCallback of this.rejectedCallbacks) {\n        try {\n          rejectedCallback({\n            type: 'reject',\n            reason,\n          });\n        } catch (e) {\n          /*ignore */\n        }\n      }\n      this.resolvedCallbacks = [];\n      this.rejectedCallbacks = [];\n    }\n  }\n\n  /**\n   * abort task with specific reason\n   * @param reason - abort reason\n   */\n  abort(reason: D) {\n    if (this.state.stage === TaskStage.Pending) {\n      this.state = {\n        stage: TaskStage.Aborted,\n        reason,\n      };\n      for (const rejectedCallback of this.rejectedCallbacks) {\n        try {\n          rejectedCallback({\n            type: 'abort',\n            reason,\n          });\n        } catch (e) {\n          /* ignore */\n        }\n      }\n      this.resolvedCallbacks = [];\n      this.rejectedCallbacks = [];\n    }\n  }\n\n  /**\n   * fail task with a TaskError from another task\n   * This is a convenience method for error propagation between tasks\n   * @param error - TaskError from another task\n   */\n  fail(error: TaskError<D>) {\n    if (error.type === 'abort') {\n      this.abort(error.reason);\n    } else {\n      this.reject(error.reason);\n    }\n  }\n\n  /**\n   * Static method to wait for all tasks to resolve\n   * Returns a new task that resolves with an array of all results\n   * Rejects immediately if any task fails\n   *\n   * @param tasks - array of tasks to wait for\n   * @returns new task that resolves when all input tasks resolve\n   * @public\n   */\n  static all<R extends readonly Task<any, any>[]>(\n    tasks: R,\n  ): Task<{ [K in keyof R]: R[K] extends Task<infer U, any> ? U : never }, any> {\n    type ResultType = { [K in keyof R]: R[K] extends Task<infer U, any> ? U : never };\n\n    const combinedTask = new Task<ResultType, any>();\n\n    if (tasks.length === 0) {\n      combinedTask.resolve([] as any);\n      return combinedTask;\n    }\n\n    const results: any[] = new Array(tasks.length);\n    let resolvedCount = 0;\n    let isSettled = false;\n\n    tasks.forEach((task, index) => {\n      task.wait(\n        (result) => {\n          if (isSettled) return;\n\n          results[index] = result;\n          resolvedCount++;\n\n          if (resolvedCount === tasks.length) {\n            isSettled = true;\n            combinedTask.resolve(results as ResultType);\n          }\n        },\n        (error) => {\n          if (isSettled) return;\n\n          isSettled = true;\n          if (error.type === 'abort') {\n            combinedTask.abort(error.reason);\n          } else {\n            combinedTask.reject(error.reason);\n          }\n        },\n      );\n    });\n\n    return combinedTask;\n  }\n\n  /**\n   * Static method to wait for all tasks to settle (resolve, reject, or abort)\n   * Always resolves with an array of settlement results\n   *\n   * @param tasks - array of tasks to wait for\n   * @returns new task that resolves when all input tasks settle\n   * @public\n   */\n  static allSettled<R extends readonly Task<any, any>[]>(\n    tasks: R,\n  ): Task<\n    { [K in keyof R]: R[K] extends Task<infer U, infer E> ? TaskSettledResult<U, E> : never },\n    never\n  > {\n    type ResultType = {\n      [K in keyof R]: R[K] extends Task<infer U, infer E> ? TaskSettledResult<U, E> : never;\n    };\n\n    const combinedTask = new Task<ResultType, never>();\n\n    if (tasks.length === 0) {\n      combinedTask.resolve([] as any);\n      return combinedTask;\n    }\n\n    const results: any[] = new Array(tasks.length);\n    let settledCount = 0;\n\n    tasks.forEach((task, index) => {\n      task.wait(\n        (result) => {\n          results[index] = { status: 'resolved', value: result };\n          settledCount++;\n\n          if (settledCount === tasks.length) {\n            combinedTask.resolve(results as ResultType);\n          }\n        },\n        (error) => {\n          results[index] = {\n            status: error.type === 'abort' ? 'aborted' : 'rejected',\n            reason: error.reason,\n          };\n          settledCount++;\n\n          if (settledCount === tasks.length) {\n            combinedTask.resolve(results as ResultType);\n          }\n        },\n      );\n    });\n\n    return combinedTask;\n  }\n\n  /**\n   * Static method that resolves/rejects with the first task that settles\n   *\n   * @param tasks - array of tasks to race\n   * @returns new task that settles with the first input task that settles\n   * @public\n   */\n  static race<R extends readonly Task<any, any>[]>(\n    tasks: R,\n  ): Task<\n    R[number] extends Task<infer U, any> ? U : never,\n    R[number] extends Task<any, infer E> ? E : never\n  > {\n    type ResultType = R[number] extends Task<infer U, any> ? U : never;\n    type ErrorType = R[number] extends Task<any, infer E> ? E : never;\n\n    const combinedTask = new Task<ResultType, ErrorType>();\n\n    if (tasks.length === 0) {\n      combinedTask.reject('No tasks provided' as ErrorType);\n      return combinedTask;\n    }\n\n    let isSettled = false;\n\n    tasks.forEach((task) => {\n      task.wait(\n        (result) => {\n          if (isSettled) return;\n          isSettled = true;\n          combinedTask.resolve(result);\n        },\n        (error) => {\n          if (isSettled) return;\n          isSettled = true;\n          if (error.type === 'abort') {\n            combinedTask.abort(error.reason);\n          } else {\n            combinedTask.reject(error.reason);\n          }\n        },\n      );\n    });\n\n    return combinedTask;\n  }\n\n  /**\n   * Utility to track progress of multiple tasks\n   *\n   * @param tasks - array of tasks to track\n   * @param onProgress - callback called when any task completes\n   * @returns new task that resolves when all input tasks resolve\n   * @public\n   */\n  static withProgress<R extends readonly Task<any, any>[]>(\n    tasks: R,\n    onProgress?: (completed: number, total: number) => void,\n  ): Task<{ [K in keyof R]: R[K] extends Task<infer U, any> ? U : never }, any> {\n    const combinedTask = Task.all(tasks);\n\n    if (onProgress) {\n      let completedCount = 0;\n      tasks.forEach((task) => {\n        task.wait(\n          () => {\n            completedCount++;\n            onProgress(completedCount, tasks.length);\n          },\n          () => {\n            completedCount++;\n            onProgress(completedCount, tasks.length);\n          },\n        );\n      });\n    }\n\n    return combinedTask;\n  }\n}\n\n/**\n * Type that represent the result of executing task\n */\nexport type TaskReturn<T extends Task<any, any>> =\n  T extends Task<infer R, infer E>\n    ? { type: 'result'; value: R } | { type: 'error'; value: TaskError<E> }\n    : never;\n","import { WebAlphaColor } from './color';\nimport { Size, Rect, Position, Rotation, Quad } from './geometry';\nimport { Task, TaskError } from './task';\n\n/**\n * Representation of pdf page\n *\n * @public\n */\nexport interface PdfPageObject {\n  /**\n   * Index of this page, starts from 0\n   */\n  index: number;\n\n  /**\n   * Orignal size of this page\n   */\n  size: Size;\n}\n\n/**\n * Representation of pdf page with rotated size\n *\n * @public\n */\nexport interface PdfPageObjectWithRotatedSize extends PdfPageObject {\n  /**\n   * Rotated size of this page\n   */\n  rotatedSize: Size;\n}\n\n/**\n * Representation of pdf document\n *\n * @public\n */\nexport interface PdfDocumentObject {\n  /**\n   * Identity of document\n   */\n  id: string;\n\n  /**\n   * Count of pages in this document\n   */\n  pageCount: number;\n\n  /**\n   * Pages in this document\n   */\n  pages: PdfPageObject[];\n}\n\n/**\n * metadata of pdf document\n *\n * @public\n */\nexport interface PdfMetadataObject {\n  /**\n   * title of the document\n   */\n  title: string;\n  /**\n   * author of the document\n   */\n  author: string;\n  /**\n   * subject of the document\n   */\n  subject: string;\n  /**\n   * keywords of the document\n   */\n  keywords: string;\n  /**\n   * producer of the document\n   */\n  producer: string;\n  /**\n   * creator of the document\n   */\n  creator: string;\n  /**\n   * creation date of the document\n   */\n  creationDate: string;\n  /**\n   * modification date of the document\n   */\n  modificationDate: string;\n}\n\n/**\n * Unicode **soft-hyphen** marker (`U+00AD`).\n * Often embedded by PDF generators as discretionary hyphens.\n *\n * @public\n */\nexport const PdfSoftHyphenMarker = '\\u00AD';\n\n/**\n * Unicode **zero-width space** (`U+200B`).\n *\n * @public\n */\nexport const PdfZeroWidthSpace = '\\u200B';\n\n/**\n * Unicode **word-joiner** (`U+2060`) – zero-width no-break.\n *\n * @public\n */\nexport const PdfWordJoiner = '\\u2060';\n\n/**\n * Unicode **byte-order mark / zero-width&nbsp;no-break space** (`U+FEFF`).\n *\n * @public\n */\nexport const PdfBomOrZwnbsp = '\\uFEFF';\n\n/**\n * Unicode non-character `U+FFFE`.\n *\n * @public\n */\nexport const PdfNonCharacterFFFE = '\\uFFFE';\n\n/**\n * Unicode non-character `U+FFFF`.\n *\n * @public\n */\nexport const PdfNonCharacterFFFF = '\\uFFFF';\n\n/**\n * **Frozen list** of all unwanted markers in canonical order.\n *\n * @public\n */\nexport const PdfUnwantedTextMarkers = Object.freeze([\n  PdfSoftHyphenMarker,\n  PdfZeroWidthSpace,\n  PdfWordJoiner,\n  PdfBomOrZwnbsp,\n  PdfNonCharacterFFFE,\n  PdfNonCharacterFFFF,\n] as const);\n\n/**\n * Compiled regular expression that matches any unwanted marker.\n *\n * @public\n */\nexport const PdfUnwantedTextRegex = new RegExp(`[${PdfUnwantedTextMarkers.join('')}]`, 'g');\n\n/**\n * Remove all {@link PdfUnwantedTextMarkers | unwanted markers} from *text*.\n *\n * @param text - raw text extracted from PDF\n * @returns cleaned text\n *\n * @public\n */\nexport function stripPdfUnwantedMarkers(text: string): string {\n  return text.replace(PdfUnwantedTextRegex, '');\n}\n\n/**\n * zoom mode\n *\n * @public\n */\nexport enum PdfZoomMode {\n  Unknown = 0,\n  /**\n   * Zoom level with specified offset.\n   */\n  XYZ = 1,\n  /**\n   * Fit both the width and height of the page (whichever smaller).\n   */\n  FitPage = 2,\n  /**\n   * Fit the page width.\n   */\n  FitHorizontal = 3,\n  /**\n   * Fit the page height.\n   */\n  FitVertical = 4,\n  /**\n   * Fit a specific rectangle area within the window.\n   */\n  FitRectangle = 5,\n}\n\n/**\n * Blend mode\n *\n * @public\n */\nexport enum PdfBlendMode {\n  Normal = 0,\n  Multiply = 1,\n  Screen = 2,\n  Overlay = 3,\n  Darken = 4,\n  Lighten = 5,\n  ColorDodge = 6,\n  ColorBurn = 7,\n  HardLight = 8,\n  SoftLight = 9,\n  Difference = 10,\n  Exclusion = 11,\n  Hue = 12,\n  Saturation = 13,\n  Color = 14,\n  Luminosity = 15,\n}\n\n/** Extra UI sentinel for “multiple different values selected”. */\nexport const MixedBlendMode = Symbol('mixed');\nexport type UiBlendModeValue = PdfBlendMode | typeof MixedBlendMode;\n\ninterface BlendModeInfo {\n  /** Pdf enum value */\n  id: PdfBlendMode;\n  /** Human label for UI */\n  label: string;\n  /** CSS mix-blend-mode token */\n  css: string;\n}\n\n/** Canonical ordered descriptor list (matches enum numeric order). */\nconst BLEND_MODE_INFOS: readonly BlendModeInfo[] = Object.freeze([\n  { id: PdfBlendMode.Normal, label: 'Normal', css: 'normal' },\n  { id: PdfBlendMode.Multiply, label: 'Multiply', css: 'multiply' },\n  { id: PdfBlendMode.Screen, label: 'Screen', css: 'screen' },\n  { id: PdfBlendMode.Overlay, label: 'Overlay', css: 'overlay' },\n  { id: PdfBlendMode.Darken, label: 'Darken', css: 'darken' },\n  { id: PdfBlendMode.Lighten, label: 'Lighten', css: 'lighten' },\n  { id: PdfBlendMode.ColorDodge, label: 'Color Dodge', css: 'color-dodge' },\n  { id: PdfBlendMode.ColorBurn, label: 'Color Burn', css: 'color-burn' },\n  { id: PdfBlendMode.HardLight, label: 'Hard Light', css: 'hard-light' },\n  { id: PdfBlendMode.SoftLight, label: 'Soft Light', css: 'soft-light' },\n  { id: PdfBlendMode.Difference, label: 'Difference', css: 'difference' },\n  { id: PdfBlendMode.Exclusion, label: 'Exclusion', css: 'exclusion' },\n  { id: PdfBlendMode.Hue, label: 'Hue', css: 'hue' },\n  { id: PdfBlendMode.Saturation, label: 'Saturation', css: 'saturation' },\n  { id: PdfBlendMode.Color, label: 'Color', css: 'color' },\n  { id: PdfBlendMode.Luminosity, label: 'Luminosity', css: 'luminosity' },\n]);\n\n/* Build O(1) maps once */\nconst enumToInfo: Record<PdfBlendMode, BlendModeInfo> = BLEND_MODE_INFOS.reduce(\n  (m, info) => {\n    m[info.id] = info;\n    return m;\n  },\n  {} as Record<PdfBlendMode, BlendModeInfo>,\n);\n\nconst cssToEnum = BLEND_MODE_INFOS.reduce<Record<string, PdfBlendMode>>((m, info) => {\n  m[info.css] = info.id;\n  return m;\n}, {});\n\n/** Get descriptor (falls back to Normal if unknown number sneaks in).\n *\n * @public\n */\nexport function getBlendModeInfo(mode: PdfBlendMode): BlendModeInfo {\n  return enumToInfo[mode] ?? enumToInfo[PdfBlendMode.Normal];\n}\n\n/** Convert enum → CSS value for `mix-blend-mode`.\n *\n * @public\n */\nexport function blendModeToCss(mode: PdfBlendMode): string {\n  return getBlendModeInfo(mode).css;\n}\n\n/** Convert CSS token → enum (returns undefined if not recognized).\n *\n * @public\n */\nexport function cssToBlendMode(value: string): PdfBlendMode | undefined {\n  return cssToEnum[value as keyof typeof cssToEnum];\n}\n\n/** Enum → UI label.\n *\n * @public\n */\nexport function blendModeLabel(mode: PdfBlendMode): string {\n  return getBlendModeInfo(mode).label;\n}\n\n/**\n * For a selection of annotations: returns the common enum value, or Mixed sentinel.\n *\n * @public\n */\nexport function reduceBlendModes(modes: readonly PdfBlendMode[]): UiBlendModeValue {\n  if (!modes.length) return PdfBlendMode.Normal;\n  const first = modes[0];\n  return modes.every((m) => m === first) ? first : MixedBlendMode;\n}\n\n/** Options for a <select>.\n *\n * @public\n */\nexport const blendModeSelectOptions = BLEND_MODE_INFOS.map((info) => ({\n  value: info.id,\n  label: info.label,\n}));\n\n/** Provide a label when Mixed sentinel used (UI convenience).\n *\n * @public\n */\nexport function uiBlendModeDisplay(value: UiBlendModeValue): string {\n  return value === MixedBlendMode ? '(mixed)' : blendModeLabel(value);\n}\n\n/**\n * Representation of the linked destination\n *\n * @public\n */\nexport interface PdfDestinationObject {\n  /**\n   * Index of target page\n   */\n  pageIndex: number;\n  /**\n   * zoom config for target destination\n   */\n  zoom:\n    | {\n        mode: PdfZoomMode.Unknown;\n      }\n    | { mode: PdfZoomMode.XYZ; params: { x: number; y: number; zoom: number } }\n    | {\n        mode: PdfZoomMode.FitPage;\n      }\n    | {\n        mode: PdfZoomMode.FitHorizontal;\n      }\n    | {\n        mode: PdfZoomMode.FitVertical;\n      }\n    | {\n        mode: PdfZoomMode.FitRectangle;\n      };\n  view: number[];\n}\n\n/**\n * Type of pdf action\n *\n * @public\n */\nexport enum PdfActionType {\n  Unsupported = 0,\n  /**\n   * Goto specified position in this document\n   */\n  Goto = 1,\n  /**\n   * Goto specified position in another document\n   */\n  RemoteGoto = 2,\n  /**\n   * Goto specified URI\n   */\n  URI = 3,\n  /**\n   * Launch specifed application\n   */\n  LaunchAppOrOpenFile = 4,\n}\n\nexport type PdfImage = {\n  data: Uint8ClampedArray;\n  width: number;\n  height: number;\n};\n\n/**\n * Representation of pdf action\n *\n * @public\n */\nexport type PdfActionObject =\n  | {\n      type: PdfActionType.Unsupported;\n    }\n  | {\n      type: PdfActionType.Goto;\n      destination: PdfDestinationObject;\n    }\n  | {\n      type: PdfActionType.RemoteGoto;\n      destination: PdfDestinationObject;\n    }\n  | {\n      type: PdfActionType.URI;\n      uri: string;\n    }\n  | {\n      type: PdfActionType.LaunchAppOrOpenFile;\n      path: string;\n    };\n\n/**\n * target of pdf link\n *\n * @public\n */\nexport type PdfLinkTarget =\n  | {\n      type: 'action';\n      action: PdfActionObject;\n    }\n  | {\n      type: 'destination';\n      destination: PdfDestinationObject;\n    };\n\n/**\n * PDF bookmark\n *\n * @public\n */\nexport interface PdfBookmarkObject {\n  /**\n   * title of bookmark\n   */\n  title: string;\n\n  /**\n   * target of bookmark\n   */\n  target?: PdfLinkTarget | undefined;\n\n  /**\n   * bookmarks in the next level\n   */\n  children?: PdfBookmarkObject[];\n}\n\n/**\n * Pdf Signature\n *\n * @public\n */\nexport interface PdfSignatureObject {\n  /**\n   * contents of signature\n   */\n  contents: ArrayBuffer;\n\n  /**\n   * byte range of signature\n   */\n  byteRange: ArrayBuffer;\n\n  /**\n   * sub filters of signature\n   */\n  subFilter: ArrayBuffer;\n\n  /**\n   * reason of signature\n   */\n  reason: string;\n\n  /**\n   * creation time of signature\n   */\n  time: string;\n\n  /**\n   * MDP\n   */\n  docMDP: number;\n}\n\n/**\n * Bookmark tree of pdf\n *\n * @public\n */\nexport interface PdfBookmarksObject {\n  bookmarks: PdfBookmarkObject[];\n}\n\n/**\n * Text rectangle in pdf page\n *\n * @public\n */\nexport interface PdfTextRectObject {\n  /**\n   * Font of the text\n   */\n  font: {\n    /**\n     * font family\n     */\n    family: string;\n\n    /**\n     * font size\n     */\n    size: number;\n  };\n\n  /**\n   * content in this rectangle area\n   */\n  content: string;\n\n  /**\n   * rectangle of the text\n   */\n  rect: Rect;\n}\n\n/**\n * Color\n *\n * @public\n */\nexport interface PdfAlphaColor {\n  /**\n   * red\n   */\n  red: number;\n  /**\n   * green\n   */\n  green: number;\n  /**\n   * blue\n   */\n  blue: number;\n  /**\n   * alpha\n   */\n  alpha: number;\n}\n\n/**\n * Annotation type\n *\n * @public\n */\nexport enum PdfAnnotationSubtype {\n  UNKNOWN = 0,\n  TEXT,\n  LINK,\n  FREETEXT,\n  LINE,\n  SQUARE,\n  CIRCLE,\n  POLYGON,\n  POLYLINE,\n  HIGHLIGHT,\n  UNDERLINE,\n  SQUIGGLY,\n  STRIKEOUT,\n  STAMP,\n  CARET,\n  INK,\n  POPUP,\n  FILEATTACHMENT,\n  SOUND,\n  MOVIE,\n  WIDGET,\n  SCREEN,\n  PRINTERMARK,\n  TRAPNET,\n  WATERMARK,\n  THREED,\n  RICHMEDIA,\n  XFAWIDGET,\n  REDACT,\n}\n\n/**\n * Name of annotation type\n *\n * @public\n */\nexport const PdfAnnotationSubtypeName: Record<PdfAnnotationSubtype, string> = {\n  [PdfAnnotationSubtype.UNKNOWN]: 'unknow',\n  [PdfAnnotationSubtype.TEXT]: 'text',\n  [PdfAnnotationSubtype.LINK]: 'link',\n  [PdfAnnotationSubtype.FREETEXT]: 'freetext',\n  [PdfAnnotationSubtype.LINE]: 'line',\n  [PdfAnnotationSubtype.SQUARE]: 'square',\n  [PdfAnnotationSubtype.CIRCLE]: 'circle',\n  [PdfAnnotationSubtype.POLYGON]: 'polygon',\n  [PdfAnnotationSubtype.POLYLINE]: 'polyline',\n  [PdfAnnotationSubtype.HIGHLIGHT]: 'highlight',\n  [PdfAnnotationSubtype.UNDERLINE]: 'underline',\n  [PdfAnnotationSubtype.SQUIGGLY]: 'squiggly',\n  [PdfAnnotationSubtype.STRIKEOUT]: 'strikeout',\n  [PdfAnnotationSubtype.STAMP]: 'stamp',\n  [PdfAnnotationSubtype.CARET]: 'caret',\n  [PdfAnnotationSubtype.INK]: 'ink',\n  [PdfAnnotationSubtype.POPUP]: 'popup',\n  [PdfAnnotationSubtype.FILEATTACHMENT]: 'fileattachment',\n  [PdfAnnotationSubtype.SOUND]: 'sound',\n  [PdfAnnotationSubtype.MOVIE]: 'movie',\n  [PdfAnnotationSubtype.WIDGET]: 'widget',\n  [PdfAnnotationSubtype.SCREEN]: 'screen',\n  [PdfAnnotationSubtype.PRINTERMARK]: 'printermark',\n  [PdfAnnotationSubtype.TRAPNET]: 'trapnet',\n  [PdfAnnotationSubtype.WATERMARK]: 'watermark',\n  [PdfAnnotationSubtype.THREED]: 'threed',\n  [PdfAnnotationSubtype.RICHMEDIA]: 'richmedia',\n  [PdfAnnotationSubtype.XFAWIDGET]: 'xfawidget',\n  [PdfAnnotationSubtype.REDACT]: 'redact',\n};\n\n/**\n * Status of pdf annotation\n *\n * @public\n */\nexport enum PdfAnnotationObjectStatus {\n  /**\n   * Annotation is created\n   */\n  Created,\n  /**\n   * Annotation is committed to PDF file\n   */\n  Committed,\n}\n\n/**\n * Appearance mode\n *\n * @public\n */\nexport enum AppearanceMode {\n  Normal = 0,\n  Rollover = 1,\n  Down = 2,\n}\n\n/**\n * State of pdf annotation\n *\n * @public\n */\nexport enum PdfAnnotationState {\n  /**\n   * Annotation is active\n   */\n  Marked = 'Marked',\n  /**\n   * Annotation is unmarked\n   */\n  Unmarked = 'Unmarked',\n  /**\n   * Annotation is ink\n   */\n  Accepted = 'Accepted',\n  /**\n   * Annotation is rejected\n   */\n  Rejected = 'Rejected',\n  /**\n   * Annotation is complete\n   */\n  Complete = 'Complete',\n  /**\n   * Annotation is cancelled\n   */\n  Cancelled = 'Cancelled',\n  /**\n   * Annotation is none\n   */\n  None = 'None',\n}\n\n/**\n * State model of pdf annotation\n *\n * @public\n */\nexport enum PdfAnnotationStateModel {\n  /**\n   * Annotation is marked\n   */\n  Marked = 'Marked',\n  /**\n   * Annotation is reviewed\n   */\n  Reviewed = 'Reviewed',\n}\n\n/**\n * Basic information of pdf annotation\n *\n * @public\n */\nexport interface PdfAnnotationObjectBase {\n  /**\n   * Author of the annotation\n   */\n  author?: string;\n\n  /**\n   * Modified date of the annotation\n   */\n  modified?: Date;\n\n  /**\n   * blend mode of annotation\n   */\n  blendMode?: PdfBlendMode;\n\n  /**\n   * intent of annotation\n   */\n  intent?: string;\n\n  /**\n   * Sub type of annotation\n   */\n  type: PdfAnnotationSubtype;\n\n  /**\n   * The index of page that this annotation belong to\n   */\n  pageIndex: number;\n\n  /**\n   * id of the annotation\n   */\n  id: number;\n\n  /**\n   * Rectangle of the annotation\n   */\n  rect: Rect;\n}\n\n/**\n * Popup annotation\n *\n * @public\n */\nexport interface PdfPopupAnnoObject extends PdfAnnotationObjectBase {\n  /** {@inheritDoc PdfAnnotationObjectBase.type} */\n  type: PdfAnnotationSubtype.POPUP;\n  /**\n   * Contents of the popup\n   */\n  contents: string;\n\n  /**\n   * Whether the popup is opened or not\n   */\n  open: boolean;\n\n  /**\n   * In reply to id\n   */\n  inReplyToId?: number;\n}\n\n/**\n * Pdf Link annotation\n *\n * @public\n */\nexport interface PdfLinkAnnoObject extends PdfAnnotationObjectBase {\n  /** {@inheritDoc PdfAnnotationObjectBase.type} */\n  type: PdfAnnotationSubtype.LINK;\n  /**\n   * Text of the link\n   */\n  text: string;\n  /**\n   * target of the link\n   */\n  target: PdfLinkTarget | undefined;\n}\n\n/**\n * Pdf Text annotation\n *\n * @public\n */\nexport interface PdfTextAnnoObject extends PdfAnnotationObjectBase {\n  /** {@inheritDoc PdfAnnotationObjectBase.type} */\n  type: PdfAnnotationSubtype.TEXT;\n  /**\n   * Text contents of the annotation\n   */\n  contents: string;\n\n  /**\n   * color of text annotation\n   */\n  color?: string;\n\n  /**\n   * opacity of text annotation\n   */\n  opacity?: number;\n\n  /**\n   * In reply to id\n   */\n  inReplyToId?: number;\n\n  /**\n   * State of the text annotation\n   */\n  state?: PdfAnnotationState;\n\n  /**\n   * State model of the text annotation\n   */\n  stateModel?: PdfAnnotationStateModel;\n}\n\n/**\n * Type of form field\n *\n * @public\n */\nexport enum PDF_FORM_FIELD_TYPE {\n  /**\n   * Unknow\n   */\n  UNKNOWN = 0,\n  /**\n   * push button type\n   */\n  PUSHBUTTON = 1,\n  /**\n   * check box type.\n   */\n  CHECKBOX = 2,\n  /**\n   * radio button type.\n   */\n  RADIOBUTTON = 3,\n  /**\n   * combo box type.\n   */\n  COMBOBOX = 4,\n  /**\n   * list box type.\n   */\n  LISTBOX = 5,\n  /**\n   *  text field type\n   */\n  TEXTFIELD = 6,\n  /**\n   * signature field type.\n   */\n  SIGNATURE = 7,\n  /**\n   * Generic XFA type.\n   */\n  XFA = 8,\n  /**\n   * XFA check box type.\n   */\n  XFA_CHECKBOX = 9,\n  /**\n   * XFA combo box type.\n   */\n  XFA_COMBOBOX = 10,\n  /**\n   * XFA image field type.\n   */\n  XFA_IMAGEFIELD = 11,\n  /**\n   * XFA list box type.\n   */\n  XFA_LISTBOX = 12,\n  /**\n   * XFA push button type.\n   */\n  XFA_PUSHBUTTON = 13,\n  /**\n   * XFA signture field type.\n   */\n  XFA_SIGNATURE = 14,\n  /**\n   * XFA text field type.\n   */\n  XFA_TEXTFIELD = 15,\n}\n\nexport enum PdfAnnotationColorType {\n  Color = 0,\n  InteriorColor = 1,\n}\n\n/**\n * Border style of pdf annotation\n *\n * @public\n */\nexport enum PdfAnnotationBorderStyle {\n  UNKNOWN = 0,\n  SOLID = 1,\n  DASHED = 2,\n  BEVELED = 3,\n  INSET = 4,\n  UNDERLINE = 5,\n  CLOUDY = 6,\n}\n\n/**\n * Flag of pdf annotation\n *\n * @public\n */\nexport enum PdfAnnotationFlags {\n  NONE = 0,\n  INVISIBLE = 1 << 0,\n  HIDDEN = 1 << 1,\n  PRINT = 1 << 2,\n  NO_ZOOM = 1 << 3,\n  NO_ROTATE = 1 << 4,\n  NO_VIEW = 1 << 5,\n  READ_ONLY = 1 << 6,\n  LOCKED = 1 << 7,\n  TOGGLE_NOVIEW = 1 << 8,\n}\n\n/**\n * Flag of form field\n *\n * @public\n */\nexport enum PDF_FORM_FIELD_FLAG {\n  NONE = 0,\n  READONLY = 1 << 0,\n  REQUIRED = 1 << 1,\n  NOEXPORT = 1 << 2,\n  TEXT_MULTIPLINE = 1 << 12,\n  TEXT_PASSWORD = 1 << 13,\n  CHOICE_COMBO = 1 << 17,\n  CHOICE_EDIT = 1 << 18,\n  CHOICE_MULTL_SELECT = 1 << 21,\n}\n\n/**\n * Type of pdf object\n *\n * @public\n */\nexport enum PdfPageObjectType {\n  UNKNOWN = 0,\n  TEXT = 1,\n  PATH = 2,\n  IMAGE = 3,\n  SHADING = 4,\n  FORM = 5,\n}\n\n/**\n * Options of pdf widget annotation\n *\n * @public\n */\nexport interface PdfWidgetAnnoOption {\n  label: string;\n  isSelected: boolean;\n}\n\nexport type PdfAnnotationFlagName =\n  | 'invisible'\n  | 'hidden'\n  | 'print'\n  | 'noZoom'\n  | 'noRotate'\n  | 'noView'\n  | 'readOnly'\n  | 'locked'\n  | 'toggleNoView';\n\ntype FlagMap = Partial<\n  Record<Exclude<PdfAnnotationFlags, PdfAnnotationFlags.NONE>, PdfAnnotationFlagName>\n>;\n\nexport const PdfAnnotationFlagName: Readonly<FlagMap> = Object.freeze({\n  [PdfAnnotationFlags.INVISIBLE]: 'invisible',\n  [PdfAnnotationFlags.HIDDEN]: 'hidden',\n  [PdfAnnotationFlags.PRINT]: 'print',\n  [PdfAnnotationFlags.NO_ZOOM]: 'noZoom',\n  [PdfAnnotationFlags.NO_ROTATE]: 'noRotate',\n  [PdfAnnotationFlags.NO_VIEW]: 'noView',\n  [PdfAnnotationFlags.READ_ONLY]: 'readOnly',\n  [PdfAnnotationFlags.LOCKED]: 'locked',\n  [PdfAnnotationFlags.TOGGLE_NOVIEW]: 'toggleNoView',\n} as const);\n\n/** Build a reverse map once so look-ups are O(1)                      */\nconst PdfAnnotationFlagValue: Record<PdfAnnotationFlagName, PdfAnnotationFlags> = Object.entries(\n  PdfAnnotationFlagName,\n).reduce(\n  (acc, [bit, name]) => {\n    acc[name as PdfAnnotationFlagName] = Number(bit) as PdfAnnotationFlags;\n    return acc;\n  },\n  {} as Record<PdfAnnotationFlagName, PdfAnnotationFlags>,\n);\n\n/**\n * Convert the raw bit-mask coming from `FPDFAnnot_GetFlags()` into\n * an array of human-readable flag names (“invisible”, “print”…).\n */\nexport function flagsToNames(raw: number): PdfAnnotationFlagName[] {\n  return (\n    Object.keys(PdfAnnotationFlagName) as unknown as Exclude<\n      PdfAnnotationFlags,\n      PdfAnnotationFlags.NONE\n    >[]\n  )\n    .filter((flag) => (raw & flag) !== 0)\n    .map((flag) => PdfAnnotationFlagName[flag]!);\n}\n\n/**\n * Convert an array of flag-names back into the numeric mask that\n * PDFium expects for `FPDFAnnot_SetFlags()`.\n */\nexport function namesToFlags(names: readonly PdfAnnotationFlagName[]): PdfAnnotationFlags {\n  return names.reduce<PdfAnnotationFlags>(\n    (mask, name) => mask | PdfAnnotationFlagValue[name],\n    PdfAnnotationFlags.NONE,\n  );\n}\n\n/**\n * Field of PDF widget annotation\n *\n * @public\n */\nexport interface PdfWidgetAnnoField {\n  /**\n   * flag of field\n   */\n  flag: PDF_FORM_FIELD_FLAG;\n  /**\n   * name of field\n   */\n  name: string;\n  /**\n   * alternate name of field\n   */\n  alternateName: string;\n  /**\n   * type of field\n   */\n  type: PDF_FORM_FIELD_TYPE;\n  /**\n   * value of field\n   */\n  value: string;\n  /**\n   * whether field is checked\n   */\n  isChecked: boolean;\n  /**\n   * options of field\n   */\n  options: PdfWidgetAnnoOption[];\n}\n\n/**\n * PDF widget object\n *\n * @public\n */\nexport interface PdfWidgetAnnoObject extends PdfAnnotationObjectBase {\n  /** {@inheritDoc PdfAnnotationObjectBase.type} */\n  type: PdfAnnotationSubtype.WIDGET;\n  /**\n   * Field of pdf widget object\n   */\n  field: PdfWidgetAnnoField;\n}\n\n/**\n * Pdf file attachments annotation\n *\n * @public\n */\nexport interface PdfFileAttachmentAnnoObject extends PdfAnnotationObjectBase {\n  /** {@inheritDoc PdfAnnotationObjectBase.type} */\n  type: PdfAnnotationSubtype.FILEATTACHMENT;\n}\n\n/**\n * ink list in pdf ink annotation\n *\n * @public\n */\nexport interface PdfInkListObject {\n  points: Position[];\n}\n\n/**\n * Pdf ink annotation\n *\n * @public\n */\nexport interface PdfInkAnnoObject extends PdfAnnotationObjectBase {\n  /** {@inheritDoc PdfAnnotationObjectBase.type} */\n  type: PdfAnnotationSubtype.INK;\n  /**\n   * ink list of annotation\n   */\n  inkList: PdfInkListObject[];\n  /**\n   * color of ink annotation\n   */\n  color: string;\n\n  /**\n   * opacity of ink annotation\n   */\n  opacity: number;\n\n  /**\n   * stroke-width of ink annotation\n   */\n  strokeWidth: number;\n}\n\n/**\n * Pdf polygon annotation\n *\n * @public\n */\nexport interface PdfPolygonAnnoObject extends PdfAnnotationObjectBase {\n  /** {@inheritDoc PdfAnnotationObjectBase.type} */\n  type: PdfAnnotationSubtype.POLYGON;\n  /**\n   * vertices of annotation\n   */\n  vertices: Position[];\n}\n\n/**\n * PDF polyline annotation\n *\n * @public\n */\nexport interface PdfPolylineAnnoObject extends PdfAnnotationObjectBase {\n  /** {@inheritDoc PdfAnnotationObjectBase.type} */\n  type: PdfAnnotationSubtype.POLYLINE;\n  /**\n   * vertices of annotation\n   */\n  vertices: Position[];\n}\n\n/**\n * PDF line annotation\n *\n * @public\n */\nexport interface PdfLineAnnoObject extends PdfAnnotationObjectBase {\n  /** {@inheritDoc PdfAnnotationObjectBase.type} */\n  type: PdfAnnotationSubtype.LINE;\n  /**\n   * start point of line\n   */\n  startPoint: Position;\n  /**\n   * end point of line\n   */\n  endPoint: Position;\n}\n\n/**\n * PDF highlight annotation\n *\n * @public\n */\nexport interface PdfHighlightAnnoObject extends PdfAnnotationObjectBase {\n  /** {@inheritDoc PdfAnnotationObjectBase.type} */\n  type: PdfAnnotationSubtype.HIGHLIGHT;\n\n  /**\n   * Text contents of the highlight annotation\n   */\n  contents?: string;\n\n  /**\n   * color of highlight annotation\n   */\n  color: string;\n\n  /**\n   * opacity of highlight annotation\n   */\n  opacity: number;\n\n  /**\n   * quads of highlight area\n   */\n  segmentRects: Rect[];\n}\n\n/**\n * Matrix for transformation, in the form [a b c d e f], equivalent to:\n * | a  b  0 |\n * | c  d  0 |\n * | e  f  1 |\n *\n * Translation is performed with [1 0 0 1 tx ty].\n * Scaling is performed with [sx 0 0 sy 0 0].\n * See PDF Reference 1.7, 4.2.2 Common Transformations for more.\n */\nexport interface PdfTransformMatrix {\n  a: number;\n  b: number;\n  c: number;\n  d: number;\n  e: number;\n  f: number;\n}\n\n/**\n * type of segment type in pdf path object\n *\n * @public\n */\nexport enum PdfSegmentObjectType {\n  UNKNOWN = -1,\n  LINETO = 0,\n  BEZIERTO = 1,\n  MOVETO = 2,\n}\n\n/**\n * segment of path object\n *\n * @public\n */\nexport interface PdfSegmentObject {\n  type: PdfSegmentObjectType;\n  /**\n   * point of the segment\n   */\n  point: Position;\n  /**\n   * whether this segment close the path\n   */\n  isClosed: boolean;\n}\n\n/**\n * Pdf path object\n *\n * @public\n */\nexport interface PdfPathObject {\n  type: PdfPageObjectType.PATH;\n  /**\n   * bound that contains the path\n   */\n  bounds: { left: number; bottom: number; right: number; top: number };\n  /**\n   * segments of the path\n   */\n  segments: PdfSegmentObject[];\n  /**\n   * transform matrix\n   */\n  matrix: PdfTransformMatrix;\n}\n\n/**\n * Pdf image object\n *\n * @public\n */\nexport interface PdfImageObject {\n  type: PdfPageObjectType.IMAGE;\n  /**\n   * data of the image\n   */\n  imageData: ImageData;\n  /**\n   * transform matrix\n   */\n  matrix: PdfTransformMatrix;\n}\n\n/**\n * Pdf form object\n *\n * @public\n */\nexport interface PdfFormObject {\n  type: PdfPageObjectType.FORM;\n  /**\n   * objects that in this form object\n   */\n  objects: (PdfImageObject | PdfPathObject | PdfFormObject)[];\n  /**\n   * transform matrix\n   */\n  matrix: PdfTransformMatrix;\n}\n\n/**\n * Contents type of pdf stamp annotation\n *\n * @public\n */\nexport type PdfStampAnnoObjectContents = Array<PdfPathObject | PdfImageObject | PdfFormObject>;\n\n/**\n * Pdf stamp annotation\n *\n * @public\n */\nexport interface PdfStampAnnoObject extends PdfAnnotationObjectBase {\n  /** {@inheritDoc PdfAnnotationObjectBase.type} */\n  type: PdfAnnotationSubtype.STAMP;\n  /**\n   * contents in this stamp annotation\n   */\n  contents: PdfStampAnnoObjectContents;\n}\n\n/**\n * Pdf circle annotation\n *\n * @public\n */\nexport interface PdfCircleAnnoObject extends PdfAnnotationObjectBase {\n  /** {@inheritDoc PdfAnnotationObjectBase.type} */\n  type: PdfAnnotationSubtype.CIRCLE;\n  /**\n   * flags of circle annotation\n   */\n  flags: PdfAnnotationFlagName[];\n  /**\n   * color of circle annotation\n   */\n  color: string;\n  /**\n   * opacity of circle annotation\n   */\n  opacity: number;\n  /**\n   * stroke-width of circle annotation\n   */\n  strokeWidth: number;\n  /**\n   * stroke color of circle annotation\n   */\n  strokeColor: string;\n  /**\n   * stroke style of circle annotation\n   */\n  strokeStyle: PdfAnnotationBorderStyle;\n  /**\n   * stroke dash array of circle annotation\n   */\n  strokeDashArray?: number[];\n  /**\n   * cloudy border intensity of circle annotation\n   */\n  cloudyBorderIntensity?: number;\n  /**\n   * cloudy border inset of circle annotation\n   */\n  cloudyBorderInset?: number[];\n}\n\n/**\n * Pdf square annotation\n *\n * @public\n */\nexport interface PdfSquareAnnoObject extends PdfAnnotationObjectBase {\n  /** {@inheritDoc PdfAnnotationObjectBase.type} */\n  type: PdfAnnotationSubtype.SQUARE;\n  /**\n   * flags of square annotation\n   */\n  flags: PdfAnnotationFlagName[];\n  /**\n   * color of square annotation\n   */\n  color: string;\n  /**\n   * opacity of square annotation\n   */\n  opacity: number;\n  /**\n   * stroke-width of square annotation\n   */\n  strokeWidth: number;\n  /**\n   * stroke color of square annotation\n   */\n  strokeColor: string;\n  /**\n   * stroke style of square annotation\n   */\n  strokeStyle: PdfAnnotationBorderStyle;\n  /**\n   * stroke dash array of square annotation\n   */\n  strokeDashArray?: number[];\n  /**\n   * cloudy border intensity of circle annotation\n   */\n  cloudyBorderIntensity?: number;\n  /**\n   * cloudy border inset of circle annotation\n   */\n  cloudyBorderInset?: number[];\n}\n\n/**\n * Pdf squiggly annotation\n *\n * @public\n */\nexport interface PdfSquigglyAnnoObject extends PdfAnnotationObjectBase {\n  /** {@inheritDoc PdfAnnotationObjectBase.type} */\n  type: PdfAnnotationSubtype.SQUIGGLY;\n  /**\n   * Text contents of the highlight annotation\n   */\n  contents?: string;\n  /**\n   * color of strike out annotation\n   */\n  color: string;\n\n  /**\n   * opacity of strike out annotation\n   */\n  opacity: number;\n  /**\n   * quads of highlight area\n   */\n  segmentRects: Rect[];\n}\n\n/**\n * Pdf underline annotation\n *\n * @public\n */\nexport interface PdfUnderlineAnnoObject extends PdfAnnotationObjectBase {\n  /** {@inheritDoc PdfAnnotationObjectBase.type} */\n  type: PdfAnnotationSubtype.UNDERLINE;\n  /**\n   * Text contents of the highlight annotation\n   */\n  contents?: string;\n  /**\n   * color of strike out annotation\n   */\n  color: string;\n\n  /**\n   * opacity of strike out annotation\n   */\n  opacity: number;\n  /**\n   * quads of highlight area\n   */\n  segmentRects: Rect[];\n}\n\n/**\n * Pdf strike out annotation\n *\n * @public\n */\nexport interface PdfStrikeOutAnnoObject extends PdfAnnotationObjectBase {\n  /** {@inheritDoc PdfAnnotationObjectBase.type} */\n  type: PdfAnnotationSubtype.STRIKEOUT;\n  /**\n   * Text contents of the strike out annotation\n   */\n  contents?: string;\n\n  /**\n   * color of strike out annotation\n   */\n  color: string;\n\n  /**\n   * opacity of strike out annotation\n   */\n  opacity: number;\n\n  /**\n   * quads of highlight area\n   */\n  segmentRects: Rect[];\n}\n\n/**\n * Pdf caret annotation\n *\n * @public\n */\nexport interface PdfCaretAnnoObject extends PdfAnnotationObjectBase {\n  /** {@inheritDoc PdfAnnotationObjectBase.type} */\n  type: PdfAnnotationSubtype.CARET;\n}\n\n/**\n * Pdf free text annotation\n *\n * @public\n */\nexport interface PdfFreeTextAnnoObject extends PdfAnnotationObjectBase {\n  /** {@inheritDoc PdfAnnotationObjectBase.type} */\n  type: PdfAnnotationSubtype.FREETEXT;\n  contents: string;\n  richContent?: string;\n}\n\n/**\n * All annotation that support\n *\n * @public\n */\nexport type PdfSupportedAnnoObject =\n  | PdfInkAnnoObject\n  | PdfTextAnnoObject\n  | PdfLinkAnnoObject\n  | PdfPolygonAnnoObject\n  | PdfPolylineAnnoObject\n  | PdfHighlightAnnoObject\n  | PdfLineAnnoObject\n  | PdfWidgetAnnoObject\n  | PdfFileAttachmentAnnoObject\n  | PdfStampAnnoObject\n  | PdfSquareAnnoObject\n  | PdfCircleAnnoObject\n  | PdfSquigglyAnnoObject\n  | PdfUnderlineAnnoObject\n  | PdfStrikeOutAnnoObject\n  | PdfCaretAnnoObject\n  | PdfFreeTextAnnoObject;\n\n/**\n * Pdf annotation that does not support\n *\n * @public\n */\nexport interface PdfUnsupportedAnnoObject extends PdfAnnotationObjectBase {\n  type: Exclude<PdfAnnotationSubtype, PdfSupportedAnnoObject['type']>;\n}\n\n/**\n * all annotations\n *\n * @public\n */\nexport type PdfAnnotationObject = PdfSupportedAnnoObject | PdfUnsupportedAnnoObject;\n\n/**\n * Pdf attachment\n *\n * @public\n */\nexport interface PdfAttachmentObject {\n  index: number;\n  name: string;\n  creationDate: string;\n  checksum: string;\n}\n\n/**\n * Pdf engine features\n *\n * @public\n */\nexport enum PdfEngineFeature {\n  RenderPage,\n  RenderPageRect,\n  Thumbnails,\n  Bookmarks,\n  Annotations,\n}\n\n/**\n * All operations for this engine\n *\n * @public\n */\nexport enum PdfEngineOperation {\n  Create,\n  Read,\n  Update,\n  Delete,\n}\n\n/**\n * flags to match the text during searching\n *\n * @public\n */\nexport enum MatchFlag {\n  None = 0,\n  MatchCase = 1,\n  MatchWholeWord = 2,\n  MatchConsecutive = 4,\n}\n\n/**\n * Union all the flags\n * @param flags - all the flags\n * @returns union of flags\n *\n * @public\n */\nexport function unionFlags(flags: MatchFlag[]) {\n  return flags.reduce((flag, currFlag) => {\n    return flag | currFlag;\n  }, MatchFlag.None);\n}\n\n/**\n * Image conversion types\n *\n * @public\n */\nexport type ImageConversionTypes = 'image/webp' | 'image/png' | 'image/jpeg';\n\n/**\n * Targe for searching\n *\n * @public\n */\nexport interface SearchTarget {\n  keyword: string;\n  flags: MatchFlag[];\n}\n\n/**\n * compare 2 search target\n * @param targetA - first target for search\n * @param targetB - second target for search\n * @returns whether 2 search target are the same\n *\n * @public\n */\nexport function compareSearchTarget(targetA: SearchTarget, targetB: SearchTarget) {\n  const flagA = unionFlags(targetA.flags);\n  const flagB = unionFlags(targetB.flags);\n\n  return flagA === flagB && targetA.keyword === targetB.keyword;\n}\n\n/** Context of one hit */\nexport interface TextContext {\n  /** Complete words that come *before* the hit (no ellipsis)            */\n  before: string;\n  /** Exactly the text that matched (case-preserved)                      */\n  match: string;\n  /** Complete words that come *after* the hit (no ellipsis)             */\n  after: string;\n  /** `true` ⇢ there were more words on the left that we cut off         */\n  truncatedLeft: boolean;\n  /** `true` ⇢ there were more words on the right that we cut off        */\n  truncatedRight: boolean;\n}\n\n/**\n * Text slice\n *\n * @public\n */\nexport interface PageTextSlice {\n  /**\n   * Index of the pdf page\n   */\n  pageIndex: number;\n  /**\n   * Index of the first character\n   */\n  charIndex: number;\n  /**\n   * Count of the characters\n   */\n  charCount: number;\n}\n\n/**\n * search result\n *\n * @public\n */\nexport interface SearchResult {\n  /**\n   * Index of the pdf page\n   */\n  pageIndex: number;\n  /**\n   * index of the first character\n   */\n  charIndex: number;\n  /**\n   * count of the characters\n   */\n  charCount: number;\n  /**\n   * highlight rects\n   */\n  rects: Rect[];\n  /**\n   * context of the hit\n   */\n  context: TextContext;\n}\n\n/**\n * Results of searching through the entire document\n */\nexport interface SearchAllPagesResult {\n  /**\n   * Array of all search results across all pages\n   */\n  results: SearchResult[];\n\n  /**\n   * Total number of results found\n   */\n  total: number;\n}\n\n/**\n * Glyph object\n *\n * @public\n */\nexport interface PdfGlyphObject {\n  /**\n   * Origin of the glyph\n   */\n  origin: { x: number; y: number };\n  /**\n   * Size of the glyph\n   */\n  size: { width: number; height: number };\n  /**\n   * Whether the glyph is a space\n   */\n  isSpace?: boolean;\n  /**\n   * Whether the glyph is a empty\n   */\n  isEmpty?: boolean;\n}\n\n/**\n * Glyph object\n *\n * @public\n */\nexport interface PdfGlyphSlim {\n  /**\n   * X coordinate of the glyph\n   */\n  x: number;\n  /**\n   * Y coordinate of the glyph\n   */\n  y: number;\n  /**\n   * Width of the glyph\n   */\n  width: number;\n  /**\n   * Height of the glyph\n   */\n  height: number;\n  /**\n   * Flags of the glyph\n   */\n  flags: number;\n}\n\n/**\n * Run object\n *\n * @public\n */\nexport interface PdfRun {\n  /**\n   * Rectangle of the run\n   */\n  rect: { x: number; y: number; width: number; height: number };\n  /**\n   * Start index of the run\n   */\n  charStart: number;\n  /**\n   * Glyphs of the run\n   */\n  glyphs: PdfGlyphSlim[];\n}\n\n/**\n * Page geometry\n *\n * @public\n */\nexport interface PdfPageGeometry {\n  /**\n   * Runs of the page\n   */\n  runs: PdfRun[];\n}\n\n/**\n * form field value\n * @public\n */\nexport type FormFieldValue =\n  | { kind: 'text'; text: string }\n  | { kind: 'selection'; index: number; isSelected: boolean }\n  | { kind: 'checked'; isChecked: boolean };\n\n/**\n * Transformation that will be applied to annotation\n *\n * @public\n */\nexport interface PdfAnnotationTransformation {\n  /**\n   * Translated offset\n   */\n  offset: Position;\n  /**\n   * Scaled factors\n   */\n  scale: Size;\n}\n\n/**\n * Render options\n *\n * @public\n */\nexport interface PdfRenderOptions {\n  /**\n   * Whether needs to render the page with annotations\n   */\n  withAnnotations: boolean;\n}\n\n/**\n * source can be byte array contains pdf content\n *\n * @public\n */\nexport type PdfFileContent = ArrayBuffer;\n\nexport enum PdfPermission {\n  PrintDocument = 2 ** 3,\n  ModifyContent = 2 ** 4,\n  CopyOrExtract = 2 ** 5,\n  AddOrModifyTextAnnot = 2 ** 6,\n  FillInExistingForm = 2 ** 9,\n  ExtractTextOrGraphics = 2 ** 10,\n  AssembleDocument = 2 ** 11,\n  PrintHighQuality = 2 ** 12,\n}\n\nexport enum PdfPageFlattenFlag {\n  Display = 0,\n  Print = 1,\n}\n\nexport enum PdfPageFlattenResult {\n  Fail = 0,\n  Success = 1,\n  NothingToDo = 2,\n}\n\n/**\n * Pdf File without content\n *\n * @public\n */\nexport interface PdfFileWithoutContent {\n  /**\n   * id of file\n   */\n  id: string;\n}\n\nexport interface PdfFileLoader extends PdfFileWithoutContent {\n  /**\n   * length of file\n   */\n  fileLength: number;\n  /**\n   * read block of file\n   * @param offset - offset of file\n   * @param length - length of file\n   * @returns block of file\n   */\n  callback: (offset: number, length: number) => Uint8Array;\n}\n\n/**\n * Pdf File\n *\n * @public\n */\nexport interface PdfFile extends PdfFileWithoutContent {\n  /**\n   * content of file\n   */\n  content: PdfFileContent;\n}\n\nexport interface PdfFileUrl extends PdfFileWithoutContent {\n  url: string;\n}\n\nexport interface PdfUrlOptions {\n  mode?: 'auto' | 'range-request' | 'full-fetch';\n  password?: string;\n}\n\nexport enum PdfErrorCode {\n  Ok, //  #define FPDF_ERR_SUCCESS 0    // No error.\n  Unknown, // #define FPDF_ERR_UNKNOWN 1    // Unknown error.\n  NotFound, // #define FPDF_ERR_FILE 2       // File not found or could not be opened.\n  WrongFormat, // #define FPDF_ERR_FORMAT 3     // File not in PDF format or corrupted.\n  Password, // #define FPDF_ERR_PASSWORD 4   // Password required or incorrect password.\n  Security, // #define FPDF_ERR_SECURITY 5   // Unsupported security scheme.\n  PageError, // #define FPDF_ERR_PAGE 6       // Page not found or content error.\n  XFALoad, // #ifdef PDF_ENABLE_XFA\n  XFALayout, //\n  Cancelled,\n  Initialization,\n  NotReady,\n  NotSupport,\n  LoadDoc,\n  DocNotOpen,\n  CantCloseDoc,\n  CantCreateNewDoc,\n  CantImportPages,\n  CantCreateAnnot,\n  CantSetAnnotRect,\n  CantSetAnnotContent,\n  CantRemoveInkList,\n  CantAddInkStoke,\n  CantReadAttachmentSize,\n  CantReadAttachmentContent,\n  CantFocusAnnot,\n  CantSelectText,\n  CantSelectOption,\n  CantCheckField,\n}\n\nexport interface PdfErrorReason {\n  code: PdfErrorCode;\n  message: string;\n}\n\nexport type PdfEngineError = TaskError<PdfErrorReason>;\n\nexport type PdfTask<R> = Task<R, PdfErrorReason>;\n\nexport class PdfTaskHelper {\n  /**\n   * Create a task\n   * @returns new task\n   */\n  static create<R>(): Task<R, PdfErrorReason> {\n    return new Task<R, PdfErrorReason>();\n  }\n\n  /**\n   * Create a task that has been resolved with value\n   * @param result - resolved value\n   * @returns resolved task\n   */\n  static resolve<R>(result: R): Task<R, PdfErrorReason> {\n    const task = new Task<R, PdfErrorReason>();\n    task.resolve(result);\n\n    return task;\n  }\n\n  /**\n   * Create a task that has been rejected with error\n   * @param reason - rejected error\n   * @returns rejected task\n   */\n  static reject<T = any>(reason: PdfErrorReason): Task<T, PdfErrorReason> {\n    const task = new Task<T, PdfErrorReason>();\n    task.reject(reason);\n\n    return task;\n  }\n\n  /**\n   * Create a task that has been aborted with error\n   * @param reason - aborted error\n   * @returns aborted task\n   */\n  static abort<T = any>(reason: PdfErrorReason): Task<T, PdfErrorReason> {\n    const task = new Task<T, PdfErrorReason>();\n    task.reject(reason);\n\n    return task;\n  }\n}\n\n/**\n * Pdf engine\n *\n * @public\n */\nexport interface PdfEngine<T = Blob> {\n  /**\n   * Check whether pdf engine supports this feature\n   * @param feature - which feature want to check\n   * @returns support or not\n   */\n  isSupport?: (feature: PdfEngineFeature) => PdfTask<PdfEngineOperation[]>;\n  /**\n   * Initialize the engine\n   * @returns task that indicate whether initialization is successful\n   */\n  initialize?: () => PdfTask<boolean>;\n  /**\n   * Destroy the engine\n   * @returns task that indicate whether destroy is successful\n   */\n  destroy?: () => PdfTask<boolean>;\n  /**\n   * Open a PDF from a URL with specified mode\n   * @param url - The PDF file URL\n   * @param options - Additional options including mode (auto, range-request, full-fetch) and password\n   * @returns Task that resolves with the PdfDocumentObject or an error\n   */\n  openDocumentUrl: (file: PdfFileUrl, options?: PdfUrlOptions) => PdfTask<PdfDocumentObject>;\n  /**\n   * Open pdf document from buffer\n   * @param file - pdf file\n   * @param password - protected password for this file\n   * @returns task that contains the file or error\n   */\n  openDocumentFromBuffer: (file: PdfFile, password: string) => PdfTask<PdfDocumentObject>;\n  /**\n   * Open pdf document from loader\n   * @param file - pdf file\n   * @param password - protected password for this file\n   * @returns task that contains the file or error\n   */\n  openDocumentFromLoader: (file: PdfFileLoader, password: string) => PdfTask<PdfDocumentObject>;\n  /**\n   * Get the metadata of the file\n   * @param doc - pdf document\n   * @returns task that contains the metadata or error\n   */\n  getMetadata: (doc: PdfDocumentObject) => PdfTask<PdfMetadataObject>;\n  /**\n   * Get permissions of the file\n   * @param doc - pdf document\n   * @returns task that contains a 32-bit integer indicating permission flags\n   */\n  getDocPermissions: (doc: PdfDocumentObject) => PdfTask<number>;\n  /**\n   * Get the user permissions of the file\n   * @param doc - pdf document\n   * @returns task that contains a 32-bit integer indicating permission flags\n   */\n  getDocUserPermissions: (doc: PdfDocumentObject) => PdfTask<number>;\n  /**\n   * Get the signatures of the file\n   * @param doc - pdf document\n   * @returns task that contains the signatures or error\n   */\n  getSignatures: (doc: PdfDocumentObject) => PdfTask<PdfSignatureObject[]>;\n  /**\n   * Get the bookmarks of the file\n   * @param doc - pdf document\n   * @returns task that contains the bookmarks or error\n   */\n  getBookmarks: (doc: PdfDocumentObject) => PdfTask<PdfBookmarksObject>;\n  /**\n   * Render the specified pdf page\n   * @param doc - pdf document\n   * @param page - pdf page\n   * @param scaleFactor - factor of scaling\n   * @param rotation - rotated angle\n   * @param dpr - devicePixelRatio\n   * @param options - render options\n   * @returns task contains the rendered image or error\n   */\n  renderPage: (\n    doc: PdfDocumentObject,\n    page: PdfPageObject,\n    scaleFactor: number,\n    rotation: Rotation,\n    dpr: number,\n    options: PdfRenderOptions,\n    imageType?: ImageConversionTypes,\n  ) => PdfTask<T>;\n  /**\n   * Render the specified rect of pdf page\n   * @param doc - pdf document\n   * @param page - pdf page\n   * @param scaleFactor - factor of scaling\n   * @param rotation - rotated angle\n   * @param dpr - devicePixelRatio\n   * @param rect - target rect\n   * @param options - render options\n   * @returns task contains the rendered image or error\n   */\n  renderPageRect: (\n    doc: PdfDocumentObject,\n    page: PdfPageObject,\n    scaleFactor: number,\n    rotation: Rotation,\n    dpr: number,\n    rect: Rect,\n    options: PdfRenderOptions,\n    imageType?: ImageConversionTypes,\n  ) => PdfTask<T>;\n  /**\n   * Render a single annotation into an ImageData blob.\n   *\n   * Note:  • honours Display-Matrix, page rotation & DPR\n   *        • you decide whether to include the page background\n   * @param doc - pdf document\n   * @param page - pdf page\n   * @param annotation - the annotation to render\n   * @param scaleFactor - factor of scaling\n   * @param rotation - rotated angle\n   * @param dpr - devicePixelRatio\n   * @param mode - appearance mode\n   */\n  renderAnnotation(\n    doc: PdfDocumentObject,\n    page: PdfPageObject,\n    annotation: PdfAnnotationObject,\n    scaleFactor: number,\n    rotation: Rotation,\n    dpr: number,\n    mode: AppearanceMode,\n    imageType: ImageConversionTypes,\n  ): PdfTask<T>;\n  /**\n   * Get annotations of pdf page\n   * @param doc - pdf document\n   * @param page - pdf page\n   * @param scaleFactor - factor of scaling\n   * @param rotation - rotated angle\n   * @returns task contains the annotations or error\n   */\n  getPageAnnotations: (\n    doc: PdfDocumentObject,\n    page: PdfPageObject,\n  ) => PdfTask<PdfAnnotationObject[]>;\n\n  /**\n   * Change the visible colour (and opacity) of an existing annotation.\n   * @param doc - pdf document\n   * @param page - pdf page\n   * @param annotation - the annotation to recolour\n   * @param colour - RGBA color values (0-255 per channel)\n   * @param which - 0 = stroke/fill colour (PDFium's \"colourType\" param)\n   * @returns task that indicates whether the operation succeeded\n   */\n  updateAnnotationColor: (\n    doc: PdfDocumentObject,\n    page: PdfPageObject,\n    annotation: PdfAnnotationObjectBase,\n    color: WebAlphaColor,\n    which?: number,\n  ) => PdfTask<boolean>;\n\n  /**\n   * Create a annotation on specified page\n   * @param doc - pdf document\n   * @param page - pdf page\n   * @param annotation - new annotations\n   * @returns task whether the annotations is created successfully\n   */\n  createPageAnnotation: (\n    doc: PdfDocumentObject,\n    page: PdfPageObject,\n    annotation: PdfAnnotationObject,\n  ) => PdfTask<number>;\n  /**\n   * Update a annotation on specified page\n   * @param doc - pdf document\n   * @param page - pdf page\n   * @param annotation - new annotations\n   * @returns task that indicates whether the operation succeeded\n   */\n  updatePageAnnotation: (\n    doc: PdfDocumentObject,\n    page: PdfPageObject,\n    annotation: PdfAnnotationObject,\n  ) => PdfTask<boolean>;\n  /**\n   * Remove a annotation on specified page\n   * @param doc - pdf document\n   * @param page - pdf page\n   * @param annotation - new annotations\n   * @returns task whether the annotations is removed successfully\n   */\n  removePageAnnotation: (\n    doc: PdfDocumentObject,\n    page: PdfPageObject,\n    annotation: PdfAnnotationObject,\n  ) => PdfTask<boolean>;\n  /**\n   * get all text rects in pdf page\n   * @param doc - pdf document\n   * @param page - pdf page\n   * @param scaleFactor - factor of scaling\n   * @param rotation - rotated angle\n   * @returns task contains the text rects or error\n   */\n  getPageTextRects: (\n    doc: PdfDocumentObject,\n    page: PdfPageObject,\n    scaleFactor: number,\n    rotation: Rotation,\n  ) => PdfTask<PdfTextRectObject[]>;\n  /**\n   * Render the thumbnail of specified pdf page\n   * @param doc - pdf document\n   * @param page - pdf page\n   * @param scaleFactor - factor of scaling\n   * @param rotation - rotated angle\n   * @param dpr - devicePixelRatio\n   * @param options - render options\n   * @returns task contains the rendered image or error\n   */\n  renderThumbnail: (\n    doc: PdfDocumentObject,\n    page: PdfPageObject,\n    scaleFactor: number,\n    rotation: Rotation,\n    dpr: number,\n  ) => PdfTask<T>;\n  /**\n   * Search across all pages in the document\n   * @param doc - pdf document\n   * @param keyword - search keyword\n   * @param flags - match flags for search\n   * @returns Task contains all search results throughout the document\n   */\n  searchAllPages: (\n    doc: PdfDocumentObject,\n    keyword: string,\n    flags?: MatchFlag[],\n  ) => PdfTask<SearchAllPagesResult>;\n  /**\n   * Get all annotations in this file\n   * @param doc - pdf document\n   * @returns task that contains the annotations or error\n   */\n  getAllAnnotations: (doc: PdfDocumentObject) => PdfTask<Record<number, PdfAnnotationObject[]>>;\n  /**\n   * Get all attachments in this file\n   * @param doc - pdf document\n   * @returns task that contains the attachments or error\n   */\n  getAttachments: (doc: PdfDocumentObject) => PdfTask<PdfAttachmentObject[]>;\n  /**\n   * Read content of pdf attachment\n   * @param doc - pdf document\n   * @param attachment - pdf attachments\n   * @returns task that contains the content of specified attachment or error\n   */\n  readAttachmentContent: (\n    doc: PdfDocumentObject,\n    attachment: PdfAttachmentObject,\n  ) => PdfTask<ArrayBuffer>;\n  /**\n   * Set form field value\n   * @param doc - pdf document\n   * @param page - pdf page\n   * @param annotation - pdf annotation\n   * @param text - text value\n   */\n  setFormFieldValue: (\n    doc: PdfDocumentObject,\n    page: PdfPageObject,\n    annotation: PdfWidgetAnnoObject,\n    value: FormFieldValue,\n  ) => PdfTask<boolean>;\n  /**\n   * Flatten annotations and form fields into the page contents.\n   * @param doc - pdf document\n   * @param page - pdf page\n   * @param flag - flatten flag\n   */\n  flattenPage: (\n    doc: PdfDocumentObject,\n    page: PdfPageObject,\n    flag: PdfPageFlattenFlag,\n  ) => PdfTask<PdfPageFlattenResult>;\n  /**\n   * Extract pdf pages to a new file\n   * @param doc - pdf document\n   * @param pageIndexes - indexes of pdf pages\n   * @returns task contains the new pdf file content\n   */\n  extractPages: (doc: PdfDocumentObject, pageIndexes: number[]) => PdfTask<ArrayBuffer>;\n  /**\n   * Extract text on specified pdf pages\n   * @param doc - pdf document\n   * @param pageIndexes - indexes of pdf pages\n   * @returns task contains the text\n   */\n  extractText: (doc: PdfDocumentObject, pageIndexes: number[]) => PdfTask<string>;\n  /**\n   * Extract text on specified pdf pages\n   * @param doc - pdf document\n   * @param pageIndexes - indexes of pdf pages\n   * @returns task contains the text\n   */\n  getTextSlices: (doc: PdfDocumentObject, slices: PageTextSlice[]) => PdfTask<string[]>;\n  /**\n   * Get all glyphs in the specified pdf page\n   * @param doc - pdf document\n   * @param page - pdf page\n   * @returns task contains the glyphs\n   */\n  getPageGlyphs: (doc: PdfDocumentObject, page: PdfPageObject) => PdfTask<PdfGlyphObject[]>;\n  /**\n   * Get the geometry of the specified pdf page\n   * @param doc - pdf document\n   * @param page - pdf page\n   * @returns task contains the geometry\n   */\n  getPageGeometry: (doc: PdfDocumentObject, page: PdfPageObject) => PdfTask<PdfPageGeometry>;\n  /**\n   * Merge multiple pdf documents\n   * @param files - all the pdf files\n   * @returns task contains the merged pdf file\n   */\n  merge: (files: PdfFile[]) => PdfTask<PdfFile>;\n  /**\n   * Merge specific pages from multiple PDF documents in a custom order\n   * @param mergeConfigs Array of configurations specifying which pages to merge from which documents\n   * @returns A PdfTask that resolves with the merged PDF file\n   * @public\n   */\n  mergePages: (mergeConfigs: Array<{ docId: string; pageIndices: number[] }>) => PdfTask<PdfFile>;\n  /**\n   * Save a copy of pdf document\n   * @param doc - pdf document\n   * @returns task contains the new pdf file content\n   */\n  saveAsCopy: (doc: PdfDocumentObject) => PdfTask<ArrayBuffer>;\n  /**\n   * Close pdf document\n   * @param doc - pdf document\n   * @returns task that file is closed or not\n   */\n  closeDocument: (doc: PdfDocumentObject) => PdfTask<boolean>;\n}\n\n/**\n * Method name of PdfEngine interface\n *\n * @public\n */\nexport type PdfEngineMethodName = keyof Required<PdfEngine>;\n\n/**\n * Arguments of PdfEngine method\n *\n * @public\n */\nexport type PdfEngineMethodArgs<P extends PdfEngineMethodName> = Readonly<\n  Parameters<Required<PdfEngine>[P]>\n>;\n\n/**\n * Return type of PdfEngine method\n *\n * @public\n */\nexport type PdfEngineMethodReturnType<P extends PdfEngineMethodName> = ReturnType<\n  Required<PdfEngine>[P]\n>;\n","import { PdfAlphaColor } from './pdf';\n\nexport interface WebAlphaColor {\n  color: string;\n  opacity: number;\n}\n\n/**\n * Convert a {@link PdfAlphaColor} to a CSS-style colour definition.\n *\n * @param c - the colour coming from PDFium (0-255 per channel)\n * @returns\n *   hex   – #RRGGBB (no alpha channel)\n *   opacity – 0-1 float suitable for CSS `opacity`/`rgba()`\n */\nexport function pdfAlphaColorToWebAlphaColor(c: PdfAlphaColor): WebAlphaColor {\n  const clamp = (n: number) => Math.max(0, Math.min(255, n));\n  const toHex = (n: number) => clamp(n).toString(16).padStart(2, '0');\n\n  const color = `#${toHex(c.red)}${toHex(c.green)}${toHex(c.blue)}` as const;\n  const opacity = clamp(c.alpha) / 255;\n\n  return { color, opacity };\n}\n\n/**\n * Convert a CSS hex colour + opacity back into {@link PdfAlphaColor}\n *\n * @param hex      - #RGB, #RRGGBB, or #rrggbb\n * @param opacity  - 0-1 float (values outside clamp automatically)\n */\nexport function webAlphaColorToPdfAlphaColor({ color, opacity }: WebAlphaColor): PdfAlphaColor {\n  // Normalise: #abc → #aabbcc\n  if (/^#?[0-9a-f]{3}$/i.test(color)) {\n    color = color.replace(/^#?([0-9a-f])([0-9a-f])([0-9a-f])$/i, '#$1$1$2$2$3$3').toLowerCase();\n  }\n\n  const [, r, g, b] =\n    /^#?([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$/i.exec(color) ??\n    (() => {\n      throw new Error(`Invalid hex colour: “${color}”`);\n    })();\n\n  const clamp = (n: number, hi = 255) => Math.max(0, Math.min(hi, n));\n\n  return {\n    red: parseInt(r, 16),\n    green: parseInt(g, 16),\n    blue: parseInt(b, 16),\n    alpha: clamp(Math.round(opacity * 255)),\n  };\n}\n","/**\n * Parse a PDF date string **D:YYYYMMDDHHmmSSOHH'mm'** to ISO-8601.\n *\n * Returns `undefined` if the input is malformed.\n *\n * @public\n */\nexport function pdfDateToDate(pdf?: string): Date | undefined {\n  if (!pdf?.startsWith('D:') || pdf.length < 16) return;\n\n  const y = +pdf.slice(2, 6);\n  const mo = +pdf.slice(6, 8) - 1; // JS months: 0-based\n  const d = +pdf.slice(8, 10);\n  const H = +pdf.slice(10, 12);\n  const M = +pdf.slice(12, 14);\n  const S = +pdf.slice(14, 16);\n\n  return new Date(Date.UTC(y, mo, d, H, M, S));\n}\n\n/**\n * Convert a date to a PDF date string\n * @param date - date to convert\n * @returns PDF date string\n *\n * @public\n */\nexport function dateToPdfDate(date: Date = new Date()): string {\n  const z = (n: number, len = 2) => n.toString().padStart(len, '0');\n\n  const YYYY = date.getUTCFullYear();\n  const MM = z(date.getUTCMonth() + 1);\n  const DD = z(date.getUTCDate());\n  const HH = z(date.getUTCHours());\n  const mm = z(date.getUTCMinutes());\n  const SS = z(date.getUTCSeconds());\n\n  return `D:${YYYY}${MM}${DD}${HH}${mm}${SS}`;\n}\n","/**\n * Library contains the common definitions of data types and logic\n *\n * @remarks\n * The `@embedpdf/models` defines the interface and classes which are used to\n * handling PDF files.\n *\n * @packageDocumentation\n */\nexport * from './geometry';\nexport * from './logger';\nexport * from './pdf';\nexport * from './task';\nexport * from './color';\nexport * from './date';\n\n/**\n * ignore will do nothing when called.\n *\n * @public\n */\nexport function ignore() {}\n","import { Action } from '@embedpdf/core';\nimport { PdfAnnotationObject } from '@embedpdf/models';\nimport { AnnotationDefaults, ToolDefaultsByMode } from './types';\n\n/* ─────────── action constants ─────────── */\nexport const SET_ANNOTATIONS = 'ANNOTATION/SET_ANNOTATIONS';\nexport const REINDEX_PAGE_ANNOTATIONS = 'ANNOTATION/REINDEX_PAGE';\nexport const SELECT_ANNOTATION = 'ANNOTATION/SELECT_ANNOTATION';\nexport const DESELECT_ANNOTATION = 'ANNOTATION/DESELECT_ANNOTATION';\nexport const UPDATE_TOOL_DEFAULTS = 'ANNOTATION/UPDATE_TOOL_DEFAULTS';\nexport const ADD_COLOR_PRESET = 'ANNOTATION/ADD_COLOR_PRESET';\nexport const CREATE_ANNOTATION = 'ANNOTATION/CREATE_ANNOTATION';\nexport const PATCH_ANNOTATION = 'ANNOTATION/PATCH_ANNOTATION';\nexport const DELETE_ANNOTATION = 'ANNOTATION/DELETE_ANNOTATION';\nexport const COMMIT_PENDING_CHANGES = 'ANNOTATION/COMMIT';\nexport const STORE_PDF_ID = 'ANNOTATION/STORE_PDF_ID';\nexport const PURGE_ANNOTATION = 'ANNOTATION/PURGE_ANNOTATION';\nexport const SET_ACTIVE_VARIANT = 'ANNOTATION/SET_ACTIVE_VARIANT';\n\n/* ─────────── action interfaces ─────────── */\nexport interface SetAnnotationsAction extends Action {\n  type: typeof SET_ANNOTATIONS;\n  payload: Record<number, PdfAnnotationObject[]>;\n}\nexport interface ReindexPageAnnotationsAction extends Action {\n  type: typeof REINDEX_PAGE_ANNOTATIONS;\n  payload: { pageIndex: number };\n}\nexport interface SelectAnnotationAction extends Action {\n  type: typeof SELECT_ANNOTATION;\n  payload: { pageIndex: number; localId: number };\n}\nexport interface DeselectAnnotationAction extends Action {\n  type: typeof DESELECT_ANNOTATION;\n}\n\nexport interface UpdateToolDefaultsAction extends Action {\n  type: typeof UPDATE_TOOL_DEFAULTS;\n  payload: { variantKey: string; patch: Partial<AnnotationDefaults> };\n}\n\nexport interface AddColorPresetAction extends Action {\n  type: typeof ADD_COLOR_PRESET;\n  payload: string;\n}\nexport interface CreateAnnotationAction extends Action {\n  type: typeof CREATE_ANNOTATION;\n  payload: { pageIndex: number; localId: number; annotation: PdfAnnotationObject };\n}\nexport interface PatchAnnotationAction extends Action {\n  type: typeof PATCH_ANNOTATION;\n  payload: { pageIndex: number; localId: number; patch: Partial<PdfAnnotationObject> };\n}\nexport interface DeleteAnnotationAction extends Action {\n  type: typeof DELETE_ANNOTATION;\n  payload: { pageIndex: number; localId: number };\n}\nexport interface CommitAction extends Action {\n  type: typeof COMMIT_PENDING_CHANGES;\n}\n\nexport interface StorePdfIdAction extends Action {\n  type: typeof STORE_PDF_ID;\n  payload: { uid: string; pdfId: number };\n}\n\nexport interface PurgeAnnotationAction extends Action {\n  type: typeof PURGE_ANNOTATION;\n  payload: { uid: string };\n}\n\nexport interface SetActiveVariantAction extends Action {\n  type: typeof SET_ACTIVE_VARIANT;\n  payload: string | null;\n}\n\nexport type AnnotationAction =\n  | SetAnnotationsAction\n  | ReindexPageAnnotationsAction\n  | SelectAnnotationAction\n  | DeselectAnnotationAction\n  | UpdateToolDefaultsAction\n  | AddColorPresetAction\n  | CreateAnnotationAction\n  | PatchAnnotationAction\n  | DeleteAnnotationAction\n  | CommitAction\n  | StorePdfIdAction\n  | PurgeAnnotationAction\n  | SetActiveVariantAction;\n\n/* ─────────── action creators ─────────── */\nexport const setAnnotations = (p: Record<number, PdfAnnotationObject[]>): SetAnnotationsAction => ({\n  type: SET_ANNOTATIONS,\n  payload: p,\n});\n\nexport const reindexPageAnnotations = (pageIndex: number): ReindexPageAnnotationsAction => ({\n  type: REINDEX_PAGE_ANNOTATIONS,\n  payload: { pageIndex },\n});\n\nexport const selectAnnotation = (pageIndex: number, localId: number): SelectAnnotationAction => ({\n  type: SELECT_ANNOTATION,\n  payload: { pageIndex, localId },\n});\n\nexport const deselectAnnotation = (): DeselectAnnotationAction => ({ type: DESELECT_ANNOTATION });\n\nexport const updateToolDefaults = (\n  variantKey: string,\n  patch: Partial<AnnotationDefaults>,\n): UpdateToolDefaultsAction => ({ type: UPDATE_TOOL_DEFAULTS, payload: { variantKey, patch } });\n\nexport const addColorPreset = (c: string): AddColorPresetAction => ({\n  type: ADD_COLOR_PRESET,\n  payload: c,\n});\n\nexport const createAnnotation = (\n  pageIndex: number,\n  localId: number,\n  annotation: PdfAnnotationObject,\n): CreateAnnotationAction => ({\n  type: CREATE_ANNOTATION,\n  payload: { pageIndex, localId, annotation },\n});\n\nexport const patchAnnotation = (\n  pageIndex: number,\n  localId: number,\n  patch: Partial<PdfAnnotationObject>,\n): PatchAnnotationAction => ({\n  type: PATCH_ANNOTATION,\n  payload: { pageIndex, localId, patch },\n});\n\nexport const deleteAnnotation = (pageIndex: number, localId: number): DeleteAnnotationAction => ({\n  type: DELETE_ANNOTATION,\n  payload: { pageIndex, localId },\n});\n\nexport const commitPendingChanges = (): CommitAction => ({ type: COMMIT_PENDING_CHANGES });\n\nexport const storePdfId = (uid: string, pdfId: number): StorePdfIdAction => ({\n  type: STORE_PDF_ID,\n  payload: { uid, pdfId },\n});\n\nexport const purgeAnnotation = (uid: string): PurgeAnnotationAction => ({\n  type: PURGE_ANNOTATION,\n  payload: { uid },\n});\n\nexport const setActiveVariant = (k: string | null): SetActiveVariantAction => ({\n  type: SET_ACTIVE_VARIANT,\n  payload: k,\n});\n","/**\n * Creates a stable, document-wide unique ID from a page index and a stable local ID.\n */\nexport const makeUid = (pageIndex: number, localId: number): string => `p${pageIndex}#${localId}`;\n\n/**\n * Parses a UID string back into its constituent page index and stable local ID.\n */\nexport const parseUid = (uid: string): { pageIndex: number; localId: number } => {\n  const [pg, rest] = uid.slice(1).split('#');\n  return { pageIndex: Number(pg), localId: Number(rest) };\n};\n","import { AnnotationState, SelectedAnnotation } from './types';\nimport { parseUid } from './utils';\n\n/* helper – mirrors the one in reducer */\nconst makeUid = (page: number, id: number) => `p${page}#${id}`;\n\n/* ─────────── public selectors ─────────── */\n\n/** All annotations _objects_ on a single page (order preserved). */\nexport const getAnnotationsByPageIndex = (s: AnnotationState, page: number) =>\n  (s.pages[page] ?? []).map((uid) => s.byUid[uid]);\n\n/** Shortcut: every page → list of annotation objects. */\nexport const getAnnotations = (s: AnnotationState) => {\n  const out: Record<number, ReturnType<typeof getAnnotationsByPageIndex>> = {};\n  for (const p of Object.keys(s.pages).map(Number)) out[p] = getAnnotationsByPageIndex(s, p);\n  return out;\n};\n\n/** The full `TrackedAnnotation` for the current selection. */\nexport const getSelectedAnnotation = (s: AnnotationState) =>\n  s.selectedUid ? s.byUid[s.selectedUid] : null;\n\nexport const getSelectedAnnotationWithPageIndex = (\n  s: AnnotationState,\n): SelectedAnnotation | null => {\n  if (!s.selectedUid) return null;\n  const { pageIndex, localId } = parseUid(s.selectedUid);\n  return { pageIndex, localId, annotation: s.byUid[s.selectedUid].object };\n};\n\nexport const getSelectedAnnotationByPageIndex = (s: AnnotationState, pageIndex: number) => {\n  if (!s.selectedUid) return null;\n\n  const pageUids = s.pages[pageIndex] ?? [];\n\n  // Check if the selected UID is on the requested page\n  if (pageUids.includes(s.selectedUid)) {\n    return s.byUid[s.selectedUid];\n  }\n\n  return null;\n};\n\nexport const isInAnnotationVariant = (s: AnnotationState) => s.activeVariant !== null;\nexport const getSelectedAnnotationVariant = (s: AnnotationState) => s.activeVariant;\n\n/** Check if a given anno on a page is the current selection. */\nexport const isAnnotationSelected = (s: AnnotationState, page: number, id: number) =>\n  s.selectedUid === makeUid(page, id);\n","import { PdfAnnotationSubtype, PdfAnnotationObject } from '@embedpdf/models';\n\nexport type VariantKey = string;\n\nexport const makeVariantKey = (\n  subtype: PdfAnnotationSubtype,\n  intent?: string | null | undefined,\n): VariantKey => (intent ? `${subtype}#${intent}` : `${subtype}`);\n\nexport const parseVariantKey = (\n  key: VariantKey,\n): { subtype: PdfAnnotationSubtype; intent?: string } => {\n  const [subStr, intent] = key.split('#');\n  return { subtype: Number(subStr) as PdfAnnotationSubtype, intent };\n};\n\nexport const variantKeyFromAnnotation = (a: PdfAnnotationObject): VariantKey =>\n  makeVariantKey(a.type, a.intent);\n","import {\n  BasePlugin,\n  createBehaviorEmitter,\n  enumEntries,\n  PluginRegistry,\n  SET_DOCUMENT,\n} from '@embedpdf/core';\nimport {\n  ignore,\n  PdfAnnotationObject,\n  PdfDocumentObject,\n  PdfEngine,\n  PdfErrorReason,\n  Task,\n  PdfAnnotationSubtype,\n  PdfTaskHelper,\n  PdfErrorCode,\n  PdfTask,\n  Rotation,\n  AppearanceMode,\n  PdfBlendMode,\n} from '@embedpdf/models';\nimport {\n  ActiveTool,\n  AnnotationCapability,\n  AnnotationPluginConfig,\n  AnnotationState,\n  BaseAnnotationDefaults,\n  GetPageAnnotationsOptions,\n  RenderAnnotationOptions,\n  TextMarkupSubtype,\n  ToolDefaultsByMode,\n  TrackedAnnotation,\n} from './types';\nimport {\n  setAnnotations,\n  selectAnnotation,\n  deselectAnnotation,\n  AnnotationAction,\n  updateToolDefaults,\n  addColorPreset,\n  createAnnotation,\n  patchAnnotation,\n  deleteAnnotation,\n  commitPendingChanges,\n  storePdfId,\n  purgeAnnotation,\n  reindexPageAnnotations,\n  setActiveVariant,\n} from './actions';\nimport {\n  InteractionManagerCapability,\n  InteractionManagerPlugin,\n  InteractionMode,\n} from '@embedpdf/plugin-interaction-manager';\nimport { SelectionPlugin, SelectionCapability } from '@embedpdf/plugin-selection';\nimport { HistoryPlugin, HistoryCapability, Command } from '@embedpdf/plugin-history';\nimport { getSelectedAnnotation } from './selectors';\nimport { makeUid, parseUid } from './utils';\nimport { makeVariantKey } from './variant-key';\n\nexport class AnnotationPlugin extends BasePlugin<\n  AnnotationPluginConfig,\n  AnnotationCapability,\n  AnnotationState,\n  AnnotationAction\n> {\n  static readonly id = 'annotation' as const;\n\n  private readonly ANNOTATION_HISTORY_TOPIC = 'annotations';\n\n  private readonly config: AnnotationPluginConfig;\n\n  private engine: PdfEngine;\n  private readonly state$ = createBehaviorEmitter<AnnotationState>();\n  private readonly interactionManager: InteractionManagerCapability | null;\n  private readonly selection: SelectionCapability | null;\n  private readonly history: HistoryCapability | null;\n\n  private readonly modeByVariant = new Map<string, string>();\n  private readonly variantByMode = new Map<string, string>();\n\n  private readonly activeVariantChange$ = createBehaviorEmitter<string | null>();\n  private readonly activeTool$ = createBehaviorEmitter<ActiveTool>({\n    variantKey: null,\n    defaults: null,\n  });\n\n  constructor(\n    id: string,\n    registry: PluginRegistry,\n    engine: PdfEngine,\n    config: AnnotationPluginConfig,\n  ) {\n    super(id, registry);\n    this.engine = engine;\n    this.config = config;\n\n    const selection = registry.getPlugin<SelectionPlugin>('selection');\n    this.selection = selection?.provides() ?? null;\n\n    const history = registry.getPlugin<HistoryPlugin>('history');\n    this.history = history?.provides() ?? null;\n\n    const interactionManager = registry.getPlugin<InteractionManagerPlugin>('interaction-manager');\n    this.interactionManager = interactionManager?.provides() ?? null;\n\n    this.coreStore.onAction(SET_DOCUMENT, (_action, state) => {\n      const doc = state.core.document;\n      if (doc) {\n        this.getAllAnnotations(doc);\n      }\n    });\n  }\n\n  async initialize(): Promise<void> {\n    for (const [variantKey, defaults] of Object.entries(this.state.toolDefaults)) {\n      this.registerTool(variantKey, defaults);\n    }\n\n    this.history?.onHistoryChange((topic) => {\n      if (topic === this.ANNOTATION_HISTORY_TOPIC && this.config.autoCommit !== false) {\n        this.commit();\n      }\n    });\n\n    this.interactionManager?.onModeChange((s) => {\n      const newVariant = this.variantByMode.get(s.activeMode) ?? null;\n      console.log(newVariant, this.state.activeVariant);\n      if (newVariant !== this.state.activeVariant) {\n        this.dispatch(setActiveVariant(newVariant));\n        this.activeVariantChange$.emit(newVariant);\n      }\n    });\n\n    this.selection?.onEndSelection(() => {\n      if (!this.state.activeVariant) return;\n\n      if (\n        !(\n          this.state.activeVariant === makeVariantKey(PdfAnnotationSubtype.HIGHLIGHT) ||\n          this.state.activeVariant === makeVariantKey(PdfAnnotationSubtype.UNDERLINE) ||\n          this.state.activeVariant === makeVariantKey(PdfAnnotationSubtype.STRIKEOUT) ||\n          this.state.activeVariant === makeVariantKey(PdfAnnotationSubtype.SQUIGGLY)\n        )\n      ) {\n        return;\n      }\n\n      const formattedSelection = this.selection?.getFormattedSelection();\n      if (!formattedSelection) return;\n\n      for (const selection of formattedSelection) {\n        const rect = selection.rect;\n        const segmentRects = selection.segmentRects;\n        const type = this.state.activeVariant;\n        const subtype = this.state.toolDefaults[type].subtype;\n        const color = this.state.toolDefaults[type].color;\n        const opacity = this.state.toolDefaults[type].opacity;\n        const blendMode = this.state.toolDefaults[type].blendMode ?? PdfBlendMode.Normal;\n\n        this.createAnnotation(selection.pageIndex, {\n          type: subtype as TextMarkupSubtype,\n          rect,\n          segmentRects,\n          color,\n          opacity,\n          blendMode,\n          pageIndex: selection.pageIndex,\n          id: Date.now() + Math.random(),\n        });\n      }\n\n      this.selection?.clear();\n    });\n  }\n\n  private registerTool(variantKey: string, defaults: BaseAnnotationDefaults) {\n    const modeId = defaults.interaction.mode;\n    const interactionMode: InteractionMode = {\n      id: modeId,\n      scope: 'page',\n      exclusive: defaults.interaction.exclusive,\n      cursor: defaults.interaction.cursor,\n    };\n\n    this.interactionManager?.registerMode(interactionMode);\n\n    if (defaults.textSelection) {\n      this.selection?.enableForMode(modeId);\n    }\n\n    this.modeByVariant.set(variantKey, modeId);\n    this.variantByMode.set(modeId, variantKey);\n  }\n\n  protected buildCapability(): AnnotationCapability {\n    return {\n      getPageAnnotations: (options: GetPageAnnotationsOptions) => {\n        return this.getPageAnnotations(options);\n      },\n      getSelectedAnnotation: () => {\n        return getSelectedAnnotation(this.state);\n      },\n      selectAnnotation: (pageIndex: number, annotationId: number) => {\n        this.selectAnnotation(pageIndex, annotationId);\n      },\n      deselectAnnotation: () => {\n        this.dispatch(deselectAnnotation());\n      },\n      getActiveVariant: () => {\n        return this.state.activeVariant;\n      },\n      setActiveVariant: (variantKey: string | null) => {\n        if (variantKey === this.state.activeVariant) return;\n        if (variantKey) {\n          const mode = this.modeByVariant.get(variantKey);\n          if (!mode) throw new Error(`Mode missing for variant ${variantKey}`);\n          this.interactionManager?.activate(mode);\n        } else {\n          this.interactionManager?.activate('default');\n        }\n      },\n      getToolDefaults: (variantKey) => {\n        const defaults = this.state.toolDefaults[variantKey];\n        if (!defaults) {\n          throw new Error(`No defaults found for variant: ${variantKey}`);\n        }\n        return defaults;\n      },\n      getToolDefaultsBySubtypeAndIntent: (subtype, intent) => {\n        const variantKey = makeVariantKey(subtype, intent);\n        const defaults = this.state.toolDefaults[variantKey];\n        if (!defaults) {\n          throw new Error(`No defaults found for variant: ${variantKey}`);\n        }\n        return defaults;\n      },\n      getToolDefaultsBySubtype: (subtype) => {\n        const defaults = this.state.toolDefaults[subtype];\n        if (!defaults) {\n          throw new Error(`No defaults found for subtype: ${subtype}`);\n        }\n        return defaults;\n      },\n      setToolDefaults: (variantKey, patch) => {\n        this.dispatch(updateToolDefaults(variantKey, patch));\n      },\n      getColorPresets: () => [...this.state.colorPresets],\n      addColorPreset: (color) => this.dispatch(addColorPreset(color)),\n      createAnnotation: (pageIndex: number, annotation: PdfAnnotationObject) =>\n        this.createAnnotation(pageIndex, annotation),\n      updateAnnotation: (pageIndex: number, localId: number, patch: Partial<PdfAnnotationObject>) =>\n        this.updateAnnotation(pageIndex, localId, patch),\n      deleteAnnotation: (pageIndex: number, localId: number) =>\n        this.deleteAnnotation(pageIndex, localId),\n      renderAnnotation: (options: RenderAnnotationOptions) => this.renderAnnotation(options),\n      onStateChange: this.state$.on,\n      onActiveVariantChange: this.activeVariantChange$.on,\n      onActiveToolChange: this.activeTool$.on,\n      commit: () => this.commit(),\n    };\n  }\n\n  private createActiveTool(mode: string | null, toolDefaults: ToolDefaultsByMode): ActiveTool {\n    if (mode === null) {\n      return { variantKey: null, defaults: null };\n    }\n    return { variantKey: mode, defaults: toolDefaults[mode] } as ActiveTool;\n  }\n\n  private emitActiveTool(state: AnnotationState) {\n    const activeTool = this.createActiveTool(state.activeVariant, state.toolDefaults);\n    this.activeTool$.emit(activeTool);\n  }\n\n  override onStoreUpdated(prev: AnnotationState, next: AnnotationState): void {\n    this.state$.emit(next);\n    if (\n      prev.activeVariant !== next.activeVariant ||\n      prev.toolDefaults[prev.activeVariant ?? PdfAnnotationSubtype.HIGHLIGHT] !==\n        next.toolDefaults[next.activeVariant ?? PdfAnnotationSubtype.HIGHLIGHT]\n    ) {\n      this.emitActiveTool(next);\n    }\n  }\n\n  private getAllAnnotations(doc: PdfDocumentObject) {\n    const task = this.engine.getAllAnnotations(doc);\n    task.wait((annotations) => this.dispatch(setAnnotations(annotations)), ignore);\n  }\n\n  private getPageAnnotations(\n    options: GetPageAnnotationsOptions,\n  ): Task<PdfAnnotationObject[], PdfErrorReason> {\n    const { pageIndex } = options;\n\n    const doc = this.coreState.core.document;\n\n    if (!doc) {\n      return PdfTaskHelper.reject({ code: PdfErrorCode.NotFound, message: 'Document not found' });\n    }\n\n    const page = doc.pages.find((p) => p.index === pageIndex);\n\n    if (!page) {\n      return PdfTaskHelper.reject({ code: PdfErrorCode.NotFound, message: 'Page not found' });\n    }\n\n    return this.engine.getPageAnnotations(doc, page);\n  }\n\n  private renderAnnotation({\n    pageIndex,\n    annotation,\n    scaleFactor = 1,\n    rotation = Rotation.Degree0,\n    dpr = 1,\n    mode = AppearanceMode.Normal,\n    imageType = 'image/webp',\n  }: RenderAnnotationOptions) {\n    const coreState = this.coreState.core;\n\n    if (!coreState.document) {\n      throw new Error('document does not open');\n    }\n\n    const page = coreState.document.pages.find((page) => page.index === pageIndex);\n    if (!page) {\n      throw new Error('page does not exist');\n    }\n\n    return this.engine.renderAnnotation(\n      coreState.document,\n      page,\n      annotation,\n      scaleFactor,\n      rotation,\n      dpr,\n      mode,\n      imageType,\n    );\n  }\n\n  private selectAnnotation(pageIndex: number, annotationId: number) {\n    this.dispatch(selectAnnotation(pageIndex, annotationId));\n  }\n\n  private createAnnotation(pageIndex: number, annotation: PdfAnnotationObject) {\n    const localId = annotation.id;\n    const execute = () => this.dispatch(createAnnotation(pageIndex, localId, annotation));\n\n    if (!this.history) {\n      execute();\n      if (this.config.autoCommit) this.commit();\n      return;\n    }\n    const command: Command = {\n      execute,\n      undo: () => {\n        this.dispatch(deselectAnnotation());\n        this.dispatch(deleteAnnotation(pageIndex, localId));\n      },\n    };\n    this.history.register(command, this.ANNOTATION_HISTORY_TOPIC);\n  }\n\n  private updateAnnotation(\n    pageIndex: number,\n    localId: number,\n    patch: Partial<PdfAnnotationObject>,\n  ) {\n    if (!this.history) {\n      this.dispatch(patchAnnotation(pageIndex, localId, patch));\n      if (this.config.autoCommit !== false) {\n        this.commit();\n      }\n      return;\n    }\n    const originalObject = this.state.byUid[makeUid(pageIndex, localId)].object;\n    const originalPatch = Object.fromEntries(\n      Object.keys(patch).map((key) => [key, originalObject[key as keyof PdfAnnotationObject]]),\n    );\n    const command: Command = {\n      execute: () => this.dispatch(patchAnnotation(pageIndex, localId, patch)),\n      undo: () => this.dispatch(patchAnnotation(pageIndex, localId, originalPatch)),\n    };\n    this.history.register(command, this.ANNOTATION_HISTORY_TOPIC);\n  }\n\n  private deleteAnnotation(pageIndex: number, localId: number) {\n    if (!this.history) {\n      this.dispatch(deselectAnnotation());\n      this.dispatch(deleteAnnotation(pageIndex, localId));\n      if (this.config.autoCommit !== false) {\n        this.commit();\n      }\n      return;\n    }\n    const originalAnnotation = this.state.byUid[makeUid(pageIndex, localId)].object;\n    const command: Command = {\n      execute: () => {\n        this.dispatch(deselectAnnotation());\n        this.dispatch(deleteAnnotation(pageIndex, localId));\n      },\n      undo: () => this.dispatch(createAnnotation(pageIndex, localId, originalAnnotation)),\n    };\n    this.history.register(command, this.ANNOTATION_HISTORY_TOPIC);\n  }\n\n  private commit(): Task<boolean, PdfErrorReason> {\n    const task = new Task<boolean, PdfErrorReason>();\n\n    if (!this.state.hasPendingChanges) return PdfTaskHelper.resolve(true);\n\n    const doc = this.coreState.core.document;\n    if (!doc)\n      return PdfTaskHelper.reject({ code: PdfErrorCode.NotFound, message: 'Document not found' });\n\n    const creations: Task<any, PdfErrorReason>[] = [];\n    const updates: Task<any, PdfErrorReason>[] = [];\n    const deletionsByPage = new Map<number, { ta: TrackedAnnotation; uid: string }[]>();\n    const affectedPages = new Set<number>();\n\n    // 1. Group all pending changes by operation type\n    for (const [uid, ta] of Object.entries(this.state.byUid)) {\n      if (ta.commitState === 'synced') continue;\n\n      const { pageIndex } = parseUid(uid);\n      const page = doc.pages.find((p) => p.index === pageIndex);\n      if (!page) continue;\n\n      affectedPages.add(pageIndex);\n\n      switch (ta.commitState) {\n        case 'new':\n          const task = this.engine.createPageAnnotation!(doc, page, ta.object);\n          task.wait((annoId) => this.dispatch(storePdfId(uid, annoId)), ignore);\n          creations.push(task);\n          break;\n        case 'dirty':\n          updates.push(\n            this.engine.updatePageAnnotation!(doc, page, { ...ta.object, id: ta.pdfId! }),\n          );\n          break;\n        case 'deleted':\n          if (!deletionsByPage.has(pageIndex)) {\n            deletionsByPage.set(pageIndex, []);\n          }\n          deletionsByPage.get(pageIndex)!.push({ ta, uid });\n          break;\n      }\n    }\n\n    // 2. Create deletion tasks, sorted by ID descending\n    const deletionTasks: Task<any, PdfErrorReason>[] = [];\n    for (const [pageIndex, deletions] of deletionsByPage.entries()) {\n      const page = doc.pages.find((p) => p.index === pageIndex)!;\n\n      deletions.sort((a, b) => (b.ta.pdfId ?? -1) - (a.ta.pdfId ?? -1));\n\n      for (const { ta, uid } of deletions) {\n        if (ta.pdfId !== undefined) {\n          const task = new Task<any, PdfErrorReason>();\n          const removeTask = this.engine.removePageAnnotation!(doc, page, {\n            ...ta.object,\n            id: ta.pdfId!,\n          });\n          removeTask.wait(() => {\n            this.dispatch(purgeAnnotation(uid));\n            task.resolve(true);\n          }, task.fail);\n          deletionTasks.push(task);\n        } else {\n          this.dispatch(purgeAnnotation(uid));\n        }\n      }\n    }\n\n    // 3. Chain the operations: creations/updates -> deletions -> re-sync\n    const allWriteTasks = [...creations, ...updates, ...deletionTasks];\n\n    Task.allSettled(allWriteTasks).wait(() => {\n      // 4. Client-Side Re-indexing\n      // After all engine operations are done, tell the reducer to re-index each affected page.\n      for (const pageIndex of affectedPages) {\n        this.dispatch(reindexPageAnnotations(pageIndex));\n      }\n\n      // 5. Finalize the commit by updating the commitState of all items.\n      this.dispatch(commitPendingChanges());\n      task.resolve(true);\n    }, task.fail);\n\n    return task;\n  }\n}\n","import { Reducer } from '@embedpdf/core';\nimport { PdfAnnotationSubtype, PdfBlendMode } from '@embedpdf/models';\nimport {\n  ADD_COLOR_PRESET,\n  COMMIT_PENDING_CHANGES,\n  CREATE_ANNOTATION,\n  DESELECT_ANNOTATION,\n  PATCH_ANNOTATION,\n  DELETE_ANNOTATION,\n  SELECT_ANNOTATION,\n  SET_ANNOTATIONS,\n  UPDATE_TOOL_DEFAULTS,\n  AnnotationAction,\n  PURGE_ANNOTATION,\n  STORE_PDF_ID,\n  REINDEX_PAGE_ANNOTATIONS,\n  SET_ACTIVE_VARIANT,\n} from './actions';\nimport {\n  AnnotationDefaults,\n  AnnotationPluginConfig,\n  AnnotationState,\n  TrackedAnnotation,\n} from './types';\nimport { makeUid } from './utils';\nimport { makeVariantKey } from './variant-key';\n\n/* ─────────── util helpers ─────────── */\nconst DEFAULT_COLORS = [\n  '#E44234',\n  '#FF8D00',\n  '#FFCD45',\n  '#5CC96E',\n  '#25D2D1',\n  '#597CE2',\n  '#C544CE',\n  '#7D2E25',\n];\n\n/* helper to immutably replace one annotation (preserving pdfId) */\nconst patchAnno = (\n  state: AnnotationState,\n  uid: string,\n  patch: Partial<TrackedAnnotation['object']>,\n): AnnotationState => {\n  const prev = state.byUid[uid];\n  if (!prev) return state;\n  return {\n    ...state,\n    byUid: {\n      ...state.byUid,\n      [uid]: {\n        ...prev,\n        commitState: prev.commitState === 'synced' ? 'dirty' : prev.commitState,\n        object: { ...prev.object, ...patch },\n      } as TrackedAnnotation,\n    },\n    hasPendingChanges: true,\n  };\n};\n\n/* ─────────── initialState ─────────── */\nexport const initialState = (cfg: AnnotationPluginConfig): AnnotationState => ({\n  pages: {},\n  byUid: {},\n  selectedUid: null,\n  activeVariant: null,\n\n  toolDefaults: {\n    [makeVariantKey(PdfAnnotationSubtype.HIGHLIGHT)]: {\n      name: 'Highlight',\n      subtype: PdfAnnotationSubtype.HIGHLIGHT,\n      interaction: { mode: 'highlight', exclusive: false },\n      textSelection: true,\n      color: '#FFCD45',\n      opacity: 1,\n      blendMode: PdfBlendMode.Multiply,\n    },\n    [makeVariantKey(PdfAnnotationSubtype.UNDERLINE)]: {\n      name: 'Underline',\n      subtype: PdfAnnotationSubtype.UNDERLINE,\n      interaction: { mode: 'underline', exclusive: false },\n      textSelection: true,\n      color: '#E44234',\n      opacity: 1,\n      blendMode: PdfBlendMode.Normal,\n    },\n    [makeVariantKey(PdfAnnotationSubtype.STRIKEOUT)]: {\n      name: 'Strikeout',\n      subtype: PdfAnnotationSubtype.STRIKEOUT,\n      interaction: { mode: 'strikeout', exclusive: false },\n      textSelection: true,\n      color: '#E44234',\n      opacity: 1,\n      blendMode: PdfBlendMode.Normal,\n    },\n    [makeVariantKey(PdfAnnotationSubtype.SQUIGGLY)]: {\n      name: 'Squiggly',\n      subtype: PdfAnnotationSubtype.SQUIGGLY,\n      interaction: { mode: 'squiggly', exclusive: false },\n      textSelection: true,\n      color: '#E44234',\n      opacity: 1,\n      blendMode: PdfBlendMode.Normal,\n    },\n    [makeVariantKey(PdfAnnotationSubtype.INK)]: {\n      name: 'Ink',\n      subtype: PdfAnnotationSubtype.INK,\n      interaction: { mode: 'ink', exclusive: true, cursor: 'crosshair' },\n      color: '#E44234',\n      opacity: 1,\n      strokeWidth: 11,\n      blendMode: PdfBlendMode.Normal,\n    },\n    [makeVariantKey(PdfAnnotationSubtype.INK, 'InkHighlight')]: {\n      name: 'Ink Highlight',\n      subtype: PdfAnnotationSubtype.INK,\n      interaction: { mode: 'inkHighlight', exclusive: true, cursor: 'crosshair' },\n      color: '#E44234',\n      opacity: 1,\n      strokeWidth: 11,\n      blendMode: PdfBlendMode.Multiply,\n    },\n    ...cfg.toolDefaults,\n  },\n  colorPresets: cfg.colorPresets ?? DEFAULT_COLORS,\n  hasPendingChanges: false,\n});\n\n/* ─────────── reducer ─────────── */\nexport const reducer: Reducer<AnnotationState, AnnotationAction> = (state, action) => {\n  switch (action.type) {\n    /* ───── bulk load from engine ───── */\n    case SET_ANNOTATIONS: {\n      const newPages = { ...state.pages };\n      const newByUid = { ...state.byUid };\n      for (const [pgStr, list] of Object.entries(action.payload)) {\n        const pageIndex = Number(pgStr);\n        const oldUidsOnPage = state.pages[pageIndex] || [];\n        for (const uid of oldUidsOnPage) {\n          delete newByUid[uid];\n        }\n        const newUidsOnPage = list.map((a, index) => {\n          const localId = Date.now() + Math.random() + index;\n          const uid = makeUid(pageIndex, localId);\n          newByUid[uid] = { localId, pdfId: a.id, commitState: 'synced', object: a };\n          return uid;\n        });\n        newPages[pageIndex] = newUidsOnPage;\n      }\n      return { ...state, pages: newPages, byUid: newByUid };\n    }\n\n    /* ───── GUI bits ───── */\n    case SET_ACTIVE_VARIANT:\n      return { ...state, activeVariant: action.payload };\n    case SELECT_ANNOTATION:\n      return {\n        ...state,\n        selectedUid: makeUid(action.payload.pageIndex, action.payload.localId),\n      };\n    case DESELECT_ANNOTATION:\n      return { ...state, selectedUid: null };\n\n    case ADD_COLOR_PRESET:\n      return state.colorPresets.includes(action.payload)\n        ? state\n        : { ...state, colorPresets: [...state.colorPresets, action.payload] };\n\n    case UPDATE_TOOL_DEFAULTS: {\n      const { variantKey, patch } = action.payload;\n      const prev = state.toolDefaults[variantKey];\n      if (!prev) return state;\n      return {\n        ...state,\n        toolDefaults: {\n          ...state.toolDefaults,\n          [variantKey]: { ...prev, ...patch } as AnnotationDefaults,\n        },\n      };\n    }\n\n    /* ───── create ───── */\n    case CREATE_ANNOTATION: {\n      const { pageIndex, localId, annotation } = action.payload;\n      const uid = makeUid(pageIndex, localId);\n\n      return {\n        ...state,\n        pages: { ...state.pages, [pageIndex]: [...(state.pages[pageIndex] ?? []), uid] },\n        byUid: {\n          ...state.byUid,\n          [uid]: { localId, pdfId: undefined, commitState: 'new', object: annotation },\n        },\n        hasPendingChanges: true,\n      };\n    }\n\n    /* ───── delete ───── */\n    case DELETE_ANNOTATION: {\n      const { pageIndex, localId } = action.payload;\n      const uid = makeUid(pageIndex, localId);\n      if (!state.byUid[uid]) return state;\n\n      /* keep the object but mark it as deleted */\n      return {\n        ...state,\n        pages: {\n          ...state.pages,\n          [pageIndex]: (state.pages[pageIndex] ?? []).filter((u) => u !== uid),\n        },\n        byUid: {\n          ...state.byUid,\n          [uid]: { ...state.byUid[uid], commitState: 'deleted' },\n        },\n        hasPendingChanges: true,\n      };\n    }\n\n    /* ───── field edits ───── */\n    case PATCH_ANNOTATION: {\n      const uid = makeUid(action.payload.pageIndex, action.payload.localId);\n      return patchAnno(state, uid, action.payload.patch);\n    }\n\n    /* ───── commit bookkeeping ───── */\n    case COMMIT_PENDING_CHANGES: {\n      const cleaned: AnnotationState['byUid'] = {};\n      for (const [uid, ta] of Object.entries(state.byUid)) {\n        cleaned[uid] = {\n          ...ta,\n          commitState:\n            ta.commitState === 'dirty' || ta.commitState === 'new' ? 'synced' : ta.commitState,\n        };\n      }\n      return { ...state, byUid: cleaned, hasPendingChanges: false };\n    }\n\n    case REINDEX_PAGE_ANNOTATIONS: {\n      const { pageIndex } = action.payload;\n      const newByUid = { ...state.byUid };\n\n      const uidsOnPage = state.pages[pageIndex] || [];\n      const annosOnPage = uidsOnPage\n        .map((uid) => state.byUid[uid])\n        .filter((ta) => ta && ta.commitState !== 'deleted'); // Filter out annotations pending deletion\n\n      // CORRECTED: Sort by the existing pdfId to maintain relative order.\n      annosOnPage.sort((a, b) => (a.pdfId ?? Infinity) - (b.pdfId ?? Infinity));\n\n      // Update the pdfId for each annotation based on its new sorted index\n      annosOnPage.forEach((ta, newPdfId) => {\n        const uid = makeUid(pageIndex, ta.localId);\n        newByUid[uid] = { ...newByUid[uid], pdfId: newPdfId };\n      });\n\n      return { ...state, byUid: newByUid };\n    }\n\n    case STORE_PDF_ID: {\n      const { uid, pdfId } = action.payload;\n\n      const ta = state.byUid[uid];\n      if (!ta) return state;\n      return {\n        ...state,\n        byUid: {\n          ...state.byUid,\n          [uid]: { ...ta, pdfId, commitState: 'synced' },\n        },\n      };\n    }\n\n    case PURGE_ANNOTATION: {\n      const { uid } = action.payload;\n      const { [uid]: _gone, ...rest } = state.byUid;\n      return { ...state, byUid: rest };\n    }\n\n    default:\n      return state;\n  }\n};\n","import { PluginPackage } from '@embedpdf/core';\nimport { manifest, ANNOTATION_PLUGIN_ID } from './manifest';\nimport { AnnotationPluginConfig, AnnotationState } from './types';\nimport { AnnotationPlugin } from './annotation-plugin';\nimport { initialState, reducer } from './reducer';\nimport { AnnotationAction } from './actions';\n\nexport const AnnotationPluginPackage: PluginPackage<\n  AnnotationPlugin,\n  AnnotationPluginConfig,\n  AnnotationState,\n  AnnotationAction\n> = {\n  manifest,\n  create: (registry, engine, config) =>\n    new AnnotationPlugin(ANNOTATION_PLUGIN_ID, registry, engine, config),\n  reducer,\n  initialState: (_, config) => initialState(config),\n};\n\nexport * from './annotation-plugin';\nexport * from './types';\nexport * from './manifest';\nexport * from './selectors';\nexport * from './variant-key';\n","import { useCapability, usePlugin } from '@embedpdf/core/preact';\nimport { AnnotationPlugin } from '@embedpdf/plugin-annotation';\n\nexport const useAnnotationPlugin = () => usePlugin<AnnotationPlugin>(AnnotationPlugin.id);\nexport const useAnnotationCapability = () => useCapability<AnnotationPlugin>(AnnotationPlugin.id);\n","/**\n * Clockwise direction\n * @public\n */\nexport enum Rotation {\n  Degree0 = 0,\n  Degree90 = 1,\n  Degree180 = 2,\n  Degree270 = 3,\n}\n\n/** Clamp a Position to device-pixel integers (floor) */\nexport function toIntPos(p: Position): Position {\n  return { x: Math.floor(p.x), y: Math.floor(p.y) };\n}\n\n/** Clamp a Size so it never truncates right / bottom (ceil) */\nexport function toIntSize(s: Size): Size {\n  return { width: Math.ceil(s.width), height: Math.ceil(s.height) };\n}\n\n/** Apply both rules to a Rect */\nexport function toIntRect(r: Rect): Rect {\n  return {\n    origin: toIntPos(r.origin),\n    size: toIntSize(r.size),\n  };\n}\n\n/**\n * Calculate degree that match the rotation type\n * @param rotation - type of rotation\n * @returns rotated degree\n *\n * @public\n */\nexport function calculateDegree(rotation: Rotation) {\n  switch (rotation) {\n    case Rotation.Degree0:\n      return 0;\n    case Rotation.Degree90:\n      return 90;\n    case Rotation.Degree180:\n      return 180;\n    case Rotation.Degree270:\n      return 270;\n  }\n}\n\n/**\n * Calculate angle that match the rotation type\n * @param rotation - type of rotation\n * @returns rotated angle\n *\n * @public\n */\nexport function calculateAngle(rotation: Rotation) {\n  return (calculateDegree(rotation) * Math.PI) / 180;\n}\n\n/**\n * Represent the size of object\n *\n * @public\n */\nexport interface Size {\n  /**\n   * width of the object\n   */\n  width: number;\n\n  /**\n   * height of the object\n   */\n  height: number;\n}\n\n/**\n * Represents a rectangle defined by its left, top, right, and bottom edges\n *\n * @public\n */\nexport interface Box {\n  /**\n   * The x-coordinate of the left edge\n   */\n  left: number;\n\n  /**\n   * The y-coordinate of the top edge\n   */\n  top: number;\n\n  /**\n   * The x-coordinate of the right edge\n   */\n  right: number;\n\n  /**\n   * The y-coordinate of the bottom edge\n   */\n  bottom: number;\n}\n\n/**\n * Swap the width and height of the size object\n * @param size - the original size\n * @returns swapped size\n *\n * @public\n */\nexport function swap(size: Size): Size {\n  const { width, height } = size;\n\n  return {\n    width: height,\n    height: width,\n  };\n}\n\n/**\n * Transform size with specified rotation angle and scale factor\n * @param size - orignal size of rect\n * @param rotation - rotation angle\n * @param scaleFactor - - scale factor\n * @returns size that has been transformed\n *\n * @public\n */\nexport function transformSize(size: Size, rotation: Rotation, scaleFactor: number): Size {\n  size = rotation % 2 === 0 ? size : swap(size);\n\n  return {\n    width: size.width * scaleFactor,\n    height: size.height * scaleFactor,\n  };\n}\n\n/**\n * position of point\n *\n * @public\n */\nexport interface Position {\n  /**\n   * x coordinate\n   */\n  x: number;\n\n  /**\n   * y coordinate\n   */\n  y: number;\n}\n\n/**\n * Quadrilateral\n *\n * @public\n */\nexport interface Quad {\n  p1: Position;\n  p2: Position;\n  p3: Position;\n  p4: Position;\n}\n\n/**\n * Convert quadrilateral to rectangle\n * @param q - quadrilateral\n * @returns rectangle\n *\n * @public\n */\nexport function quadToRect(q: Quad): Rect {\n  const xs = [q.p1.x, q.p2.x, q.p3.x, q.p4.x];\n  const ys = [q.p1.y, q.p2.y, q.p3.y, q.p4.y];\n\n  return {\n    origin: { x: Math.min(...xs), y: Math.min(...ys) },\n    size: {\n      width: Math.max(...xs) - Math.min(...xs),\n      height: Math.max(...ys) - Math.min(...ys),\n    },\n  };\n}\n\n/**\n * Convert rectangle to quadrilateral\n * @param r - rectangle\n * @returns quadrilateral\n *\n * @public\n */\nexport function rectToQuad(r: Rect): Quad {\n  return {\n    p1: { x: r.origin.x, y: r.origin.y },\n    p2: { x: r.origin.x + r.size.width, y: r.origin.y },\n    p3: { x: r.origin.x + r.size.width, y: r.origin.y + r.size.height },\n    p4: { x: r.origin.x, y: r.origin.y + r.size.height },\n  };\n}\n\n/**\n * Rotate the container and calculate the new position for a point\n * in specified position\n * @param containerSize - size of the container\n * @param position - position of the point\n * @param rotation - rotated angle\n * @returns new position of the point\n *\n * @public\n */\nexport function rotatePosition(\n  containerSize: Size,\n  position: Position,\n  rotation: Rotation,\n): Position {\n  let x = position.x;\n  let y = position.y;\n\n  switch (rotation) {\n    case Rotation.Degree0:\n      x = position.x;\n      y = position.y;\n      break;\n    case Rotation.Degree90:\n      x = containerSize.height - position.y;\n      y = position.x;\n      break;\n    case Rotation.Degree180:\n      x = containerSize.width - position.x;\n      y = containerSize.height - position.y;\n      break;\n    case Rotation.Degree270:\n      x = position.y;\n      y = containerSize.width - position.x;\n      break;\n  }\n\n  return {\n    x,\n    y,\n  };\n}\n\n/**\n * Calculate the position of point by scaling the container\n * @param position - position of the point\n * @param scaleFactor - factor of scaling\n * @returns new position of point\n *\n * @public\n */\nexport function scalePosition(position: Position, scaleFactor: number): Position {\n  return {\n    x: position.x * scaleFactor,\n    y: position.y * scaleFactor,\n  };\n}\n\n/**\n * Calculate the position of the point by applying the specified transformation\n * @param containerSize - size of container\n * @param position - position of the point\n * @param rotation - rotated angle\n * @param scaleFactor - factor of scaling\n * @returns new position of point\n *\n * @public\n */\nexport function transformPosition(\n  containerSize: Size,\n  position: Position,\n  rotation: Rotation,\n  scaleFactor: number,\n): Position {\n  return scalePosition(rotatePosition(containerSize, position, rotation), scaleFactor);\n}\n\n/**\n * Restore the position in a transformed cotainer\n * @param containerSize - size of the container\n * @param position - position of the point\n * @param rotation - rotated angle\n * @param scaleFactor - factor of scaling\n * @returns the original position of the point\n *\n * @public\n */\nexport function restorePosition(\n  containerSize: Size,\n  position: Position,\n  rotation: Rotation,\n  scaleFactor: number,\n): Position {\n  return scalePosition(\n    rotatePosition(containerSize, position, (4 - rotation) % 4),\n    1 / scaleFactor,\n  );\n}\n\n/**\n * representation of rectangle\n *\n * @public\n */\nexport interface Rect {\n  /**\n   * origin of the rectangle\n   */\n  origin: Position;\n\n  /**\n   * size of the rectangle\n   */\n  size: Size;\n}\n\n/**\n * Calculate the rect after rotated the container\n * @param containerSize - size of container\n * @param rect - target rect\n * @param rotation - rotation angle\n * @returns rotated rect\n *\n * @public\n */\nexport function rotateRect(containerSize: Size, rect: Rect, rotation: Rotation): Rect {\n  let x = rect.origin.x;\n  let y = rect.origin.y;\n  let size = rect.size;\n\n  switch (rotation) {\n    case Rotation.Degree0:\n      break;\n    case Rotation.Degree90:\n      x = containerSize.height - rect.origin.y - rect.size.height;\n      y = rect.origin.x;\n      size = swap(rect.size);\n      break;\n    case Rotation.Degree180:\n      x = containerSize.width - rect.origin.x - rect.size.width;\n      y = containerSize.height - rect.origin.y - rect.size.height;\n      break;\n    case Rotation.Degree270:\n      x = rect.origin.y;\n      y = containerSize.width - rect.origin.x - rect.size.width;\n      size = swap(rect.size);\n      break;\n  }\n\n  return {\n    origin: {\n      x,\n      y,\n    },\n    size: {\n      width: size.width,\n      height: size.height,\n    },\n  };\n}\n\n/**\n * Scale the rectangle\n * @param rect - rectangle\n * @param scaleFactor - factor of scaling\n * @returns new rectangle\n *\n * @public\n */\nexport function scaleRect(rect: Rect, scaleFactor: number): Rect {\n  return {\n    origin: {\n      x: rect.origin.x * scaleFactor,\n      y: rect.origin.y * scaleFactor,\n    },\n    size: {\n      width: rect.size.width * scaleFactor,\n      height: rect.size.height * scaleFactor,\n    },\n  };\n}\n\n/**\n * Calculate new rectangle after transforming the container\n * @param containerSize - size of the container\n * @param rect - the target rectangle\n * @param rotation - rotated angle\n * @param scaleFactor - factor of scaling\n * @returns new rectangle after transformation\n *\n * @public\n */\nexport function transformRect(\n  containerSize: Size,\n  rect: Rect,\n  rotation: Rotation,\n  scaleFactor: number,\n): Rect {\n  return scaleRect(rotateRect(containerSize, rect, rotation), scaleFactor);\n}\n\n/**\n * Calculate new rectangle before transforming the container\n * @param containerSize - size of the container\n * @param rect - the target rectangle\n * @param rotation - rotated angle\n * @param scaleFactor - factor of scaling\n * @returns original rectangle before transformation\n *\n * @public\n */\nexport function restoreRect(\n  containerSize: Size,\n  rect: Rect,\n  rotation: Rotation,\n  scaleFactor: number,\n): Rect {\n  return scaleRect(rotateRect(containerSize, rect, (4 - rotation) % 4), 1 / scaleFactor);\n}\n\n/**\n * Calculate the original offset in a transformed container\n * @param offset - position of the point\n * @param rotation - rotated angle\n * @param scaleFactor - factor of scaling\n * @returns original position of the point\n *\n * @public\n */\nexport function restoreOffset(offset: Position, rotation: Rotation, scaleFactor: number): Position {\n  let offsetX = offset.x;\n  let offsetY = offset.y;\n  switch (rotation) {\n    case Rotation.Degree0:\n      offsetX = offset.x / scaleFactor;\n      offsetY = offset.y / scaleFactor;\n      break;\n    case Rotation.Degree90:\n      offsetX = offset.y / scaleFactor;\n      offsetY = -offset.x / scaleFactor;\n      break;\n    case Rotation.Degree180:\n      offsetX = -offset.x / scaleFactor;\n      offsetY = -offset.y / scaleFactor;\n      break;\n    case Rotation.Degree270:\n      offsetX = -offset.y / scaleFactor;\n      offsetY = offset.x / scaleFactor;\n      break;\n  }\n\n  return {\n    x: offsetX,\n    y: offsetY,\n  };\n}\n\n/**\n * Return the smallest rectangle that encloses *all* `rects`.\n * If the array is empty, returns `null`.\n *\n * @param rects - array of rectangles\n * @returns smallest rectangle that encloses all the rectangles\n *\n * @public\n */\nexport function boundingRect(rects: Rect[]): Rect | null {\n  if (rects.length === 0) return null;\n\n  let minX = rects[0].origin.x,\n    minY = rects[0].origin.y,\n    maxX = rects[0].origin.x + rects[0].size.width,\n    maxY = rects[0].origin.y + rects[0].size.height;\n\n  for (const r of rects) {\n    minX = Math.min(minX, r.origin.x);\n    minY = Math.min(minY, r.origin.y);\n    maxX = Math.max(maxX, r.origin.x + r.size.width);\n    maxY = Math.max(maxY, r.origin.y + r.size.height);\n  }\n\n  return {\n    origin: {\n      x: minX,\n      y: minY,\n    },\n    size: {\n      width: maxX - minX,\n      height: maxY - minY,\n    },\n  };\n}\n\nexport interface Matrix {\n  a: number;\n  b: number;\n  c: number;\n  d: number;\n  e: number;\n  f: number;\n}\n\n/**\n * Build a CTM that maps *PDF-space* inside the annotation\n * → *device-space* inside the bitmap, honouring\n * zoom (scaleFactor × dpr) **and** page-rotation.\n */\n/** build the CTM for any page-rotation */\nexport const makeMatrix = (rectangle: Rect, rotation: Rotation, scaleFactor: number): Matrix => {\n  const { width, height } = rectangle.size;\n\n  switch (rotation) {\n    case Rotation.Degree0: // normal\n      return {\n        a: scaleFactor,\n        b: 0,\n        c: 0,\n        d: -scaleFactor,\n        e: 0,\n        f: height * scaleFactor,\n      };\n\n    case Rotation.Degree90: // +90° CW\n      //  matrix =   [ 0  s ]   after flip-Y → no extra translation needed\n      //              [ s  0 ]\n      return {\n        a: 0,\n        b: scaleFactor,\n        c: scaleFactor,\n        d: 0,\n        e: 0,\n        f: 0,\n      };\n\n    case Rotation.Degree180: // +180°\n      return {\n        a: -scaleFactor,\n        b: 0,\n        c: 0,\n        d: scaleFactor,\n        e: width * scaleFactor,\n        f: 0,\n      };\n\n    case Rotation.Degree270: // +270° CW  (= 90° CCW)\n      //  flips the other way, so we nudge it back inside the bitmap\n      return {\n        a: 0,\n        b: -scaleFactor,\n        c: -scaleFactor,\n        d: 0,\n        e: height * scaleFactor,\n        f: width * scaleFactor,\n      };\n  }\n};\n","/**\n * logger for logging\n *\n * @public\n */\nexport interface Logger {\n  /**\n   * Log debug message\n   * @param source - source of log\n   * @param category - category of log\n   * @param args - parameters of log\n   * @returns\n   *\n   * @public\n   */\n  debug: (source: string, category: string, ...args: any) => void;\n\n  /**\n   * Log infor message\n   * @param source - source of log\n   * @param category - category of log\n   * @param args - parameters of log\n   * @returns\n   *\n   * @public\n   */\n  info: (source: string, category: string, ...args: any) => void;\n\n  /**\n   * Log warning message\n   * @param source - source of log\n   * @param category - category of log\n   * @param args - parameters of log\n   * @returns\n   *\n   * @public\n   */\n  warn: (source: string, category: string, ...args: any) => void;\n  /**\n   * Log error message\n   * @param source - source of log\n   * @param category - category of log\n   * @param args - parameters of log\n   * @returns\n   *\n   * @public\n   */\n  error: (source: string, category: string, ...args: any) => void;\n\n  /**\n   * Log performance log\n   * @param source - source of log\n   * @param category - category of log\n   * @param event - event of log\n   * @param phase - event phase of log\n   * @param args - parameters of log\n   * @returns\n   *\n   * @public\n   */\n  perf: (\n    source: string,\n    category: string,\n    event: string,\n    phase: 'Begin' | 'End',\n    ...args: any\n  ) => void;\n}\n\n/**\n * Logger that log nothing, it will ignore all the logs\n *\n * @public\n */\nexport class NoopLogger implements Logger {\n  /** {@inheritDoc Logger.debug} */\n  debug() {}\n  /** {@inheritDoc Logger.info} */\n  info() {}\n  /** {@inheritDoc Logger.warn} */\n  warn() {}\n  /** {@inheritDoc Logger.error} */\n  error() {}\n  /** {@inheritDoc Logger.perf} */\n  perf() {}\n}\n\n/**\n * Logger that use console as the output\n *\n * @public\n */\nexport class ConsoleLogger implements Logger {\n  /** {@inheritDoc Logger.debug} */\n  debug(source: string, category: string, ...args: any) {\n    console.debug(`${source}.${category}`, ...args);\n  }\n\n  /** {@inheritDoc Logger.info} */\n  info(source: string, category: string, ...args: any) {\n    console.info(`${source}.${category}`, ...args);\n  }\n\n  /** {@inheritDoc Logger.warn} */\n  warn(source: string, category: string, ...args: any) {\n    console.warn(`${source}.${category}`, ...args);\n  }\n\n  /** {@inheritDoc Logger.error} */\n  error(source: string, category: string, ...args: any) {\n    console.error(`${source}.${category}`, ...args);\n  }\n\n  /** {@inheritDoc Logger.perf} */\n  perf(source: string, category: string, event: string, phase: 'Begin' | 'End', ...args: any) {\n    console.info(`${source}.${category}.${event}.${phase}`, ...args);\n  }\n}\n\n/**\n * Level of log\n *\n * @public\n */\nexport enum LogLevel {\n  Debug = 0,\n  Info,\n  Warn,\n  Error,\n}\n\n/**\n * Logger that support filtering by log level\n *\n * @public\n */\nexport class LevelLogger implements Logger {\n  /**\n   * create new LevelLogger\n   * @param logger - the original logger\n   * @param level - log level that used for filtering, all logs lower than this level will be filtered out\n   */\n  constructor(\n    private logger: Logger,\n    private level: LogLevel,\n  ) {}\n\n  /** {@inheritDoc Logger.debug} */\n  debug(source: string, category: string, ...args: any) {\n    if (this.level <= LogLevel.Debug) {\n      this.logger.debug(source, category, ...args);\n    }\n  }\n\n  /** {@inheritDoc Logger.info} */\n  info(source: string, category: string, ...args: any) {\n    if (this.level <= LogLevel.Info) {\n      this.logger.info(source, category, ...args);\n    }\n  }\n\n  /** {@inheritDoc Logger.warn} */\n  warn(source: string, category: string, ...args: any) {\n    if (this.level <= LogLevel.Warn) {\n      this.logger.warn(source, category, ...args);\n    }\n  }\n\n  /** {@inheritDoc Logger.error} */\n  error(source: string, category: string, ...args: any) {\n    if (this.level <= LogLevel.Error) {\n      this.logger.error(source, category, ...args);\n    }\n  }\n\n  /** {@inheritDoc Logger.perf} */\n  perf(source: string, category: string, event: string, phase: 'Begin' | 'End', ...args: any) {\n    this.logger.perf(source, category, event, phase, ...args);\n  }\n}\n\n/**\n * Logger for performance tracking\n *\n * @public\n */\nexport class PerfLogger implements Logger {\n  /**\n   * create new PerfLogger\n   */\n  constructor() {}\n\n  /** {@inheritDoc Logger.debug} */\n  debug(source: string, category: string, ...args: any) {}\n\n  /** {@inheritDoc Logger.info} */\n  info(source: string, category: string, ...args: any) {}\n\n  /** {@inheritDoc Logger.warn} */\n  warn(source: string, category: string, ...args: any) {}\n\n  /** {@inheritDoc Logger.error} */\n  error(source: string, category: string, ...args: any) {}\n\n  /** {@inheritDoc Logger.perf} */\n  perf(\n    source: string,\n    category: string,\n    event: string,\n    phase: 'Begin' | 'End',\n    identifier: string,\n    ...args: any\n  ) {\n    switch (phase) {\n      case 'Begin':\n        window.performance.mark(`${source}.${category}.${event}.${phase}.${identifier}`, {\n          detail: args,\n        });\n        break;\n      case 'End':\n        window.performance.mark(`${source}.${category}.${event}.${phase}.${identifier}`, {\n          detail: args,\n        });\n        window.performance.measure(\n          `${source}.${category}.${event}.Measure.${identifier}`,\n          `${source}.${category}.${event}.Begin.${identifier}`,\n          `${source}.${category}.${event}.End.${identifier}`,\n        );\n        break;\n    }\n  }\n}\n\n/**\n * Logger that will track and call child loggers\n *\n * @public\n */\nexport class AllLogger implements Logger {\n  /**\n   * create new PerfLogger\n   */\n  constructor(private loggers: Logger[]) {}\n\n  /** {@inheritDoc Logger.debug} */\n  debug(source: string, category: string, ...args: any) {\n    for (const logger of this.loggers) {\n      logger.debug(source, category, ...args);\n    }\n  }\n\n  /** {@inheritDoc Logger.info} */\n  info(source: string, category: string, ...args: any) {\n    for (const logger of this.loggers) {\n      logger.info(source, category, ...args);\n    }\n  }\n\n  /** {@inheritDoc Logger.warn} */\n  warn(source: string, category: string, ...args: any) {\n    for (const logger of this.loggers) {\n      logger.warn(source, category, ...args);\n    }\n  }\n\n  /** {@inheritDoc Logger.error} */\n  error(source: string, category: string, ...args: any) {\n    for (const logger of this.loggers) {\n      logger.error(source, category, ...args);\n    }\n  }\n\n  /** {@inheritDoc Logger.perf} */\n  perf(source: string, category: string, event: string, phase: 'Begin' | 'End', ...args: any) {\n    for (const logger of this.loggers) {\n      logger.perf(source, category, event, phase, ...args);\n    }\n  }\n}\n","/**\n * Stage of task\n *\n * @public\n */\nexport enum TaskStage {\n  /**\n   * Task is pending, means it just start executing\n   */\n  Pending = 0,\n  /**\n   * Task is succeed\n   */\n  Resolved = 1,\n  /**\n   * Task is failed\n   */\n  Rejected = 2,\n  /**\n   * Task is aborted\n   */\n  Aborted = 3,\n}\n\nexport interface TaskError<D> {\n  /**\n   * task error type\n   */\n  type: 'reject' | 'abort';\n  /**\n   * task error\n   */\n  reason: D;\n}\n\n/**\n * callback that will be called when task is resolved\n *\n * @public\n */\nexport type ResolvedCallback<R> = (r: R) => void;\n\n/**\n * callback that will be called when task is rejected\n *\n * @public\n */\nexport type RejectedCallback<D> = (e: TaskError<D>) => void;\n\n/**\n * Task state in different stage\n *\n * @public\n */\nexport type TaskState<R, D> =\n  | {\n      stage: TaskStage.Pending;\n    }\n  | {\n      stage: TaskStage.Resolved;\n      result: R;\n    }\n  | {\n      stage: TaskStage.Rejected;\n      reason: D;\n    }\n  | {\n      stage: TaskStage.Aborted;\n      reason: D;\n    };\n\n/**\n * Result type for allSettled\n *\n * @public\n */\nexport type TaskSettledResult<R, D> =\n  | { status: 'resolved'; value: R }\n  | { status: 'rejected'; reason: D }\n  | { status: 'aborted'; reason: D };\n\nexport class TaskAbortedError<D> extends Error {\n  constructor(reason: D) {\n    super(`Task aborted: ${JSON.stringify(reason)}`);\n    this.name = 'TaskAbortedError';\n  }\n}\n\nexport class TaskRejectedError<D> extends Error {\n  constructor(reason: D) {\n    super(`Task rejected: ${JSON.stringify(reason)}`);\n    this.name = 'TaskRejectedError';\n  }\n}\n\n/**\n * Base class of task\n *\n * @public\n */\nexport class Task<R, D> {\n  state: TaskState<R, D> = {\n    stage: TaskStage.Pending,\n  };\n  /**\n   * callbacks that will be executed when task is resolved\n   */\n  resolvedCallbacks: ResolvedCallback<R>[] = [];\n  /**\n   * callbacks that will be executed when task is rejected\n   */\n  rejectedCallbacks: RejectedCallback<D>[] = [];\n\n  /**\n   * Promise that will be resolved when task is settled\n   */\n  private _promise: Promise<R> | null = null;\n\n  /**\n   * Convert task to promise\n   * @returns promise that will be resolved when task is settled\n   */\n  toPromise(): Promise<R> {\n    if (!this._promise) {\n      this._promise = new Promise((resolve, reject) => {\n        this.wait(\n          (result) => resolve(result),\n          (error) => {\n            if (error.type === 'abort') {\n              reject(new TaskAbortedError(error.reason));\n            } else {\n              reject(new TaskRejectedError(error.reason));\n            }\n          },\n        );\n      });\n    }\n    return this._promise;\n  }\n\n  /**\n   * wait for task to be settled\n   * @param resolvedCallback - callback for resolved value\n   * @param rejectedCallback - callback for rejected value\n   */\n  wait(resolvedCallback: ResolvedCallback<R>, rejectedCallback: RejectedCallback<D>) {\n    switch (this.state.stage) {\n      case TaskStage.Pending:\n        this.resolvedCallbacks.push(resolvedCallback);\n        this.rejectedCallbacks.push(rejectedCallback);\n        break;\n      case TaskStage.Resolved:\n        resolvedCallback(this.state.result);\n        break;\n      case TaskStage.Rejected:\n        rejectedCallback({\n          type: 'reject',\n          reason: this.state.reason,\n        });\n        break;\n      case TaskStage.Aborted:\n        rejectedCallback({\n          type: 'abort',\n          reason: this.state.reason,\n        });\n        break;\n    }\n  }\n\n  /**\n   * resolve task with specific result\n   * @param result - result value\n   */\n  resolve(result: R) {\n    if (this.state.stage === TaskStage.Pending) {\n      this.state = {\n        stage: TaskStage.Resolved,\n        result,\n      };\n      for (const resolvedCallback of this.resolvedCallbacks) {\n        try {\n          resolvedCallback(result);\n        } catch (e) {\n          /* ignore */\n        }\n      }\n      this.resolvedCallbacks = [];\n      this.rejectedCallbacks = [];\n    }\n  }\n\n  /**\n   * reject task with specific reason\n   * @param reason - abort reason\n   *\n   */\n  reject(reason: D) {\n    if (this.state.stage === TaskStage.Pending) {\n      this.state = {\n        stage: TaskStage.Rejected,\n        reason,\n      };\n      for (const rejectedCallback of this.rejectedCallbacks) {\n        try {\n          rejectedCallback({\n            type: 'reject',\n            reason,\n          });\n        } catch (e) {\n          /*ignore */\n        }\n      }\n      this.resolvedCallbacks = [];\n      this.rejectedCallbacks = [];\n    }\n  }\n\n  /**\n   * abort task with specific reason\n   * @param reason - abort reason\n   */\n  abort(reason: D) {\n    if (this.state.stage === TaskStage.Pending) {\n      this.state = {\n        stage: TaskStage.Aborted,\n        reason,\n      };\n      for (const rejectedCallback of this.rejectedCallbacks) {\n        try {\n          rejectedCallback({\n            type: 'abort',\n            reason,\n          });\n        } catch (e) {\n          /* ignore */\n        }\n      }\n      this.resolvedCallbacks = [];\n      this.rejectedCallbacks = [];\n    }\n  }\n\n  /**\n   * fail task with a TaskError from another task\n   * This is a convenience method for error propagation between tasks\n   * @param error - TaskError from another task\n   */\n  fail(error: TaskError<D>) {\n    if (error.type === 'abort') {\n      this.abort(error.reason);\n    } else {\n      this.reject(error.reason);\n    }\n  }\n\n  /**\n   * Static method to wait for all tasks to resolve\n   * Returns a new task that resolves with an array of all results\n   * Rejects immediately if any task fails\n   *\n   * @param tasks - array of tasks to wait for\n   * @returns new task that resolves when all input tasks resolve\n   * @public\n   */\n  static all<R extends readonly Task<any, any>[]>(\n    tasks: R,\n  ): Task<{ [K in keyof R]: R[K] extends Task<infer U, any> ? U : never }, any> {\n    type ResultType = { [K in keyof R]: R[K] extends Task<infer U, any> ? U : never };\n\n    const combinedTask = new Task<ResultType, any>();\n\n    if (tasks.length === 0) {\n      combinedTask.resolve([] as any);\n      return combinedTask;\n    }\n\n    const results: any[] = new Array(tasks.length);\n    let resolvedCount = 0;\n    let isSettled = false;\n\n    tasks.forEach((task, index) => {\n      task.wait(\n        (result) => {\n          if (isSettled) return;\n\n          results[index] = result;\n          resolvedCount++;\n\n          if (resolvedCount === tasks.length) {\n            isSettled = true;\n            combinedTask.resolve(results as ResultType);\n          }\n        },\n        (error) => {\n          if (isSettled) return;\n\n          isSettled = true;\n          if (error.type === 'abort') {\n            combinedTask.abort(error.reason);\n          } else {\n            combinedTask.reject(error.reason);\n          }\n        },\n      );\n    });\n\n    return combinedTask;\n  }\n\n  /**\n   * Static method to wait for all tasks to settle (resolve, reject, or abort)\n   * Always resolves with an array of settlement results\n   *\n   * @param tasks - array of tasks to wait for\n   * @returns new task that resolves when all input tasks settle\n   * @public\n   */\n  static allSettled<R extends readonly Task<any, any>[]>(\n    tasks: R,\n  ): Task<\n    { [K in keyof R]: R[K] extends Task<infer U, infer E> ? TaskSettledResult<U, E> : never },\n    never\n  > {\n    type ResultType = {\n      [K in keyof R]: R[K] extends Task<infer U, infer E> ? TaskSettledResult<U, E> : never;\n    };\n\n    const combinedTask = new Task<ResultType, never>();\n\n    if (tasks.length === 0) {\n      combinedTask.resolve([] as any);\n      return combinedTask;\n    }\n\n    const results: any[] = new Array(tasks.length);\n    let settledCount = 0;\n\n    tasks.forEach((task, index) => {\n      task.wait(\n        (result) => {\n          results[index] = { status: 'resolved', value: result };\n          settledCount++;\n\n          if (settledCount === tasks.length) {\n            combinedTask.resolve(results as ResultType);\n          }\n        },\n        (error) => {\n          results[index] = {\n            status: error.type === 'abort' ? 'aborted' : 'rejected',\n            reason: error.reason,\n          };\n          settledCount++;\n\n          if (settledCount === tasks.length) {\n            combinedTask.resolve(results as ResultType);\n          }\n        },\n      );\n    });\n\n    return combinedTask;\n  }\n\n  /**\n   * Static method that resolves/rejects with the first task that settles\n   *\n   * @param tasks - array of tasks to race\n   * @returns new task that settles with the first input task that settles\n   * @public\n   */\n  static race<R extends readonly Task<any, any>[]>(\n    tasks: R,\n  ): Task<\n    R[number] extends Task<infer U, any> ? U : never,\n    R[number] extends Task<any, infer E> ? E : never\n  > {\n    type ResultType = R[number] extends Task<infer U, any> ? U : never;\n    type ErrorType = R[number] extends Task<any, infer E> ? E : never;\n\n    const combinedTask = new Task<ResultType, ErrorType>();\n\n    if (tasks.length === 0) {\n      combinedTask.reject('No tasks provided' as ErrorType);\n      return combinedTask;\n    }\n\n    let isSettled = false;\n\n    tasks.forEach((task) => {\n      task.wait(\n        (result) => {\n          if (isSettled) return;\n          isSettled = true;\n          combinedTask.resolve(result);\n        },\n        (error) => {\n          if (isSettled) return;\n          isSettled = true;\n          if (error.type === 'abort') {\n            combinedTask.abort(error.reason);\n          } else {\n            combinedTask.reject(error.reason);\n          }\n        },\n      );\n    });\n\n    return combinedTask;\n  }\n\n  /**\n   * Utility to track progress of multiple tasks\n   *\n   * @param tasks - array of tasks to track\n   * @param onProgress - callback called when any task completes\n   * @returns new task that resolves when all input tasks resolve\n   * @public\n   */\n  static withProgress<R extends readonly Task<any, any>[]>(\n    tasks: R,\n    onProgress?: (completed: number, total: number) => void,\n  ): Task<{ [K in keyof R]: R[K] extends Task<infer U, any> ? U : never }, any> {\n    const combinedTask = Task.all(tasks);\n\n    if (onProgress) {\n      let completedCount = 0;\n      tasks.forEach((task) => {\n        task.wait(\n          () => {\n            completedCount++;\n            onProgress(completedCount, tasks.length);\n          },\n          () => {\n            completedCount++;\n            onProgress(completedCount, tasks.length);\n          },\n        );\n      });\n    }\n\n    return combinedTask;\n  }\n}\n\n/**\n * Type that represent the result of executing task\n */\nexport type TaskReturn<T extends Task<any, any>> =\n  T extends Task<infer R, infer E>\n    ? { type: 'result'; value: R } | { type: 'error'; value: TaskError<E> }\n    : never;\n","import { WebAlphaColor } from './color';\nimport { Size, Rect, Position, Rotation, Quad } from './geometry';\nimport { Task, TaskError } from './task';\n\n/**\n * Representation of pdf page\n *\n * @public\n */\nexport interface PdfPageObject {\n  /**\n   * Index of this page, starts from 0\n   */\n  index: number;\n\n  /**\n   * Orignal size of this page\n   */\n  size: Size;\n}\n\n/**\n * Representation of pdf page with rotated size\n *\n * @public\n */\nexport interface PdfPageObjectWithRotatedSize extends PdfPageObject {\n  /**\n   * Rotated size of this page\n   */\n  rotatedSize: Size;\n}\n\n/**\n * Representation of pdf document\n *\n * @public\n */\nexport interface PdfDocumentObject {\n  /**\n   * Identity of document\n   */\n  id: string;\n\n  /**\n   * Count of pages in this document\n   */\n  pageCount: number;\n\n  /**\n   * Pages in this document\n   */\n  pages: PdfPageObject[];\n}\n\n/**\n * metadata of pdf document\n *\n * @public\n */\nexport interface PdfMetadataObject {\n  /**\n   * title of the document\n   */\n  title: string;\n  /**\n   * author of the document\n   */\n  author: string;\n  /**\n   * subject of the document\n   */\n  subject: string;\n  /**\n   * keywords of the document\n   */\n  keywords: string;\n  /**\n   * producer of the document\n   */\n  producer: string;\n  /**\n   * creator of the document\n   */\n  creator: string;\n  /**\n   * creation date of the document\n   */\n  creationDate: string;\n  /**\n   * modification date of the document\n   */\n  modificationDate: string;\n}\n\n/**\n * Unicode **soft-hyphen** marker (`U+00AD`).\n * Often embedded by PDF generators as discretionary hyphens.\n *\n * @public\n */\nexport const PdfSoftHyphenMarker = '\\u00AD';\n\n/**\n * Unicode **zero-width space** (`U+200B`).\n *\n * @public\n */\nexport const PdfZeroWidthSpace = '\\u200B';\n\n/**\n * Unicode **word-joiner** (`U+2060`) – zero-width no-break.\n *\n * @public\n */\nexport const PdfWordJoiner = '\\u2060';\n\n/**\n * Unicode **byte-order mark / zero-width&nbsp;no-break space** (`U+FEFF`).\n *\n * @public\n */\nexport const PdfBomOrZwnbsp = '\\uFEFF';\n\n/**\n * Unicode non-character `U+FFFE`.\n *\n * @public\n */\nexport const PdfNonCharacterFFFE = '\\uFFFE';\n\n/**\n * Unicode non-character `U+FFFF`.\n *\n * @public\n */\nexport const PdfNonCharacterFFFF = '\\uFFFF';\n\n/**\n * **Frozen list** of all unwanted markers in canonical order.\n *\n * @public\n */\nexport const PdfUnwantedTextMarkers = Object.freeze([\n  PdfSoftHyphenMarker,\n  PdfZeroWidthSpace,\n  PdfWordJoiner,\n  PdfBomOrZwnbsp,\n  PdfNonCharacterFFFE,\n  PdfNonCharacterFFFF,\n] as const);\n\n/**\n * Compiled regular expression that matches any unwanted marker.\n *\n * @public\n */\nexport const PdfUnwantedTextRegex = new RegExp(`[${PdfUnwantedTextMarkers.join('')}]`, 'g');\n\n/**\n * Remove all {@link PdfUnwantedTextMarkers | unwanted markers} from *text*.\n *\n * @param text - raw text extracted from PDF\n * @returns cleaned text\n *\n * @public\n */\nexport function stripPdfUnwantedMarkers(text: string): string {\n  return text.replace(PdfUnwantedTextRegex, '');\n}\n\n/**\n * zoom mode\n *\n * @public\n */\nexport enum PdfZoomMode {\n  Unknown = 0,\n  /**\n   * Zoom level with specified offset.\n   */\n  XYZ = 1,\n  /**\n   * Fit both the width and height of the page (whichever smaller).\n   */\n  FitPage = 2,\n  /**\n   * Fit the page width.\n   */\n  FitHorizontal = 3,\n  /**\n   * Fit the page height.\n   */\n  FitVertical = 4,\n  /**\n   * Fit a specific rectangle area within the window.\n   */\n  FitRectangle = 5,\n}\n\n/**\n * Blend mode\n *\n * @public\n */\nexport enum PdfBlendMode {\n  Normal = 0,\n  Multiply = 1,\n  Screen = 2,\n  Overlay = 3,\n  Darken = 4,\n  Lighten = 5,\n  ColorDodge = 6,\n  ColorBurn = 7,\n  HardLight = 8,\n  SoftLight = 9,\n  Difference = 10,\n  Exclusion = 11,\n  Hue = 12,\n  Saturation = 13,\n  Color = 14,\n  Luminosity = 15,\n}\n\n/** Extra UI sentinel for “multiple different values selected”. */\nexport const MixedBlendMode = Symbol('mixed');\nexport type UiBlendModeValue = PdfBlendMode | typeof MixedBlendMode;\n\ninterface BlendModeInfo {\n  /** Pdf enum value */\n  id: PdfBlendMode;\n  /** Human label for UI */\n  label: string;\n  /** CSS mix-blend-mode token */\n  css: string;\n}\n\n/** Canonical ordered descriptor list (matches enum numeric order). */\nconst BLEND_MODE_INFOS: readonly BlendModeInfo[] = Object.freeze([\n  { id: PdfBlendMode.Normal, label: 'Normal', css: 'normal' },\n  { id: PdfBlendMode.Multiply, label: 'Multiply', css: 'multiply' },\n  { id: PdfBlendMode.Screen, label: 'Screen', css: 'screen' },\n  { id: PdfBlendMode.Overlay, label: 'Overlay', css: 'overlay' },\n  { id: PdfBlendMode.Darken, label: 'Darken', css: 'darken' },\n  { id: PdfBlendMode.Lighten, label: 'Lighten', css: 'lighten' },\n  { id: PdfBlendMode.ColorDodge, label: 'Color Dodge', css: 'color-dodge' },\n  { id: PdfBlendMode.ColorBurn, label: 'Color Burn', css: 'color-burn' },\n  { id: PdfBlendMode.HardLight, label: 'Hard Light', css: 'hard-light' },\n  { id: PdfBlendMode.SoftLight, label: 'Soft Light', css: 'soft-light' },\n  { id: PdfBlendMode.Difference, label: 'Difference', css: 'difference' },\n  { id: PdfBlendMode.Exclusion, label: 'Exclusion', css: 'exclusion' },\n  { id: PdfBlendMode.Hue, label: 'Hue', css: 'hue' },\n  { id: PdfBlendMode.Saturation, label: 'Saturation', css: 'saturation' },\n  { id: PdfBlendMode.Color, label: 'Color', css: 'color' },\n  { id: PdfBlendMode.Luminosity, label: 'Luminosity', css: 'luminosity' },\n]);\n\n/* Build O(1) maps once */\nconst enumToInfo: Record<PdfBlendMode, BlendModeInfo> = BLEND_MODE_INFOS.reduce(\n  (m, info) => {\n    m[info.id] = info;\n    return m;\n  },\n  {} as Record<PdfBlendMode, BlendModeInfo>,\n);\n\nconst cssToEnum = BLEND_MODE_INFOS.reduce<Record<string, PdfBlendMode>>((m, info) => {\n  m[info.css] = info.id;\n  return m;\n}, {});\n\n/** Get descriptor (falls back to Normal if unknown number sneaks in).\n *\n * @public\n */\nexport function getBlendModeInfo(mode: PdfBlendMode): BlendModeInfo {\n  return enumToInfo[mode] ?? enumToInfo[PdfBlendMode.Normal];\n}\n\n/** Convert enum → CSS value for `mix-blend-mode`.\n *\n * @public\n */\nexport function blendModeToCss(mode: PdfBlendMode): string {\n  return getBlendModeInfo(mode).css;\n}\n\n/** Convert CSS token → enum (returns undefined if not recognized).\n *\n * @public\n */\nexport function cssToBlendMode(value: string): PdfBlendMode | undefined {\n  return cssToEnum[value as keyof typeof cssToEnum];\n}\n\n/** Enum → UI label.\n *\n * @public\n */\nexport function blendModeLabel(mode: PdfBlendMode): string {\n  return getBlendModeInfo(mode).label;\n}\n\n/**\n * For a selection of annotations: returns the common enum value, or Mixed sentinel.\n *\n * @public\n */\nexport function reduceBlendModes(modes: readonly PdfBlendMode[]): UiBlendModeValue {\n  if (!modes.length) return PdfBlendMode.Normal;\n  const first = modes[0];\n  return modes.every((m) => m === first) ? first : MixedBlendMode;\n}\n\n/** Options for a <select>.\n *\n * @public\n */\nexport const blendModeSelectOptions = BLEND_MODE_INFOS.map((info) => ({\n  value: info.id,\n  label: info.label,\n}));\n\n/** Provide a label when Mixed sentinel used (UI convenience).\n *\n * @public\n */\nexport function uiBlendModeDisplay(value: UiBlendModeValue): string {\n  return value === MixedBlendMode ? '(mixed)' : blendModeLabel(value);\n}\n\n/**\n * Representation of the linked destination\n *\n * @public\n */\nexport interface PdfDestinationObject {\n  /**\n   * Index of target page\n   */\n  pageIndex: number;\n  /**\n   * zoom config for target destination\n   */\n  zoom:\n    | {\n        mode: PdfZoomMode.Unknown;\n      }\n    | { mode: PdfZoomMode.XYZ; params: { x: number; y: number; zoom: number } }\n    | {\n        mode: PdfZoomMode.FitPage;\n      }\n    | {\n        mode: PdfZoomMode.FitHorizontal;\n      }\n    | {\n        mode: PdfZoomMode.FitVertical;\n      }\n    | {\n        mode: PdfZoomMode.FitRectangle;\n      };\n  view: number[];\n}\n\n/**\n * Type of pdf action\n *\n * @public\n */\nexport enum PdfActionType {\n  Unsupported = 0,\n  /**\n   * Goto specified position in this document\n   */\n  Goto = 1,\n  /**\n   * Goto specified position in another document\n   */\n  RemoteGoto = 2,\n  /**\n   * Goto specified URI\n   */\n  URI = 3,\n  /**\n   * Launch specifed application\n   */\n  LaunchAppOrOpenFile = 4,\n}\n\nexport type PdfImage = {\n  data: Uint8ClampedArray;\n  width: number;\n  height: number;\n};\n\n/**\n * Representation of pdf action\n *\n * @public\n */\nexport type PdfActionObject =\n  | {\n      type: PdfActionType.Unsupported;\n    }\n  | {\n      type: PdfActionType.Goto;\n      destination: PdfDestinationObject;\n    }\n  | {\n      type: PdfActionType.RemoteGoto;\n      destination: PdfDestinationObject;\n    }\n  | {\n      type: PdfActionType.URI;\n      uri: string;\n    }\n  | {\n      type: PdfActionType.LaunchAppOrOpenFile;\n      path: string;\n    };\n\n/**\n * target of pdf link\n *\n * @public\n */\nexport type PdfLinkTarget =\n  | {\n      type: 'action';\n      action: PdfActionObject;\n    }\n  | {\n      type: 'destination';\n      destination: PdfDestinationObject;\n    };\n\n/**\n * PDF bookmark\n *\n * @public\n */\nexport interface PdfBookmarkObject {\n  /**\n   * title of bookmark\n   */\n  title: string;\n\n  /**\n   * target of bookmark\n   */\n  target?: PdfLinkTarget | undefined;\n\n  /**\n   * bookmarks in the next level\n   */\n  children?: PdfBookmarkObject[];\n}\n\n/**\n * Pdf Signature\n *\n * @public\n */\nexport interface PdfSignatureObject {\n  /**\n   * contents of signature\n   */\n  contents: ArrayBuffer;\n\n  /**\n   * byte range of signature\n   */\n  byteRange: ArrayBuffer;\n\n  /**\n   * sub filters of signature\n   */\n  subFilter: ArrayBuffer;\n\n  /**\n   * reason of signature\n   */\n  reason: string;\n\n  /**\n   * creation time of signature\n   */\n  time: string;\n\n  /**\n   * MDP\n   */\n  docMDP: number;\n}\n\n/**\n * Bookmark tree of pdf\n *\n * @public\n */\nexport interface PdfBookmarksObject {\n  bookmarks: PdfBookmarkObject[];\n}\n\n/**\n * Text rectangle in pdf page\n *\n * @public\n */\nexport interface PdfTextRectObject {\n  /**\n   * Font of the text\n   */\n  font: {\n    /**\n     * font family\n     */\n    family: string;\n\n    /**\n     * font size\n     */\n    size: number;\n  };\n\n  /**\n   * content in this rectangle area\n   */\n  content: string;\n\n  /**\n   * rectangle of the text\n   */\n  rect: Rect;\n}\n\n/**\n * Color\n *\n * @public\n */\nexport interface PdfAlphaColor {\n  /**\n   * red\n   */\n  red: number;\n  /**\n   * green\n   */\n  green: number;\n  /**\n   * blue\n   */\n  blue: number;\n  /**\n   * alpha\n   */\n  alpha: number;\n}\n\n/**\n * Annotation type\n *\n * @public\n */\nexport enum PdfAnnotationSubtype {\n  UNKNOWN = 0,\n  TEXT,\n  LINK,\n  FREETEXT,\n  LINE,\n  SQUARE,\n  CIRCLE,\n  POLYGON,\n  POLYLINE,\n  HIGHLIGHT,\n  UNDERLINE,\n  SQUIGGLY,\n  STRIKEOUT,\n  STAMP,\n  CARET,\n  INK,\n  POPUP,\n  FILEATTACHMENT,\n  SOUND,\n  MOVIE,\n  WIDGET,\n  SCREEN,\n  PRINTERMARK,\n  TRAPNET,\n  WATERMARK,\n  THREED,\n  RICHMEDIA,\n  XFAWIDGET,\n  REDACT,\n}\n\n/**\n * Name of annotation type\n *\n * @public\n */\nexport const PdfAnnotationSubtypeName: Record<PdfAnnotationSubtype, string> = {\n  [PdfAnnotationSubtype.UNKNOWN]: 'unknow',\n  [PdfAnnotationSubtype.TEXT]: 'text',\n  [PdfAnnotationSubtype.LINK]: 'link',\n  [PdfAnnotationSubtype.FREETEXT]: 'freetext',\n  [PdfAnnotationSubtype.LINE]: 'line',\n  [PdfAnnotationSubtype.SQUARE]: 'square',\n  [PdfAnnotationSubtype.CIRCLE]: 'circle',\n  [PdfAnnotationSubtype.POLYGON]: 'polygon',\n  [PdfAnnotationSubtype.POLYLINE]: 'polyline',\n  [PdfAnnotationSubtype.HIGHLIGHT]: 'highlight',\n  [PdfAnnotationSubtype.UNDERLINE]: 'underline',\n  [PdfAnnotationSubtype.SQUIGGLY]: 'squiggly',\n  [PdfAnnotationSubtype.STRIKEOUT]: 'strikeout',\n  [PdfAnnotationSubtype.STAMP]: 'stamp',\n  [PdfAnnotationSubtype.CARET]: 'caret',\n  [PdfAnnotationSubtype.INK]: 'ink',\n  [PdfAnnotationSubtype.POPUP]: 'popup',\n  [PdfAnnotationSubtype.FILEATTACHMENT]: 'fileattachment',\n  [PdfAnnotationSubtype.SOUND]: 'sound',\n  [PdfAnnotationSubtype.MOVIE]: 'movie',\n  [PdfAnnotationSubtype.WIDGET]: 'widget',\n  [PdfAnnotationSubtype.SCREEN]: 'screen',\n  [PdfAnnotationSubtype.PRINTERMARK]: 'printermark',\n  [PdfAnnotationSubtype.TRAPNET]: 'trapnet',\n  [PdfAnnotationSubtype.WATERMARK]: 'watermark',\n  [PdfAnnotationSubtype.THREED]: 'threed',\n  [PdfAnnotationSubtype.RICHMEDIA]: 'richmedia',\n  [PdfAnnotationSubtype.XFAWIDGET]: 'xfawidget',\n  [PdfAnnotationSubtype.REDACT]: 'redact',\n};\n\n/**\n * Status of pdf annotation\n *\n * @public\n */\nexport enum PdfAnnotationObjectStatus {\n  /**\n   * Annotation is created\n   */\n  Created,\n  /**\n   * Annotation is committed to PDF file\n   */\n  Committed,\n}\n\n/**\n * Appearance mode\n *\n * @public\n */\nexport enum AppearanceMode {\n  Normal = 0,\n  Rollover = 1,\n  Down = 2,\n}\n\n/**\n * State of pdf annotation\n *\n * @public\n */\nexport enum PdfAnnotationState {\n  /**\n   * Annotation is active\n   */\n  Marked = 'Marked',\n  /**\n   * Annotation is unmarked\n   */\n  Unmarked = 'Unmarked',\n  /**\n   * Annotation is ink\n   */\n  Accepted = 'Accepted',\n  /**\n   * Annotation is rejected\n   */\n  Rejected = 'Rejected',\n  /**\n   * Annotation is complete\n   */\n  Complete = 'Complete',\n  /**\n   * Annotation is cancelled\n   */\n  Cancelled = 'Cancelled',\n  /**\n   * Annotation is none\n   */\n  None = 'None',\n}\n\n/**\n * State model of pdf annotation\n *\n * @public\n */\nexport enum PdfAnnotationStateModel {\n  /**\n   * Annotation is marked\n   */\n  Marked = 'Marked',\n  /**\n   * Annotation is reviewed\n   */\n  Reviewed = 'Reviewed',\n}\n\n/**\n * Basic information of pdf annotation\n *\n * @public\n */\nexport interface PdfAnnotationObjectBase {\n  /**\n   * Author of the annotation\n   */\n  author?: string;\n\n  /**\n   * Modified date of the annotation\n   */\n  modified?: Date;\n\n  /**\n   * blend mode of annotation\n   */\n  blendMode?: PdfBlendMode;\n\n  /**\n   * intent of annotation\n   */\n  intent?: string;\n\n  /**\n   * Sub type of annotation\n   */\n  type: PdfAnnotationSubtype;\n\n  /**\n   * The index of page that this annotation belong to\n   */\n  pageIndex: number;\n\n  /**\n   * id of the annotation\n   */\n  id: number;\n\n  /**\n   * Rectangle of the annotation\n   */\n  rect: Rect;\n}\n\n/**\n * Popup annotation\n *\n * @public\n */\nexport interface PdfPopupAnnoObject extends PdfAnnotationObjectBase {\n  /** {@inheritDoc PdfAnnotationObjectBase.type} */\n  type: PdfAnnotationSubtype.POPUP;\n  /**\n   * Contents of the popup\n   */\n  contents: string;\n\n  /**\n   * Whether the popup is opened or not\n   */\n  open: boolean;\n\n  /**\n   * In reply to id\n   */\n  inReplyToId?: number;\n}\n\n/**\n * Pdf Link annotation\n *\n * @public\n */\nexport interface PdfLinkAnnoObject extends PdfAnnotationObjectBase {\n  /** {@inheritDoc PdfAnnotationObjectBase.type} */\n  type: PdfAnnotationSubtype.LINK;\n  /**\n   * Text of the link\n   */\n  text: string;\n  /**\n   * target of the link\n   */\n  target: PdfLinkTarget | undefined;\n}\n\n/**\n * Pdf Text annotation\n *\n * @public\n */\nexport interface PdfTextAnnoObject extends PdfAnnotationObjectBase {\n  /** {@inheritDoc PdfAnnotationObjectBase.type} */\n  type: PdfAnnotationSubtype.TEXT;\n  /**\n   * Text contents of the annotation\n   */\n  contents: string;\n\n  /**\n   * color of text annotation\n   */\n  color?: string;\n\n  /**\n   * opacity of text annotation\n   */\n  opacity?: number;\n\n  /**\n   * In reply to id\n   */\n  inReplyToId?: number;\n\n  /**\n   * State of the text annotation\n   */\n  state?: PdfAnnotationState;\n\n  /**\n   * State model of the text annotation\n   */\n  stateModel?: PdfAnnotationStateModel;\n}\n\n/**\n * Type of form field\n *\n * @public\n */\nexport enum PDF_FORM_FIELD_TYPE {\n  /**\n   * Unknow\n   */\n  UNKNOWN = 0,\n  /**\n   * push button type\n   */\n  PUSHBUTTON = 1,\n  /**\n   * check box type.\n   */\n  CHECKBOX = 2,\n  /**\n   * radio button type.\n   */\n  RADIOBUTTON = 3,\n  /**\n   * combo box type.\n   */\n  COMBOBOX = 4,\n  /**\n   * list box type.\n   */\n  LISTBOX = 5,\n  /**\n   *  text field type\n   */\n  TEXTFIELD = 6,\n  /**\n   * signature field type.\n   */\n  SIGNATURE = 7,\n  /**\n   * Generic XFA type.\n   */\n  XFA = 8,\n  /**\n   * XFA check box type.\n   */\n  XFA_CHECKBOX = 9,\n  /**\n   * XFA combo box type.\n   */\n  XFA_COMBOBOX = 10,\n  /**\n   * XFA image field type.\n   */\n  XFA_IMAGEFIELD = 11,\n  /**\n   * XFA list box type.\n   */\n  XFA_LISTBOX = 12,\n  /**\n   * XFA push button type.\n   */\n  XFA_PUSHBUTTON = 13,\n  /**\n   * XFA signture field type.\n   */\n  XFA_SIGNATURE = 14,\n  /**\n   * XFA text field type.\n   */\n  XFA_TEXTFIELD = 15,\n}\n\nexport enum PdfAnnotationColorType {\n  Color = 0,\n  InteriorColor = 1,\n}\n\n/**\n * Border style of pdf annotation\n *\n * @public\n */\nexport enum PdfAnnotationBorderStyle {\n  UNKNOWN = 0,\n  SOLID = 1,\n  DASHED = 2,\n  BEVELED = 3,\n  INSET = 4,\n  UNDERLINE = 5,\n  CLOUDY = 6,\n}\n\n/**\n * Flag of pdf annotation\n *\n * @public\n */\nexport enum PdfAnnotationFlags {\n  NONE = 0,\n  INVISIBLE = 1 << 0,\n  HIDDEN = 1 << 1,\n  PRINT = 1 << 2,\n  NO_ZOOM = 1 << 3,\n  NO_ROTATE = 1 << 4,\n  NO_VIEW = 1 << 5,\n  READ_ONLY = 1 << 6,\n  LOCKED = 1 << 7,\n  TOGGLE_NOVIEW = 1 << 8,\n}\n\n/**\n * Flag of form field\n *\n * @public\n */\nexport enum PDF_FORM_FIELD_FLAG {\n  NONE = 0,\n  READONLY = 1 << 0,\n  REQUIRED = 1 << 1,\n  NOEXPORT = 1 << 2,\n  TEXT_MULTIPLINE = 1 << 12,\n  TEXT_PASSWORD = 1 << 13,\n  CHOICE_COMBO = 1 << 17,\n  CHOICE_EDIT = 1 << 18,\n  CHOICE_MULTL_SELECT = 1 << 21,\n}\n\n/**\n * Type of pdf object\n *\n * @public\n */\nexport enum PdfPageObjectType {\n  UNKNOWN = 0,\n  TEXT = 1,\n  PATH = 2,\n  IMAGE = 3,\n  SHADING = 4,\n  FORM = 5,\n}\n\n/**\n * Options of pdf widget annotation\n *\n * @public\n */\nexport interface PdfWidgetAnnoOption {\n  label: string;\n  isSelected: boolean;\n}\n\nexport type PdfAnnotationFlagName =\n  | 'invisible'\n  | 'hidden'\n  | 'print'\n  | 'noZoom'\n  | 'noRotate'\n  | 'noView'\n  | 'readOnly'\n  | 'locked'\n  | 'toggleNoView';\n\ntype FlagMap = Partial<\n  Record<Exclude<PdfAnnotationFlags, PdfAnnotationFlags.NONE>, PdfAnnotationFlagName>\n>;\n\nexport const PdfAnnotationFlagName: Readonly<FlagMap> = Object.freeze({\n  [PdfAnnotationFlags.INVISIBLE]: 'invisible',\n  [PdfAnnotationFlags.HIDDEN]: 'hidden',\n  [PdfAnnotationFlags.PRINT]: 'print',\n  [PdfAnnotationFlags.NO_ZOOM]: 'noZoom',\n  [PdfAnnotationFlags.NO_ROTATE]: 'noRotate',\n  [PdfAnnotationFlags.NO_VIEW]: 'noView',\n  [PdfAnnotationFlags.READ_ONLY]: 'readOnly',\n  [PdfAnnotationFlags.LOCKED]: 'locked',\n  [PdfAnnotationFlags.TOGGLE_NOVIEW]: 'toggleNoView',\n} as const);\n\n/** Build a reverse map once so look-ups are O(1)                      */\nconst PdfAnnotationFlagValue: Record<PdfAnnotationFlagName, PdfAnnotationFlags> = Object.entries(\n  PdfAnnotationFlagName,\n).reduce(\n  (acc, [bit, name]) => {\n    acc[name as PdfAnnotationFlagName] = Number(bit) as PdfAnnotationFlags;\n    return acc;\n  },\n  {} as Record<PdfAnnotationFlagName, PdfAnnotationFlags>,\n);\n\n/**\n * Convert the raw bit-mask coming from `FPDFAnnot_GetFlags()` into\n * an array of human-readable flag names (“invisible”, “print”…).\n */\nexport function flagsToNames(raw: number): PdfAnnotationFlagName[] {\n  return (\n    Object.keys(PdfAnnotationFlagName) as unknown as Exclude<\n      PdfAnnotationFlags,\n      PdfAnnotationFlags.NONE\n    >[]\n  )\n    .filter((flag) => (raw & flag) !== 0)\n    .map((flag) => PdfAnnotationFlagName[flag]!);\n}\n\n/**\n * Convert an array of flag-names back into the numeric mask that\n * PDFium expects for `FPDFAnnot_SetFlags()`.\n */\nexport function namesToFlags(names: readonly PdfAnnotationFlagName[]): PdfAnnotationFlags {\n  return names.reduce<PdfAnnotationFlags>(\n    (mask, name) => mask | PdfAnnotationFlagValue[name],\n    PdfAnnotationFlags.NONE,\n  );\n}\n\n/**\n * Field of PDF widget annotation\n *\n * @public\n */\nexport interface PdfWidgetAnnoField {\n  /**\n   * flag of field\n   */\n  flag: PDF_FORM_FIELD_FLAG;\n  /**\n   * name of field\n   */\n  name: string;\n  /**\n   * alternate name of field\n   */\n  alternateName: string;\n  /**\n   * type of field\n   */\n  type: PDF_FORM_FIELD_TYPE;\n  /**\n   * value of field\n   */\n  value: string;\n  /**\n   * whether field is checked\n   */\n  isChecked: boolean;\n  /**\n   * options of field\n   */\n  options: PdfWidgetAnnoOption[];\n}\n\n/**\n * PDF widget object\n *\n * @public\n */\nexport interface PdfWidgetAnnoObject extends PdfAnnotationObjectBase {\n  /** {@inheritDoc PdfAnnotationObjectBase.type} */\n  type: PdfAnnotationSubtype.WIDGET;\n  /**\n   * Field of pdf widget object\n   */\n  field: PdfWidgetAnnoField;\n}\n\n/**\n * Pdf file attachments annotation\n *\n * @public\n */\nexport interface PdfFileAttachmentAnnoObject extends PdfAnnotationObjectBase {\n  /** {@inheritDoc PdfAnnotationObjectBase.type} */\n  type: PdfAnnotationSubtype.FILEATTACHMENT;\n}\n\n/**\n * ink list in pdf ink annotation\n *\n * @public\n */\nexport interface PdfInkListObject {\n  points: Position[];\n}\n\n/**\n * Pdf ink annotation\n *\n * @public\n */\nexport interface PdfInkAnnoObject extends PdfAnnotationObjectBase {\n  /** {@inheritDoc PdfAnnotationObjectBase.type} */\n  type: PdfAnnotationSubtype.INK;\n  /**\n   * ink list of annotation\n   */\n  inkList: PdfInkListObject[];\n  /**\n   * color of ink annotation\n   */\n  color: string;\n\n  /**\n   * opacity of ink annotation\n   */\n  opacity: number;\n\n  /**\n   * stroke-width of ink annotation\n   */\n  strokeWidth: number;\n}\n\n/**\n * Pdf polygon annotation\n *\n * @public\n */\nexport interface PdfPolygonAnnoObject extends PdfAnnotationObjectBase {\n  /** {@inheritDoc PdfAnnotationObjectBase.type} */\n  type: PdfAnnotationSubtype.POLYGON;\n  /**\n   * vertices of annotation\n   */\n  vertices: Position[];\n}\n\n/**\n * PDF polyline annotation\n *\n * @public\n */\nexport interface PdfPolylineAnnoObject extends PdfAnnotationObjectBase {\n  /** {@inheritDoc PdfAnnotationObjectBase.type} */\n  type: PdfAnnotationSubtype.POLYLINE;\n  /**\n   * vertices of annotation\n   */\n  vertices: Position[];\n}\n\n/**\n * PDF line annotation\n *\n * @public\n */\nexport interface PdfLineAnnoObject extends PdfAnnotationObjectBase {\n  /** {@inheritDoc PdfAnnotationObjectBase.type} */\n  type: PdfAnnotationSubtype.LINE;\n  /**\n   * start point of line\n   */\n  startPoint: Position;\n  /**\n   * end point of line\n   */\n  endPoint: Position;\n}\n\n/**\n * PDF highlight annotation\n *\n * @public\n */\nexport interface PdfHighlightAnnoObject extends PdfAnnotationObjectBase {\n  /** {@inheritDoc PdfAnnotationObjectBase.type} */\n  type: PdfAnnotationSubtype.HIGHLIGHT;\n\n  /**\n   * Text contents of the highlight annotation\n   */\n  contents?: string;\n\n  /**\n   * color of highlight annotation\n   */\n  color: string;\n\n  /**\n   * opacity of highlight annotation\n   */\n  opacity: number;\n\n  /**\n   * quads of highlight area\n   */\n  segmentRects: Rect[];\n}\n\n/**\n * Matrix for transformation, in the form [a b c d e f], equivalent to:\n * | a  b  0 |\n * | c  d  0 |\n * | e  f  1 |\n *\n * Translation is performed with [1 0 0 1 tx ty].\n * Scaling is performed with [sx 0 0 sy 0 0].\n * See PDF Reference 1.7, 4.2.2 Common Transformations for more.\n */\nexport interface PdfTransformMatrix {\n  a: number;\n  b: number;\n  c: number;\n  d: number;\n  e: number;\n  f: number;\n}\n\n/**\n * type of segment type in pdf path object\n *\n * @public\n */\nexport enum PdfSegmentObjectType {\n  UNKNOWN = -1,\n  LINETO = 0,\n  BEZIERTO = 1,\n  MOVETO = 2,\n}\n\n/**\n * segment of path object\n *\n * @public\n */\nexport interface PdfSegmentObject {\n  type: PdfSegmentObjectType;\n  /**\n   * point of the segment\n   */\n  point: Position;\n  /**\n   * whether this segment close the path\n   */\n  isClosed: boolean;\n}\n\n/**\n * Pdf path object\n *\n * @public\n */\nexport interface PdfPathObject {\n  type: PdfPageObjectType.PATH;\n  /**\n   * bound that contains the path\n   */\n  bounds: { left: number; bottom: number; right: number; top: number };\n  /**\n   * segments of the path\n   */\n  segments: PdfSegmentObject[];\n  /**\n   * transform matrix\n   */\n  matrix: PdfTransformMatrix;\n}\n\n/**\n * Pdf image object\n *\n * @public\n */\nexport interface PdfImageObject {\n  type: PdfPageObjectType.IMAGE;\n  /**\n   * data of the image\n   */\n  imageData: ImageData;\n  /**\n   * transform matrix\n   */\n  matrix: PdfTransformMatrix;\n}\n\n/**\n * Pdf form object\n *\n * @public\n */\nexport interface PdfFormObject {\n  type: PdfPageObjectType.FORM;\n  /**\n   * objects that in this form object\n   */\n  objects: (PdfImageObject | PdfPathObject | PdfFormObject)[];\n  /**\n   * transform matrix\n   */\n  matrix: PdfTransformMatrix;\n}\n\n/**\n * Contents type of pdf stamp annotation\n *\n * @public\n */\nexport type PdfStampAnnoObjectContents = Array<PdfPathObject | PdfImageObject | PdfFormObject>;\n\n/**\n * Pdf stamp annotation\n *\n * @public\n */\nexport interface PdfStampAnnoObject extends PdfAnnotationObjectBase {\n  /** {@inheritDoc PdfAnnotationObjectBase.type} */\n  type: PdfAnnotationSubtype.STAMP;\n  /**\n   * contents in this stamp annotation\n   */\n  contents: PdfStampAnnoObjectContents;\n}\n\n/**\n * Pdf circle annotation\n *\n * @public\n */\nexport interface PdfCircleAnnoObject extends PdfAnnotationObjectBase {\n  /** {@inheritDoc PdfAnnotationObjectBase.type} */\n  type: PdfAnnotationSubtype.CIRCLE;\n  /**\n   * flags of circle annotation\n   */\n  flags: PdfAnnotationFlagName[];\n  /**\n   * color of circle annotation\n   */\n  color: string;\n  /**\n   * opacity of circle annotation\n   */\n  opacity: number;\n  /**\n   * stroke-width of circle annotation\n   */\n  strokeWidth: number;\n  /**\n   * stroke color of circle annotation\n   */\n  strokeColor: string;\n  /**\n   * stroke style of circle annotation\n   */\n  strokeStyle: PdfAnnotationBorderStyle;\n  /**\n   * stroke dash array of circle annotation\n   */\n  strokeDashArray?: number[];\n  /**\n   * cloudy border intensity of circle annotation\n   */\n  cloudyBorderIntensity?: number;\n  /**\n   * cloudy border inset of circle annotation\n   */\n  cloudyBorderInset?: number[];\n}\n\n/**\n * Pdf square annotation\n *\n * @public\n */\nexport interface PdfSquareAnnoObject extends PdfAnnotationObjectBase {\n  /** {@inheritDoc PdfAnnotationObjectBase.type} */\n  type: PdfAnnotationSubtype.SQUARE;\n  /**\n   * flags of square annotation\n   */\n  flags: PdfAnnotationFlagName[];\n  /**\n   * color of square annotation\n   */\n  color: string;\n  /**\n   * opacity of square annotation\n   */\n  opacity: number;\n  /**\n   * stroke-width of square annotation\n   */\n  strokeWidth: number;\n  /**\n   * stroke color of square annotation\n   */\n  strokeColor: string;\n  /**\n   * stroke style of square annotation\n   */\n  strokeStyle: PdfAnnotationBorderStyle;\n  /**\n   * stroke dash array of square annotation\n   */\n  strokeDashArray?: number[];\n  /**\n   * cloudy border intensity of circle annotation\n   */\n  cloudyBorderIntensity?: number;\n  /**\n   * cloudy border inset of circle annotation\n   */\n  cloudyBorderInset?: number[];\n}\n\n/**\n * Pdf squiggly annotation\n *\n * @public\n */\nexport interface PdfSquigglyAnnoObject extends PdfAnnotationObjectBase {\n  /** {@inheritDoc PdfAnnotationObjectBase.type} */\n  type: PdfAnnotationSubtype.SQUIGGLY;\n  /**\n   * Text contents of the highlight annotation\n   */\n  contents?: string;\n  /**\n   * color of strike out annotation\n   */\n  color: string;\n\n  /**\n   * opacity of strike out annotation\n   */\n  opacity: number;\n  /**\n   * quads of highlight area\n   */\n  segmentRects: Rect[];\n}\n\n/**\n * Pdf underline annotation\n *\n * @public\n */\nexport interface PdfUnderlineAnnoObject extends PdfAnnotationObjectBase {\n  /** {@inheritDoc PdfAnnotationObjectBase.type} */\n  type: PdfAnnotationSubtype.UNDERLINE;\n  /**\n   * Text contents of the highlight annotation\n   */\n  contents?: string;\n  /**\n   * color of strike out annotation\n   */\n  color: string;\n\n  /**\n   * opacity of strike out annotation\n   */\n  opacity: number;\n  /**\n   * quads of highlight area\n   */\n  segmentRects: Rect[];\n}\n\n/**\n * Pdf strike out annotation\n *\n * @public\n */\nexport interface PdfStrikeOutAnnoObject extends PdfAnnotationObjectBase {\n  /** {@inheritDoc PdfAnnotationObjectBase.type} */\n  type: PdfAnnotationSubtype.STRIKEOUT;\n  /**\n   * Text contents of the strike out annotation\n   */\n  contents?: string;\n\n  /**\n   * color of strike out annotation\n   */\n  color: string;\n\n  /**\n   * opacity of strike out annotation\n   */\n  opacity: number;\n\n  /**\n   * quads of highlight area\n   */\n  segmentRects: Rect[];\n}\n\n/**\n * Pdf caret annotation\n *\n * @public\n */\nexport interface PdfCaretAnnoObject extends PdfAnnotationObjectBase {\n  /** {@inheritDoc PdfAnnotationObjectBase.type} */\n  type: PdfAnnotationSubtype.CARET;\n}\n\n/**\n * Pdf free text annotation\n *\n * @public\n */\nexport interface PdfFreeTextAnnoObject extends PdfAnnotationObjectBase {\n  /** {@inheritDoc PdfAnnotationObjectBase.type} */\n  type: PdfAnnotationSubtype.FREETEXT;\n  contents: string;\n  richContent?: string;\n}\n\n/**\n * All annotation that support\n *\n * @public\n */\nexport type PdfSupportedAnnoObject =\n  | PdfInkAnnoObject\n  | PdfTextAnnoObject\n  | PdfLinkAnnoObject\n  | PdfPolygonAnnoObject\n  | PdfPolylineAnnoObject\n  | PdfHighlightAnnoObject\n  | PdfLineAnnoObject\n  | PdfWidgetAnnoObject\n  | PdfFileAttachmentAnnoObject\n  | PdfStampAnnoObject\n  | PdfSquareAnnoObject\n  | PdfCircleAnnoObject\n  | PdfSquigglyAnnoObject\n  | PdfUnderlineAnnoObject\n  | PdfStrikeOutAnnoObject\n  | PdfCaretAnnoObject\n  | PdfFreeTextAnnoObject;\n\n/**\n * Pdf annotation that does not support\n *\n * @public\n */\nexport interface PdfUnsupportedAnnoObject extends PdfAnnotationObjectBase {\n  type: Exclude<PdfAnnotationSubtype, PdfSupportedAnnoObject['type']>;\n}\n\n/**\n * all annotations\n *\n * @public\n */\nexport type PdfAnnotationObject = PdfSupportedAnnoObject | PdfUnsupportedAnnoObject;\n\n/**\n * Pdf attachment\n *\n * @public\n */\nexport interface PdfAttachmentObject {\n  index: number;\n  name: string;\n  creationDate: string;\n  checksum: string;\n}\n\n/**\n * Pdf engine features\n *\n * @public\n */\nexport enum PdfEngineFeature {\n  RenderPage,\n  RenderPageRect,\n  Thumbnails,\n  Bookmarks,\n  Annotations,\n}\n\n/**\n * All operations for this engine\n *\n * @public\n */\nexport enum PdfEngineOperation {\n  Create,\n  Read,\n  Update,\n  Delete,\n}\n\n/**\n * flags to match the text during searching\n *\n * @public\n */\nexport enum MatchFlag {\n  None = 0,\n  MatchCase = 1,\n  MatchWholeWord = 2,\n  MatchConsecutive = 4,\n}\n\n/**\n * Union all the flags\n * @param flags - all the flags\n * @returns union of flags\n *\n * @public\n */\nexport function unionFlags(flags: MatchFlag[]) {\n  return flags.reduce((flag, currFlag) => {\n    return flag | currFlag;\n  }, MatchFlag.None);\n}\n\n/**\n * Image conversion types\n *\n * @public\n */\nexport type ImageConversionTypes = 'image/webp' | 'image/png' | 'image/jpeg';\n\n/**\n * Targe for searching\n *\n * @public\n */\nexport interface SearchTarget {\n  keyword: string;\n  flags: MatchFlag[];\n}\n\n/**\n * compare 2 search target\n * @param targetA - first target for search\n * @param targetB - second target for search\n * @returns whether 2 search target are the same\n *\n * @public\n */\nexport function compareSearchTarget(targetA: SearchTarget, targetB: SearchTarget) {\n  const flagA = unionFlags(targetA.flags);\n  const flagB = unionFlags(targetB.flags);\n\n  return flagA === flagB && targetA.keyword === targetB.keyword;\n}\n\n/** Context of one hit */\nexport interface TextContext {\n  /** Complete words that come *before* the hit (no ellipsis)            */\n  before: string;\n  /** Exactly the text that matched (case-preserved)                      */\n  match: string;\n  /** Complete words that come *after* the hit (no ellipsis)             */\n  after: string;\n  /** `true` ⇢ there were more words on the left that we cut off         */\n  truncatedLeft: boolean;\n  /** `true` ⇢ there were more words on the right that we cut off        */\n  truncatedRight: boolean;\n}\n\n/**\n * Text slice\n *\n * @public\n */\nexport interface PageTextSlice {\n  /**\n   * Index of the pdf page\n   */\n  pageIndex: number;\n  /**\n   * Index of the first character\n   */\n  charIndex: number;\n  /**\n   * Count of the characters\n   */\n  charCount: number;\n}\n\n/**\n * search result\n *\n * @public\n */\nexport interface SearchResult {\n  /**\n   * Index of the pdf page\n   */\n  pageIndex: number;\n  /**\n   * index of the first character\n   */\n  charIndex: number;\n  /**\n   * count of the characters\n   */\n  charCount: number;\n  /**\n   * highlight rects\n   */\n  rects: Rect[];\n  /**\n   * context of the hit\n   */\n  context: TextContext;\n}\n\n/**\n * Results of searching through the entire document\n */\nexport interface SearchAllPagesResult {\n  /**\n   * Array of all search results across all pages\n   */\n  results: SearchResult[];\n\n  /**\n   * Total number of results found\n   */\n  total: number;\n}\n\n/**\n * Glyph object\n *\n * @public\n */\nexport interface PdfGlyphObject {\n  /**\n   * Origin of the glyph\n   */\n  origin: { x: number; y: number };\n  /**\n   * Size of the glyph\n   */\n  size: { width: number; height: number };\n  /**\n   * Whether the glyph is a space\n   */\n  isSpace?: boolean;\n  /**\n   * Whether the glyph is a empty\n   */\n  isEmpty?: boolean;\n}\n\n/**\n * Glyph object\n *\n * @public\n */\nexport interface PdfGlyphSlim {\n  /**\n   * X coordinate of the glyph\n   */\n  x: number;\n  /**\n   * Y coordinate of the glyph\n   */\n  y: number;\n  /**\n   * Width of the glyph\n   */\n  width: number;\n  /**\n   * Height of the glyph\n   */\n  height: number;\n  /**\n   * Flags of the glyph\n   */\n  flags: number;\n}\n\n/**\n * Run object\n *\n * @public\n */\nexport interface PdfRun {\n  /**\n   * Rectangle of the run\n   */\n  rect: { x: number; y: number; width: number; height: number };\n  /**\n   * Start index of the run\n   */\n  charStart: number;\n  /**\n   * Glyphs of the run\n   */\n  glyphs: PdfGlyphSlim[];\n}\n\n/**\n * Page geometry\n *\n * @public\n */\nexport interface PdfPageGeometry {\n  /**\n   * Runs of the page\n   */\n  runs: PdfRun[];\n}\n\n/**\n * form field value\n * @public\n */\nexport type FormFieldValue =\n  | { kind: 'text'; text: string }\n  | { kind: 'selection'; index: number; isSelected: boolean }\n  | { kind: 'checked'; isChecked: boolean };\n\n/**\n * Transformation that will be applied to annotation\n *\n * @public\n */\nexport interface PdfAnnotationTransformation {\n  /**\n   * Translated offset\n   */\n  offset: Position;\n  /**\n   * Scaled factors\n   */\n  scale: Size;\n}\n\n/**\n * Render options\n *\n * @public\n */\nexport interface PdfRenderOptions {\n  /**\n   * Whether needs to render the page with annotations\n   */\n  withAnnotations: boolean;\n}\n\n/**\n * source can be byte array contains pdf content\n *\n * @public\n */\nexport type PdfFileContent = ArrayBuffer;\n\nexport enum PdfPermission {\n  PrintDocument = 2 ** 3,\n  ModifyContent = 2 ** 4,\n  CopyOrExtract = 2 ** 5,\n  AddOrModifyTextAnnot = 2 ** 6,\n  FillInExistingForm = 2 ** 9,\n  ExtractTextOrGraphics = 2 ** 10,\n  AssembleDocument = 2 ** 11,\n  PrintHighQuality = 2 ** 12,\n}\n\nexport enum PdfPageFlattenFlag {\n  Display = 0,\n  Print = 1,\n}\n\nexport enum PdfPageFlattenResult {\n  Fail = 0,\n  Success = 1,\n  NothingToDo = 2,\n}\n\n/**\n * Pdf File without content\n *\n * @public\n */\nexport interface PdfFileWithoutContent {\n  /**\n   * id of file\n   */\n  id: string;\n}\n\nexport interface PdfFileLoader extends PdfFileWithoutContent {\n  /**\n   * length of file\n   */\n  fileLength: number;\n  /**\n   * read block of file\n   * @param offset - offset of file\n   * @param length - length of file\n   * @returns block of file\n   */\n  callback: (offset: number, length: number) => Uint8Array;\n}\n\n/**\n * Pdf File\n *\n * @public\n */\nexport interface PdfFile extends PdfFileWithoutContent {\n  /**\n   * content of file\n   */\n  content: PdfFileContent;\n}\n\nexport interface PdfFileUrl extends PdfFileWithoutContent {\n  url: string;\n}\n\nexport interface PdfUrlOptions {\n  mode?: 'auto' | 'range-request' | 'full-fetch';\n  password?: string;\n}\n\nexport enum PdfErrorCode {\n  Ok, //  #define FPDF_ERR_SUCCESS 0    // No error.\n  Unknown, // #define FPDF_ERR_UNKNOWN 1    // Unknown error.\n  NotFound, // #define FPDF_ERR_FILE 2       // File not found or could not be opened.\n  WrongFormat, // #define FPDF_ERR_FORMAT 3     // File not in PDF format or corrupted.\n  Password, // #define FPDF_ERR_PASSWORD 4   // Password required or incorrect password.\n  Security, // #define FPDF_ERR_SECURITY 5   // Unsupported security scheme.\n  PageError, // #define FPDF_ERR_PAGE 6       // Page not found or content error.\n  XFALoad, // #ifdef PDF_ENABLE_XFA\n  XFALayout, //\n  Cancelled,\n  Initialization,\n  NotReady,\n  NotSupport,\n  LoadDoc,\n  DocNotOpen,\n  CantCloseDoc,\n  CantCreateNewDoc,\n  CantImportPages,\n  CantCreateAnnot,\n  CantSetAnnotRect,\n  CantSetAnnotContent,\n  CantRemoveInkList,\n  CantAddInkStoke,\n  CantReadAttachmentSize,\n  CantReadAttachmentContent,\n  CantFocusAnnot,\n  CantSelectText,\n  CantSelectOption,\n  CantCheckField,\n}\n\nexport interface PdfErrorReason {\n  code: PdfErrorCode;\n  message: string;\n}\n\nexport type PdfEngineError = TaskError<PdfErrorReason>;\n\nexport type PdfTask<R> = Task<R, PdfErrorReason>;\n\nexport class PdfTaskHelper {\n  /**\n   * Create a task\n   * @returns new task\n   */\n  static create<R>(): Task<R, PdfErrorReason> {\n    return new Task<R, PdfErrorReason>();\n  }\n\n  /**\n   * Create a task that has been resolved with value\n   * @param result - resolved value\n   * @returns resolved task\n   */\n  static resolve<R>(result: R): Task<R, PdfErrorReason> {\n    const task = new Task<R, PdfErrorReason>();\n    task.resolve(result);\n\n    return task;\n  }\n\n  /**\n   * Create a task that has been rejected with error\n   * @param reason - rejected error\n   * @returns rejected task\n   */\n  static reject<T = any>(reason: PdfErrorReason): Task<T, PdfErrorReason> {\n    const task = new Task<T, PdfErrorReason>();\n    task.reject(reason);\n\n    return task;\n  }\n\n  /**\n   * Create a task that has been aborted with error\n   * @param reason - aborted error\n   * @returns aborted task\n   */\n  static abort<T = any>(reason: PdfErrorReason): Task<T, PdfErrorReason> {\n    const task = new Task<T, PdfErrorReason>();\n    task.reject(reason);\n\n    return task;\n  }\n}\n\n/**\n * Pdf engine\n *\n * @public\n */\nexport interface PdfEngine<T = Blob> {\n  /**\n   * Check whether pdf engine supports this feature\n   * @param feature - which feature want to check\n   * @returns support or not\n   */\n  isSupport?: (feature: PdfEngineFeature) => PdfTask<PdfEngineOperation[]>;\n  /**\n   * Initialize the engine\n   * @returns task that indicate whether initialization is successful\n   */\n  initialize?: () => PdfTask<boolean>;\n  /**\n   * Destroy the engine\n   * @returns task that indicate whether destroy is successful\n   */\n  destroy?: () => PdfTask<boolean>;\n  /**\n   * Open a PDF from a URL with specified mode\n   * @param url - The PDF file URL\n   * @param options - Additional options including mode (auto, range-request, full-fetch) and password\n   * @returns Task that resolves with the PdfDocumentObject or an error\n   */\n  openDocumentUrl: (file: PdfFileUrl, options?: PdfUrlOptions) => PdfTask<PdfDocumentObject>;\n  /**\n   * Open pdf document from buffer\n   * @param file - pdf file\n   * @param password - protected password for this file\n   * @returns task that contains the file or error\n   */\n  openDocumentFromBuffer: (file: PdfFile, password: string) => PdfTask<PdfDocumentObject>;\n  /**\n   * Open pdf document from loader\n   * @param file - pdf file\n   * @param password - protected password for this file\n   * @returns task that contains the file or error\n   */\n  openDocumentFromLoader: (file: PdfFileLoader, password: string) => PdfTask<PdfDocumentObject>;\n  /**\n   * Get the metadata of the file\n   * @param doc - pdf document\n   * @returns task that contains the metadata or error\n   */\n  getMetadata: (doc: PdfDocumentObject) => PdfTask<PdfMetadataObject>;\n  /**\n   * Get permissions of the file\n   * @param doc - pdf document\n   * @returns task that contains a 32-bit integer indicating permission flags\n   */\n  getDocPermissions: (doc: PdfDocumentObject) => PdfTask<number>;\n  /**\n   * Get the user permissions of the file\n   * @param doc - pdf document\n   * @returns task that contains a 32-bit integer indicating permission flags\n   */\n  getDocUserPermissions: (doc: PdfDocumentObject) => PdfTask<number>;\n  /**\n   * Get the signatures of the file\n   * @param doc - pdf document\n   * @returns task that contains the signatures or error\n   */\n  getSignatures: (doc: PdfDocumentObject) => PdfTask<PdfSignatureObject[]>;\n  /**\n   * Get the bookmarks of the file\n   * @param doc - pdf document\n   * @returns task that contains the bookmarks or error\n   */\n  getBookmarks: (doc: PdfDocumentObject) => PdfTask<PdfBookmarksObject>;\n  /**\n   * Render the specified pdf page\n   * @param doc - pdf document\n   * @param page - pdf page\n   * @param scaleFactor - factor of scaling\n   * @param rotation - rotated angle\n   * @param dpr - devicePixelRatio\n   * @param options - render options\n   * @returns task contains the rendered image or error\n   */\n  renderPage: (\n    doc: PdfDocumentObject,\n    page: PdfPageObject,\n    scaleFactor: number,\n    rotation: Rotation,\n    dpr: number,\n    options: PdfRenderOptions,\n    imageType?: ImageConversionTypes,\n  ) => PdfTask<T>;\n  /**\n   * Render the specified rect of pdf page\n   * @param doc - pdf document\n   * @param page - pdf page\n   * @param scaleFactor - factor of scaling\n   * @param rotation - rotated angle\n   * @param dpr - devicePixelRatio\n   * @param rect - target rect\n   * @param options - render options\n   * @returns task contains the rendered image or error\n   */\n  renderPageRect: (\n    doc: PdfDocumentObject,\n    page: PdfPageObject,\n    scaleFactor: number,\n    rotation: Rotation,\n    dpr: number,\n    rect: Rect,\n    options: PdfRenderOptions,\n    imageType?: ImageConversionTypes,\n  ) => PdfTask<T>;\n  /**\n   * Render a single annotation into an ImageData blob.\n   *\n   * Note:  • honours Display-Matrix, page rotation & DPR\n   *        • you decide whether to include the page background\n   * @param doc - pdf document\n   * @param page - pdf page\n   * @param annotation - the annotation to render\n   * @param scaleFactor - factor of scaling\n   * @param rotation - rotated angle\n   * @param dpr - devicePixelRatio\n   * @param mode - appearance mode\n   */\n  renderAnnotation(\n    doc: PdfDocumentObject,\n    page: PdfPageObject,\n    annotation: PdfAnnotationObject,\n    scaleFactor: number,\n    rotation: Rotation,\n    dpr: number,\n    mode: AppearanceMode,\n    imageType: ImageConversionTypes,\n  ): PdfTask<T>;\n  /**\n   * Get annotations of pdf page\n   * @param doc - pdf document\n   * @param page - pdf page\n   * @param scaleFactor - factor of scaling\n   * @param rotation - rotated angle\n   * @returns task contains the annotations or error\n   */\n  getPageAnnotations: (\n    doc: PdfDocumentObject,\n    page: PdfPageObject,\n  ) => PdfTask<PdfAnnotationObject[]>;\n\n  /**\n   * Change the visible colour (and opacity) of an existing annotation.\n   * @param doc - pdf document\n   * @param page - pdf page\n   * @param annotation - the annotation to recolour\n   * @param colour - RGBA color values (0-255 per channel)\n   * @param which - 0 = stroke/fill colour (PDFium's \"colourType\" param)\n   * @returns task that indicates whether the operation succeeded\n   */\n  updateAnnotationColor: (\n    doc: PdfDocumentObject,\n    page: PdfPageObject,\n    annotation: PdfAnnotationObjectBase,\n    color: WebAlphaColor,\n    which?: number,\n  ) => PdfTask<boolean>;\n\n  /**\n   * Create a annotation on specified page\n   * @param doc - pdf document\n   * @param page - pdf page\n   * @param annotation - new annotations\n   * @returns task whether the annotations is created successfully\n   */\n  createPageAnnotation: (\n    doc: PdfDocumentObject,\n    page: PdfPageObject,\n    annotation: PdfAnnotationObject,\n  ) => PdfTask<number>;\n  /**\n   * Update a annotation on specified page\n   * @param doc - pdf document\n   * @param page - pdf page\n   * @param annotation - new annotations\n   * @returns task that indicates whether the operation succeeded\n   */\n  updatePageAnnotation: (\n    doc: PdfDocumentObject,\n    page: PdfPageObject,\n    annotation: PdfAnnotationObject,\n  ) => PdfTask<boolean>;\n  /**\n   * Remove a annotation on specified page\n   * @param doc - pdf document\n   * @param page - pdf page\n   * @param annotation - new annotations\n   * @returns task whether the annotations is removed successfully\n   */\n  removePageAnnotation: (\n    doc: PdfDocumentObject,\n    page: PdfPageObject,\n    annotation: PdfAnnotationObject,\n  ) => PdfTask<boolean>;\n  /**\n   * get all text rects in pdf page\n   * @param doc - pdf document\n   * @param page - pdf page\n   * @param scaleFactor - factor of scaling\n   * @param rotation - rotated angle\n   * @returns task contains the text rects or error\n   */\n  getPageTextRects: (\n    doc: PdfDocumentObject,\n    page: PdfPageObject,\n    scaleFactor: number,\n    rotation: Rotation,\n  ) => PdfTask<PdfTextRectObject[]>;\n  /**\n   * Render the thumbnail of specified pdf page\n   * @param doc - pdf document\n   * @param page - pdf page\n   * @param scaleFactor - factor of scaling\n   * @param rotation - rotated angle\n   * @param dpr - devicePixelRatio\n   * @param options - render options\n   * @returns task contains the rendered image or error\n   */\n  renderThumbnail: (\n    doc: PdfDocumentObject,\n    page: PdfPageObject,\n    scaleFactor: number,\n    rotation: Rotation,\n    dpr: number,\n  ) => PdfTask<T>;\n  /**\n   * Search across all pages in the document\n   * @param doc - pdf document\n   * @param keyword - search keyword\n   * @param flags - match flags for search\n   * @returns Task contains all search results throughout the document\n   */\n  searchAllPages: (\n    doc: PdfDocumentObject,\n    keyword: string,\n    flags?: MatchFlag[],\n  ) => PdfTask<SearchAllPagesResult>;\n  /**\n   * Get all annotations in this file\n   * @param doc - pdf document\n   * @returns task that contains the annotations or error\n   */\n  getAllAnnotations: (doc: PdfDocumentObject) => PdfTask<Record<number, PdfAnnotationObject[]>>;\n  /**\n   * Get all attachments in this file\n   * @param doc - pdf document\n   * @returns task that contains the attachments or error\n   */\n  getAttachments: (doc: PdfDocumentObject) => PdfTask<PdfAttachmentObject[]>;\n  /**\n   * Read content of pdf attachment\n   * @param doc - pdf document\n   * @param attachment - pdf attachments\n   * @returns task that contains the content of specified attachment or error\n   */\n  readAttachmentContent: (\n    doc: PdfDocumentObject,\n    attachment: PdfAttachmentObject,\n  ) => PdfTask<ArrayBuffer>;\n  /**\n   * Set form field value\n   * @param doc - pdf document\n   * @param page - pdf page\n   * @param annotation - pdf annotation\n   * @param text - text value\n   */\n  setFormFieldValue: (\n    doc: PdfDocumentObject,\n    page: PdfPageObject,\n    annotation: PdfWidgetAnnoObject,\n    value: FormFieldValue,\n  ) => PdfTask<boolean>;\n  /**\n   * Flatten annotations and form fields into the page contents.\n   * @param doc - pdf document\n   * @param page - pdf page\n   * @param flag - flatten flag\n   */\n  flattenPage: (\n    doc: PdfDocumentObject,\n    page: PdfPageObject,\n    flag: PdfPageFlattenFlag,\n  ) => PdfTask<PdfPageFlattenResult>;\n  /**\n   * Extract pdf pages to a new file\n   * @param doc - pdf document\n   * @param pageIndexes - indexes of pdf pages\n   * @returns task contains the new pdf file content\n   */\n  extractPages: (doc: PdfDocumentObject, pageIndexes: number[]) => PdfTask<ArrayBuffer>;\n  /**\n   * Extract text on specified pdf pages\n   * @param doc - pdf document\n   * @param pageIndexes - indexes of pdf pages\n   * @returns task contains the text\n   */\n  extractText: (doc: PdfDocumentObject, pageIndexes: number[]) => PdfTask<string>;\n  /**\n   * Extract text on specified pdf pages\n   * @param doc - pdf document\n   * @param pageIndexes - indexes of pdf pages\n   * @returns task contains the text\n   */\n  getTextSlices: (doc: PdfDocumentObject, slices: PageTextSlice[]) => PdfTask<string[]>;\n  /**\n   * Get all glyphs in the specified pdf page\n   * @param doc - pdf document\n   * @param page - pdf page\n   * @returns task contains the glyphs\n   */\n  getPageGlyphs: (doc: PdfDocumentObject, page: PdfPageObject) => PdfTask<PdfGlyphObject[]>;\n  /**\n   * Get the geometry of the specified pdf page\n   * @param doc - pdf document\n   * @param page - pdf page\n   * @returns task contains the geometry\n   */\n  getPageGeometry: (doc: PdfDocumentObject, page: PdfPageObject) => PdfTask<PdfPageGeometry>;\n  /**\n   * Merge multiple pdf documents\n   * @param files - all the pdf files\n   * @returns task contains the merged pdf file\n   */\n  merge: (files: PdfFile[]) => PdfTask<PdfFile>;\n  /**\n   * Merge specific pages from multiple PDF documents in a custom order\n   * @param mergeConfigs Array of configurations specifying which pages to merge from which documents\n   * @returns A PdfTask that resolves with the merged PDF file\n   * @public\n   */\n  mergePages: (mergeConfigs: Array<{ docId: string; pageIndices: number[] }>) => PdfTask<PdfFile>;\n  /**\n   * Save a copy of pdf document\n   * @param doc - pdf document\n   * @returns task contains the new pdf file content\n   */\n  saveAsCopy: (doc: PdfDocumentObject) => PdfTask<ArrayBuffer>;\n  /**\n   * Close pdf document\n   * @param doc - pdf document\n   * @returns task that file is closed or not\n   */\n  closeDocument: (doc: PdfDocumentObject) => PdfTask<boolean>;\n}\n\n/**\n * Method name of PdfEngine interface\n *\n * @public\n */\nexport type PdfEngineMethodName = keyof Required<PdfEngine>;\n\n/**\n * Arguments of PdfEngine method\n *\n * @public\n */\nexport type PdfEngineMethodArgs<P extends PdfEngineMethodName> = Readonly<\n  Parameters<Required<PdfEngine>[P]>\n>;\n\n/**\n * Return type of PdfEngine method\n *\n * @public\n */\nexport type PdfEngineMethodReturnType<P extends PdfEngineMethodName> = ReturnType<\n  Required<PdfEngine>[P]\n>;\n","import { PdfAlphaColor } from './pdf';\n\nexport interface WebAlphaColor {\n  color: string;\n  opacity: number;\n}\n\n/**\n * Convert a {@link PdfAlphaColor} to a CSS-style colour definition.\n *\n * @param c - the colour coming from PDFium (0-255 per channel)\n * @returns\n *   hex   – #RRGGBB (no alpha channel)\n *   opacity – 0-1 float suitable for CSS `opacity`/`rgba()`\n */\nexport function pdfAlphaColorToWebAlphaColor(c: PdfAlphaColor): WebAlphaColor {\n  const clamp = (n: number) => Math.max(0, Math.min(255, n));\n  const toHex = (n: number) => clamp(n).toString(16).padStart(2, '0');\n\n  const color = `#${toHex(c.red)}${toHex(c.green)}${toHex(c.blue)}` as const;\n  const opacity = clamp(c.alpha) / 255;\n\n  return { color, opacity };\n}\n\n/**\n * Convert a CSS hex colour + opacity back into {@link PdfAlphaColor}\n *\n * @param hex      - #RGB, #RRGGBB, or #rrggbb\n * @param opacity  - 0-1 float (values outside clamp automatically)\n */\nexport function webAlphaColorToPdfAlphaColor({ color, opacity }: WebAlphaColor): PdfAlphaColor {\n  // Normalise: #abc → #aabbcc\n  if (/^#?[0-9a-f]{3}$/i.test(color)) {\n    color = color.replace(/^#?([0-9a-f])([0-9a-f])([0-9a-f])$/i, '#$1$1$2$2$3$3').toLowerCase();\n  }\n\n  const [, r, g, b] =\n    /^#?([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$/i.exec(color) ??\n    (() => {\n      throw new Error(`Invalid hex colour: “${color}”`);\n    })();\n\n  const clamp = (n: number, hi = 255) => Math.max(0, Math.min(hi, n));\n\n  return {\n    red: parseInt(r, 16),\n    green: parseInt(g, 16),\n    blue: parseInt(b, 16),\n    alpha: clamp(Math.round(opacity * 255)),\n  };\n}\n","/**\n * Parse a PDF date string **D:YYYYMMDDHHmmSSOHH'mm'** to ISO-8601.\n *\n * Returns `undefined` if the input is malformed.\n *\n * @public\n */\nexport function pdfDateToDate(pdf?: string): Date | undefined {\n  if (!pdf?.startsWith('D:') || pdf.length < 16) return;\n\n  const y = +pdf.slice(2, 6);\n  const mo = +pdf.slice(6, 8) - 1; // JS months: 0-based\n  const d = +pdf.slice(8, 10);\n  const H = +pdf.slice(10, 12);\n  const M = +pdf.slice(12, 14);\n  const S = +pdf.slice(14, 16);\n\n  return new Date(Date.UTC(y, mo, d, H, M, S));\n}\n\n/**\n * Convert a date to a PDF date string\n * @param date - date to convert\n * @returns PDF date string\n *\n * @public\n */\nexport function dateToPdfDate(date: Date = new Date()): string {\n  const z = (n: number, len = 2) => n.toString().padStart(len, '0');\n\n  const YYYY = date.getUTCFullYear();\n  const MM = z(date.getUTCMonth() + 1);\n  const DD = z(date.getUTCDate());\n  const HH = z(date.getUTCHours());\n  const mm = z(date.getUTCMinutes());\n  const SS = z(date.getUTCSeconds());\n\n  return `D:${YYYY}${MM}${DD}${HH}${mm}${SS}`;\n}\n","/**\n * Library contains the common definitions of data types and logic\n *\n * @remarks\n * The `@embedpdf/models` defines the interface and classes which are used to\n * handling PDF files.\n *\n * @packageDocumentation\n */\nexport * from './geometry';\nexport * from './logger';\nexport * from './pdf';\nexport * from './task';\nexport * from './color';\nexport * from './date';\n\n/**\n * ignore will do nothing when called.\n *\n * @public\n */\nexport function ignore() {}\n","import { Position } from '@embedpdf/models';\nimport type {\n  InteractionManagerCapability,\n  InteractionScope,\n  PointerEventHandlers,\n} from '@embedpdf/plugin-interaction-manager';\n\n/**\n * Hook one DOM element into the interaction-manager.\n *  – keeps handlers & cursor in-sync with the current mode\n *  – returns a teardown fn for React/Preact effects\n */\nexport function createPointerProvider(\n  cap: InteractionManagerCapability,\n  scope: InteractionScope,\n  element: HTMLElement,\n  convertEventToPoint?: (evt: PointerEvent, host: HTMLElement) => Position,\n) {\n  /* ------------------------------------------------------------------ */\n  /* active handler set – hot-swapped on every mode change              */\n  /* ------------------------------------------------------------------ */\n  let active: PointerEventHandlers | null = cap.getHandlersForScope(scope);\n\n  const stopMode = cap.onModeChange(() => {\n    if (scope.type === 'global') {\n      const mode = cap.getActiveInteractionMode();\n      element.style.cursor = mode?.scope === 'global' ? (mode.cursor ?? 'auto') : 'auto';\n    }\n    active = cap.getHandlersForScope(scope);\n  });\n\n  const stopHandler = cap.onHandlerChange(() => {\n    active = cap.getHandlersForScope(scope);\n  });\n\n  /* ------------------------------------------------------------------ */\n  /* cursor                                                             */\n  /* ------------------------------------------------------------------ */\n  const modeNow = cap.getActiveInteractionMode();\n  const cursorNow = cap.getCurrentCursor();\n\n  /** initial cursor -------------------------------------------------- */\n  if (scope.type === 'global') {\n    // global wrapper only shows the cursor while a *global* mode is active\n    element.style.cursor = modeNow?.scope === 'global' ? cursorNow : 'auto';\n  } else {\n    // page wrappers always mirror the latest cursor\n    element.style.cursor = cursorNow;\n  }\n\n  const stopCursor = cap.onCursorChange((c) => {\n    /**  ❖  Propagation rule\n     *      ─────────────────\n     *   • global provider updates its cursor *only* while the active\n     *     mode itself is ‘global’.\n     *   • page providers always sync (so they show the cursor during\n     *     a global mode as well). */\n    if (scope.type === 'global') {\n      const isGlobalMode = cap.getActiveInteractionMode()?.scope === 'global';\n      if (!isGlobalMode) return; // active mode is page-scoped → ignore\n    }\n    element.style.cursor = c;\n  });\n\n  /* ------------------------------------------------------------------ */\n  /* event wiring                                                       */\n  /* ------------------------------------------------------------------ */\n  type K = keyof PointerEventHandlers;\n  const domEvent: Record<K, keyof HTMLElementEventMap> = {\n    onPointerDown: 'pointerdown',\n    onPointerUp: 'pointerup',\n    onPointerMove: 'pointermove',\n    onPointerEnter: 'pointerenter',\n    onPointerLeave: 'pointerleave',\n    onPointerCancel: 'pointercancel',\n  };\n\n  /* one stable EventListener per key -> needed for removeEventListener */\n  const listeners: Partial<Record<K, EventListener>> = {};\n\n  const toPos = (e: PointerEvent, host: HTMLElement): Position => {\n    if (convertEventToPoint) return convertEventToPoint(e, host);\n    const r = host.getBoundingClientRect();\n    return { x: e.clientX - r.left, y: e.clientY - r.top };\n  };\n\n  (Object.keys(domEvent) as K[]).forEach((k) => {\n    listeners[k] = (evt: Event) => {\n      if (cap.isPaused()) return;\n\n      const pe = evt as PointerEvent; // safe – we only attach to pointer*\n      const currentModeId = cap.getActiveMode();\n      active?.[k]?.(toPos(pe, element), pe, currentModeId);\n      /* if you need to stop default behaviour when no handler is active:\n       * if (!active?.[k]) pe.preventDefault(); */\n    };\n    element.addEventListener(domEvent[k], listeners[k]!);\n  });\n\n  /* ------------------------------------------------------------------ */\n  /* teardown                                                           */\n  /* ------------------------------------------------------------------ */\n  return () => {\n    (Object.keys(domEvent) as K[]).forEach((k) =>\n      element.removeEventListener(domEvent[k], listeners[k]!),\n    );\n    stopMode();\n    stopCursor();\n    stopHandler();\n  };\n}\n","// src/geometry.ts\nvar Rotation = /* @__PURE__ */ ((Rotation2) => {\n  Rotation2[Rotation2[\"Degree0\"] = 0] = \"Degree0\";\n  Rotation2[Rotation2[\"Degree90\"] = 1] = \"Degree90\";\n  Rotation2[Rotation2[\"Degree180\"] = 2] = \"Degree180\";\n  Rotation2[Rotation2[\"Degree270\"] = 3] = \"Degree270\";\n  return Rotation2;\n})(Rotation || {});\nfunction toIntPos(p) {\n  return { x: Math.floor(p.x), y: Math.floor(p.y) };\n}\nfunction toIntSize(s) {\n  return { width: Math.ceil(s.width), height: Math.ceil(s.height) };\n}\nfunction toIntRect(r) {\n  return {\n    origin: toIntPos(r.origin),\n    size: toIntSize(r.size)\n  };\n}\nfunction calculateDegree(rotation) {\n  switch (rotation) {\n    case 0 /* Degree0 */:\n      return 0;\n    case 1 /* Degree90 */:\n      return 90;\n    case 2 /* Degree180 */:\n      return 180;\n    case 3 /* Degree270 */:\n      return 270;\n  }\n}\nfunction calculateAngle(rotation) {\n  return calculateDegree(rotation) * Math.PI / 180;\n}\nfunction swap(size) {\n  const { width, height } = size;\n  return {\n    width: height,\n    height: width\n  };\n}\nfunction transformSize(size, rotation, scaleFactor) {\n  size = rotation % 2 === 0 ? size : swap(size);\n  return {\n    width: size.width * scaleFactor,\n    height: size.height * scaleFactor\n  };\n}\nfunction quadToRect(q) {\n  const xs = [q.p1.x, q.p2.x, q.p3.x, q.p4.x];\n  const ys = [q.p1.y, q.p2.y, q.p3.y, q.p4.y];\n  return {\n    origin: { x: Math.min(...xs), y: Math.min(...ys) },\n    size: {\n      width: Math.max(...xs) - Math.min(...xs),\n      height: Math.max(...ys) - Math.min(...ys)\n    }\n  };\n}\nfunction rectToQuad(r) {\n  return {\n    p1: { x: r.origin.x, y: r.origin.y },\n    p2: { x: r.origin.x + r.size.width, y: r.origin.y },\n    p3: { x: r.origin.x + r.size.width, y: r.origin.y + r.size.height },\n    p4: { x: r.origin.x, y: r.origin.y + r.size.height }\n  };\n}\nfunction rotatePosition(containerSize, position, rotation) {\n  let x = position.x;\n  let y = position.y;\n  switch (rotation) {\n    case 0 /* Degree0 */:\n      x = position.x;\n      y = position.y;\n      break;\n    case 1 /* Degree90 */:\n      x = containerSize.height - position.y;\n      y = position.x;\n      break;\n    case 2 /* Degree180 */:\n      x = containerSize.width - position.x;\n      y = containerSize.height - position.y;\n      break;\n    case 3 /* Degree270 */:\n      x = position.y;\n      y = containerSize.width - position.x;\n      break;\n  }\n  return {\n    x,\n    y\n  };\n}\nfunction scalePosition(position, scaleFactor) {\n  return {\n    x: position.x * scaleFactor,\n    y: position.y * scaleFactor\n  };\n}\nfunction transformPosition(containerSize, position, rotation, scaleFactor) {\n  return scalePosition(rotatePosition(containerSize, position, rotation), scaleFactor);\n}\nfunction restorePosition(containerSize, position, rotation, scaleFactor) {\n  return scalePosition(\n    rotatePosition(containerSize, position, (4 - rotation) % 4),\n    1 / scaleFactor\n  );\n}\nfunction rotateRect(containerSize, rect, rotation) {\n  let x = rect.origin.x;\n  let y = rect.origin.y;\n  let size = rect.size;\n  switch (rotation) {\n    case 0 /* Degree0 */:\n      break;\n    case 1 /* Degree90 */:\n      x = containerSize.height - rect.origin.y - rect.size.height;\n      y = rect.origin.x;\n      size = swap(rect.size);\n      break;\n    case 2 /* Degree180 */:\n      x = containerSize.width - rect.origin.x - rect.size.width;\n      y = containerSize.height - rect.origin.y - rect.size.height;\n      break;\n    case 3 /* Degree270 */:\n      x = rect.origin.y;\n      y = containerSize.width - rect.origin.x - rect.size.width;\n      size = swap(rect.size);\n      break;\n  }\n  return {\n    origin: {\n      x,\n      y\n    },\n    size: {\n      width: size.width,\n      height: size.height\n    }\n  };\n}\nfunction scaleRect(rect, scaleFactor) {\n  return {\n    origin: {\n      x: rect.origin.x * scaleFactor,\n      y: rect.origin.y * scaleFactor\n    },\n    size: {\n      width: rect.size.width * scaleFactor,\n      height: rect.size.height * scaleFactor\n    }\n  };\n}\nfunction transformRect(containerSize, rect, rotation, scaleFactor) {\n  return scaleRect(rotateRect(containerSize, rect, rotation), scaleFactor);\n}\nfunction restoreRect(containerSize, rect, rotation, scaleFactor) {\n  return scaleRect(rotateRect(containerSize, rect, (4 - rotation) % 4), 1 / scaleFactor);\n}\nfunction restoreOffset(offset, rotation, scaleFactor) {\n  let offsetX = offset.x;\n  let offsetY = offset.y;\n  switch (rotation) {\n    case 0 /* Degree0 */:\n      offsetX = offset.x / scaleFactor;\n      offsetY = offset.y / scaleFactor;\n      break;\n    case 1 /* Degree90 */:\n      offsetX = offset.y / scaleFactor;\n      offsetY = -offset.x / scaleFactor;\n      break;\n    case 2 /* Degree180 */:\n      offsetX = -offset.x / scaleFactor;\n      offsetY = -offset.y / scaleFactor;\n      break;\n    case 3 /* Degree270 */:\n      offsetX = -offset.y / scaleFactor;\n      offsetY = offset.x / scaleFactor;\n      break;\n  }\n  return {\n    x: offsetX,\n    y: offsetY\n  };\n}\nfunction boundingRect(rects) {\n  if (rects.length === 0) return null;\n  let minX = rects[0].origin.x, minY = rects[0].origin.y, maxX = rects[0].origin.x + rects[0].size.width, maxY = rects[0].origin.y + rects[0].size.height;\n  for (const r of rects) {\n    minX = Math.min(minX, r.origin.x);\n    minY = Math.min(minY, r.origin.y);\n    maxX = Math.max(maxX, r.origin.x + r.size.width);\n    maxY = Math.max(maxY, r.origin.y + r.size.height);\n  }\n  return {\n    origin: {\n      x: minX,\n      y: minY\n    },\n    size: {\n      width: maxX - minX,\n      height: maxY - minY\n    }\n  };\n}\nvar makeMatrix = (rectangle, rotation, scaleFactor) => {\n  const { width, height } = rectangle.size;\n  switch (rotation) {\n    case 0 /* Degree0 */:\n      return {\n        a: scaleFactor,\n        b: 0,\n        c: 0,\n        d: -scaleFactor,\n        e: 0,\n        f: height * scaleFactor\n      };\n    case 1 /* Degree90 */:\n      return {\n        a: 0,\n        b: scaleFactor,\n        c: scaleFactor,\n        d: 0,\n        e: 0,\n        f: 0\n      };\n    case 2 /* Degree180 */:\n      return {\n        a: -scaleFactor,\n        b: 0,\n        c: 0,\n        d: scaleFactor,\n        e: width * scaleFactor,\n        f: 0\n      };\n    case 3 /* Degree270 */:\n      return {\n        a: 0,\n        b: -scaleFactor,\n        c: -scaleFactor,\n        d: 0,\n        e: height * scaleFactor,\n        f: width * scaleFactor\n      };\n  }\n};\n\n// src/logger.ts\nvar NoopLogger = class {\n  /** {@inheritDoc Logger.debug} */\n  debug() {\n  }\n  /** {@inheritDoc Logger.info} */\n  info() {\n  }\n  /** {@inheritDoc Logger.warn} */\n  warn() {\n  }\n  /** {@inheritDoc Logger.error} */\n  error() {\n  }\n  /** {@inheritDoc Logger.perf} */\n  perf() {\n  }\n};\nvar ConsoleLogger = class {\n  /** {@inheritDoc Logger.debug} */\n  debug(source, category, ...args) {\n    console.debug(`${source}.${category}`, ...args);\n  }\n  /** {@inheritDoc Logger.info} */\n  info(source, category, ...args) {\n    console.info(`${source}.${category}`, ...args);\n  }\n  /** {@inheritDoc Logger.warn} */\n  warn(source, category, ...args) {\n    console.warn(`${source}.${category}`, ...args);\n  }\n  /** {@inheritDoc Logger.error} */\n  error(source, category, ...args) {\n    console.error(`${source}.${category}`, ...args);\n  }\n  /** {@inheritDoc Logger.perf} */\n  perf(source, category, event, phase, ...args) {\n    console.info(`${source}.${category}.${event}.${phase}`, ...args);\n  }\n};\nvar LogLevel = /* @__PURE__ */ ((LogLevel2) => {\n  LogLevel2[LogLevel2[\"Debug\"] = 0] = \"Debug\";\n  LogLevel2[LogLevel2[\"Info\"] = 1] = \"Info\";\n  LogLevel2[LogLevel2[\"Warn\"] = 2] = \"Warn\";\n  LogLevel2[LogLevel2[\"Error\"] = 3] = \"Error\";\n  return LogLevel2;\n})(LogLevel || {});\nvar LevelLogger = class {\n  /**\n   * create new LevelLogger\n   * @param logger - the original logger\n   * @param level - log level that used for filtering, all logs lower than this level will be filtered out\n   */\n  constructor(logger, level) {\n    this.logger = logger;\n    this.level = level;\n  }\n  /** {@inheritDoc Logger.debug} */\n  debug(source, category, ...args) {\n    if (this.level <= 0 /* Debug */) {\n      this.logger.debug(source, category, ...args);\n    }\n  }\n  /** {@inheritDoc Logger.info} */\n  info(source, category, ...args) {\n    if (this.level <= 1 /* Info */) {\n      this.logger.info(source, category, ...args);\n    }\n  }\n  /** {@inheritDoc Logger.warn} */\n  warn(source, category, ...args) {\n    if (this.level <= 2 /* Warn */) {\n      this.logger.warn(source, category, ...args);\n    }\n  }\n  /** {@inheritDoc Logger.error} */\n  error(source, category, ...args) {\n    if (this.level <= 3 /* Error */) {\n      this.logger.error(source, category, ...args);\n    }\n  }\n  /** {@inheritDoc Logger.perf} */\n  perf(source, category, event, phase, ...args) {\n    this.logger.perf(source, category, event, phase, ...args);\n  }\n};\nvar PerfLogger = class {\n  /**\n   * create new PerfLogger\n   */\n  constructor() {\n  }\n  /** {@inheritDoc Logger.debug} */\n  debug(source, category, ...args) {\n  }\n  /** {@inheritDoc Logger.info} */\n  info(source, category, ...args) {\n  }\n  /** {@inheritDoc Logger.warn} */\n  warn(source, category, ...args) {\n  }\n  /** {@inheritDoc Logger.error} */\n  error(source, category, ...args) {\n  }\n  /** {@inheritDoc Logger.perf} */\n  perf(source, category, event, phase, identifier, ...args) {\n    switch (phase) {\n      case \"Begin\":\n        window.performance.mark(`${source}.${category}.${event}.${phase}.${identifier}`, {\n          detail: args\n        });\n        break;\n      case \"End\":\n        window.performance.mark(`${source}.${category}.${event}.${phase}.${identifier}`, {\n          detail: args\n        });\n        window.performance.measure(\n          `${source}.${category}.${event}.Measure.${identifier}`,\n          `${source}.${category}.${event}.Begin.${identifier}`,\n          `${source}.${category}.${event}.End.${identifier}`\n        );\n        break;\n    }\n  }\n};\nvar AllLogger = class {\n  /**\n   * create new PerfLogger\n   */\n  constructor(loggers) {\n    this.loggers = loggers;\n  }\n  /** {@inheritDoc Logger.debug} */\n  debug(source, category, ...args) {\n    for (const logger of this.loggers) {\n      logger.debug(source, category, ...args);\n    }\n  }\n  /** {@inheritDoc Logger.info} */\n  info(source, category, ...args) {\n    for (const logger of this.loggers) {\n      logger.info(source, category, ...args);\n    }\n  }\n  /** {@inheritDoc Logger.warn} */\n  warn(source, category, ...args) {\n    for (const logger of this.loggers) {\n      logger.warn(source, category, ...args);\n    }\n  }\n  /** {@inheritDoc Logger.error} */\n  error(source, category, ...args) {\n    for (const logger of this.loggers) {\n      logger.error(source, category, ...args);\n    }\n  }\n  /** {@inheritDoc Logger.perf} */\n  perf(source, category, event, phase, ...args) {\n    for (const logger of this.loggers) {\n      logger.perf(source, category, event, phase, ...args);\n    }\n  }\n};\n\n// src/task.ts\nvar TaskStage = /* @__PURE__ */ ((TaskStage2) => {\n  TaskStage2[TaskStage2[\"Pending\"] = 0] = \"Pending\";\n  TaskStage2[TaskStage2[\"Resolved\"] = 1] = \"Resolved\";\n  TaskStage2[TaskStage2[\"Rejected\"] = 2] = \"Rejected\";\n  TaskStage2[TaskStage2[\"Aborted\"] = 3] = \"Aborted\";\n  return TaskStage2;\n})(TaskStage || {});\nvar TaskAbortedError = class extends Error {\n  constructor(reason) {\n    super(`Task aborted: ${JSON.stringify(reason)}`);\n    this.name = \"TaskAbortedError\";\n  }\n};\nvar TaskRejectedError = class extends Error {\n  constructor(reason) {\n    super(`Task rejected: ${JSON.stringify(reason)}`);\n    this.name = \"TaskRejectedError\";\n  }\n};\nvar Task = class _Task {\n  constructor() {\n    this.state = {\n      stage: 0 /* Pending */\n    };\n    /**\n     * callbacks that will be executed when task is resolved\n     */\n    this.resolvedCallbacks = [];\n    /**\n     * callbacks that will be executed when task is rejected\n     */\n    this.rejectedCallbacks = [];\n    /**\n     * Promise that will be resolved when task is settled\n     */\n    this._promise = null;\n  }\n  /**\n   * Convert task to promise\n   * @returns promise that will be resolved when task is settled\n   */\n  toPromise() {\n    if (!this._promise) {\n      this._promise = new Promise((resolve, reject) => {\n        this.wait(\n          (result) => resolve(result),\n          (error) => {\n            if (error.type === \"abort\") {\n              reject(new TaskAbortedError(error.reason));\n            } else {\n              reject(new TaskRejectedError(error.reason));\n            }\n          }\n        );\n      });\n    }\n    return this._promise;\n  }\n  /**\n   * wait for task to be settled\n   * @param resolvedCallback - callback for resolved value\n   * @param rejectedCallback - callback for rejected value\n   */\n  wait(resolvedCallback, rejectedCallback) {\n    switch (this.state.stage) {\n      case 0 /* Pending */:\n        this.resolvedCallbacks.push(resolvedCallback);\n        this.rejectedCallbacks.push(rejectedCallback);\n        break;\n      case 1 /* Resolved */:\n        resolvedCallback(this.state.result);\n        break;\n      case 2 /* Rejected */:\n        rejectedCallback({\n          type: \"reject\",\n          reason: this.state.reason\n        });\n        break;\n      case 3 /* Aborted */:\n        rejectedCallback({\n          type: \"abort\",\n          reason: this.state.reason\n        });\n        break;\n    }\n  }\n  /**\n   * resolve task with specific result\n   * @param result - result value\n   */\n  resolve(result) {\n    if (this.state.stage === 0 /* Pending */) {\n      this.state = {\n        stage: 1 /* Resolved */,\n        result\n      };\n      for (const resolvedCallback of this.resolvedCallbacks) {\n        try {\n          resolvedCallback(result);\n        } catch (e) {\n        }\n      }\n      this.resolvedCallbacks = [];\n      this.rejectedCallbacks = [];\n    }\n  }\n  /**\n   * reject task with specific reason\n   * @param reason - abort reason\n   *\n   */\n  reject(reason) {\n    if (this.state.stage === 0 /* Pending */) {\n      this.state = {\n        stage: 2 /* Rejected */,\n        reason\n      };\n      for (const rejectedCallback of this.rejectedCallbacks) {\n        try {\n          rejectedCallback({\n            type: \"reject\",\n            reason\n          });\n        } catch (e) {\n        }\n      }\n      this.resolvedCallbacks = [];\n      this.rejectedCallbacks = [];\n    }\n  }\n  /**\n   * abort task with specific reason\n   * @param reason - abort reason\n   */\n  abort(reason) {\n    if (this.state.stage === 0 /* Pending */) {\n      this.state = {\n        stage: 3 /* Aborted */,\n        reason\n      };\n      for (const rejectedCallback of this.rejectedCallbacks) {\n        try {\n          rejectedCallback({\n            type: \"abort\",\n            reason\n          });\n        } catch (e) {\n        }\n      }\n      this.resolvedCallbacks = [];\n      this.rejectedCallbacks = [];\n    }\n  }\n  /**\n   * fail task with a TaskError from another task\n   * This is a convenience method for error propagation between tasks\n   * @param error - TaskError from another task\n   */\n  fail(error) {\n    if (error.type === \"abort\") {\n      this.abort(error.reason);\n    } else {\n      this.reject(error.reason);\n    }\n  }\n  /**\n   * Static method to wait for all tasks to resolve\n   * Returns a new task that resolves with an array of all results\n   * Rejects immediately if any task fails\n   *\n   * @param tasks - array of tasks to wait for\n   * @returns new task that resolves when all input tasks resolve\n   * @public\n   */\n  static all(tasks) {\n    const combinedTask = new _Task();\n    if (tasks.length === 0) {\n      combinedTask.resolve([]);\n      return combinedTask;\n    }\n    const results = new Array(tasks.length);\n    let resolvedCount = 0;\n    let isSettled = false;\n    tasks.forEach((task, index) => {\n      task.wait(\n        (result) => {\n          if (isSettled) return;\n          results[index] = result;\n          resolvedCount++;\n          if (resolvedCount === tasks.length) {\n            isSettled = true;\n            combinedTask.resolve(results);\n          }\n        },\n        (error) => {\n          if (isSettled) return;\n          isSettled = true;\n          if (error.type === \"abort\") {\n            combinedTask.abort(error.reason);\n          } else {\n            combinedTask.reject(error.reason);\n          }\n        }\n      );\n    });\n    return combinedTask;\n  }\n  /**\n   * Static method to wait for all tasks to settle (resolve, reject, or abort)\n   * Always resolves with an array of settlement results\n   *\n   * @param tasks - array of tasks to wait for\n   * @returns new task that resolves when all input tasks settle\n   * @public\n   */\n  static allSettled(tasks) {\n    const combinedTask = new _Task();\n    if (tasks.length === 0) {\n      combinedTask.resolve([]);\n      return combinedTask;\n    }\n    const results = new Array(tasks.length);\n    let settledCount = 0;\n    tasks.forEach((task, index) => {\n      task.wait(\n        (result) => {\n          results[index] = { status: \"resolved\", value: result };\n          settledCount++;\n          if (settledCount === tasks.length) {\n            combinedTask.resolve(results);\n          }\n        },\n        (error) => {\n          results[index] = {\n            status: error.type === \"abort\" ? \"aborted\" : \"rejected\",\n            reason: error.reason\n          };\n          settledCount++;\n          if (settledCount === tasks.length) {\n            combinedTask.resolve(results);\n          }\n        }\n      );\n    });\n    return combinedTask;\n  }\n  /**\n   * Static method that resolves/rejects with the first task that settles\n   *\n   * @param tasks - array of tasks to race\n   * @returns new task that settles with the first input task that settles\n   * @public\n   */\n  static race(tasks) {\n    const combinedTask = new _Task();\n    if (tasks.length === 0) {\n      combinedTask.reject(\"No tasks provided\");\n      return combinedTask;\n    }\n    let isSettled = false;\n    tasks.forEach((task) => {\n      task.wait(\n        (result) => {\n          if (isSettled) return;\n          isSettled = true;\n          combinedTask.resolve(result);\n        },\n        (error) => {\n          if (isSettled) return;\n          isSettled = true;\n          if (error.type === \"abort\") {\n            combinedTask.abort(error.reason);\n          } else {\n            combinedTask.reject(error.reason);\n          }\n        }\n      );\n    });\n    return combinedTask;\n  }\n  /**\n   * Utility to track progress of multiple tasks\n   *\n   * @param tasks - array of tasks to track\n   * @param onProgress - callback called when any task completes\n   * @returns new task that resolves when all input tasks resolve\n   * @public\n   */\n  static withProgress(tasks, onProgress) {\n    const combinedTask = _Task.all(tasks);\n    if (onProgress) {\n      let completedCount = 0;\n      tasks.forEach((task) => {\n        task.wait(\n          () => {\n            completedCount++;\n            onProgress(completedCount, tasks.length);\n          },\n          () => {\n            completedCount++;\n            onProgress(completedCount, tasks.length);\n          }\n        );\n      });\n    }\n    return combinedTask;\n  }\n};\n\n// src/pdf.ts\nvar PdfSoftHyphenMarker = \"\\xAD\";\nvar PdfZeroWidthSpace = \"\\u200B\";\nvar PdfWordJoiner = \"\\u2060\";\nvar PdfBomOrZwnbsp = \"\\uFEFF\";\nvar PdfNonCharacterFFFE = \"\\uFFFE\";\nvar PdfNonCharacterFFFF = \"\\uFFFF\";\nvar PdfUnwantedTextMarkers = Object.freeze([\n  PdfSoftHyphenMarker,\n  PdfZeroWidthSpace,\n  PdfWordJoiner,\n  PdfBomOrZwnbsp,\n  PdfNonCharacterFFFE,\n  PdfNonCharacterFFFF\n]);\nvar PdfUnwantedTextRegex = new RegExp(`[${PdfUnwantedTextMarkers.join(\"\")}]`, \"g\");\nfunction stripPdfUnwantedMarkers(text) {\n  return text.replace(PdfUnwantedTextRegex, \"\");\n}\nvar PdfZoomMode = /* @__PURE__ */ ((PdfZoomMode2) => {\n  PdfZoomMode2[PdfZoomMode2[\"Unknown\"] = 0] = \"Unknown\";\n  PdfZoomMode2[PdfZoomMode2[\"XYZ\"] = 1] = \"XYZ\";\n  PdfZoomMode2[PdfZoomMode2[\"FitPage\"] = 2] = \"FitPage\";\n  PdfZoomMode2[PdfZoomMode2[\"FitHorizontal\"] = 3] = \"FitHorizontal\";\n  PdfZoomMode2[PdfZoomMode2[\"FitVertical\"] = 4] = \"FitVertical\";\n  PdfZoomMode2[PdfZoomMode2[\"FitRectangle\"] = 5] = \"FitRectangle\";\n  return PdfZoomMode2;\n})(PdfZoomMode || {});\nvar PdfBlendMode = /* @__PURE__ */ ((PdfBlendMode2) => {\n  PdfBlendMode2[PdfBlendMode2[\"Normal\"] = 0] = \"Normal\";\n  PdfBlendMode2[PdfBlendMode2[\"Multiply\"] = 1] = \"Multiply\";\n  PdfBlendMode2[PdfBlendMode2[\"Screen\"] = 2] = \"Screen\";\n  PdfBlendMode2[PdfBlendMode2[\"Overlay\"] = 3] = \"Overlay\";\n  PdfBlendMode2[PdfBlendMode2[\"Darken\"] = 4] = \"Darken\";\n  PdfBlendMode2[PdfBlendMode2[\"Lighten\"] = 5] = \"Lighten\";\n  PdfBlendMode2[PdfBlendMode2[\"ColorDodge\"] = 6] = \"ColorDodge\";\n  PdfBlendMode2[PdfBlendMode2[\"ColorBurn\"] = 7] = \"ColorBurn\";\n  PdfBlendMode2[PdfBlendMode2[\"HardLight\"] = 8] = \"HardLight\";\n  PdfBlendMode2[PdfBlendMode2[\"SoftLight\"] = 9] = \"SoftLight\";\n  PdfBlendMode2[PdfBlendMode2[\"Difference\"] = 10] = \"Difference\";\n  PdfBlendMode2[PdfBlendMode2[\"Exclusion\"] = 11] = \"Exclusion\";\n  PdfBlendMode2[PdfBlendMode2[\"Hue\"] = 12] = \"Hue\";\n  PdfBlendMode2[PdfBlendMode2[\"Saturation\"] = 13] = \"Saturation\";\n  PdfBlendMode2[PdfBlendMode2[\"Color\"] = 14] = \"Color\";\n  PdfBlendMode2[PdfBlendMode2[\"Luminosity\"] = 15] = \"Luminosity\";\n  return PdfBlendMode2;\n})(PdfBlendMode || {});\nvar MixedBlendMode = Symbol(\"mixed\");\nvar BLEND_MODE_INFOS = Object.freeze([\n  { id: 0 /* Normal */, label: \"Normal\", css: \"normal\" },\n  { id: 1 /* Multiply */, label: \"Multiply\", css: \"multiply\" },\n  { id: 2 /* Screen */, label: \"Screen\", css: \"screen\" },\n  { id: 3 /* Overlay */, label: \"Overlay\", css: \"overlay\" },\n  { id: 4 /* Darken */, label: \"Darken\", css: \"darken\" },\n  { id: 5 /* Lighten */, label: \"Lighten\", css: \"lighten\" },\n  { id: 6 /* ColorDodge */, label: \"Color Dodge\", css: \"color-dodge\" },\n  { id: 7 /* ColorBurn */, label: \"Color Burn\", css: \"color-burn\" },\n  { id: 8 /* HardLight */, label: \"Hard Light\", css: \"hard-light\" },\n  { id: 9 /* SoftLight */, label: \"Soft Light\", css: \"soft-light\" },\n  { id: 10 /* Difference */, label: \"Difference\", css: \"difference\" },\n  { id: 11 /* Exclusion */, label: \"Exclusion\", css: \"exclusion\" },\n  { id: 12 /* Hue */, label: \"Hue\", css: \"hue\" },\n  { id: 13 /* Saturation */, label: \"Saturation\", css: \"saturation\" },\n  { id: 14 /* Color */, label: \"Color\", css: \"color\" },\n  { id: 15 /* Luminosity */, label: \"Luminosity\", css: \"luminosity\" }\n]);\nvar enumToInfo = BLEND_MODE_INFOS.reduce(\n  (m, info) => {\n    m[info.id] = info;\n    return m;\n  },\n  {}\n);\nvar cssToEnum = BLEND_MODE_INFOS.reduce((m, info) => {\n  m[info.css] = info.id;\n  return m;\n}, {});\nfunction getBlendModeInfo(mode) {\n  return enumToInfo[mode] ?? enumToInfo[0 /* Normal */];\n}\nfunction blendModeToCss(mode) {\n  return getBlendModeInfo(mode).css;\n}\nfunction cssToBlendMode(value) {\n  return cssToEnum[value];\n}\nfunction blendModeLabel(mode) {\n  return getBlendModeInfo(mode).label;\n}\nfunction reduceBlendModes(modes) {\n  if (!modes.length) return 0 /* Normal */;\n  const first = modes[0];\n  return modes.every((m) => m === first) ? first : MixedBlendMode;\n}\nvar blendModeSelectOptions = BLEND_MODE_INFOS.map((info) => ({\n  value: info.id,\n  label: info.label\n}));\nfunction uiBlendModeDisplay(value) {\n  return value === MixedBlendMode ? \"(mixed)\" : blendModeLabel(value);\n}\nvar PdfActionType = /* @__PURE__ */ ((PdfActionType2) => {\n  PdfActionType2[PdfActionType2[\"Unsupported\"] = 0] = \"Unsupported\";\n  PdfActionType2[PdfActionType2[\"Goto\"] = 1] = \"Goto\";\n  PdfActionType2[PdfActionType2[\"RemoteGoto\"] = 2] = \"RemoteGoto\";\n  PdfActionType2[PdfActionType2[\"URI\"] = 3] = \"URI\";\n  PdfActionType2[PdfActionType2[\"LaunchAppOrOpenFile\"] = 4] = \"LaunchAppOrOpenFile\";\n  return PdfActionType2;\n})(PdfActionType || {});\nvar PdfAnnotationSubtype = /* @__PURE__ */ ((PdfAnnotationSubtype2) => {\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"TEXT\"] = 1] = \"TEXT\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"LINK\"] = 2] = \"LINK\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"FREETEXT\"] = 3] = \"FREETEXT\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"LINE\"] = 4] = \"LINE\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"SQUARE\"] = 5] = \"SQUARE\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"CIRCLE\"] = 6] = \"CIRCLE\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"POLYGON\"] = 7] = \"POLYGON\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"POLYLINE\"] = 8] = \"POLYLINE\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"HIGHLIGHT\"] = 9] = \"HIGHLIGHT\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"UNDERLINE\"] = 10] = \"UNDERLINE\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"SQUIGGLY\"] = 11] = \"SQUIGGLY\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"STRIKEOUT\"] = 12] = \"STRIKEOUT\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"STAMP\"] = 13] = \"STAMP\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"CARET\"] = 14] = \"CARET\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"INK\"] = 15] = \"INK\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"POPUP\"] = 16] = \"POPUP\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"FILEATTACHMENT\"] = 17] = \"FILEATTACHMENT\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"SOUND\"] = 18] = \"SOUND\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"MOVIE\"] = 19] = \"MOVIE\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"WIDGET\"] = 20] = \"WIDGET\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"SCREEN\"] = 21] = \"SCREEN\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"PRINTERMARK\"] = 22] = \"PRINTERMARK\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"TRAPNET\"] = 23] = \"TRAPNET\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"WATERMARK\"] = 24] = \"WATERMARK\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"THREED\"] = 25] = \"THREED\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"RICHMEDIA\"] = 26] = \"RICHMEDIA\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"XFAWIDGET\"] = 27] = \"XFAWIDGET\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"REDACT\"] = 28] = \"REDACT\";\n  return PdfAnnotationSubtype2;\n})(PdfAnnotationSubtype || {});\nvar PdfAnnotationSubtypeName = {\n  [0 /* UNKNOWN */]: \"unknow\",\n  [1 /* TEXT */]: \"text\",\n  [2 /* LINK */]: \"link\",\n  [3 /* FREETEXT */]: \"freetext\",\n  [4 /* LINE */]: \"line\",\n  [5 /* SQUARE */]: \"square\",\n  [6 /* CIRCLE */]: \"circle\",\n  [7 /* POLYGON */]: \"polygon\",\n  [8 /* POLYLINE */]: \"polyline\",\n  [9 /* HIGHLIGHT */]: \"highlight\",\n  [10 /* UNDERLINE */]: \"underline\",\n  [11 /* SQUIGGLY */]: \"squiggly\",\n  [12 /* STRIKEOUT */]: \"strikeout\",\n  [13 /* STAMP */]: \"stamp\",\n  [14 /* CARET */]: \"caret\",\n  [15 /* INK */]: \"ink\",\n  [16 /* POPUP */]: \"popup\",\n  [17 /* FILEATTACHMENT */]: \"fileattachment\",\n  [18 /* SOUND */]: \"sound\",\n  [19 /* MOVIE */]: \"movie\",\n  [20 /* WIDGET */]: \"widget\",\n  [21 /* SCREEN */]: \"screen\",\n  [22 /* PRINTERMARK */]: \"printermark\",\n  [23 /* TRAPNET */]: \"trapnet\",\n  [24 /* WATERMARK */]: \"watermark\",\n  [25 /* THREED */]: \"threed\",\n  [26 /* RICHMEDIA */]: \"richmedia\",\n  [27 /* XFAWIDGET */]: \"xfawidget\",\n  [28 /* REDACT */]: \"redact\"\n};\nvar PdfAnnotationObjectStatus = /* @__PURE__ */ ((PdfAnnotationObjectStatus2) => {\n  PdfAnnotationObjectStatus2[PdfAnnotationObjectStatus2[\"Created\"] = 0] = \"Created\";\n  PdfAnnotationObjectStatus2[PdfAnnotationObjectStatus2[\"Committed\"] = 1] = \"Committed\";\n  return PdfAnnotationObjectStatus2;\n})(PdfAnnotationObjectStatus || {});\nvar AppearanceMode = /* @__PURE__ */ ((AppearanceMode2) => {\n  AppearanceMode2[AppearanceMode2[\"Normal\"] = 0] = \"Normal\";\n  AppearanceMode2[AppearanceMode2[\"Rollover\"] = 1] = \"Rollover\";\n  AppearanceMode2[AppearanceMode2[\"Down\"] = 2] = \"Down\";\n  return AppearanceMode2;\n})(AppearanceMode || {});\nvar PdfAnnotationState = /* @__PURE__ */ ((PdfAnnotationState2) => {\n  PdfAnnotationState2[\"Marked\"] = \"Marked\";\n  PdfAnnotationState2[\"Unmarked\"] = \"Unmarked\";\n  PdfAnnotationState2[\"Accepted\"] = \"Accepted\";\n  PdfAnnotationState2[\"Rejected\"] = \"Rejected\";\n  PdfAnnotationState2[\"Complete\"] = \"Complete\";\n  PdfAnnotationState2[\"Cancelled\"] = \"Cancelled\";\n  PdfAnnotationState2[\"None\"] = \"None\";\n  return PdfAnnotationState2;\n})(PdfAnnotationState || {});\nvar PdfAnnotationStateModel = /* @__PURE__ */ ((PdfAnnotationStateModel2) => {\n  PdfAnnotationStateModel2[\"Marked\"] = \"Marked\";\n  PdfAnnotationStateModel2[\"Reviewed\"] = \"Reviewed\";\n  return PdfAnnotationStateModel2;\n})(PdfAnnotationStateModel || {});\nvar PDF_FORM_FIELD_TYPE = /* @__PURE__ */ ((PDF_FORM_FIELD_TYPE2) => {\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"PUSHBUTTON\"] = 1] = \"PUSHBUTTON\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"CHECKBOX\"] = 2] = \"CHECKBOX\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"RADIOBUTTON\"] = 3] = \"RADIOBUTTON\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"COMBOBOX\"] = 4] = \"COMBOBOX\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"LISTBOX\"] = 5] = \"LISTBOX\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"TEXTFIELD\"] = 6] = \"TEXTFIELD\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"SIGNATURE\"] = 7] = \"SIGNATURE\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"XFA\"] = 8] = \"XFA\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"XFA_CHECKBOX\"] = 9] = \"XFA_CHECKBOX\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"XFA_COMBOBOX\"] = 10] = \"XFA_COMBOBOX\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"XFA_IMAGEFIELD\"] = 11] = \"XFA_IMAGEFIELD\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"XFA_LISTBOX\"] = 12] = \"XFA_LISTBOX\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"XFA_PUSHBUTTON\"] = 13] = \"XFA_PUSHBUTTON\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"XFA_SIGNATURE\"] = 14] = \"XFA_SIGNATURE\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"XFA_TEXTFIELD\"] = 15] = \"XFA_TEXTFIELD\";\n  return PDF_FORM_FIELD_TYPE2;\n})(PDF_FORM_FIELD_TYPE || {});\nvar PdfAnnotationColorType = /* @__PURE__ */ ((PdfAnnotationColorType2) => {\n  PdfAnnotationColorType2[PdfAnnotationColorType2[\"Color\"] = 0] = \"Color\";\n  PdfAnnotationColorType2[PdfAnnotationColorType2[\"InteriorColor\"] = 1] = \"InteriorColor\";\n  return PdfAnnotationColorType2;\n})(PdfAnnotationColorType || {});\nvar PdfAnnotationBorderStyle = /* @__PURE__ */ ((PdfAnnotationBorderStyle2) => {\n  PdfAnnotationBorderStyle2[PdfAnnotationBorderStyle2[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n  PdfAnnotationBorderStyle2[PdfAnnotationBorderStyle2[\"SOLID\"] = 1] = \"SOLID\";\n  PdfAnnotationBorderStyle2[PdfAnnotationBorderStyle2[\"DASHED\"] = 2] = \"DASHED\";\n  PdfAnnotationBorderStyle2[PdfAnnotationBorderStyle2[\"BEVELED\"] = 3] = \"BEVELED\";\n  PdfAnnotationBorderStyle2[PdfAnnotationBorderStyle2[\"INSET\"] = 4] = \"INSET\";\n  PdfAnnotationBorderStyle2[PdfAnnotationBorderStyle2[\"UNDERLINE\"] = 5] = \"UNDERLINE\";\n  PdfAnnotationBorderStyle2[PdfAnnotationBorderStyle2[\"CLOUDY\"] = 6] = \"CLOUDY\";\n  return PdfAnnotationBorderStyle2;\n})(PdfAnnotationBorderStyle || {});\nvar PdfAnnotationFlags = /* @__PURE__ */ ((PdfAnnotationFlags2) => {\n  PdfAnnotationFlags2[PdfAnnotationFlags2[\"NONE\"] = 0] = \"NONE\";\n  PdfAnnotationFlags2[PdfAnnotationFlags2[\"INVISIBLE\"] = 1] = \"INVISIBLE\";\n  PdfAnnotationFlags2[PdfAnnotationFlags2[\"HIDDEN\"] = 2] = \"HIDDEN\";\n  PdfAnnotationFlags2[PdfAnnotationFlags2[\"PRINT\"] = 4] = \"PRINT\";\n  PdfAnnotationFlags2[PdfAnnotationFlags2[\"NO_ZOOM\"] = 8] = \"NO_ZOOM\";\n  PdfAnnotationFlags2[PdfAnnotationFlags2[\"NO_ROTATE\"] = 16] = \"NO_ROTATE\";\n  PdfAnnotationFlags2[PdfAnnotationFlags2[\"NO_VIEW\"] = 32] = \"NO_VIEW\";\n  PdfAnnotationFlags2[PdfAnnotationFlags2[\"READ_ONLY\"] = 64] = \"READ_ONLY\";\n  PdfAnnotationFlags2[PdfAnnotationFlags2[\"LOCKED\"] = 128] = \"LOCKED\";\n  PdfAnnotationFlags2[PdfAnnotationFlags2[\"TOGGLE_NOVIEW\"] = 256] = \"TOGGLE_NOVIEW\";\n  return PdfAnnotationFlags2;\n})(PdfAnnotationFlags || {});\nvar PDF_FORM_FIELD_FLAG = /* @__PURE__ */ ((PDF_FORM_FIELD_FLAG2) => {\n  PDF_FORM_FIELD_FLAG2[PDF_FORM_FIELD_FLAG2[\"NONE\"] = 0] = \"NONE\";\n  PDF_FORM_FIELD_FLAG2[PDF_FORM_FIELD_FLAG2[\"READONLY\"] = 1] = \"READONLY\";\n  PDF_FORM_FIELD_FLAG2[PDF_FORM_FIELD_FLAG2[\"REQUIRED\"] = 2] = \"REQUIRED\";\n  PDF_FORM_FIELD_FLAG2[PDF_FORM_FIELD_FLAG2[\"NOEXPORT\"] = 4] = \"NOEXPORT\";\n  PDF_FORM_FIELD_FLAG2[PDF_FORM_FIELD_FLAG2[\"TEXT_MULTIPLINE\"] = 4096] = \"TEXT_MULTIPLINE\";\n  PDF_FORM_FIELD_FLAG2[PDF_FORM_FIELD_FLAG2[\"TEXT_PASSWORD\"] = 8192] = \"TEXT_PASSWORD\";\n  PDF_FORM_FIELD_FLAG2[PDF_FORM_FIELD_FLAG2[\"CHOICE_COMBO\"] = 131072] = \"CHOICE_COMBO\";\n  PDF_FORM_FIELD_FLAG2[PDF_FORM_FIELD_FLAG2[\"CHOICE_EDIT\"] = 262144] = \"CHOICE_EDIT\";\n  PDF_FORM_FIELD_FLAG2[PDF_FORM_FIELD_FLAG2[\"CHOICE_MULTL_SELECT\"] = 2097152] = \"CHOICE_MULTL_SELECT\";\n  return PDF_FORM_FIELD_FLAG2;\n})(PDF_FORM_FIELD_FLAG || {});\nvar PdfPageObjectType = /* @__PURE__ */ ((PdfPageObjectType2) => {\n  PdfPageObjectType2[PdfPageObjectType2[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n  PdfPageObjectType2[PdfPageObjectType2[\"TEXT\"] = 1] = \"TEXT\";\n  PdfPageObjectType2[PdfPageObjectType2[\"PATH\"] = 2] = \"PATH\";\n  PdfPageObjectType2[PdfPageObjectType2[\"IMAGE\"] = 3] = \"IMAGE\";\n  PdfPageObjectType2[PdfPageObjectType2[\"SHADING\"] = 4] = \"SHADING\";\n  PdfPageObjectType2[PdfPageObjectType2[\"FORM\"] = 5] = \"FORM\";\n  return PdfPageObjectType2;\n})(PdfPageObjectType || {});\nvar PdfAnnotationFlagName = Object.freeze({\n  [1 /* INVISIBLE */]: \"invisible\",\n  [2 /* HIDDEN */]: \"hidden\",\n  [4 /* PRINT */]: \"print\",\n  [8 /* NO_ZOOM */]: \"noZoom\",\n  [16 /* NO_ROTATE */]: \"noRotate\",\n  [32 /* NO_VIEW */]: \"noView\",\n  [64 /* READ_ONLY */]: \"readOnly\",\n  [128 /* LOCKED */]: \"locked\",\n  [256 /* TOGGLE_NOVIEW */]: \"toggleNoView\"\n});\nvar PdfAnnotationFlagValue = Object.entries(\n  PdfAnnotationFlagName\n).reduce(\n  (acc, [bit, name]) => {\n    acc[name] = Number(bit);\n    return acc;\n  },\n  {}\n);\nfunction flagsToNames(raw) {\n  return Object.keys(PdfAnnotationFlagName).filter((flag) => (raw & flag) !== 0).map((flag) => PdfAnnotationFlagName[flag]);\n}\nfunction namesToFlags(names) {\n  return names.reduce(\n    (mask, name) => mask | PdfAnnotationFlagValue[name],\n    0 /* NONE */\n  );\n}\nvar PdfSegmentObjectType = /* @__PURE__ */ ((PdfSegmentObjectType2) => {\n  PdfSegmentObjectType2[PdfSegmentObjectType2[\"UNKNOWN\"] = -1] = \"UNKNOWN\";\n  PdfSegmentObjectType2[PdfSegmentObjectType2[\"LINETO\"] = 0] = \"LINETO\";\n  PdfSegmentObjectType2[PdfSegmentObjectType2[\"BEZIERTO\"] = 1] = \"BEZIERTO\";\n  PdfSegmentObjectType2[PdfSegmentObjectType2[\"MOVETO\"] = 2] = \"MOVETO\";\n  return PdfSegmentObjectType2;\n})(PdfSegmentObjectType || {});\nvar PdfEngineFeature = /* @__PURE__ */ ((PdfEngineFeature2) => {\n  PdfEngineFeature2[PdfEngineFeature2[\"RenderPage\"] = 0] = \"RenderPage\";\n  PdfEngineFeature2[PdfEngineFeature2[\"RenderPageRect\"] = 1] = \"RenderPageRect\";\n  PdfEngineFeature2[PdfEngineFeature2[\"Thumbnails\"] = 2] = \"Thumbnails\";\n  PdfEngineFeature2[PdfEngineFeature2[\"Bookmarks\"] = 3] = \"Bookmarks\";\n  PdfEngineFeature2[PdfEngineFeature2[\"Annotations\"] = 4] = \"Annotations\";\n  return PdfEngineFeature2;\n})(PdfEngineFeature || {});\nvar PdfEngineOperation = /* @__PURE__ */ ((PdfEngineOperation2) => {\n  PdfEngineOperation2[PdfEngineOperation2[\"Create\"] = 0] = \"Create\";\n  PdfEngineOperation2[PdfEngineOperation2[\"Read\"] = 1] = \"Read\";\n  PdfEngineOperation2[PdfEngineOperation2[\"Update\"] = 2] = \"Update\";\n  PdfEngineOperation2[PdfEngineOperation2[\"Delete\"] = 3] = \"Delete\";\n  return PdfEngineOperation2;\n})(PdfEngineOperation || {});\nvar MatchFlag = /* @__PURE__ */ ((MatchFlag2) => {\n  MatchFlag2[MatchFlag2[\"None\"] = 0] = \"None\";\n  MatchFlag2[MatchFlag2[\"MatchCase\"] = 1] = \"MatchCase\";\n  MatchFlag2[MatchFlag2[\"MatchWholeWord\"] = 2] = \"MatchWholeWord\";\n  MatchFlag2[MatchFlag2[\"MatchConsecutive\"] = 4] = \"MatchConsecutive\";\n  return MatchFlag2;\n})(MatchFlag || {});\nfunction unionFlags(flags) {\n  return flags.reduce((flag, currFlag) => {\n    return flag | currFlag;\n  }, 0 /* None */);\n}\nfunction compareSearchTarget(targetA, targetB) {\n  const flagA = unionFlags(targetA.flags);\n  const flagB = unionFlags(targetB.flags);\n  return flagA === flagB && targetA.keyword === targetB.keyword;\n}\nvar PdfPermission = /* @__PURE__ */ ((PdfPermission2) => {\n  PdfPermission2[PdfPermission2[\"PrintDocument\"] = 8] = \"PrintDocument\";\n  PdfPermission2[PdfPermission2[\"ModifyContent\"] = 16] = \"ModifyContent\";\n  PdfPermission2[PdfPermission2[\"CopyOrExtract\"] = 32] = \"CopyOrExtract\";\n  PdfPermission2[PdfPermission2[\"AddOrModifyTextAnnot\"] = 64] = \"AddOrModifyTextAnnot\";\n  PdfPermission2[PdfPermission2[\"FillInExistingForm\"] = 512] = \"FillInExistingForm\";\n  PdfPermission2[PdfPermission2[\"ExtractTextOrGraphics\"] = 1024] = \"ExtractTextOrGraphics\";\n  PdfPermission2[PdfPermission2[\"AssembleDocument\"] = 2048] = \"AssembleDocument\";\n  PdfPermission2[PdfPermission2[\"PrintHighQuality\"] = 4096] = \"PrintHighQuality\";\n  return PdfPermission2;\n})(PdfPermission || {});\nvar PdfPageFlattenFlag = /* @__PURE__ */ ((PdfPageFlattenFlag2) => {\n  PdfPageFlattenFlag2[PdfPageFlattenFlag2[\"Display\"] = 0] = \"Display\";\n  PdfPageFlattenFlag2[PdfPageFlattenFlag2[\"Print\"] = 1] = \"Print\";\n  return PdfPageFlattenFlag2;\n})(PdfPageFlattenFlag || {});\nvar PdfPageFlattenResult = /* @__PURE__ */ ((PdfPageFlattenResult2) => {\n  PdfPageFlattenResult2[PdfPageFlattenResult2[\"Fail\"] = 0] = \"Fail\";\n  PdfPageFlattenResult2[PdfPageFlattenResult2[\"Success\"] = 1] = \"Success\";\n  PdfPageFlattenResult2[PdfPageFlattenResult2[\"NothingToDo\"] = 2] = \"NothingToDo\";\n  return PdfPageFlattenResult2;\n})(PdfPageFlattenResult || {});\nvar PdfErrorCode = /* @__PURE__ */ ((PdfErrorCode2) => {\n  PdfErrorCode2[PdfErrorCode2[\"Ok\"] = 0] = \"Ok\";\n  PdfErrorCode2[PdfErrorCode2[\"Unknown\"] = 1] = \"Unknown\";\n  PdfErrorCode2[PdfErrorCode2[\"NotFound\"] = 2] = \"NotFound\";\n  PdfErrorCode2[PdfErrorCode2[\"WrongFormat\"] = 3] = \"WrongFormat\";\n  PdfErrorCode2[PdfErrorCode2[\"Password\"] = 4] = \"Password\";\n  PdfErrorCode2[PdfErrorCode2[\"Security\"] = 5] = \"Security\";\n  PdfErrorCode2[PdfErrorCode2[\"PageError\"] = 6] = \"PageError\";\n  PdfErrorCode2[PdfErrorCode2[\"XFALoad\"] = 7] = \"XFALoad\";\n  PdfErrorCode2[PdfErrorCode2[\"XFALayout\"] = 8] = \"XFALayout\";\n  PdfErrorCode2[PdfErrorCode2[\"Cancelled\"] = 9] = \"Cancelled\";\n  PdfErrorCode2[PdfErrorCode2[\"Initialization\"] = 10] = \"Initialization\";\n  PdfErrorCode2[PdfErrorCode2[\"NotReady\"] = 11] = \"NotReady\";\n  PdfErrorCode2[PdfErrorCode2[\"NotSupport\"] = 12] = \"NotSupport\";\n  PdfErrorCode2[PdfErrorCode2[\"LoadDoc\"] = 13] = \"LoadDoc\";\n  PdfErrorCode2[PdfErrorCode2[\"DocNotOpen\"] = 14] = \"DocNotOpen\";\n  PdfErrorCode2[PdfErrorCode2[\"CantCloseDoc\"] = 15] = \"CantCloseDoc\";\n  PdfErrorCode2[PdfErrorCode2[\"CantCreateNewDoc\"] = 16] = \"CantCreateNewDoc\";\n  PdfErrorCode2[PdfErrorCode2[\"CantImportPages\"] = 17] = \"CantImportPages\";\n  PdfErrorCode2[PdfErrorCode2[\"CantCreateAnnot\"] = 18] = \"CantCreateAnnot\";\n  PdfErrorCode2[PdfErrorCode2[\"CantSetAnnotRect\"] = 19] = \"CantSetAnnotRect\";\n  PdfErrorCode2[PdfErrorCode2[\"CantSetAnnotContent\"] = 20] = \"CantSetAnnotContent\";\n  PdfErrorCode2[PdfErrorCode2[\"CantRemoveInkList\"] = 21] = \"CantRemoveInkList\";\n  PdfErrorCode2[PdfErrorCode2[\"CantAddInkStoke\"] = 22] = \"CantAddInkStoke\";\n  PdfErrorCode2[PdfErrorCode2[\"CantReadAttachmentSize\"] = 23] = \"CantReadAttachmentSize\";\n  PdfErrorCode2[PdfErrorCode2[\"CantReadAttachmentContent\"] = 24] = \"CantReadAttachmentContent\";\n  PdfErrorCode2[PdfErrorCode2[\"CantFocusAnnot\"] = 25] = \"CantFocusAnnot\";\n  PdfErrorCode2[PdfErrorCode2[\"CantSelectText\"] = 26] = \"CantSelectText\";\n  PdfErrorCode2[PdfErrorCode2[\"CantSelectOption\"] = 27] = \"CantSelectOption\";\n  PdfErrorCode2[PdfErrorCode2[\"CantCheckField\"] = 28] = \"CantCheckField\";\n  return PdfErrorCode2;\n})(PdfErrorCode || {});\nvar PdfTaskHelper = class {\n  /**\n   * Create a task\n   * @returns new task\n   */\n  static create() {\n    return new Task();\n  }\n  /**\n   * Create a task that has been resolved with value\n   * @param result - resolved value\n   * @returns resolved task\n   */\n  static resolve(result) {\n    const task = new Task();\n    task.resolve(result);\n    return task;\n  }\n  /**\n   * Create a task that has been rejected with error\n   * @param reason - rejected error\n   * @returns rejected task\n   */\n  static reject(reason) {\n    const task = new Task();\n    task.reject(reason);\n    return task;\n  }\n  /**\n   * Create a task that has been aborted with error\n   * @param reason - aborted error\n   * @returns aborted task\n   */\n  static abort(reason) {\n    const task = new Task();\n    task.reject(reason);\n    return task;\n  }\n};\n\n// src/color.ts\nfunction pdfAlphaColorToWebAlphaColor(c) {\n  const clamp = (n) => Math.max(0, Math.min(255, n));\n  const toHex = (n) => clamp(n).toString(16).padStart(2, \"0\");\n  const color = `#${toHex(c.red)}${toHex(c.green)}${toHex(c.blue)}`;\n  const opacity = clamp(c.alpha) / 255;\n  return { color, opacity };\n}\nfunction webAlphaColorToPdfAlphaColor({ color, opacity }) {\n  if (/^#?[0-9a-f]{3}$/i.test(color)) {\n    color = color.replace(/^#?([0-9a-f])([0-9a-f])([0-9a-f])$/i, \"#$1$1$2$2$3$3\").toLowerCase();\n  }\n  const [, r, g, b] = /^#?([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$/i.exec(color) ?? (() => {\n    throw new Error(`Invalid hex colour: \\u201C${color}\\u201D`);\n  })();\n  const clamp = (n, hi = 255) => Math.max(0, Math.min(hi, n));\n  return {\n    red: parseInt(r, 16),\n    green: parseInt(g, 16),\n    blue: parseInt(b, 16),\n    alpha: clamp(Math.round(opacity * 255))\n  };\n}\n\n// src/date.ts\nfunction pdfDateToDate(pdf) {\n  if (!pdf?.startsWith(\"D:\") || pdf.length < 16) return;\n  const y = +pdf.slice(2, 6);\n  const mo = +pdf.slice(6, 8) - 1;\n  const d = +pdf.slice(8, 10);\n  const H = +pdf.slice(10, 12);\n  const M = +pdf.slice(12, 14);\n  const S = +pdf.slice(14, 16);\n  return new Date(Date.UTC(y, mo, d, H, M, S));\n}\nfunction dateToPdfDate(date = /* @__PURE__ */ new Date()) {\n  const z = (n, len = 2) => n.toString().padStart(len, \"0\");\n  const YYYY = date.getUTCFullYear();\n  const MM = z(date.getUTCMonth() + 1);\n  const DD = z(date.getUTCDate());\n  const HH = z(date.getUTCHours());\n  const mm = z(date.getUTCMinutes());\n  const SS = z(date.getUTCSeconds());\n  return `D:${YYYY}${MM}${DD}${HH}${mm}${SS}`;\n}\n\n// src/index.ts\nfunction ignore() {\n}\nexport {\n  AllLogger,\n  AppearanceMode,\n  ConsoleLogger,\n  LevelLogger,\n  LogLevel,\n  MatchFlag,\n  MixedBlendMode,\n  NoopLogger,\n  PDF_FORM_FIELD_FLAG,\n  PDF_FORM_FIELD_TYPE,\n  PdfActionType,\n  PdfAnnotationBorderStyle,\n  PdfAnnotationColorType,\n  PdfAnnotationFlagName,\n  PdfAnnotationFlags,\n  PdfAnnotationObjectStatus,\n  PdfAnnotationState,\n  PdfAnnotationStateModel,\n  PdfAnnotationSubtype,\n  PdfAnnotationSubtypeName,\n  PdfBlendMode,\n  PdfBomOrZwnbsp,\n  PdfEngineFeature,\n  PdfEngineOperation,\n  PdfErrorCode,\n  PdfNonCharacterFFFE,\n  PdfNonCharacterFFFF,\n  PdfPageFlattenFlag,\n  PdfPageFlattenResult,\n  PdfPageObjectType,\n  PdfPermission,\n  PdfSegmentObjectType,\n  PdfSoftHyphenMarker,\n  PdfTaskHelper,\n  PdfUnwantedTextMarkers,\n  PdfUnwantedTextRegex,\n  PdfWordJoiner,\n  PdfZeroWidthSpace,\n  PdfZoomMode,\n  PerfLogger,\n  Rotation,\n  Task,\n  TaskAbortedError,\n  TaskRejectedError,\n  TaskStage,\n  blendModeLabel,\n  blendModeSelectOptions,\n  blendModeToCss,\n  boundingRect,\n  calculateAngle,\n  calculateDegree,\n  compareSearchTarget,\n  cssToBlendMode,\n  dateToPdfDate,\n  flagsToNames,\n  getBlendModeInfo,\n  ignore,\n  makeMatrix,\n  namesToFlags,\n  pdfAlphaColorToWebAlphaColor,\n  pdfDateToDate,\n  quadToRect,\n  rectToQuad,\n  reduceBlendModes,\n  restoreOffset,\n  restorePosition,\n  restoreRect,\n  rotatePosition,\n  rotateRect,\n  scalePosition,\n  scaleRect,\n  stripPdfUnwantedMarkers,\n  swap,\n  toIntPos,\n  toIntRect,\n  toIntSize,\n  transformPosition,\n  transformRect,\n  transformSize,\n  uiBlendModeDisplay,\n  unionFlags,\n  webAlphaColorToPdfAlphaColor\n};\n//# sourceMappingURL=index.js.map","class b {\n  constructor() {\n    this.dependencyGraph = /* @__PURE__ */ new Map();\n  }\n  addNode(e, t = []) {\n    this.dependencyGraph.set(e, new Set(t));\n  }\n  hasCircularDependencies() {\n    const e = /* @__PURE__ */ new Set(), t = /* @__PURE__ */ new Set(), r = (s) => {\n      e.add(s), t.add(s);\n      const n = this.dependencyGraph.get(s) || /* @__PURE__ */ new Set();\n      for (const a of n)\n        if (e.has(a)) {\n          if (t.has(a))\n            return !0;\n        } else if (r(a)) return !0;\n      return t.delete(s), !1;\n    };\n    for (const s of this.dependencyGraph.keys())\n      if (!e.has(s) && r(s))\n        return !0;\n    return !1;\n  }\n  resolveLoadOrder() {\n    if (this.hasCircularDependencies())\n      throw new Error(\"Circular dependencies detected\");\n    const e = [], t = /* @__PURE__ */ new Set(), r = /* @__PURE__ */ new Set(), s = (n) => {\n      if (r.has(n)) throw new Error(\"Circular dependency\");\n      if (t.has(n)) return;\n      r.add(n);\n      const a = this.dependencyGraph.get(n) || /* @__PURE__ */ new Set();\n      for (const o of a)\n        s(o);\n      r.delete(n), t.add(n), e.push(n);\n    };\n    for (const n of this.dependencyGraph.keys())\n      t.has(n) || s(n);\n    return e;\n  }\n}\nclass l extends Error {\n  constructor(e) {\n    super(e), this.name = \"PluginRegistrationError\";\n  }\n}\nclass u extends Error {\n  constructor(e) {\n    super(e), this.name = \"PluginNotFoundError\";\n  }\n}\nclass m extends Error {\n  constructor(e) {\n    super(e), this.name = \"CircularDependencyError\";\n  }\n}\nclass K extends Error {\n  constructor(e) {\n    super(e), this.name = \"CapabilityNotFoundError\";\n  }\n}\nclass H extends Error {\n  constructor(e) {\n    super(e), this.name = \"CapabilityConflictError\";\n  }\n}\nclass W extends Error {\n  constructor(e) {\n    super(e), this.name = \"PluginInitializationError\";\n  }\n}\nclass R extends Error {\n  constructor(e) {\n    super(e), this.name = \"PluginConfigurationError\";\n  }\n}\nclass D {\n  /**\n   * Initializes the PluginStore with the main store and plugin ID.\n   * @param store The main store instance.\n   * @param pluginId The unique identifier for the plugin.\n   */\n  constructor(e, t) {\n    this.store = e, this.pluginId = t;\n  }\n  /**\n   * Gets the current state of the plugin.\n   * @returns The plugin's state.\n   */\n  getState() {\n    return this.store.getState().plugins[this.pluginId];\n  }\n  /**\n   * Dispatches an action for the plugin and returns the *new* global state.\n   * If you only need the plugin’s updated state, call `getState()` afterward.\n   * @param action The action to dispatch.\n   * @returns The updated global store state (after plugin reducer).\n   */\n  dispatch(e) {\n    return this.store.dispatchToPlugin(this.pluginId, e);\n  }\n  /**\n   * Subscribes to state changes only for this specific plugin.\n   * You now receive (action, newPluginState, oldPluginState) in the callback.\n   *\n   * @param listener The callback to invoke when plugin state changes.\n   * @returns A function to unsubscribe the listener.\n   */\n  subscribeToState(e) {\n    return this.store.subscribeToPlugin(this.pluginId, (t, r, s) => {\n      e(\n        t,\n        r,\n        s\n      );\n    });\n  }\n  /**\n   * Subscribes to a specific action type for the plugin.\n   * This still uses the main store's `onAction`, so you get the *global*\n   * old/new store states there. If you specifically want old/new plugin state,\n   * use `subscribeToState` instead.\n   *\n   * @param type The action type to listen for.\n   * @param handler The callback to invoke when the action occurs.\n   * @returns A function to unsubscribe the handler.\n   */\n  onAction(e, t) {\n    return this.store.onAction(e, (r, s, n) => {\n      t(\n        r,\n        s.plugins[this.pluginId],\n        n.plugins[this.pluginId]\n      );\n    });\n  }\n}\nconst g = \"LOAD_DOCUMENT\", f = \"SET_DOCUMENT\", p = \"SET_DOCUMENT_ERROR\", y = \"SET_SCALE\", w = \"SET_ROTATION\", E = \"SET_PAGES\", O = [\n  g,\n  f,\n  p,\n  y,\n  w,\n  E\n], Z = () => ({ type: g }), I = (i) => ({\n  type: f,\n  payload: i\n}), V = (i) => ({\n  type: p,\n  payload: i\n}), J = (i) => ({ type: y, payload: i }), Y = (i) => ({\n  type: w,\n  payload: i\n}), Q = (i) => ({\n  type: E,\n  payload: i\n});\nclass A {\n  /**\n   * Initializes the store with the provided core state.\n   * @param reducer          The core reducer function\n   * @param initialCoreState The initial core state\n   */\n  constructor(e, t) {\n    this.initialCoreState = t, this.pluginReducers = {}, this.listeners = [], this.pluginListeners = {}, this.state = { core: t, plugins: {} }, this.coreReducer = e;\n  }\n  /**\n   * Adds a reducer for a plugin-specific state.\n   * @param pluginId The unique identifier for the plugin.\n   * @param reducer The reducer function for the plugin state.\n   * @param initialState The initial state for the plugin.\n   */\n  addPluginReducer(e, t, r) {\n    this.state.plugins[e] = r, this.pluginReducers[e] = t;\n  }\n  /**\n   * Dispatches an action *only* to the core reducer.\n   * Notifies the global store listeners with (action, newState, oldState).\n   *\n   * @param action The action to dispatch, typed as CoreAction\n   * @returns The updated *global* store state\n   */\n  dispatchToCore(e) {\n    if (!this.coreReducer)\n      return this.getState();\n    const t = this.getState();\n    this.state.core = this.coreReducer(this.state.core, e);\n    const r = this.getState();\n    return this.listeners.forEach((s) => s(e, r, t)), r;\n  }\n  /**\n   * Dispatches an action *only* to a specific plugin.\n   * Optionally notifies global store listeners if `notifyGlobal` is true.\n   * Always notifies plugin-specific listeners with (action, newPluginState, oldPluginState).\n   *\n   * @param pluginId   The plugin identifier\n   * @param action     The plugin action to dispatch\n   * @param notifyGlobal Whether to also notify global store listeners\n   * @returns The updated *global* store state\n   */\n  dispatchToPlugin(e, t, r = !0) {\n    const s = this.getState(), n = this.pluginReducers[e];\n    if (!n)\n      return s;\n    const a = s.plugins[e], o = n(a, t);\n    this.state.plugins[e] = o;\n    const c = this.getState();\n    return r && this.listeners.forEach((h) => h(t, c, s)), this.pluginListeners[e] && this.pluginListeners[e].forEach((h) => {\n      h(t, o, a);\n    }), o;\n  }\n  /**\n   * Dispatches an action to update the state using:\n   * - the core reducer (if it's a CoreAction)\n   * - *all* plugin reducers (regardless of action type), with no global notify for each plugin\n   *\n   * Returns the new *global* store state after all reducers have processed the action.\n   *\n   * @param action The action to dispatch (can be CoreAction or any Action).\n   */\n  dispatch(e) {\n    const t = this.getState();\n    this.isCoreAction(e) && (this.state.core = this.coreReducer(this.state.core, e));\n    for (const s in this.pluginReducers) {\n      const n = this.pluginReducers[s], a = t.plugins[s];\n      n && (this.state.plugins[s] = n(a, e));\n    }\n    const r = this.getState();\n    return this.listeners.forEach((s) => s(e, r, t)), r;\n  }\n  /**\n   * Returns a shallow copy of the current state.\n   * @returns The current store state.\n   */\n  getState() {\n    return {\n      core: { ...this.state.core },\n      plugins: { ...this.state.plugins }\n    };\n  }\n  /**\n   * Subscribes a listener to *global* state changes.\n   * The callback signature is now (action, newState, oldState).\n   *\n   * @param listener The callback to invoke on state changes\n   * @returns A function to unsubscribe the listener\n   */\n  subscribe(e) {\n    return this.listeners.push(e), () => {\n      this.listeners = this.listeners.filter((t) => t !== e);\n    };\n  }\n  /**\n   * Subscribes a listener to *plugin-specific* state changes.\n   * The callback signature is now (action, newPluginState, oldPluginState).\n   *\n   * @param pluginId The unique identifier for the plugin.\n   * @param listener The callback to invoke on plugin state changes.\n   * @returns A function to unsubscribe the listener.\n   */\n  subscribeToPlugin(e, t) {\n    if (!(e in this.state.plugins))\n      throw new Error(\n        `Plugin state not found for plugin \"${e}\". Did you forget to call addPluginReducer?`\n      );\n    return this.pluginListeners[e] || (this.pluginListeners[e] = []), this.pluginListeners[e].push(t), () => {\n      this.pluginListeners[e] = this.pluginListeners[e].filter((r) => r !== t), this.pluginListeners[e].length === 0 && delete this.pluginListeners[e];\n    };\n  }\n  /**\n   * Subscribes to a specific action type (only from the core's action union).\n   * The callback signature is (action, newState, oldState).\n   *\n   * @param type The action type to listen for.\n   * @param handler The callback to invoke when the action occurs.\n   * @returns A function to unsubscribe the handler.\n   */\n  onAction(e, t) {\n    return this.subscribe((r, s, n) => {\n      r.type === e && t(r, s, n);\n    });\n  }\n  /**\n   * Gets a PluginStore handle for a specific plugin.\n   * @param pluginId The unique identifier for the plugin.\n   * @returns A PluginStore instance for the plugin.\n   */\n  getPluginStore(e) {\n    if (!(e in this.state.plugins))\n      throw new Error(\n        `Plugin state not found for plugin \"${e}\". Did you forget to call addPluginReducer?`\n      );\n    return new D(this, e);\n  }\n  /**\n   * Helper method to check if an action is a CoreAction.\n   * Adjust if you have a more refined way to differentiate CoreAction vs. any other Action.\n   */\n  isCoreAction(e) {\n    return O.includes(e.type);\n  }\n  /**\n   * Destroy the store: drop every listener and plugin reducer\n   */\n  destroy() {\n    var e, t;\n    this.listeners.length = 0;\n    for (const r in this.pluginListeners)\n      (t = (e = this.pluginListeners[r]) == null ? void 0 : e.splice) == null || t.call(e, 0);\n    this.pluginListeners = {}, this.pluginReducers = {}, this.state.plugins = {}, this.state.core = { ...this.initialCoreState };\n  }\n}\nvar C = /* @__PURE__ */ ((i) => (i[i.Degree0 = 0] = \"Degree0\", i[i.Degree90 = 1] = \"Degree90\", i[i.Degree180 = 2] = \"Degree180\", i[i.Degree270 = 3] = \"Degree270\", i))(C || {});\nfunction T(i) {\n  const { width: e, height: t } = i;\n  return {\n    width: t,\n    height: e\n  };\n}\nfunction X(i, e, t) {\n  return i = e % 2 === 0 ? i : T(i), {\n    width: i.width * t,\n    height: i.height * t\n  };\n}\nvar z = \"­\", M = \"​\", L = \"⁠\", $ = \"\\uFEFF\", F = \"￾\", N = \"￿\", k = Object.freeze([\n  z,\n  M,\n  L,\n  $,\n  F,\n  N\n]);\nnew RegExp(`[${k.join(\"\")}]`, \"g\");\nvar P = Object.freeze([\n  { id: 0, label: \"Normal\", css: \"normal\" },\n  { id: 1, label: \"Multiply\", css: \"multiply\" },\n  { id: 2, label: \"Screen\", css: \"screen\" },\n  { id: 3, label: \"Overlay\", css: \"overlay\" },\n  { id: 4, label: \"Darken\", css: \"darken\" },\n  { id: 5, label: \"Lighten\", css: \"lighten\" },\n  { id: 6, label: \"Color Dodge\", css: \"color-dodge\" },\n  { id: 7, label: \"Color Burn\", css: \"color-burn\" },\n  { id: 8, label: \"Hard Light\", css: \"hard-light\" },\n  { id: 9, label: \"Soft Light\", css: \"soft-light\" },\n  { id: 10, label: \"Difference\", css: \"difference\" },\n  { id: 11, label: \"Exclusion\", css: \"exclusion\" },\n  { id: 12, label: \"Hue\", css: \"hue\" },\n  { id: 13, label: \"Saturation\", css: \"saturation\" },\n  { id: 14, label: \"Color\", css: \"color\" },\n  { id: 15, label: \"Luminosity\", css: \"luminosity\" }\n]);\nP.reduce(\n  (i, e) => (i[e.id] = e, i),\n  {}\n);\nP.reduce((i, e) => (i[e.css] = e.id, i), {});\nP.map((i) => ({\n  value: i.id,\n  label: i.label\n}));\nvar _ = Object.freeze({\n  1: \"invisible\",\n  2: \"hidden\",\n  4: \"print\",\n  8: \"noZoom\",\n  16: \"noRotate\",\n  32: \"noView\",\n  64: \"readOnly\",\n  128: \"locked\",\n  256: \"toggleNoView\"\n});\nObject.entries(\n  _\n).reduce(\n  (i, [e, t]) => (i[t] = Number(e), i),\n  {}\n);\nconst j = (i) => ({\n  scale: (i == null ? void 0 : i.scale) ?? 1,\n  rotation: (i == null ? void 0 : i.rotation) ?? C.Degree0,\n  document: null,\n  pages: [],\n  loading: !1,\n  error: null\n}), q = (i, e) => {\n  switch (e.type) {\n    case g:\n      return {\n        ...i,\n        loading: !0,\n        error: null\n      };\n    case f:\n      return {\n        ...i,\n        document: e.payload,\n        pages: e.payload.pages.map((t) => [t]),\n        loading: !1,\n        error: null\n      };\n    case w:\n      return {\n        ...i,\n        rotation: e.payload\n      };\n    case E:\n      return {\n        ...i,\n        pages: e.payload\n      };\n    case p:\n      return {\n        ...i,\n        loading: !1,\n        error: e.payload\n      };\n    case y:\n      return {\n        ...i,\n        scale: e.payload\n      };\n    default:\n      return i;\n  }\n};\nclass ee {\n  constructor(e, t) {\n    this.plugins = /* @__PURE__ */ new Map(), this.manifests = /* @__PURE__ */ new Map(), this.capabilities = /* @__PURE__ */ new Map(), this.status = /* @__PURE__ */ new Map(), this.configurations = /* @__PURE__ */ new Map(), this.engineInitialized = !1, this.initPromise = null, this.pendingRegistrations = [], this.processingRegistrations = [], this.initialized = !1, this.isInitializing = !1, this.pluginsReadyPromise = null, this.destroyed = !1, this.resolver = new b(), this.engine = e, this.initialCoreState = j(t), this.store = new A(q, this.initialCoreState);\n  }\n  /**\n   * Ensure engine is initialized before proceeding\n   */\n  async ensureEngineInitialized() {\n    this.engineInitialized || (this.engine.initialize ? (await this.engine.initialize().toPromise(), this.engineInitialized = !0) : this.engineInitialized = !0);\n  }\n  /**\n   * Register a plugin without initializing it\n   */\n  registerPlugin(e, t) {\n    if (this.initialized && !this.isInitializing)\n      throw new l(\"Cannot register plugins after initialization\");\n    this.validateManifest(e.manifest), this.store.addPluginReducer(\n      e.manifest.id,\n      // We need one type assertion here since we can't fully reconcile TAction with Action\n      // due to TypeScript's type system limitations with generic variance\n      e.reducer,\n      typeof e.initialState == \"function\" ? e.initialState(\n        this.initialCoreState,\n        {\n          ...e.manifest.defaultConfig,\n          ...t\n        }\n      ) : e.initialState\n    ), this.pendingRegistrations.push({\n      package: e,\n      config: t\n    });\n  }\n  /**\n   * Get the central store instance\n   */\n  getStore() {\n    return this.store;\n  }\n  /**\n   * Get the engine instance\n   */\n  getEngine() {\n    return this.engine;\n  }\n  /**\n   * Get a promise that resolves when all plugins are ready\n   */\n  pluginsReady() {\n    return this.pluginsReadyPromise ? this.pluginsReadyPromise : (this.pluginsReadyPromise = (async () => {\n      this.initialized || await this.initialize();\n      const e = Array.from(this.plugins.values()).map(\n        (t) => typeof t.ready == \"function\" ? t.ready() : Promise.resolve()\n      );\n      await Promise.all(e);\n    })(), this.pluginsReadyPromise);\n  }\n  /**\n   * INITIALISE THE REGISTRY – runs once no-matter-how-many calls   *\n   */\n  async initialize() {\n    if (this.destroyed)\n      throw new l(\"Registry has been destroyed\");\n    return this.initPromise ? this.initPromise : (this.initPromise = (async () => {\n      var e;\n      if (this.initialized)\n        throw new l(\"Registry is already initialized\");\n      this.isInitializing = !0;\n      try {\n        if (await this.ensureEngineInitialized(), this.destroyed)\n          return;\n        for (; this.pendingRegistrations.length > 0; ) {\n          if (this.destroyed)\n            return;\n          this.processingRegistrations = [...this.pendingRegistrations], this.pendingRegistrations = [];\n          for (const r of this.processingRegistrations) {\n            const s = /* @__PURE__ */ new Set(), n = [...r.package.manifest.requires, ...r.package.manifest.optional];\n            for (const a of n) {\n              const o = this.processingRegistrations.find(\n                (c) => c.package.manifest.provides.includes(a)\n              );\n              o && s.add(o.package.manifest.id);\n            }\n            this.resolver.addNode(r.package.manifest.id, [...s]);\n          }\n          const t = this.resolver.resolveLoadOrder();\n          for (const r of t) {\n            const s = this.processingRegistrations.find((n) => n.package.manifest.id === r);\n            await this.initializePlugin(s.package.manifest, s.package.create, s.config);\n          }\n          this.processingRegistrations = [], this.resolver = new b();\n        }\n        for (const t of this.plugins.values())\n          await ((e = t.postInitialize) == null ? void 0 : e.call(t).catch((r) => {\n            console.error(`Error in postInitialize for plugin ${t.id}`, r), this.status.set(t.id, \"error\");\n          }));\n        this.initialized = !0;\n      } catch (t) {\n        throw t instanceof Error ? new m(\n          `Failed to resolve plugin dependencies: ${t.message}`\n        ) : t;\n      } finally {\n        this.isInitializing = !1;\n      }\n    })(), this.initPromise);\n  }\n  /**\n   * Initialize a single plugin with all necessary checks\n   */\n  async initializePlugin(e, t, r) {\n    const s = {\n      ...e.defaultConfig,\n      ...r\n    };\n    this.validateConfig(e.id, s, e.defaultConfig);\n    const n = t(this, this.engine, s);\n    this.validatePlugin(n);\n    for (const a of e.requires)\n      if (!this.capabilities.has(a))\n        throw new l(\n          `Missing required capability: ${a} for plugin ${e.id}`\n        );\n    for (const a of e.optional)\n      this.capabilities.has(a) && console.debug(`Optional capability ${a} is available for plugin ${e.id}`);\n    console.log(\"initializePlugin\", e.id, e.provides);\n    for (const a of e.provides) {\n      if (this.capabilities.has(a))\n        throw new l(\n          `Capability ${a} is already provided by plugin ${this.capabilities.get(a)}`\n        );\n      this.capabilities.set(a, e.id);\n    }\n    this.plugins.set(e.id, n), this.manifests.set(e.id, e), this.status.set(e.id, \"registered\"), this.configurations.set(e.id, s);\n    try {\n      n.initialize && await n.initialize(s), this.status.set(e.id, \"active\");\n    } catch (a) {\n      throw this.plugins.delete(e.id), this.manifests.delete(e.id), console.log(\"initializePlugin failed\", e.id, e.provides), e.provides.forEach((o) => this.capabilities.delete(o)), a;\n    }\n  }\n  getPluginConfig(e) {\n    const t = this.configurations.get(e);\n    if (!t)\n      throw new u(`Configuration for plugin ${e} not found`);\n    return t;\n  }\n  validateConfig(e, t, r) {\n    const n = Object.keys(r).filter((a) => !t.hasOwnProperty(a));\n    if (n.length > 0)\n      throw new R(\n        `Missing required configuration keys for plugin ${e}: ${n.join(\", \")}`\n      );\n  }\n  async updatePluginConfig(e, t) {\n    const r = this.getPlugin(e);\n    if (!r)\n      throw new u(`Plugin ${e} not found`);\n    const s = this.manifests.get(e), n = this.configurations.get(e);\n    if (!s || !n)\n      throw new u(`Plugin ${e} not found`);\n    const a = {\n      ...n,\n      ...t\n    };\n    this.validateConfig(e, a, s.defaultConfig), this.configurations.set(e, a), r.initialize && await r.initialize(a);\n  }\n  /**\n   * Register multiple plugins at once\n   */\n  registerPluginBatch(e) {\n    for (const t of e)\n      this.registerPlugin(t.package, t.config);\n  }\n  /**\n   * Unregister a plugin\n   */\n  async unregisterPlugin(e) {\n    const t = this.plugins.get(e);\n    if (!t)\n      throw new u(`Plugin ${e} is not registered`);\n    const r = this.manifests.get(e);\n    if (!r)\n      throw new u(`Manifest for plugin ${e} not found`);\n    for (const [s, n] of this.manifests.entries()) {\n      if (s === e) continue;\n      if ([...n.requires, ...n.optional].some(\n        (o) => r.provides.includes(o)\n      ))\n        throw new l(\n          `Cannot unregister plugin ${e}: plugin ${s} depends on it`\n        );\n    }\n    try {\n      t.destroy && await t.destroy();\n      for (const s of r.provides)\n        this.capabilities.delete(s);\n      this.plugins.delete(e), this.manifests.delete(e), this.status.delete(e);\n    } catch (s) {\n      throw s instanceof Error ? new Error(`Failed to unregister plugin ${e}: ${s.message}`) : s;\n    }\n  }\n  /**\n   * Get a plugin instance\n   * @param pluginId The ID of the plugin to get\n   * @returns The plugin instance or null if not found\n   */\n  getPlugin(e) {\n    const t = this.plugins.get(e);\n    return t || null;\n  }\n  /**\n   * Get a plugin that provides a specific capability\n   * @param capability The capability to get a provider for\n   * @returns The plugin providing the capability or null if not found\n   */\n  getCapabilityProvider(e) {\n    const t = this.capabilities.get(e);\n    return t ? this.getPlugin(t) : null;\n  }\n  /**\n   * Check if a capability is available\n   */\n  hasCapability(e) {\n    return this.capabilities.has(e);\n  }\n  /**\n   * Get all registered plugins\n   */\n  getAllPlugins() {\n    return Array.from(this.plugins.values());\n  }\n  /**\n   * Get plugin status\n   */\n  getPluginStatus(e) {\n    const t = this.status.get(e);\n    if (!t)\n      throw new u(`Plugin ${e} not found`);\n    return t;\n  }\n  /**\n   * Validate plugin object\n   */\n  validatePlugin(e) {\n    if (!e.id)\n      throw new l(\"Plugin must have an id\");\n  }\n  /**\n   * Validate plugin manifest\n   */\n  validateManifest(e) {\n    if (!e.id)\n      throw new l(\"Manifest must have an id\");\n    if (!e.name)\n      throw new l(\"Manifest must have a name\");\n    if (!e.version)\n      throw new l(\"Manifest must have a version\");\n    if (!Array.isArray(e.provides))\n      throw new l(\"Manifest must have a provides array\");\n    if (!Array.isArray(e.requires))\n      throw new l(\"Manifest must have a requires array\");\n    if (!Array.isArray(e.optional))\n      throw new l(\"Manifest must have an optional array\");\n  }\n  isDestroyed() {\n    return this.destroyed;\n  }\n  /**\n   * DESTROY EVERYTHING – waits for any ongoing initialise(), once  *\n   */\n  async destroy() {\n    var e;\n    if (this.destroyed) throw new l(\"Registry has already been destroyed\");\n    this.destroyed = !0;\n    try {\n      await this.initPromise;\n    } catch {\n    }\n    for (const t of Array.from(this.plugins.values()).reverse())\n      await ((e = t.destroy) == null ? void 0 : e.call(t));\n    this.store.destroy(), this.plugins.clear(), this.manifests.clear(), this.capabilities.clear(), this.status.clear(), this.pendingRegistrations.length = 0, this.processingRegistrations.length = 0;\n  }\n}\nfunction te(i, e, t) {\n  return i < e ? e : i > t ? t : i;\n}\nfunction v(i, e, t) {\n  if (i === e)\n    return !0;\n  if (i == null || e == null)\n    return i === e;\n  const r = typeof i;\n  if (r !== typeof e) return !1;\n  if (r === \"object\") {\n    t || (t = /* @__PURE__ */ new Set());\n    const n = x(i, e);\n    if (t.has(n))\n      return !0;\n    t.add(n);\n    const a = Array.isArray(i), o = Array.isArray(e);\n    return a && o ? U(i, e, t) : !a && !o ? B(i, e, t) : !1;\n  }\n  return !1;\n}\nfunction x(i, e) {\n  return `${S(i)}__${S(e)}`;\n}\nlet G = 0;\nconst d = /* @__PURE__ */ new WeakMap();\nfunction S(i) {\n  return d.has(i) || d.set(i, ++G), d.get(i);\n}\nfunction U(i, e, t) {\n  if (i.length !== e.length) return !1;\n  const r = new Array(e.length).fill(!1);\n  e: for (let s = 0; s < i.length; s++) {\n    const n = i[s];\n    for (let a = 0; a < e.length; a++)\n      if (!r[a] && v(n, e[a], t)) {\n        r[a] = !0;\n        continue e;\n      }\n    return !1;\n  }\n  return !0;\n}\nfunction B(i, e, t) {\n  const r = Object.keys(i).sort(), s = Object.keys(e).sort();\n  if (r.length !== s.length) return !1;\n  for (let n = 0; n < r.length; n++)\n    if (r[n] !== s[n]) return !1;\n  for (const n of r) {\n    const a = i[n], o = e[n];\n    if (!v(a, o, t))\n      return !1;\n  }\n  return !0;\n}\nexport {\n  m as C,\n  b as D,\n  g as L,\n  ee as P,\n  f as S,\n  v as a,\n  l as b,\n  u as c,\n  K as d,\n  H as e,\n  W as f,\n  R as g,\n  p as h,\n  y as i,\n  w as j,\n  E as k,\n  O as l,\n  Z as m,\n  V as n,\n  J as o,\n  Y as p,\n  Q as q,\n  j as r,\n  I as s,\n  X as t,\n  te as u\n};\n//# sourceMappingURL=math-ChSRQF3r.js.map\n","import { t as S, a as m } from \"./math-ChSRQF3r.js\";\nimport { l as v, e as D, d as I, C as F, D as _, L as O, g as A, f as N, c as M, b as U, P as z, S as x, h as L, k as j, j as q, i as B, u as K, r as $, m as k, s as G, n as W, q as Y, p as H, o as J } from \"./math-ChSRQF3r.js\";\nconst f = (o) => o.pages.map(\n  (t) => t.map((e) => ({\n    ...e,\n    rotatedSize: S(e.size, o.rotation, 1)\n  }))\n);\nfunction y(o, t) {\n  return {\n    package: o,\n    config: t\n  };\n}\nclass w {\n  constructor(t, e) {\n    if (this.id = t, this.registry = e, this.debouncedActions = {}, this.unsubscribeFromState = null, this.unsubscribeFromCoreStore = null, t !== this.constructor.id)\n      throw new Error(\n        `Plugin ID mismatch: ${t} !== ${this.constructor.id}`\n      );\n    this.coreStore = this.registry.getStore(), this.pluginStore = this.coreStore.getPluginStore(this.id), this.unsubscribeFromState = this.pluginStore.subscribeToState((i, s, c) => {\n      this.onStoreUpdated(c, s);\n    }), this.unsubscribeFromCoreStore = this.coreStore.subscribe((i, s, c) => {\n      this.onCoreStoreUpdated(c, s);\n    }), this.readyPromise = new Promise((i) => {\n      this.readyResolve = i;\n    }), this.readyResolve();\n  }\n  provides() {\n    if (!this._capability) {\n      const t = this.buildCapability();\n      this._capability = Object.freeze(t);\n    }\n    return this._capability;\n  }\n  /**\n   *  Get a copy of the current state\n   */\n  get state() {\n    return this.pluginStore.getState();\n  }\n  /**\n   *  Get a copy of the current core state\n   */\n  get coreState() {\n    return this.coreStore.getState();\n  }\n  /**\n   * @deprecated  use `this.state` Get a copy of the current state\n   */\n  getState() {\n    return this.pluginStore.getState();\n  }\n  /**\n   * @deprecated  use `this.coreState` Get a copy of the current core state\n   */\n  getCoreState() {\n    return this.coreStore.getState();\n  }\n  /**\n   * Core Dispatch\n   */\n  dispatchCoreAction(t) {\n    return this.coreStore.dispatchToCore(t);\n  }\n  /**\n   * Dispatch an action to all plugins\n   */\n  dispatchToAllPlugins(t) {\n    return this.coreStore.dispatch(t);\n  }\n  /**\n   * Dispatch an action\n   */\n  dispatch(t) {\n    return this.pluginStore.dispatch(t);\n  }\n  /**\n   * Dispatch an action with debouncing to prevent rapid repeated calls\n   * @param action The action to dispatch\n   * @param debounceTime Time in ms to debounce (default: 100ms)\n   * @returns boolean indicating whether the action was dispatched or debounced\n   */\n  debouncedDispatch(t, e = 100) {\n    const i = Date.now(), s = this.debouncedActions[t.type] || 0;\n    return i - s >= e ? (this.debouncedActions[t.type] = i, this.dispatch(t), !0) : !1;\n  }\n  /**\n   * Subscribe to state changes\n   */\n  subscribe(t) {\n    return this.pluginStore.subscribeToState(t);\n  }\n  /**\n   * Subscribe to core store changes\n   */\n  subscribeToCoreStore(t) {\n    return this.coreStore.subscribe(t);\n  }\n  /**\n   * Called when the plugin store state is updated\n   * @param oldState Previous state\n   * @param newState New state\n   */\n  onStoreUpdated(t, e) {\n  }\n  /**\n   * Called when the core store state is updated\n   * @param oldState Previous state\n   * @param newState New state\n   */\n  onCoreStoreUpdated(t, e) {\n  }\n  /**\n   * Cleanup method to be called when plugin is being destroyed\n   */\n  destroy() {\n    this.unsubscribeFromState && (this.unsubscribeFromState(), this.unsubscribeFromState = null), this.unsubscribeFromCoreStore && (this.unsubscribeFromCoreStore(), this.unsubscribeFromCoreStore = null);\n  }\n  /**\n   * Returns a promise that resolves when the plugin is ready\n   */\n  ready() {\n    return this.readyPromise;\n  }\n  /**\n   * Mark the plugin as ready\n   */\n  markReady() {\n    this.readyResolve();\n  }\n  /**\n   * Reset the ready state (useful for plugins that need to reinitialize)\n   */\n  resetReady() {\n    this.readyPromise = new Promise((t) => {\n      this.readyResolve = t;\n    });\n  }\n}\nclass b {\n  constructor(t, e) {\n    this.handler = t, this.options = e, this.lastRun = 0, this.handle = (i) => {\n      this.options.mode === \"debounce\" ? this.debounce(i) : this.throttle(i);\n    };\n  }\n  debounce(t) {\n    this.timeoutId && window.clearTimeout(this.timeoutId), this.timeoutId = window.setTimeout(() => {\n      this.handler(t), this.timeoutId = void 0;\n    }, this.options.wait);\n  }\n  throttle(t) {\n    if (this.options.mode === \"debounce\") return;\n    const e = Date.now(), i = this.options.throttleMode || \"leading-trailing\";\n    e - this.lastRun >= this.options.wait && (i === \"leading-trailing\" && this.handler(t), this.lastRun = e), this.timeoutId && window.clearTimeout(this.timeoutId), this.timeoutId = window.setTimeout(\n      () => {\n        this.handler(t), this.lastRun = Date.now(), this.timeoutId = void 0;\n      },\n      this.options.wait - (e - this.lastRun)\n    );\n  }\n  destroy() {\n    this.timeoutId && window.clearTimeout(this.timeoutId);\n  }\n}\nfunction E() {\n  const o = /* @__PURE__ */ new Set();\n  return {\n    emit: (e = void 0) => o.forEach((i) => i(e)),\n    on: (e) => (o.add(e), () => o.delete(e)),\n    off: (e) => o.delete(e),\n    clear: () => o.clear()\n  };\n}\nfunction C(o, t = m) {\n  const e = /* @__PURE__ */ new Set(), i = /* @__PURE__ */ new Map();\n  let s = o;\n  const c = (r) => e.forEach((n) => n(r)), p = (r, n) => {\n    let a = r, d = () => {\n    };\n    if (n) {\n      const u = new b(r, n);\n      a = u.handle, d = () => u.destroy(), i.set(r, { wrapped: a, destroy: d });\n    }\n    return s !== void 0 && a(s), e.add(a), () => {\n      e.delete(a), d(), i.delete(r);\n    };\n  };\n  return {\n    /* emitter behaviour ---------------------------------------- */\n    get value() {\n      return s;\n    },\n    emit(r = void 0) {\n      (s === void 0 || !t(s, r)) && (s = r, c(r));\n    },\n    on: p,\n    off(r) {\n      const n = i.get(r);\n      n ? (e.delete(n.wrapped), n.destroy(), i.delete(r)) : e.delete(r);\n    },\n    clear() {\n      e.clear(), i.forEach((r) => r.destroy()), i.clear();\n    },\n    /* derived hook --------------------------------------------- */\n    select(r, n = m) {\n      return (a, d) => {\n        let u;\n        if (s !== void 0) {\n          const h = r(s);\n          u = h, a(h);\n        }\n        return p(\n          (h) => {\n            const l = r(h);\n            (u === void 0 || !n(u, l)) && (u = l, a(l));\n          },\n          d\n        );\n      };\n    }\n  };\n}\nfunction T(o) {\n  return Object.entries(o).map(([t, e]) => {\n    const i = Number(t);\n    return [Number.isFinite(i) && t.trim() !== \"\" ? i : t, e];\n  });\n}\nexport {\n  w as BasePlugin,\n  v as CORE_ACTION_TYPES,\n  D as CapabilityConflictError,\n  I as CapabilityNotFoundError,\n  F as CircularDependencyError,\n  _ as DependencyResolver,\n  b as EventControl,\n  O as LOAD_DOCUMENT,\n  A as PluginConfigurationError,\n  N as PluginInitializationError,\n  M as PluginNotFoundError,\n  U as PluginRegistrationError,\n  z as PluginRegistry,\n  x as SET_DOCUMENT,\n  L as SET_DOCUMENT_ERROR,\n  j as SET_PAGES,\n  q as SET_ROTATION,\n  B as SET_SCALE,\n  m as arePropsEqual,\n  K as clamp,\n  C as createBehaviorEmitter,\n  E as createEmitter,\n  y as createPluginRegistration,\n  T as enumEntries,\n  f as getPagesWithRotatedSize,\n  $ as initialCoreState,\n  k as loadDocument,\n  G as setDocument,\n  W as setDocumentError,\n  Y as setPages,\n  H as setRotation,\n  J as setScale\n};\n//# sourceMappingURL=index.js.map\n","import { Action } from '@embedpdf/core';\n\nexport const ACTIVATE_MODE = 'INTERACTION/ACTIVATE_MODE';\nexport const PAUSE_INTERACTION = 'INTERACTION/PAUSE';\nexport const RESUME_INTERACTION = 'INTERACTION/RESUME';\nexport const SET_CURSOR = 'INTERACTION/SET_CURSOR';\n\nexport interface ActivateModeAction extends Action {\n  type: typeof ACTIVATE_MODE;\n  payload: { mode: string };\n}\n\nexport interface PauseInteractionAction extends Action {\n  type: typeof PAUSE_INTERACTION;\n}\n\nexport interface ResumeInteractionAction extends Action {\n  type: typeof RESUME_INTERACTION;\n}\n\nexport interface SetCursorAction extends Action {\n  type: typeof SET_CURSOR;\n  payload: { cursor: string };\n}\n\nexport const activateMode = (mode: string): ActivateModeAction => ({\n  type: ACTIVATE_MODE,\n  payload: { mode },\n});\n\nexport const setCursor = (cursor: string): SetCursorAction => ({\n  type: SET_CURSOR,\n  payload: { cursor },\n});\n\nexport const pauseInteraction = (): PauseInteractionAction => ({\n  type: PAUSE_INTERACTION,\n});\n\nexport const resumeInteraction = (): ResumeInteractionAction => ({\n  type: RESUME_INTERACTION,\n});\n\nexport type InteractionManagerAction =\n  | ActivateModeAction\n  | PauseInteractionAction\n  | ResumeInteractionAction\n  | SetCursorAction;\n","import { PointerEventHandlers } from './types';\n\nexport function mergeHandlers(list: PointerEventHandlers[]): PointerEventHandlers {\n  const keys: (keyof PointerEventHandlers)[] = [\n    'onPointerDown',\n    'onPointerUp',\n    'onPointerMove',\n    'onPointerEnter',\n    'onPointerLeave',\n    'onPointerCancel',\n  ];\n  const out: Partial<PointerEventHandlers> = {};\n  for (const k of keys) {\n    out[k] = (evt: any, nativeEvt: any, modeId: string) => {\n      for (const h of list) h[k]?.(evt, nativeEvt, modeId);\n    };\n  }\n  return out as PointerEventHandlers;\n}\n","import { BasePlugin, createBehaviorEmitter, createEmitter, PluginRegistry } from '@embedpdf/core';\n\nimport {\n  InteractionManagerCapability,\n  InteractionManagerPluginConfig,\n  InteractionManagerState,\n  InteractionMode,\n  InteractionScope,\n  PointerEventHandlers,\n  PointerEventHandlersWithLifecycle,\n  RegisterAlwaysOptions,\n  RegisterHandlersOptions,\n} from './types';\nimport { activateMode, pauseInteraction, resumeInteraction, setCursor } from './actions';\nimport { mergeHandlers } from './helper';\n\ninterface CursorClaim {\n  cursor: string;\n  priority: number;\n}\n\ntype HandlerSet = Set<PointerEventHandlersWithLifecycle>;\ntype PageHandlerMap = Map<number /*pageIdx*/, HandlerSet>;\n\ninterface ModeBuckets {\n  /** handlers that listen on the global wrapper (only once per viewer) */\n  global: HandlerSet;\n  /** handlers that listen on a *specific* page wrapper */\n  page: PageHandlerMap;\n}\n\nexport class InteractionManagerPlugin extends BasePlugin<\n  InteractionManagerPluginConfig,\n  InteractionManagerCapability,\n  InteractionManagerState\n> {\n  static readonly id = 'interaction-manager' as const;\n\n  private modes = new Map<string, InteractionMode>();\n  private cursorClaims = new Map<string, CursorClaim>();\n  private buckets = new Map<string, ModeBuckets>();\n\n  private alwaysGlobal = new Set<PointerEventHandlersWithLifecycle>();\n  private alwaysPage = new Map<number, Set<PointerEventHandlersWithLifecycle>>();\n\n  private readonly onModeChange$ = createEmitter<InteractionManagerState>();\n  private readonly onHandlerChange$ = createEmitter<InteractionManagerState>();\n  private readonly onCursorChange$ = createEmitter<string>();\n  private readonly onStateChange$ = createBehaviorEmitter<InteractionManagerState>();\n\n  constructor(id: string, registry: PluginRegistry) {\n    super(id, registry);\n\n    this.registerMode({\n      id: 'default',\n      scope: 'page',\n      exclusive: false,\n      cursor: 'auto',\n    });\n  }\n\n  async initialize(_: InteractionManagerPluginConfig): Promise<void> {}\n\n  protected buildCapability(): InteractionManagerCapability {\n    return {\n      activate: (modeId: string) => this.activate(modeId),\n      onModeChange: this.onModeChange$.on,\n      onCursorChange: this.onCursorChange$.on,\n      onHandlerChange: this.onHandlerChange$.on,\n      onStateChange: this.onStateChange$.on,\n      getActiveMode: () => this.state.activeMode,\n      getActiveInteractionMode: () => this.getActiveInteractionMode(),\n      finish: () => this.activate('default'),\n      registerMode: (mode: InteractionMode) => this.registerMode(mode),\n      registerHandlers: (options: RegisterHandlersOptions) => this.registerHandlers(options),\n      registerAlways: (options: RegisterAlwaysOptions) => this.registerAlways(options),\n      setCursor: (token: string, cursor: string, priority = 0) =>\n        this.setCursor(token, cursor, priority),\n      removeCursor: (token: string) => this.removeCursor(token),\n      getCurrentCursor: () => this.state.cursor,\n      getHandlersForScope: (scope: InteractionScope) => this.getHandlersForScope(scope),\n      activeModeIsExclusive: () => this.activeModeIsExclusive(),\n      pause: () => this.dispatch(pauseInteraction()),\n      resume: () => this.dispatch(resumeInteraction()),\n      isPaused: () => this.state.paused,\n    };\n  }\n\n  private activate(mode: string) {\n    if (!this.modes.has(mode)) {\n      throw new Error(`[interaction] unknown mode '${mode}'`);\n    }\n    if (mode === this.state.activeMode) return;\n\n    const previousMode = this.state.activeMode;\n    this.cursorClaims.clear(); // prevent cursor leaks\n\n    this.notifyHandlersInactive(previousMode);\n\n    this.dispatch(activateMode(mode));\n    this.emitCursor();\n\n    // Call lifecycle hooks for handlers going active\n    this.notifyHandlersActive(mode);\n\n    this.onModeChange$.emit({ ...this.state, activeMode: mode });\n  }\n\n  private notifyHandlersActive(modeId: string) {\n    this.alwaysGlobal.forEach((handler) => {\n      handler.onHandlerActiveStart?.(modeId);\n    });\n\n    this.alwaysPage.forEach((handlerSet) => {\n      handlerSet.forEach((handler) => {\n        handler.onHandlerActiveStart?.(modeId);\n      });\n    });\n\n    const mode = this.modes.get(modeId);\n    if (!mode) return;\n\n    const bucket = this.buckets.get(modeId);\n    if (!bucket) return;\n\n    // Notify global handlers if mode is global\n    if (mode.scope === 'global') {\n      bucket.global.forEach((handler) => {\n        handler.onHandlerActiveStart?.(modeId);\n      });\n    }\n\n    // Notify page handlers if mode is page\n    if (mode.scope === 'page') {\n      bucket.page.forEach((handlerSet, pageIndex) => {\n        handlerSet.forEach((handler) => {\n          handler.onHandlerActiveStart?.(modeId);\n        });\n      });\n    }\n  }\n\n  private notifyHandlersInactive(modeId: string) {\n    this.alwaysGlobal.forEach((handler) => {\n      handler.onHandlerActiveEnd?.(modeId);\n    });\n\n    this.alwaysPage.forEach((handlerSet) => {\n      handlerSet.forEach((handler) => {\n        handler.onHandlerActiveEnd?.(modeId);\n      });\n    });\n\n    const mode = this.modes.get(modeId);\n    if (!mode) return;\n\n    const bucket = this.buckets.get(modeId);\n    if (!bucket) return;\n\n    // Notify global handlers if mode is global\n    if (mode.scope === 'global') {\n      bucket.global.forEach((handler) => {\n        handler.onHandlerActiveEnd?.(modeId);\n      });\n    }\n\n    // Notify page handlers if mode is page\n    if (mode.scope === 'page') {\n      bucket.page.forEach((handlerSet, pageIndex) => {\n        handlerSet.forEach((handler) => {\n          handler.onHandlerActiveEnd?.(modeId);\n        });\n      });\n    }\n  }\n\n  private registerMode(mode: InteractionMode) {\n    this.modes.set(mode.id, mode);\n    if (!this.buckets.has(mode.id)) {\n      this.buckets.set(mode.id, { global: new Set(), page: new Map() });\n    }\n  }\n\n  /** ---------- pointer-handler handling ------------ */\n  private registerHandlers({ modeId, handlers, pageIndex }: RegisterHandlersOptions): () => void {\n    const modeIds = Array.isArray(modeId) ? modeId : [modeId];\n    const cleanupFunctions: (() => void)[] = [];\n\n    for (const id of modeIds) {\n      const bucket = this.buckets.get(id);\n      if (!bucket) throw new Error(`unknown mode '${id}'`);\n\n      if (pageIndex == null) {\n        bucket.global.add(handlers);\n      } else {\n        const set = bucket.page.get(pageIndex) ?? new Set();\n        set.add(handlers);\n        bucket.page.set(pageIndex, set);\n      }\n\n      // Create cleanup function for this specific mode\n      cleanupFunctions.push(() => {\n        if (pageIndex == null) {\n          bucket.global.delete(handlers);\n        } else {\n          const set = bucket.page.get(pageIndex);\n          if (set) {\n            set.delete(handlers);\n            if (set.size === 0) {\n              bucket.page.delete(pageIndex);\n            }\n          }\n        }\n      });\n    }\n\n    this.onHandlerChange$.emit({ ...this.state });\n\n    // Return a cleanup function that removes handlers from all registered modes\n    return () => {\n      cleanupFunctions.forEach((cleanup) => cleanup());\n      this.onHandlerChange$.emit({ ...this.state });\n    };\n  }\n\n  public registerAlways({ scope, handlers }: RegisterAlwaysOptions): () => void {\n    if (scope.type === 'global') {\n      this.alwaysGlobal.add(handlers);\n      this.onHandlerChange$.emit({ ...this.state });\n      return () => this.alwaysGlobal.delete(handlers);\n    }\n    const set = this.alwaysPage.get(scope.pageIndex) ?? new Set();\n    set.add(handlers);\n    this.alwaysPage.set(scope.pageIndex, set);\n    this.onHandlerChange$.emit({ ...this.state });\n    return () => {\n      set.delete(handlers);\n      this.onHandlerChange$.emit({ ...this.state });\n    };\n  }\n\n  /** Returns the *merged* handler set that should be active for the given\n   *  provider (`global` wrapper or a single page wrapper).\n   *  – `alwaysGlobal` / `alwaysPage` are **always** active.\n   *  – Handlers that belong to the current mode are added on top **iff**\n   *    the mode’s own scope matches the provider’s scope.            */\n  private getHandlersForScope(scope: InteractionScope): PointerEventHandlers | null {\n    if (!this.state) return null;\n\n    const mode = this.modes.get(this.state.activeMode);\n    if (!mode) return null;\n\n    const bucket = this.buckets.get(mode.id);\n    if (!bucket) return null;\n\n    /** helper – merge two handler sets into one object (or `null` if both are empty) */\n    const mergeSets = (a: HandlerSet, b: HandlerSet) =>\n      a.size || b.size ? mergeHandlers([...a, ...b]) : null;\n\n    /* ─────────────────────  GLOBAL PROVIDER  ─────────────────────── */\n    if (scope.type === 'global') {\n      const modeSpecific =\n        mode.scope === 'global' // only include mode handlers if the\n          ? bucket.global // mode itself is global-scoped\n          : new Set<PointerEventHandlers>();\n      return mergeSets(this.alwaysGlobal, modeSpecific);\n    }\n\n    /* ───────────────────────  PAGE PROVIDER  ──────────────────────── */\n    const alwaysPageSet = this.alwaysPage.get(scope.pageIndex) ?? new Set<PointerEventHandlers>();\n    const modePageSet =\n      mode.scope === 'page'\n        ? (bucket.page.get(scope.pageIndex) ?? new Set<PointerEventHandlers>())\n        : new Set<PointerEventHandlers>(); // global-scoped mode → ignore page buckets\n\n    return mergeSets(alwaysPageSet, modePageSet);\n  }\n\n  /** ---------- cursor handling --------------------- */\n  private setCursor(token: string, cursor: string, priority = 0) {\n    this.cursorClaims.set(token, { cursor, priority });\n    this.emitCursor();\n  }\n  private removeCursor(token: string) {\n    this.cursorClaims.delete(token);\n    this.emitCursor();\n  }\n\n  private emitCursor() {\n    /* pick highest priority claim, else mode baseline */\n    const top = [...this.cursorClaims.values()].sort((a, b) => b.priority - a.priority)[0] ?? {\n      cursor: this.modes.get(this.state.activeMode)?.cursor ?? 'auto',\n    };\n\n    if (top.cursor !== this.state.cursor) {\n      this.dispatch(setCursor(top.cursor));\n      this.onCursorChange$.emit(top.cursor);\n    }\n  }\n\n  override onStoreUpdated(_: InteractionManagerState, newState: InteractionManagerState): void {\n    this.onStateChange$.emit(newState);\n  }\n\n  private activeModeIsExclusive(): boolean {\n    const mode = this.modes.get(this.state.activeMode);\n    return !!mode?.exclusive;\n  }\n\n  private getActiveInteractionMode(): InteractionMode | null {\n    return this.modes.get(this.state.activeMode) ?? null;\n  }\n\n  // keep emitter clean\n  async destroy(): Promise<void> {\n    this.onModeChange$.clear();\n    this.onCursorChange$.clear();\n    await super.destroy();\n  }\n}\n","import { Reducer } from '@embedpdf/core';\nimport {\n  ACTIVATE_MODE,\n  InteractionManagerAction,\n  PAUSE_INTERACTION,\n  RESUME_INTERACTION,\n  SET_CURSOR,\n} from './actions';\nimport { InteractionManagerState } from './types';\n\nexport const initialState: InteractionManagerState = {\n  activeMode: 'default',\n  cursor: 'auto',\n  paused: false,\n};\n\nexport const reducer: Reducer<InteractionManagerState, InteractionManagerAction> = (\n  state,\n  action,\n) => {\n  switch (action.type) {\n    case ACTIVATE_MODE:\n      return {\n        ...state,\n        activeMode: action.payload.mode,\n      };\n    case SET_CURSOR:\n      return {\n        ...state,\n        cursor: action.payload.cursor,\n      };\n    case PAUSE_INTERACTION:\n      return {\n        ...state,\n        paused: true,\n      };\n    case RESUME_INTERACTION:\n      return {\n        ...state,\n        paused: false,\n      };\n    default:\n      return state;\n  }\n};\n","import { createContext as b } from \"preact\";\nimport { u as w } from \"../jsxRuntime.module-Bzuv3cXw.js\";\nimport { useState as a, useRef as m, useEffect as f, useContext as S } from \"preact/hooks\";\nimport { P as v, a as C } from \"../math-ChSRQF3r.js\";\nconst P = b({\n  registry: null,\n  isInitializing: !0,\n  pluginsReady: !1\n});\nfunction F({ engine: t, onInitialized: r, plugins: e, children: i }) {\n  const [o, s] = a(null), [u, c] = a(!0), [y, d] = a(!1), l = m(r);\n  return f(() => {\n    l.current = r;\n  }, [r]), f(() => {\n    const n = new v(t);\n    return n.registerPluginBatch(e), (async () => {\n      var p;\n      await n.initialize(), !n.isDestroyed() && (await ((p = l.current) == null ? void 0 : p.call(l, n)), !n.isDestroyed() && (n.pluginsReady().then(() => {\n        n.isDestroyed() || d(!0);\n      }), s(n), c(!1)));\n    })().catch(console.error), () => {\n      n.destroy(), s(null), c(!0), d(!1);\n    };\n  }, [t, e]), /* @__PURE__ */ w(P.Provider, { value: { registry: o, isInitializing: u, pluginsReady: y }, children: typeof i == \"function\" ? i({ registry: o, isInitializing: u, pluginsReady: y }) : i });\n}\nfunction g() {\n  const t = S(P);\n  if (t === void 0)\n    throw new Error(\"useCapability must be used within a PDFContext.Provider\");\n  const { registry: r, isInitializing: e } = t;\n  if (e)\n    return t;\n  if (r === null)\n    throw new Error(\"PDF registry failed to initialize properly\");\n  return t;\n}\nfunction h(t) {\n  const { registry: r } = g();\n  if (r === null)\n    return {\n      plugin: null,\n      isLoading: !0,\n      ready: new Promise(() => {\n      })\n    };\n  const e = r.getPlugin(t);\n  if (!e)\n    throw new Error(`Plugin ${t} not found`);\n  return {\n    plugin: e,\n    isLoading: !1,\n    ready: e.ready()\n  };\n}\nfunction L(t) {\n  const { plugin: r, isLoading: e, ready: i } = h(t);\n  if (!r)\n    return {\n      provides: null,\n      isLoading: e,\n      ready: i\n    };\n  if (!r.provides)\n    throw new Error(`Plugin ${t} does not provide a capability`);\n  return {\n    provides: r.provides(),\n    isLoading: e,\n    ready: i\n  };\n}\nfunction V() {\n  const { registry: t } = g(), [r, e] = a(null);\n  return f(() => {\n    if (!t) return;\n    e(t.getStore().getState());\n    const i = t.getStore().subscribe((o, s) => {\n      e(s);\n    });\n    return () => i();\n  }, [t]), r;\n}\nfunction $() {\n  const { registry: t } = g(), [r, e] = a(null);\n  return f(() => {\n    if (!t) return;\n    const i = t.getStore();\n    e(i.getState().core);\n    const o = i.subscribe((s, u, c) => {\n      i.isCoreAction(s) && !C(u.core, c.core) && e(u.core);\n    });\n    return () => o();\n  }, [t]), r;\n}\nexport {\n  F as EmbedPDF,\n  P as PDFContext,\n  L as useCapability,\n  $ as useCoreState,\n  h as usePlugin,\n  g as useRegistry,\n  V as useStoreState\n};\n//# sourceMappingURL=index.js.map\n","import { useCapability, usePlugin } from '@embedpdf/core/preact';\nimport {\n  initialState,\n  InteractionManagerPlugin,\n  InteractionManagerState,\n  PointerEventHandlers,\n  PointerEventHandlersWithLifecycle,\n} from '@embedpdf/plugin-interaction-manager';\nimport { useState, useEffect } from 'preact/hooks';\n\nexport const useInteractionManagerPlugin = () =>\n  usePlugin<InteractionManagerPlugin>(InteractionManagerPlugin.id);\nexport const useInteractionManagerCapability = () =>\n  useCapability<InteractionManagerPlugin>(InteractionManagerPlugin.id);\n\nexport function useInteractionManager() {\n  const { provides } = useInteractionManagerCapability();\n  const [state, setState] = useState<InteractionManagerState>(initialState);\n\n  useEffect(() => {\n    if (!provides) return;\n    return provides.onStateChange((state) => {\n      setState(state);\n    });\n  }, [provides]);\n\n  return {\n    provides,\n    state,\n  };\n}\n\nexport function useCursor() {\n  const { provides } = useInteractionManagerCapability();\n  return {\n    setCursor: (token: string, cursor: string, prio = 0) => {\n      provides?.setCursor(token, cursor, prio);\n    },\n    removeCursor: (token: string) => {\n      provides?.removeCursor(token);\n    },\n  };\n}\n\ninterface UsePointerHandlersOptions {\n  modeId?: string | string[];\n  pageIndex?: number;\n}\n\nexport function usePointerHandlers({ modeId, pageIndex }: UsePointerHandlersOptions) {\n  const { provides } = useInteractionManagerCapability();\n  return {\n    register: (\n      handlers: PointerEventHandlersWithLifecycle,\n      options?: { modeId?: string | string[]; pageIndex?: number },\n    ) => {\n      // Use provided options or fall back to hook-level options\n      const finalModeId = options?.modeId ?? modeId;\n      const finalPageIndex = options?.pageIndex ?? pageIndex;\n\n      return finalModeId\n        ? provides?.registerHandlers({\n            modeId: finalModeId,\n            handlers,\n            pageIndex: finalPageIndex,\n          })\n        : provides?.registerAlways({\n            scope:\n              finalPageIndex !== undefined\n                ? { type: 'page', pageIndex: finalPageIndex }\n                : { type: 'global' },\n            handlers,\n          });\n    },\n  };\n}\n\nexport function useIsPageExclusive() {\n  const { provides: cap } = useInteractionManagerCapability();\n\n  const [isPageExclusive, setIsPageExclusive] = useState<boolean>(() => {\n    const m = cap?.getActiveInteractionMode();\n    return m?.scope === 'page' && !!m.exclusive;\n  });\n\n  useEffect(() => {\n    if (!cap) return;\n\n    return cap.onModeChange(() => {\n      const mode = cap.getActiveInteractionMode();\n      setIsPageExclusive(mode?.scope === 'page' && !!mode?.exclusive);\n    });\n  }, [cap]);\n\n  return isPageExclusive;\n}\n","/** @jsxImportSource preact */\nimport { ComponentChildren, JSX } from 'preact';\nimport { useEffect, useRef } from 'preact/hooks';\nimport { createPointerProvider } from '../../shared/utils';\n\nimport { useInteractionManagerCapability } from '../hooks';\n\ninterface GlobalPointerProviderProps extends JSX.HTMLAttributes<HTMLDivElement> {\n  children: ComponentChildren;\n  style?: JSX.CSSProperties;\n}\n\nexport const GlobalPointerProvider = ({\n  children,\n  style,\n  ...props\n}: GlobalPointerProviderProps) => {\n  const ref = useRef<HTMLDivElement>(null);\n  const { provides: cap } = useInteractionManagerCapability();\n\n  useEffect(() => {\n    if (!cap || !ref.current) return;\n\n    return createPointerProvider(cap, { type: 'global' }, ref.current);\n  }, [cap]);\n\n  return (\n    <div\n      ref={ref}\n      style={{\n        width: '100%',\n        height: '100%',\n        ...style,\n      }}\n      {...props}\n    >\n      {children}\n    </div>\n  );\n};\n","/** @jsxImportSource preact */\nimport { ComponentChildren, JSX } from 'preact';\nimport { useCallback, useEffect, useRef } from 'preact/hooks';\nimport { Position, restorePosition } from '@embedpdf/models';\nimport { createPointerProvider } from '../../shared/utils';\n\nimport { useInteractionManagerCapability, useIsPageExclusive } from '../hooks';\n\ninterface PagePointerProviderProps extends JSX.HTMLAttributes<HTMLDivElement> {\n  children: ComponentChildren;\n  pageIndex: number;\n  pageWidth: number;\n  pageHeight: number;\n  rotation: number;\n  scale: number;\n  style?: JSX.CSSProperties;\n  convertEventToPoint?: (event: PointerEvent, element: HTMLElement) => Position;\n}\n\nexport const PagePointerProvider = ({\n  pageIndex,\n  children,\n  pageWidth,\n  pageHeight,\n  rotation,\n  scale,\n  convertEventToPoint,\n  style,\n  ...props\n}: PagePointerProviderProps) => {\n  const ref = useRef<HTMLDivElement>(null);\n  const { provides: cap } = useInteractionManagerCapability();\n  const isPageExclusive = useIsPageExclusive();\n\n  const defaultConvertEventToPoint = useCallback(\n    (event: PointerEvent, element: HTMLElement): Position => {\n      const rect = element.getBoundingClientRect();\n      const displayPoint = {\n        x: event.clientX - rect.left,\n        y: event.clientY - rect.top,\n      };\n      return restorePosition(\n        { width: pageWidth, height: pageHeight },\n        displayPoint,\n        rotation,\n        scale,\n      );\n    },\n    [pageWidth, pageHeight, rotation, scale],\n  );\n\n  useEffect(() => {\n    if (!cap || !ref.current) return;\n\n    return createPointerProvider(\n      cap,\n      { type: 'page', pageIndex },\n      ref.current,\n      convertEventToPoint || defaultConvertEventToPoint,\n    );\n  }, [cap, pageIndex, convertEventToPoint, defaultConvertEventToPoint]);\n\n  return (\n    <div\n      ref={ref}\n      style={{\n        ...style,\n      }}\n      {...props}\n    >\n      {children}\n      {isPageExclusive && (\n        <div style={{ position: 'absolute', top: 0, left: 0, right: 0, bottom: 0, zIndex: 10 }} />\n      )}\n    </div>\n  );\n};\n","/** @jsxImportSource preact */\nimport { JSX } from 'preact';\nimport {\n  blendModeToCss,\n  PdfAnnotationSubtype,\n  PdfBlendMode,\n  PdfInkAnnoObject,\n} from '@embedpdf/models';\nimport { PointerEventHandlers } from '@embedpdf/plugin-interaction-manager';\nimport { usePointerHandlers } from '@embedpdf/plugin-interaction-manager/preact';\nimport {\n  getAnnotationsByPageIndex,\n  getSelectedAnnotationByPageIndex,\n  TrackedAnnotation,\n} from '@embedpdf/plugin-annotation';\nimport { useAnnotationCapability } from '../hooks';\nimport { useMemo, useState, useEffect, useCallback } from 'preact/hooks';\nimport { AnnotationContainer } from './annotation-container';\nimport { Highlight } from './text-markup/highlight';\nimport { Underline } from './text-markup/underline';\nimport { Strikeout } from './text-markup/strikeout';\nimport { Squiggly } from './text-markup/squiggly';\nimport { Ink } from './annotations/ink';\nimport { useSelectionCapability } from '@embedpdf/plugin-selection/preact';\nimport { resizeInkAnnotation } from '../../shared/resize-ink';\n\ninterface AnnotationsProps {\n  pageIndex: number;\n  scale: number;\n  rotation: number;\n}\n\nexport function Annotations(annotationsProps: AnnotationsProps) {\n  const { pageIndex, scale } = annotationsProps;\n  const { provides: annotationProvides } = useAnnotationCapability();\n  const { provides: selectionProvides } = useSelectionCapability();\n  const [annotations, setAnnotations] = useState<TrackedAnnotation[]>([]);\n  const { register } = usePointerHandlers({ pageIndex });\n  const [selectionState, setSelectionState] = useState<TrackedAnnotation | null>(null);\n\n  useEffect(() => {\n    if (annotationProvides) {\n      annotationProvides.onStateChange((state) => {\n        setAnnotations(getAnnotationsByPageIndex(state, pageIndex));\n        setSelectionState(getSelectedAnnotationByPageIndex(state, pageIndex));\n      });\n    }\n  }, [annotationProvides]);\n\n  const handlers = useMemo(\n    (): PointerEventHandlers<MouseEvent> => ({\n      onPointerDown: (_, pe) => {\n        // Only deselect if clicking directly on the layer (not on an annotation)\n        if (pe.target === pe.currentTarget && annotationProvides) {\n          annotationProvides.deselectAnnotation();\n        }\n      },\n    }),\n    [annotationProvides],\n  );\n\n  const handleClick = useCallback(\n    (e: MouseEvent, annotation: TrackedAnnotation) => {\n      e.stopPropagation();\n      if (annotationProvides && selectionProvides) {\n        annotationProvides.selectAnnotation(pageIndex, annotation.localId);\n        selectionProvides.clear();\n      }\n    },\n    [annotationProvides, selectionProvides, pageIndex],\n  );\n\n  useEffect(() => {\n    return register(handlers);\n  }, [register, handlers]);\n\n  return (\n    <>\n      {annotations.map((annotation) => {\n        const isSelected = selectionState?.localId === annotation.localId;\n\n        switch (annotation.object.type) {\n          case PdfAnnotationSubtype.UNDERLINE:\n            return (\n              <AnnotationContainer\n                key={annotation.localId}\n                trackedAnnotation={annotation}\n                isSelected={isSelected}\n                isDraggable={false}\n                isResizable={false}\n                style={{\n                  mixBlendMode: blendModeToCss(annotation.object.blendMode ?? PdfBlendMode.Normal),\n                }}\n                {...annotationsProps}\n              >\n                <Underline\n                  rect={annotation.object.rect}\n                  color={annotation.object.color}\n                  opacity={annotation.object.opacity}\n                  rects={annotation.object.segmentRects}\n                  scale={scale}\n                  onClick={(e) => handleClick(e, annotation)}\n                />\n              </AnnotationContainer>\n            );\n          case PdfAnnotationSubtype.STRIKEOUT:\n            return (\n              <AnnotationContainer\n                key={annotation.localId}\n                trackedAnnotation={annotation}\n                isSelected={isSelected}\n                isDraggable={false}\n                isResizable={false}\n                style={{\n                  mixBlendMode: blendModeToCss(annotation.object.blendMode ?? PdfBlendMode.Normal),\n                }}\n                {...annotationsProps}\n              >\n                <Strikeout\n                  rect={annotation.object.rect}\n                  color={annotation.object.color}\n                  opacity={annotation.object.opacity}\n                  rects={annotation.object.segmentRects}\n                  scale={scale}\n                  onClick={(e) => handleClick(e, annotation)}\n                />\n              </AnnotationContainer>\n            );\n          case PdfAnnotationSubtype.SQUIGGLY:\n            return (\n              <AnnotationContainer\n                key={annotation.localId}\n                trackedAnnotation={annotation}\n                isSelected={isSelected}\n                isDraggable={false}\n                isResizable={false}\n                style={{\n                  mixBlendMode: blendModeToCss(annotation.object.blendMode ?? PdfBlendMode.Normal),\n                }}\n                {...annotationsProps}\n              >\n                <Squiggly\n                  color={annotation.object.color}\n                  opacity={annotation.object.opacity}\n                  rects={annotation.object.segmentRects}\n                  rect={annotation.object.rect}\n                  scale={scale}\n                  onClick={(e) => handleClick(e, annotation)}\n                />\n              </AnnotationContainer>\n            );\n          case PdfAnnotationSubtype.HIGHLIGHT:\n            return (\n              <AnnotationContainer\n                key={annotation.localId}\n                trackedAnnotation={annotation}\n                isSelected={isSelected}\n                isDraggable={false}\n                isResizable={false}\n                style={{\n                  mixBlendMode: blendModeToCss(\n                    annotation.object.blendMode ?? PdfBlendMode.Multiply,\n                  ),\n                }}\n                {...annotationsProps}\n              >\n                <Highlight\n                  color={annotation.object.color}\n                  opacity={annotation.object.opacity}\n                  rects={annotation.object.segmentRects}\n                  scale={scale}\n                  rect={annotation.object.rect}\n                  onClick={(e) => handleClick(e, annotation)}\n                />\n              </AnnotationContainer>\n            );\n          case PdfAnnotationSubtype.INK:\n            return (\n              <AnnotationContainer\n                key={annotation.localId}\n                isSelected={isSelected}\n                trackedAnnotation={annotation}\n                outlineOffset={6}\n                computeResizePatch={resizeInkAnnotation}\n                style={{\n                  mixBlendMode: blendModeToCss(annotation.object.blendMode ?? PdfBlendMode.Normal),\n                }}\n                {...annotationsProps}\n              >\n                {(obj: PdfInkAnnoObject) => (\n                  <Ink\n                    color={obj.color}\n                    opacity={obj.opacity}\n                    strokeWidth={obj.strokeWidth}\n                    inkList={obj.inkList}\n                    rect={obj.rect}\n                    scale={scale}\n                    onClick={(e) => handleClick(e, annotation)}\n                  />\n                )}\n              </AnnotationContainer>\n            );\n          default:\n            return null;\n        }\n      })}\n    </>\n  );\n}\n","/** @jsxImportSource preact */\nimport { ComponentChildren, JSX } from 'preact';\nimport { useEffect, useRef, useState } from 'preact/hooks';\nimport { TrackedAnnotation } from '@embedpdf/plugin-annotation';\nimport { PdfAnnotationObject, Rect, restoreOffset, restoreRect } from '@embedpdf/models';\nimport { useAnnotationCapability } from '../hooks';\nimport { ResizeDirection } from '../../shared/types';\n\ntype AnnotationContainerProps = Omit<JSX.HTMLAttributes<HTMLDivElement>, 'style'> & {\n  scale: number;\n  isSelected?: boolean;\n  pageIndex: number;\n  rotation: number;\n  trackedAnnotation: TrackedAnnotation;\n  children: ComponentChildren | ((annotation: PdfAnnotationObject) => ComponentChildren);\n  style?: JSX.CSSProperties;\n  isDraggable?: boolean;\n  isResizable?: boolean;\n  outlineOffset?: number;\n  computeResizePatch?: (\n    original: PdfAnnotationObject,\n    newRect: Rect,\n    direction: ResizeDirection,\n  ) => Partial<PdfAnnotationObject>;\n};\n\ntype Point = { x: number; y: number };\n\nexport function AnnotationContainer({\n  scale,\n  pageIndex,\n  rotation,\n  trackedAnnotation,\n  children,\n  style,\n  outlineOffset = 1,\n  isSelected = false,\n  isDraggable = true,\n  isResizable = true,\n  computeResizePatch,\n  ...props\n}: AnnotationContainerProps) {\n  const { provides: annotationProvides } = useAnnotationCapability();\n  const ref = useRef<HTMLDivElement>(null);\n  const [dragState, setDragState] = useState<'idle' | 'dragging' | 'resizing'>('idle');\n  const [resizeDirection, setResizeDirection] = useState<ResizeDirection | null>(null);\n  const [startPos, setStartPos] = useState<Point | null>(null);\n  const [startRect, setStartRect] = useState<Rect | null>(null);\n  const [currentRect, setCurrentRect] = useState<Rect>(trackedAnnotation.object.rect);\n  const [previewObject, setPreviewObject] = useState<Partial<PdfAnnotationObject> | null>(null);\n\n  useEffect(() => {\n    setCurrentRect(trackedAnnotation.object.rect);\n    setPreviewObject(null);\n  }, [trackedAnnotation]);\n\n  const handlePointerDown = (e: PointerEvent) => {\n    if (!isSelected) return;\n\n    e.stopPropagation();\n    e.preventDefault();\n\n    const target = e.target as HTMLElement;\n\n    if (isResizable && target.classList.contains('resize-handle')) {\n      setDragState('resizing');\n      setResizeDirection(target.dataset.direction as ResizeDirection);\n    } else if (isDraggable) {\n      setDragState('dragging');\n    } else {\n      return;\n    }\n\n    setStartPos({ x: e.clientX, y: e.clientY });\n    setStartRect(currentRect);\n\n    ref.current?.setPointerCapture(e.pointerId);\n  };\n\n  const handlePointerMove = (e: PointerEvent) => {\n    if (dragState === 'idle' || !startPos || !startRect) return;\n\n    const dispDelta = { x: e.clientX - startPos.x, y: e.clientY - startPos.y };\n    const { x: dx, y: dy } = restoreOffset(dispDelta, rotation, scale);\n\n    let newOriginX = startRect.origin.x;\n    let newOriginY = startRect.origin.y;\n    let newWidth = startRect.size.width;\n    let newHeight = startRect.size.height;\n\n    if (dragState === 'dragging') {\n      newOriginX += dx;\n      newOriginY += dy;\n    } else if (dragState === 'resizing' && resizeDirection) {\n      if (resizeDirection.includes('right')) {\n        newWidth += dx;\n      } else if (resizeDirection.includes('left')) {\n        newOriginX += dx;\n        newWidth -= dx;\n      }\n\n      if (resizeDirection.includes('bottom')) {\n        newHeight += dy;\n      } else if (resizeDirection.includes('top')) {\n        newOriginY += dy;\n        newHeight -= dy;\n      }\n\n      // Prevent negative dimensions\n      if (newWidth < 1 || newHeight < 1) return;\n    }\n\n    const tentativeRect = {\n      origin: { x: newOriginX, y: newOriginY },\n      size: { width: newWidth, height: newHeight },\n    };\n\n    let previewPatch: Partial<PdfAnnotationObject> = { rect: tentativeRect };\n\n    if (computeResizePatch) {\n      const dir = dragState === 'resizing' ? resizeDirection : 'bottom-right';\n      if (dir) {\n        previewPatch = computeResizePatch(trackedAnnotation.object, tentativeRect, dir);\n      }\n    }\n\n    setCurrentRect(previewPatch.rect || tentativeRect);\n    setPreviewObject(previewPatch);\n  };\n\n  const handlePointerUp = (e: PointerEvent) => {\n    if (dragState === 'idle') return;\n\n    const usedDirection = resizeDirection || 'bottom-right';\n    setDragState('idle');\n    setResizeDirection(null);\n\n    ref.current?.releasePointerCapture(e.pointerId);\n\n    // Commit the changes\n    if (annotationProvides && trackedAnnotation) {\n      let patch: Partial<PdfAnnotationObject> = { rect: currentRect };\n      if (computeResizePatch && usedDirection) {\n        patch = computeResizePatch(trackedAnnotation.object, currentRect, usedDirection);\n      }\n      annotationProvides.updateAnnotation(pageIndex, trackedAnnotation.localId, patch);\n    }\n\n    setStartPos(null);\n    setStartRect(null);\n    setPreviewObject(null);\n  };\n\n  const currentObject = previewObject\n    ? ({ ...trackedAnnotation.object, ...previewObject } as PdfAnnotationObject)\n    : trackedAnnotation.object;\n\n  return (\n    <div\n      ref={ref}\n      onPointerDown={handlePointerDown}\n      onPointerMove={handlePointerMove}\n      onPointerUp={handlePointerUp}\n      style={{\n        position: 'absolute',\n        outline: isSelected ? '1px solid #007ACC' : 'none',\n        outlineOffset: isSelected ? `${outlineOffset}px` : '0px',\n        left: `${currentRect.origin.x * scale}px`,\n        top: `${currentRect.origin.y * scale}px`,\n        width: `${currentRect.size.width * scale}px`,\n        height: `${currentRect.size.height * scale}px`,\n        pointerEvents: isSelected ? 'auto' : 'none',\n        cursor: isSelected && isDraggable ? 'move' : 'default',\n        ...style,\n      }}\n      {...props}\n    >\n      {typeof children === 'function' ? children(currentObject) : children}\n      {isSelected && isResizable && (\n        <>\n          <div\n            className=\"resize-handle\"\n            data-direction=\"top-left\"\n            style={{\n              position: 'absolute',\n              top: -7 - outlineOffset,\n              left: -7 - outlineOffset,\n              width: 13,\n              height: 13,\n              background: 'blue',\n              borderRadius: '50%',\n              cursor: rotation % 2 ? 'nesw-resize' : 'nwse-resize',\n            }}\n          />\n          <div\n            className=\"resize-handle\"\n            data-direction=\"top-right\"\n            style={{\n              position: 'absolute',\n              top: -7 - outlineOffset,\n              right: -7 - outlineOffset,\n              width: 13,\n              height: 13,\n              background: 'blue',\n              borderRadius: '50%',\n              cursor: rotation % 2 ? 'nwse-resize' : 'nesw-resize',\n            }}\n          />\n          <div\n            className=\"resize-handle\"\n            data-direction=\"bottom-left\"\n            style={{\n              position: 'absolute',\n              bottom: -7 - outlineOffset,\n              left: -7 - outlineOffset,\n              width: 13,\n              height: 13,\n              background: 'blue',\n              borderRadius: '50%',\n              cursor: rotation % 2 ? 'nwse-resize' : 'nesw-resize',\n            }}\n          />\n          <div\n            className=\"resize-handle\"\n            data-direction=\"bottom-right\"\n            style={{\n              position: 'absolute',\n              bottom: -7 - outlineOffset,\n              right: -7 - outlineOffset,\n              width: 13,\n              height: 13,\n              background: 'blue',\n              borderRadius: '50%',\n              cursor: rotation % 2 ? 'nesw-resize' : 'nwse-resize',\n            }}\n          />\n        </>\n      )}\n    </div>\n  );\n}\n","/** @jsxImportSource preact */\nimport { JSX } from 'preact';\nimport { Rect } from '@embedpdf/models';\n\ntype HighlightProps = Omit<JSX.HTMLAttributes<HTMLDivElement>, 'style'> & {\n  color?: string;\n  opacity?: number;\n  rects: Rect[];\n  rect?: Rect;\n  scale: number;\n  onClick?: (e: MouseEvent) => void;\n  style?: JSX.CSSProperties;\n};\n\nexport function Highlight({\n  color = '#FFFF00',\n  opacity = 0.5,\n  rects,\n  rect,\n  scale,\n  onClick,\n  style,\n  ...props\n}: HighlightProps) {\n  return (\n    <>\n      {rects.map((b, i) => (\n        <div\n          key={i}\n          onMouseDown={onClick}\n          style={{\n            position: 'absolute',\n            left: (rect ? b.origin.x - rect.origin.x : b.origin.x) * scale,\n            top: (rect ? b.origin.y - rect.origin.y : b.origin.y) * scale,\n            width: b.size.width * scale,\n            height: b.size.height * scale,\n            background: color,\n            opacity: opacity,\n            pointerEvents: onClick ? 'auto' : 'none',\n            cursor: onClick ? 'pointer' : 'default',\n            zIndex: onClick ? 1 : null,\n            ...style,\n          }}\n          {...props}\n        />\n      ))}\n    </>\n  );\n}\n","/** @jsxImportSource preact */\nimport { JSX } from 'preact';\nimport { Rect } from '@embedpdf/models';\n\ntype UnderlineProps = Omit<JSX.HTMLAttributes<HTMLDivElement>, 'style'> & {\n  color?: string;\n  opacity?: number;\n  rects: Rect[];\n  rect?: Rect;\n  scale: number;\n  onClick?: (e: MouseEvent) => void;\n  style?: JSX.CSSProperties;\n};\n\nexport function Underline({\n  color = '#FFFF00',\n  opacity = 0.5,\n  rects,\n  rect,\n  scale,\n  onClick,\n  style,\n  ...props\n}: UnderlineProps) {\n  const thickness = 2 * scale; // 2 CSS px at 100 % zoom\n\n  return (\n    <>\n      {rects.map((r, i) => (\n        <div\n          key={i}\n          onMouseDown={onClick}\n          style={{\n            position: 'absolute',\n            left: (rect ? r.origin.x - rect.origin.x : r.origin.x) * scale,\n            top: (rect ? r.origin.y - rect.origin.y : r.origin.y) * scale,\n            width: r.size.width * scale,\n            height: r.size.height * scale,\n            background: 'transparent',\n            pointerEvents: onClick ? 'auto' : 'none',\n            cursor: onClick ? 'pointer' : 'default',\n            zIndex: onClick ? 1 : 0,\n            ...style,\n          }}\n          {...props}\n        >\n          {/* Visual underline */}\n          <div\n            style={{\n              position: 'absolute',\n              left: 0,\n              bottom: 0,\n              width: '100%',\n              height: thickness,\n              background: color,\n              opacity: opacity,\n              pointerEvents: 'none',\n            }}\n          />\n        </div>\n      ))}\n    </>\n  );\n}\n","/** @jsxImportSource preact */\nimport { JSX } from 'preact';\nimport { Rect } from '@embedpdf/models';\n\ntype StrikeoutProps = Omit<JSX.HTMLAttributes<HTMLDivElement>, 'style'> & {\n  color?: string;\n  opacity?: number;\n  rects: Rect[];\n  rect?: Rect;\n  scale: number;\n  onClick?: (e: MouseEvent) => void;\n  style?: JSX.CSSProperties;\n};\n\nexport function Strikeout({\n  color = '#FFFF00',\n  opacity = 0.5,\n  rects,\n  rect,\n  scale,\n  onClick,\n  style,\n  ...props\n}: StrikeoutProps) {\n  const thickness = 2 * scale;\n\n  return (\n    <>\n      {rects.map((r, i) => (\n        <div\n          key={i}\n          onMouseDown={onClick}\n          style={{\n            position: 'absolute',\n            left: (rect ? r.origin.x - rect.origin.x : r.origin.x) * scale,\n            top: (rect ? r.origin.y - rect.origin.y : r.origin.y) * scale,\n            width: r.size.width * scale,\n            height: r.size.height * scale,\n            background: 'transparent',\n            pointerEvents: onClick ? 'auto' : 'none',\n            cursor: onClick ? 'pointer' : 'default',\n            zIndex: onClick ? 1 : 0,\n            ...style,\n          }}\n          {...props}\n        >\n          {/* Visual strikeout line */}\n          <div\n            style={{\n              position: 'absolute',\n              left: 0,\n              top: '50%',\n              width: '100%',\n              height: thickness,\n              background: color,\n              opacity: opacity,\n              transform: 'translateY(-50%)',\n              pointerEvents: 'none',\n            }}\n          />\n        </div>\n      ))}\n    </>\n  );\n}\n","/** @jsxImportSource preact */\nimport { JSX } from 'preact';\nimport { Rect } from '@embedpdf/models';\n\ntype SquigglyProps = Omit<JSX.HTMLAttributes<HTMLDivElement>, 'style'> & {\n  color?: string;\n  opacity?: number;\n  rects: Rect[];\n  rect?: Rect;\n  scale: number;\n  onClick?: (e: MouseEvent) => void;\n  style?: JSX.CSSProperties;\n};\n\nexport function Squiggly({\n  color = '#FFFF00',\n  opacity = 0.5,\n  rects,\n  rect,\n  scale,\n  onClick,\n  style,\n  ...props\n}: SquigglyProps) {\n  const amplitude = 2 * scale; // wave height\n  const period = 6 * scale; // wave length\n\n  const svg = `<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"${period}\" height=\"${amplitude * 2}\" viewBox=\"0 0 ${period} ${amplitude * 2}\">\n      <path d=\"M0 ${amplitude} Q ${period / 4} 0 ${period / 2} ${amplitude} T ${period} ${amplitude}\"\n            fill=\"none\" stroke=\"${color}\" stroke-width=\"${amplitude}\" stroke-linecap=\"round\"/>\n    </svg>`;\n\n  // Completely escape the SVG markup\n  const svgDataUri = `url(\"data:image/svg+xml;utf8,${encodeURIComponent(svg)}\")`;\n\n  return (\n    <>\n      {rects.map((r, i) => (\n        <div\n          key={i}\n          onMouseDown={onClick}\n          style={{\n            position: 'absolute',\n            left: (rect ? r.origin.x - rect.origin.x : r.origin.x) * scale,\n            top: (rect ? r.origin.y - rect.origin.y : r.origin.y) * scale,\n            width: r.size.width * scale,\n            height: r.size.height * scale,\n            background: 'transparent',\n            pointerEvents: onClick ? 'auto' : 'none',\n            cursor: onClick ? 'pointer' : 'default',\n            zIndex: onClick ? 1 : 0,\n            ...style,\n          }}\n          {...props}\n        >\n          {/* Visual squiggly line */}\n          <div\n            style={{\n              position: 'absolute',\n              left: 0,\n              bottom: 0,\n              width: '100%',\n              height: amplitude * 2,\n              backgroundImage: svgDataUri,\n              backgroundRepeat: 'repeat-x',\n              backgroundSize: `${period}px ${amplitude * 2}px`,\n              opacity: opacity,\n              pointerEvents: 'none',\n            }}\n          />\n        </div>\n      ))}\n    </>\n  );\n}\n","/** @jsxImportSource preact */\nimport { JSX } from 'preact';\nimport { useMemo } from 'preact/hooks';\nimport { PdfInkListObject, Rect } from '@embedpdf/models';\n\n/* ---------------------------------------------------------------- *\\\n|* Types                                                            *|\n\\* ---------------------------------------------------------------- */\n\ninterface InkProps {\n  /** Stroke colour (falls back to PDFium default black) */\n  color?: string;\n  /** 0 – 1 */\n  opacity?: number;\n  /** Line width in PDF units */\n  strokeWidth: number;\n  /** Array of strokes — exactly as in your JSON */\n  inkList: PdfInkListObject[];\n  /** Bounding box of the whole annotation */\n  rect: Rect;\n  /** Page zoom factor */\n  scale: number;\n  /** Callback for when the annotation is clicked */\n  onClick?: (e: MouseEvent) => void;\n}\n\n/**\n * Renders a PDF Ink annotation (free-hand drawing) as SVG.\n */\nexport function Ink({\n  color = '#000000',\n  opacity = 1,\n  strokeWidth,\n  inkList,\n  rect,\n  scale,\n  onClick,\n}: InkProps) {\n  /* convert each stroke to an SVG <path d=\"\"> string */\n  const paths = useMemo(() => {\n    return inkList.map(({ points }) => {\n      let d = '';\n      points.forEach(({ x, y }, i) => {\n        // localise to the annotation’s own bbox so viewBox can stay tidy\n        const lx = x - rect.origin.x;\n        const ly = y - rect.origin.y;\n        d += (i === 0 ? 'M' : 'L') + lx + ' ' + ly + ' ';\n      });\n      return d.trim();\n    });\n  }, [inkList, rect]);\n\n  /* absolute placement + scaling just like your text-markup components */\n  const width = rect.size.width * scale;\n  const height = rect.size.height * scale;\n\n  return (\n    <svg\n      style={{\n        position: 'absolute',\n        width,\n        height,\n        pointerEvents: 'none',\n        zIndex: 2,\n      }}\n      width={width}\n      height={height}\n      viewBox={`0 0 ${rect.size.width} ${rect.size.height}`}\n    >\n      {paths.map((d, i) => (\n        <path\n          key={i}\n          d={d}\n          fill=\"none\"\n          stroke={color}\n          strokeWidth={strokeWidth}\n          strokeLinecap=\"round\"\n          strokeLinejoin=\"round\"\n          opacity={opacity}\n          pointerEvents=\"visibleStroke\"\n          onMouseDown={onClick}\n          style={{\n            cursor: 'pointer',\n          }}\n        />\n      ))}\n    </svg>\n  );\n}\n","class b {\n  constructor() {\n    this.dependencyGraph = /* @__PURE__ */ new Map();\n  }\n  addNode(e, t = []) {\n    this.dependencyGraph.set(e, new Set(t));\n  }\n  hasCircularDependencies() {\n    const e = /* @__PURE__ */ new Set(), t = /* @__PURE__ */ new Set(), r = (s) => {\n      e.add(s), t.add(s);\n      const n = this.dependencyGraph.get(s) || /* @__PURE__ */ new Set();\n      for (const a of n)\n        if (e.has(a)) {\n          if (t.has(a))\n            return !0;\n        } else if (r(a)) return !0;\n      return t.delete(s), !1;\n    };\n    for (const s of this.dependencyGraph.keys())\n      if (!e.has(s) && r(s))\n        return !0;\n    return !1;\n  }\n  resolveLoadOrder() {\n    if (this.hasCircularDependencies())\n      throw new Error(\"Circular dependencies detected\");\n    const e = [], t = /* @__PURE__ */ new Set(), r = /* @__PURE__ */ new Set(), s = (n) => {\n      if (r.has(n)) throw new Error(\"Circular dependency\");\n      if (t.has(n)) return;\n      r.add(n);\n      const a = this.dependencyGraph.get(n) || /* @__PURE__ */ new Set();\n      for (const o of a)\n        s(o);\n      r.delete(n), t.add(n), e.push(n);\n    };\n    for (const n of this.dependencyGraph.keys())\n      t.has(n) || s(n);\n    return e;\n  }\n}\nclass l extends Error {\n  constructor(e) {\n    super(e), this.name = \"PluginRegistrationError\";\n  }\n}\nclass u extends Error {\n  constructor(e) {\n    super(e), this.name = \"PluginNotFoundError\";\n  }\n}\nclass m extends Error {\n  constructor(e) {\n    super(e), this.name = \"CircularDependencyError\";\n  }\n}\nclass K extends Error {\n  constructor(e) {\n    super(e), this.name = \"CapabilityNotFoundError\";\n  }\n}\nclass H extends Error {\n  constructor(e) {\n    super(e), this.name = \"CapabilityConflictError\";\n  }\n}\nclass W extends Error {\n  constructor(e) {\n    super(e), this.name = \"PluginInitializationError\";\n  }\n}\nclass R extends Error {\n  constructor(e) {\n    super(e), this.name = \"PluginConfigurationError\";\n  }\n}\nclass D {\n  /**\n   * Initializes the PluginStore with the main store and plugin ID.\n   * @param store The main store instance.\n   * @param pluginId The unique identifier for the plugin.\n   */\n  constructor(e, t) {\n    this.store = e, this.pluginId = t;\n  }\n  /**\n   * Gets the current state of the plugin.\n   * @returns The plugin's state.\n   */\n  getState() {\n    return this.store.getState().plugins[this.pluginId];\n  }\n  /**\n   * Dispatches an action for the plugin and returns the *new* global state.\n   * If you only need the plugin’s updated state, call `getState()` afterward.\n   * @param action The action to dispatch.\n   * @returns The updated global store state (after plugin reducer).\n   */\n  dispatch(e) {\n    return this.store.dispatchToPlugin(this.pluginId, e);\n  }\n  /**\n   * Subscribes to state changes only for this specific plugin.\n   * You now receive (action, newPluginState, oldPluginState) in the callback.\n   *\n   * @param listener The callback to invoke when plugin state changes.\n   * @returns A function to unsubscribe the listener.\n   */\n  subscribeToState(e) {\n    return this.store.subscribeToPlugin(this.pluginId, (t, r, s) => {\n      e(\n        t,\n        r,\n        s\n      );\n    });\n  }\n  /**\n   * Subscribes to a specific action type for the plugin.\n   * This still uses the main store's `onAction`, so you get the *global*\n   * old/new store states there. If you specifically want old/new plugin state,\n   * use `subscribeToState` instead.\n   *\n   * @param type The action type to listen for.\n   * @param handler The callback to invoke when the action occurs.\n   * @returns A function to unsubscribe the handler.\n   */\n  onAction(e, t) {\n    return this.store.onAction(e, (r, s, n) => {\n      t(\n        r,\n        s.plugins[this.pluginId],\n        n.plugins[this.pluginId]\n      );\n    });\n  }\n}\nconst g = \"LOAD_DOCUMENT\", f = \"SET_DOCUMENT\", p = \"SET_DOCUMENT_ERROR\", y = \"SET_SCALE\", w = \"SET_ROTATION\", E = \"SET_PAGES\", O = [\n  g,\n  f,\n  p,\n  y,\n  w,\n  E\n], Z = () => ({ type: g }), I = (i) => ({\n  type: f,\n  payload: i\n}), V = (i) => ({\n  type: p,\n  payload: i\n}), J = (i) => ({ type: y, payload: i }), Y = (i) => ({\n  type: w,\n  payload: i\n}), Q = (i) => ({\n  type: E,\n  payload: i\n});\nclass A {\n  /**\n   * Initializes the store with the provided core state.\n   * @param reducer          The core reducer function\n   * @param initialCoreState The initial core state\n   */\n  constructor(e, t) {\n    this.initialCoreState = t, this.pluginReducers = {}, this.listeners = [], this.pluginListeners = {}, this.state = { core: t, plugins: {} }, this.coreReducer = e;\n  }\n  /**\n   * Adds a reducer for a plugin-specific state.\n   * @param pluginId The unique identifier for the plugin.\n   * @param reducer The reducer function for the plugin state.\n   * @param initialState The initial state for the plugin.\n   */\n  addPluginReducer(e, t, r) {\n    this.state.plugins[e] = r, this.pluginReducers[e] = t;\n  }\n  /**\n   * Dispatches an action *only* to the core reducer.\n   * Notifies the global store listeners with (action, newState, oldState).\n   *\n   * @param action The action to dispatch, typed as CoreAction\n   * @returns The updated *global* store state\n   */\n  dispatchToCore(e) {\n    if (!this.coreReducer)\n      return this.getState();\n    const t = this.getState();\n    this.state.core = this.coreReducer(this.state.core, e);\n    const r = this.getState();\n    return this.listeners.forEach((s) => s(e, r, t)), r;\n  }\n  /**\n   * Dispatches an action *only* to a specific plugin.\n   * Optionally notifies global store listeners if `notifyGlobal` is true.\n   * Always notifies plugin-specific listeners with (action, newPluginState, oldPluginState).\n   *\n   * @param pluginId   The plugin identifier\n   * @param action     The plugin action to dispatch\n   * @param notifyGlobal Whether to also notify global store listeners\n   * @returns The updated *global* store state\n   */\n  dispatchToPlugin(e, t, r = !0) {\n    const s = this.getState(), n = this.pluginReducers[e];\n    if (!n)\n      return s;\n    const a = s.plugins[e], o = n(a, t);\n    this.state.plugins[e] = o;\n    const c = this.getState();\n    return r && this.listeners.forEach((h) => h(t, c, s)), this.pluginListeners[e] && this.pluginListeners[e].forEach((h) => {\n      h(t, o, a);\n    }), o;\n  }\n  /**\n   * Dispatches an action to update the state using:\n   * - the core reducer (if it's a CoreAction)\n   * - *all* plugin reducers (regardless of action type), with no global notify for each plugin\n   *\n   * Returns the new *global* store state after all reducers have processed the action.\n   *\n   * @param action The action to dispatch (can be CoreAction or any Action).\n   */\n  dispatch(e) {\n    const t = this.getState();\n    this.isCoreAction(e) && (this.state.core = this.coreReducer(this.state.core, e));\n    for (const s in this.pluginReducers) {\n      const n = this.pluginReducers[s], a = t.plugins[s];\n      n && (this.state.plugins[s] = n(a, e));\n    }\n    const r = this.getState();\n    return this.listeners.forEach((s) => s(e, r, t)), r;\n  }\n  /**\n   * Returns a shallow copy of the current state.\n   * @returns The current store state.\n   */\n  getState() {\n    return {\n      core: { ...this.state.core },\n      plugins: { ...this.state.plugins }\n    };\n  }\n  /**\n   * Subscribes a listener to *global* state changes.\n   * The callback signature is now (action, newState, oldState).\n   *\n   * @param listener The callback to invoke on state changes\n   * @returns A function to unsubscribe the listener\n   */\n  subscribe(e) {\n    return this.listeners.push(e), () => {\n      this.listeners = this.listeners.filter((t) => t !== e);\n    };\n  }\n  /**\n   * Subscribes a listener to *plugin-specific* state changes.\n   * The callback signature is now (action, newPluginState, oldPluginState).\n   *\n   * @param pluginId The unique identifier for the plugin.\n   * @param listener The callback to invoke on plugin state changes.\n   * @returns A function to unsubscribe the listener.\n   */\n  subscribeToPlugin(e, t) {\n    if (!(e in this.state.plugins))\n      throw new Error(\n        `Plugin state not found for plugin \"${e}\". Did you forget to call addPluginReducer?`\n      );\n    return this.pluginListeners[e] || (this.pluginListeners[e] = []), this.pluginListeners[e].push(t), () => {\n      this.pluginListeners[e] = this.pluginListeners[e].filter((r) => r !== t), this.pluginListeners[e].length === 0 && delete this.pluginListeners[e];\n    };\n  }\n  /**\n   * Subscribes to a specific action type (only from the core's action union).\n   * The callback signature is (action, newState, oldState).\n   *\n   * @param type The action type to listen for.\n   * @param handler The callback to invoke when the action occurs.\n   * @returns A function to unsubscribe the handler.\n   */\n  onAction(e, t) {\n    return this.subscribe((r, s, n) => {\n      r.type === e && t(r, s, n);\n    });\n  }\n  /**\n   * Gets a PluginStore handle for a specific plugin.\n   * @param pluginId The unique identifier for the plugin.\n   * @returns A PluginStore instance for the plugin.\n   */\n  getPluginStore(e) {\n    if (!(e in this.state.plugins))\n      throw new Error(\n        `Plugin state not found for plugin \"${e}\". Did you forget to call addPluginReducer?`\n      );\n    return new D(this, e);\n  }\n  /**\n   * Helper method to check if an action is a CoreAction.\n   * Adjust if you have a more refined way to differentiate CoreAction vs. any other Action.\n   */\n  isCoreAction(e) {\n    return O.includes(e.type);\n  }\n  /**\n   * Destroy the store: drop every listener and plugin reducer\n   */\n  destroy() {\n    var e, t;\n    this.listeners.length = 0;\n    for (const r in this.pluginListeners)\n      (t = (e = this.pluginListeners[r]) == null ? void 0 : e.splice) == null || t.call(e, 0);\n    this.pluginListeners = {}, this.pluginReducers = {}, this.state.plugins = {}, this.state.core = { ...this.initialCoreState };\n  }\n}\nvar C = /* @__PURE__ */ ((i) => (i[i.Degree0 = 0] = \"Degree0\", i[i.Degree90 = 1] = \"Degree90\", i[i.Degree180 = 2] = \"Degree180\", i[i.Degree270 = 3] = \"Degree270\", i))(C || {});\nfunction T(i) {\n  const { width: e, height: t } = i;\n  return {\n    width: t,\n    height: e\n  };\n}\nfunction X(i, e, t) {\n  return i = e % 2 === 0 ? i : T(i), {\n    width: i.width * t,\n    height: i.height * t\n  };\n}\nvar z = \"­\", M = \"​\", L = \"⁠\", $ = \"\\uFEFF\", F = \"￾\", N = \"￿\", k = Object.freeze([\n  z,\n  M,\n  L,\n  $,\n  F,\n  N\n]);\nnew RegExp(`[${k.join(\"\")}]`, \"g\");\nvar P = Object.freeze([\n  { id: 0, label: \"Normal\", css: \"normal\" },\n  { id: 1, label: \"Multiply\", css: \"multiply\" },\n  { id: 2, label: \"Screen\", css: \"screen\" },\n  { id: 3, label: \"Overlay\", css: \"overlay\" },\n  { id: 4, label: \"Darken\", css: \"darken\" },\n  { id: 5, label: \"Lighten\", css: \"lighten\" },\n  { id: 6, label: \"Color Dodge\", css: \"color-dodge\" },\n  { id: 7, label: \"Color Burn\", css: \"color-burn\" },\n  { id: 8, label: \"Hard Light\", css: \"hard-light\" },\n  { id: 9, label: \"Soft Light\", css: \"soft-light\" },\n  { id: 10, label: \"Difference\", css: \"difference\" },\n  { id: 11, label: \"Exclusion\", css: \"exclusion\" },\n  { id: 12, label: \"Hue\", css: \"hue\" },\n  { id: 13, label: \"Saturation\", css: \"saturation\" },\n  { id: 14, label: \"Color\", css: \"color\" },\n  { id: 15, label: \"Luminosity\", css: \"luminosity\" }\n]);\nP.reduce(\n  (i, e) => (i[e.id] = e, i),\n  {}\n);\nP.reduce((i, e) => (i[e.css] = e.id, i), {});\nP.map((i) => ({\n  value: i.id,\n  label: i.label\n}));\nvar _ = Object.freeze({\n  1: \"invisible\",\n  2: \"hidden\",\n  4: \"print\",\n  8: \"noZoom\",\n  16: \"noRotate\",\n  32: \"noView\",\n  64: \"readOnly\",\n  128: \"locked\",\n  256: \"toggleNoView\"\n});\nObject.entries(\n  _\n).reduce(\n  (i, [e, t]) => (i[t] = Number(e), i),\n  {}\n);\nconst j = (i) => ({\n  scale: (i == null ? void 0 : i.scale) ?? 1,\n  rotation: (i == null ? void 0 : i.rotation) ?? C.Degree0,\n  document: null,\n  pages: [],\n  loading: !1,\n  error: null\n}), q = (i, e) => {\n  switch (e.type) {\n    case g:\n      return {\n        ...i,\n        loading: !0,\n        error: null\n      };\n    case f:\n      return {\n        ...i,\n        document: e.payload,\n        pages: e.payload.pages.map((t) => [t]),\n        loading: !1,\n        error: null\n      };\n    case w:\n      return {\n        ...i,\n        rotation: e.payload\n      };\n    case E:\n      return {\n        ...i,\n        pages: e.payload\n      };\n    case p:\n      return {\n        ...i,\n        loading: !1,\n        error: e.payload\n      };\n    case y:\n      return {\n        ...i,\n        scale: e.payload\n      };\n    default:\n      return i;\n  }\n};\nclass ee {\n  constructor(e, t) {\n    this.plugins = /* @__PURE__ */ new Map(), this.manifests = /* @__PURE__ */ new Map(), this.capabilities = /* @__PURE__ */ new Map(), this.status = /* @__PURE__ */ new Map(), this.configurations = /* @__PURE__ */ new Map(), this.engineInitialized = !1, this.initPromise = null, this.pendingRegistrations = [], this.processingRegistrations = [], this.initialized = !1, this.isInitializing = !1, this.pluginsReadyPromise = null, this.destroyed = !1, this.resolver = new b(), this.engine = e, this.initialCoreState = j(t), this.store = new A(q, this.initialCoreState);\n  }\n  /**\n   * Ensure engine is initialized before proceeding\n   */\n  async ensureEngineInitialized() {\n    this.engineInitialized || (this.engine.initialize ? (await this.engine.initialize().toPromise(), this.engineInitialized = !0) : this.engineInitialized = !0);\n  }\n  /**\n   * Register a plugin without initializing it\n   */\n  registerPlugin(e, t) {\n    if (this.initialized && !this.isInitializing)\n      throw new l(\"Cannot register plugins after initialization\");\n    this.validateManifest(e.manifest), this.store.addPluginReducer(\n      e.manifest.id,\n      // We need one type assertion here since we can't fully reconcile TAction with Action\n      // due to TypeScript's type system limitations with generic variance\n      e.reducer,\n      typeof e.initialState == \"function\" ? e.initialState(\n        this.initialCoreState,\n        {\n          ...e.manifest.defaultConfig,\n          ...t\n        }\n      ) : e.initialState\n    ), this.pendingRegistrations.push({\n      package: e,\n      config: t\n    });\n  }\n  /**\n   * Get the central store instance\n   */\n  getStore() {\n    return this.store;\n  }\n  /**\n   * Get the engine instance\n   */\n  getEngine() {\n    return this.engine;\n  }\n  /**\n   * Get a promise that resolves when all plugins are ready\n   */\n  pluginsReady() {\n    return this.pluginsReadyPromise ? this.pluginsReadyPromise : (this.pluginsReadyPromise = (async () => {\n      this.initialized || await this.initialize();\n      const e = Array.from(this.plugins.values()).map(\n        (t) => typeof t.ready == \"function\" ? t.ready() : Promise.resolve()\n      );\n      await Promise.all(e);\n    })(), this.pluginsReadyPromise);\n  }\n  /**\n   * INITIALISE THE REGISTRY – runs once no-matter-how-many calls   *\n   */\n  async initialize() {\n    if (this.destroyed)\n      throw new l(\"Registry has been destroyed\");\n    return this.initPromise ? this.initPromise : (this.initPromise = (async () => {\n      var e;\n      if (this.initialized)\n        throw new l(\"Registry is already initialized\");\n      this.isInitializing = !0;\n      try {\n        if (await this.ensureEngineInitialized(), this.destroyed)\n          return;\n        for (; this.pendingRegistrations.length > 0; ) {\n          if (this.destroyed)\n            return;\n          this.processingRegistrations = [...this.pendingRegistrations], this.pendingRegistrations = [];\n          for (const r of this.processingRegistrations) {\n            const s = /* @__PURE__ */ new Set(), n = [...r.package.manifest.requires, ...r.package.manifest.optional];\n            for (const a of n) {\n              const o = this.processingRegistrations.find(\n                (c) => c.package.manifest.provides.includes(a)\n              );\n              o && s.add(o.package.manifest.id);\n            }\n            this.resolver.addNode(r.package.manifest.id, [...s]);\n          }\n          const t = this.resolver.resolveLoadOrder();\n          for (const r of t) {\n            const s = this.processingRegistrations.find((n) => n.package.manifest.id === r);\n            await this.initializePlugin(s.package.manifest, s.package.create, s.config);\n          }\n          this.processingRegistrations = [], this.resolver = new b();\n        }\n        for (const t of this.plugins.values())\n          await ((e = t.postInitialize) == null ? void 0 : e.call(t).catch((r) => {\n            console.error(`Error in postInitialize for plugin ${t.id}`, r), this.status.set(t.id, \"error\");\n          }));\n        this.initialized = !0;\n      } catch (t) {\n        throw t instanceof Error ? new m(\n          `Failed to resolve plugin dependencies: ${t.message}`\n        ) : t;\n      } finally {\n        this.isInitializing = !1;\n      }\n    })(), this.initPromise);\n  }\n  /**\n   * Initialize a single plugin with all necessary checks\n   */\n  async initializePlugin(e, t, r) {\n    const s = {\n      ...e.defaultConfig,\n      ...r\n    };\n    this.validateConfig(e.id, s, e.defaultConfig);\n    const n = t(this, this.engine, s);\n    this.validatePlugin(n);\n    for (const a of e.requires)\n      if (!this.capabilities.has(a))\n        throw new l(\n          `Missing required capability: ${a} for plugin ${e.id}`\n        );\n    for (const a of e.optional)\n      this.capabilities.has(a) && console.debug(`Optional capability ${a} is available for plugin ${e.id}`);\n    console.log(\"initializePlugin\", e.id, e.provides);\n    for (const a of e.provides) {\n      if (this.capabilities.has(a))\n        throw new l(\n          `Capability ${a} is already provided by plugin ${this.capabilities.get(a)}`\n        );\n      this.capabilities.set(a, e.id);\n    }\n    this.plugins.set(e.id, n), this.manifests.set(e.id, e), this.status.set(e.id, \"registered\"), this.configurations.set(e.id, s);\n    try {\n      n.initialize && await n.initialize(s), this.status.set(e.id, \"active\");\n    } catch (a) {\n      throw this.plugins.delete(e.id), this.manifests.delete(e.id), console.log(\"initializePlugin failed\", e.id, e.provides), e.provides.forEach((o) => this.capabilities.delete(o)), a;\n    }\n  }\n  getPluginConfig(e) {\n    const t = this.configurations.get(e);\n    if (!t)\n      throw new u(`Configuration for plugin ${e} not found`);\n    return t;\n  }\n  validateConfig(e, t, r) {\n    const n = Object.keys(r).filter((a) => !t.hasOwnProperty(a));\n    if (n.length > 0)\n      throw new R(\n        `Missing required configuration keys for plugin ${e}: ${n.join(\", \")}`\n      );\n  }\n  async updatePluginConfig(e, t) {\n    const r = this.getPlugin(e);\n    if (!r)\n      throw new u(`Plugin ${e} not found`);\n    const s = this.manifests.get(e), n = this.configurations.get(e);\n    if (!s || !n)\n      throw new u(`Plugin ${e} not found`);\n    const a = {\n      ...n,\n      ...t\n    };\n    this.validateConfig(e, a, s.defaultConfig), this.configurations.set(e, a), r.initialize && await r.initialize(a);\n  }\n  /**\n   * Register multiple plugins at once\n   */\n  registerPluginBatch(e) {\n    for (const t of e)\n      this.registerPlugin(t.package, t.config);\n  }\n  /**\n   * Unregister a plugin\n   */\n  async unregisterPlugin(e) {\n    const t = this.plugins.get(e);\n    if (!t)\n      throw new u(`Plugin ${e} is not registered`);\n    const r = this.manifests.get(e);\n    if (!r)\n      throw new u(`Manifest for plugin ${e} not found`);\n    for (const [s, n] of this.manifests.entries()) {\n      if (s === e) continue;\n      if ([...n.requires, ...n.optional].some(\n        (o) => r.provides.includes(o)\n      ))\n        throw new l(\n          `Cannot unregister plugin ${e}: plugin ${s} depends on it`\n        );\n    }\n    try {\n      t.destroy && await t.destroy();\n      for (const s of r.provides)\n        this.capabilities.delete(s);\n      this.plugins.delete(e), this.manifests.delete(e), this.status.delete(e);\n    } catch (s) {\n      throw s instanceof Error ? new Error(`Failed to unregister plugin ${e}: ${s.message}`) : s;\n    }\n  }\n  /**\n   * Get a plugin instance\n   * @param pluginId The ID of the plugin to get\n   * @returns The plugin instance or null if not found\n   */\n  getPlugin(e) {\n    const t = this.plugins.get(e);\n    return t || null;\n  }\n  /**\n   * Get a plugin that provides a specific capability\n   * @param capability The capability to get a provider for\n   * @returns The plugin providing the capability or null if not found\n   */\n  getCapabilityProvider(e) {\n    const t = this.capabilities.get(e);\n    return t ? this.getPlugin(t) : null;\n  }\n  /**\n   * Check if a capability is available\n   */\n  hasCapability(e) {\n    return this.capabilities.has(e);\n  }\n  /**\n   * Get all registered plugins\n   */\n  getAllPlugins() {\n    return Array.from(this.plugins.values());\n  }\n  /**\n   * Get plugin status\n   */\n  getPluginStatus(e) {\n    const t = this.status.get(e);\n    if (!t)\n      throw new u(`Plugin ${e} not found`);\n    return t;\n  }\n  /**\n   * Validate plugin object\n   */\n  validatePlugin(e) {\n    if (!e.id)\n      throw new l(\"Plugin must have an id\");\n  }\n  /**\n   * Validate plugin manifest\n   */\n  validateManifest(e) {\n    if (!e.id)\n      throw new l(\"Manifest must have an id\");\n    if (!e.name)\n      throw new l(\"Manifest must have a name\");\n    if (!e.version)\n      throw new l(\"Manifest must have a version\");\n    if (!Array.isArray(e.provides))\n      throw new l(\"Manifest must have a provides array\");\n    if (!Array.isArray(e.requires))\n      throw new l(\"Manifest must have a requires array\");\n    if (!Array.isArray(e.optional))\n      throw new l(\"Manifest must have an optional array\");\n  }\n  isDestroyed() {\n    return this.destroyed;\n  }\n  /**\n   * DESTROY EVERYTHING – waits for any ongoing initialise(), once  *\n   */\n  async destroy() {\n    var e;\n    if (this.destroyed) throw new l(\"Registry has already been destroyed\");\n    this.destroyed = !0;\n    try {\n      await this.initPromise;\n    } catch {\n    }\n    for (const t of Array.from(this.plugins.values()).reverse())\n      await ((e = t.destroy) == null ? void 0 : e.call(t));\n    this.store.destroy(), this.plugins.clear(), this.manifests.clear(), this.capabilities.clear(), this.status.clear(), this.pendingRegistrations.length = 0, this.processingRegistrations.length = 0;\n  }\n}\nfunction te(i, e, t) {\n  return i < e ? e : i > t ? t : i;\n}\nfunction v(i, e, t) {\n  if (i === e)\n    return !0;\n  if (i == null || e == null)\n    return i === e;\n  const r = typeof i;\n  if (r !== typeof e) return !1;\n  if (r === \"object\") {\n    t || (t = /* @__PURE__ */ new Set());\n    const n = x(i, e);\n    if (t.has(n))\n      return !0;\n    t.add(n);\n    const a = Array.isArray(i), o = Array.isArray(e);\n    return a && o ? U(i, e, t) : !a && !o ? B(i, e, t) : !1;\n  }\n  return !1;\n}\nfunction x(i, e) {\n  return `${S(i)}__${S(e)}`;\n}\nlet G = 0;\nconst d = /* @__PURE__ */ new WeakMap();\nfunction S(i) {\n  return d.has(i) || d.set(i, ++G), d.get(i);\n}\nfunction U(i, e, t) {\n  if (i.length !== e.length) return !1;\n  const r = new Array(e.length).fill(!1);\n  e: for (let s = 0; s < i.length; s++) {\n    const n = i[s];\n    for (let a = 0; a < e.length; a++)\n      if (!r[a] && v(n, e[a], t)) {\n        r[a] = !0;\n        continue e;\n      }\n    return !1;\n  }\n  return !0;\n}\nfunction B(i, e, t) {\n  const r = Object.keys(i).sort(), s = Object.keys(e).sort();\n  if (r.length !== s.length) return !1;\n  for (let n = 0; n < r.length; n++)\n    if (r[n] !== s[n]) return !1;\n  for (const n of r) {\n    const a = i[n], o = e[n];\n    if (!v(a, o, t))\n      return !1;\n  }\n  return !0;\n}\nexport {\n  m as C,\n  b as D,\n  g as L,\n  ee as P,\n  f as S,\n  v as a,\n  l as b,\n  u as c,\n  K as d,\n  H as e,\n  W as f,\n  R as g,\n  p as h,\n  y as i,\n  w as j,\n  E as k,\n  O as l,\n  Z as m,\n  V as n,\n  J as o,\n  Y as p,\n  Q as q,\n  j as r,\n  I as s,\n  X as t,\n  te as u\n};\n//# sourceMappingURL=math-ChSRQF3r.js.map\n","import { t as S, a as m } from \"./math-ChSRQF3r.js\";\nimport { l as v, e as D, d as I, C as F, D as _, L as O, g as A, f as N, c as M, b as U, P as z, S as x, h as L, k as j, j as q, i as B, u as K, r as $, m as k, s as G, n as W, q as Y, p as H, o as J } from \"./math-ChSRQF3r.js\";\nconst f = (o) => o.pages.map(\n  (t) => t.map((e) => ({\n    ...e,\n    rotatedSize: S(e.size, o.rotation, 1)\n  }))\n);\nfunction y(o, t) {\n  return {\n    package: o,\n    config: t\n  };\n}\nclass w {\n  constructor(t, e) {\n    if (this.id = t, this.registry = e, this.debouncedActions = {}, this.unsubscribeFromState = null, this.unsubscribeFromCoreStore = null, t !== this.constructor.id)\n      throw new Error(\n        `Plugin ID mismatch: ${t} !== ${this.constructor.id}`\n      );\n    this.coreStore = this.registry.getStore(), this.pluginStore = this.coreStore.getPluginStore(this.id), this.unsubscribeFromState = this.pluginStore.subscribeToState((i, s, c) => {\n      this.onStoreUpdated(c, s);\n    }), this.unsubscribeFromCoreStore = this.coreStore.subscribe((i, s, c) => {\n      this.onCoreStoreUpdated(c, s);\n    }), this.readyPromise = new Promise((i) => {\n      this.readyResolve = i;\n    }), this.readyResolve();\n  }\n  provides() {\n    if (!this._capability) {\n      const t = this.buildCapability();\n      this._capability = Object.freeze(t);\n    }\n    return this._capability;\n  }\n  /**\n   *  Get a copy of the current state\n   */\n  get state() {\n    return this.pluginStore.getState();\n  }\n  /**\n   *  Get a copy of the current core state\n   */\n  get coreState() {\n    return this.coreStore.getState();\n  }\n  /**\n   * @deprecated  use `this.state` Get a copy of the current state\n   */\n  getState() {\n    return this.pluginStore.getState();\n  }\n  /**\n   * @deprecated  use `this.coreState` Get a copy of the current core state\n   */\n  getCoreState() {\n    return this.coreStore.getState();\n  }\n  /**\n   * Core Dispatch\n   */\n  dispatchCoreAction(t) {\n    return this.coreStore.dispatchToCore(t);\n  }\n  /**\n   * Dispatch an action to all plugins\n   */\n  dispatchToAllPlugins(t) {\n    return this.coreStore.dispatch(t);\n  }\n  /**\n   * Dispatch an action\n   */\n  dispatch(t) {\n    return this.pluginStore.dispatch(t);\n  }\n  /**\n   * Dispatch an action with debouncing to prevent rapid repeated calls\n   * @param action The action to dispatch\n   * @param debounceTime Time in ms to debounce (default: 100ms)\n   * @returns boolean indicating whether the action was dispatched or debounced\n   */\n  debouncedDispatch(t, e = 100) {\n    const i = Date.now(), s = this.debouncedActions[t.type] || 0;\n    return i - s >= e ? (this.debouncedActions[t.type] = i, this.dispatch(t), !0) : !1;\n  }\n  /**\n   * Subscribe to state changes\n   */\n  subscribe(t) {\n    return this.pluginStore.subscribeToState(t);\n  }\n  /**\n   * Subscribe to core store changes\n   */\n  subscribeToCoreStore(t) {\n    return this.coreStore.subscribe(t);\n  }\n  /**\n   * Called when the plugin store state is updated\n   * @param oldState Previous state\n   * @param newState New state\n   */\n  onStoreUpdated(t, e) {\n  }\n  /**\n   * Called when the core store state is updated\n   * @param oldState Previous state\n   * @param newState New state\n   */\n  onCoreStoreUpdated(t, e) {\n  }\n  /**\n   * Cleanup method to be called when plugin is being destroyed\n   */\n  destroy() {\n    this.unsubscribeFromState && (this.unsubscribeFromState(), this.unsubscribeFromState = null), this.unsubscribeFromCoreStore && (this.unsubscribeFromCoreStore(), this.unsubscribeFromCoreStore = null);\n  }\n  /**\n   * Returns a promise that resolves when the plugin is ready\n   */\n  ready() {\n    return this.readyPromise;\n  }\n  /**\n   * Mark the plugin as ready\n   */\n  markReady() {\n    this.readyResolve();\n  }\n  /**\n   * Reset the ready state (useful for plugins that need to reinitialize)\n   */\n  resetReady() {\n    this.readyPromise = new Promise((t) => {\n      this.readyResolve = t;\n    });\n  }\n}\nclass b {\n  constructor(t, e) {\n    this.handler = t, this.options = e, this.lastRun = 0, this.handle = (i) => {\n      this.options.mode === \"debounce\" ? this.debounce(i) : this.throttle(i);\n    };\n  }\n  debounce(t) {\n    this.timeoutId && window.clearTimeout(this.timeoutId), this.timeoutId = window.setTimeout(() => {\n      this.handler(t), this.timeoutId = void 0;\n    }, this.options.wait);\n  }\n  throttle(t) {\n    if (this.options.mode === \"debounce\") return;\n    const e = Date.now(), i = this.options.throttleMode || \"leading-trailing\";\n    e - this.lastRun >= this.options.wait && (i === \"leading-trailing\" && this.handler(t), this.lastRun = e), this.timeoutId && window.clearTimeout(this.timeoutId), this.timeoutId = window.setTimeout(\n      () => {\n        this.handler(t), this.lastRun = Date.now(), this.timeoutId = void 0;\n      },\n      this.options.wait - (e - this.lastRun)\n    );\n  }\n  destroy() {\n    this.timeoutId && window.clearTimeout(this.timeoutId);\n  }\n}\nfunction E() {\n  const o = /* @__PURE__ */ new Set();\n  return {\n    emit: (e = void 0) => o.forEach((i) => i(e)),\n    on: (e) => (o.add(e), () => o.delete(e)),\n    off: (e) => o.delete(e),\n    clear: () => o.clear()\n  };\n}\nfunction C(o, t = m) {\n  const e = /* @__PURE__ */ new Set(), i = /* @__PURE__ */ new Map();\n  let s = o;\n  const c = (r) => e.forEach((n) => n(r)), p = (r, n) => {\n    let a = r, d = () => {\n    };\n    if (n) {\n      const u = new b(r, n);\n      a = u.handle, d = () => u.destroy(), i.set(r, { wrapped: a, destroy: d });\n    }\n    return s !== void 0 && a(s), e.add(a), () => {\n      e.delete(a), d(), i.delete(r);\n    };\n  };\n  return {\n    /* emitter behaviour ---------------------------------------- */\n    get value() {\n      return s;\n    },\n    emit(r = void 0) {\n      (s === void 0 || !t(s, r)) && (s = r, c(r));\n    },\n    on: p,\n    off(r) {\n      const n = i.get(r);\n      n ? (e.delete(n.wrapped), n.destroy(), i.delete(r)) : e.delete(r);\n    },\n    clear() {\n      e.clear(), i.forEach((r) => r.destroy()), i.clear();\n    },\n    /* derived hook --------------------------------------------- */\n    select(r, n = m) {\n      return (a, d) => {\n        let u;\n        if (s !== void 0) {\n          const h = r(s);\n          u = h, a(h);\n        }\n        return p(\n          (h) => {\n            const l = r(h);\n            (u === void 0 || !n(u, l)) && (u = l, a(l));\n          },\n          d\n        );\n      };\n    }\n  };\n}\nfunction T(o) {\n  return Object.entries(o).map(([t, e]) => {\n    const i = Number(t);\n    return [Number.isFinite(i) && t.trim() !== \"\" ? i : t, e];\n  });\n}\nexport {\n  w as BasePlugin,\n  v as CORE_ACTION_TYPES,\n  D as CapabilityConflictError,\n  I as CapabilityNotFoundError,\n  F as CircularDependencyError,\n  _ as DependencyResolver,\n  b as EventControl,\n  O as LOAD_DOCUMENT,\n  A as PluginConfigurationError,\n  N as PluginInitializationError,\n  M as PluginNotFoundError,\n  U as PluginRegistrationError,\n  z as PluginRegistry,\n  x as SET_DOCUMENT,\n  L as SET_DOCUMENT_ERROR,\n  j as SET_PAGES,\n  q as SET_ROTATION,\n  B as SET_SCALE,\n  m as arePropsEqual,\n  K as clamp,\n  C as createBehaviorEmitter,\n  E as createEmitter,\n  y as createPluginRegistration,\n  T as enumEntries,\n  f as getPagesWithRotatedSize,\n  $ as initialCoreState,\n  k as loadDocument,\n  G as setDocument,\n  W as setDocumentError,\n  Y as setPages,\n  H as setRotation,\n  J as setScale\n};\n//# sourceMappingURL=index.js.map\n","// src/geometry.ts\nvar Rotation = /* @__PURE__ */ ((Rotation2) => {\n  Rotation2[Rotation2[\"Degree0\"] = 0] = \"Degree0\";\n  Rotation2[Rotation2[\"Degree90\"] = 1] = \"Degree90\";\n  Rotation2[Rotation2[\"Degree180\"] = 2] = \"Degree180\";\n  Rotation2[Rotation2[\"Degree270\"] = 3] = \"Degree270\";\n  return Rotation2;\n})(Rotation || {});\nfunction toIntPos(p) {\n  return { x: Math.floor(p.x), y: Math.floor(p.y) };\n}\nfunction toIntSize(s) {\n  return { width: Math.ceil(s.width), height: Math.ceil(s.height) };\n}\nfunction toIntRect(r) {\n  return {\n    origin: toIntPos(r.origin),\n    size: toIntSize(r.size)\n  };\n}\nfunction calculateDegree(rotation) {\n  switch (rotation) {\n    case 0 /* Degree0 */:\n      return 0;\n    case 1 /* Degree90 */:\n      return 90;\n    case 2 /* Degree180 */:\n      return 180;\n    case 3 /* Degree270 */:\n      return 270;\n  }\n}\nfunction calculateAngle(rotation) {\n  return calculateDegree(rotation) * Math.PI / 180;\n}\nfunction swap(size) {\n  const { width, height } = size;\n  return {\n    width: height,\n    height: width\n  };\n}\nfunction transformSize(size, rotation, scaleFactor) {\n  size = rotation % 2 === 0 ? size : swap(size);\n  return {\n    width: size.width * scaleFactor,\n    height: size.height * scaleFactor\n  };\n}\nfunction quadToRect(q) {\n  const xs = [q.p1.x, q.p2.x, q.p3.x, q.p4.x];\n  const ys = [q.p1.y, q.p2.y, q.p3.y, q.p4.y];\n  return {\n    origin: { x: Math.min(...xs), y: Math.min(...ys) },\n    size: {\n      width: Math.max(...xs) - Math.min(...xs),\n      height: Math.max(...ys) - Math.min(...ys)\n    }\n  };\n}\nfunction rectToQuad(r) {\n  return {\n    p1: { x: r.origin.x, y: r.origin.y },\n    p2: { x: r.origin.x + r.size.width, y: r.origin.y },\n    p3: { x: r.origin.x + r.size.width, y: r.origin.y + r.size.height },\n    p4: { x: r.origin.x, y: r.origin.y + r.size.height }\n  };\n}\nfunction rotatePosition(containerSize, position, rotation) {\n  let x = position.x;\n  let y = position.y;\n  switch (rotation) {\n    case 0 /* Degree0 */:\n      x = position.x;\n      y = position.y;\n      break;\n    case 1 /* Degree90 */:\n      x = containerSize.height - position.y;\n      y = position.x;\n      break;\n    case 2 /* Degree180 */:\n      x = containerSize.width - position.x;\n      y = containerSize.height - position.y;\n      break;\n    case 3 /* Degree270 */:\n      x = position.y;\n      y = containerSize.width - position.x;\n      break;\n  }\n  return {\n    x,\n    y\n  };\n}\nfunction scalePosition(position, scaleFactor) {\n  return {\n    x: position.x * scaleFactor,\n    y: position.y * scaleFactor\n  };\n}\nfunction transformPosition(containerSize, position, rotation, scaleFactor) {\n  return scalePosition(rotatePosition(containerSize, position, rotation), scaleFactor);\n}\nfunction restorePosition(containerSize, position, rotation, scaleFactor) {\n  return scalePosition(\n    rotatePosition(containerSize, position, (4 - rotation) % 4),\n    1 / scaleFactor\n  );\n}\nfunction rotateRect(containerSize, rect, rotation) {\n  let x = rect.origin.x;\n  let y = rect.origin.y;\n  let size = rect.size;\n  switch (rotation) {\n    case 0 /* Degree0 */:\n      break;\n    case 1 /* Degree90 */:\n      x = containerSize.height - rect.origin.y - rect.size.height;\n      y = rect.origin.x;\n      size = swap(rect.size);\n      break;\n    case 2 /* Degree180 */:\n      x = containerSize.width - rect.origin.x - rect.size.width;\n      y = containerSize.height - rect.origin.y - rect.size.height;\n      break;\n    case 3 /* Degree270 */:\n      x = rect.origin.y;\n      y = containerSize.width - rect.origin.x - rect.size.width;\n      size = swap(rect.size);\n      break;\n  }\n  return {\n    origin: {\n      x,\n      y\n    },\n    size: {\n      width: size.width,\n      height: size.height\n    }\n  };\n}\nfunction scaleRect(rect, scaleFactor) {\n  return {\n    origin: {\n      x: rect.origin.x * scaleFactor,\n      y: rect.origin.y * scaleFactor\n    },\n    size: {\n      width: rect.size.width * scaleFactor,\n      height: rect.size.height * scaleFactor\n    }\n  };\n}\nfunction transformRect(containerSize, rect, rotation, scaleFactor) {\n  return scaleRect(rotateRect(containerSize, rect, rotation), scaleFactor);\n}\nfunction restoreRect(containerSize, rect, rotation, scaleFactor) {\n  return scaleRect(rotateRect(containerSize, rect, (4 - rotation) % 4), 1 / scaleFactor);\n}\nfunction restoreOffset(offset, rotation, scaleFactor) {\n  let offsetX = offset.x;\n  let offsetY = offset.y;\n  switch (rotation) {\n    case 0 /* Degree0 */:\n      offsetX = offset.x / scaleFactor;\n      offsetY = offset.y / scaleFactor;\n      break;\n    case 1 /* Degree90 */:\n      offsetX = offset.y / scaleFactor;\n      offsetY = -offset.x / scaleFactor;\n      break;\n    case 2 /* Degree180 */:\n      offsetX = -offset.x / scaleFactor;\n      offsetY = -offset.y / scaleFactor;\n      break;\n    case 3 /* Degree270 */:\n      offsetX = -offset.y / scaleFactor;\n      offsetY = offset.x / scaleFactor;\n      break;\n  }\n  return {\n    x: offsetX,\n    y: offsetY\n  };\n}\nfunction boundingRect(rects) {\n  if (rects.length === 0) return null;\n  let minX = rects[0].origin.x, minY = rects[0].origin.y, maxX = rects[0].origin.x + rects[0].size.width, maxY = rects[0].origin.y + rects[0].size.height;\n  for (const r of rects) {\n    minX = Math.min(minX, r.origin.x);\n    minY = Math.min(minY, r.origin.y);\n    maxX = Math.max(maxX, r.origin.x + r.size.width);\n    maxY = Math.max(maxY, r.origin.y + r.size.height);\n  }\n  return {\n    origin: {\n      x: minX,\n      y: minY\n    },\n    size: {\n      width: maxX - minX,\n      height: maxY - minY\n    }\n  };\n}\nvar makeMatrix = (rectangle, rotation, scaleFactor) => {\n  const { width, height } = rectangle.size;\n  switch (rotation) {\n    case 0 /* Degree0 */:\n      return {\n        a: scaleFactor,\n        b: 0,\n        c: 0,\n        d: -scaleFactor,\n        e: 0,\n        f: height * scaleFactor\n      };\n    case 1 /* Degree90 */:\n      return {\n        a: 0,\n        b: scaleFactor,\n        c: scaleFactor,\n        d: 0,\n        e: 0,\n        f: 0\n      };\n    case 2 /* Degree180 */:\n      return {\n        a: -scaleFactor,\n        b: 0,\n        c: 0,\n        d: scaleFactor,\n        e: width * scaleFactor,\n        f: 0\n      };\n    case 3 /* Degree270 */:\n      return {\n        a: 0,\n        b: -scaleFactor,\n        c: -scaleFactor,\n        d: 0,\n        e: height * scaleFactor,\n        f: width * scaleFactor\n      };\n  }\n};\n\n// src/logger.ts\nvar NoopLogger = class {\n  /** {@inheritDoc Logger.debug} */\n  debug() {\n  }\n  /** {@inheritDoc Logger.info} */\n  info() {\n  }\n  /** {@inheritDoc Logger.warn} */\n  warn() {\n  }\n  /** {@inheritDoc Logger.error} */\n  error() {\n  }\n  /** {@inheritDoc Logger.perf} */\n  perf() {\n  }\n};\nvar ConsoleLogger = class {\n  /** {@inheritDoc Logger.debug} */\n  debug(source, category, ...args) {\n    console.debug(`${source}.${category}`, ...args);\n  }\n  /** {@inheritDoc Logger.info} */\n  info(source, category, ...args) {\n    console.info(`${source}.${category}`, ...args);\n  }\n  /** {@inheritDoc Logger.warn} */\n  warn(source, category, ...args) {\n    console.warn(`${source}.${category}`, ...args);\n  }\n  /** {@inheritDoc Logger.error} */\n  error(source, category, ...args) {\n    console.error(`${source}.${category}`, ...args);\n  }\n  /** {@inheritDoc Logger.perf} */\n  perf(source, category, event, phase, ...args) {\n    console.info(`${source}.${category}.${event}.${phase}`, ...args);\n  }\n};\nvar LogLevel = /* @__PURE__ */ ((LogLevel2) => {\n  LogLevel2[LogLevel2[\"Debug\"] = 0] = \"Debug\";\n  LogLevel2[LogLevel2[\"Info\"] = 1] = \"Info\";\n  LogLevel2[LogLevel2[\"Warn\"] = 2] = \"Warn\";\n  LogLevel2[LogLevel2[\"Error\"] = 3] = \"Error\";\n  return LogLevel2;\n})(LogLevel || {});\nvar LevelLogger = class {\n  /**\n   * create new LevelLogger\n   * @param logger - the original logger\n   * @param level - log level that used for filtering, all logs lower than this level will be filtered out\n   */\n  constructor(logger, level) {\n    this.logger = logger;\n    this.level = level;\n  }\n  /** {@inheritDoc Logger.debug} */\n  debug(source, category, ...args) {\n    if (this.level <= 0 /* Debug */) {\n      this.logger.debug(source, category, ...args);\n    }\n  }\n  /** {@inheritDoc Logger.info} */\n  info(source, category, ...args) {\n    if (this.level <= 1 /* Info */) {\n      this.logger.info(source, category, ...args);\n    }\n  }\n  /** {@inheritDoc Logger.warn} */\n  warn(source, category, ...args) {\n    if (this.level <= 2 /* Warn */) {\n      this.logger.warn(source, category, ...args);\n    }\n  }\n  /** {@inheritDoc Logger.error} */\n  error(source, category, ...args) {\n    if (this.level <= 3 /* Error */) {\n      this.logger.error(source, category, ...args);\n    }\n  }\n  /** {@inheritDoc Logger.perf} */\n  perf(source, category, event, phase, ...args) {\n    this.logger.perf(source, category, event, phase, ...args);\n  }\n};\nvar PerfLogger = class {\n  /**\n   * create new PerfLogger\n   */\n  constructor() {\n  }\n  /** {@inheritDoc Logger.debug} */\n  debug(source, category, ...args) {\n  }\n  /** {@inheritDoc Logger.info} */\n  info(source, category, ...args) {\n  }\n  /** {@inheritDoc Logger.warn} */\n  warn(source, category, ...args) {\n  }\n  /** {@inheritDoc Logger.error} */\n  error(source, category, ...args) {\n  }\n  /** {@inheritDoc Logger.perf} */\n  perf(source, category, event, phase, identifier, ...args) {\n    switch (phase) {\n      case \"Begin\":\n        window.performance.mark(`${source}.${category}.${event}.${phase}.${identifier}`, {\n          detail: args\n        });\n        break;\n      case \"End\":\n        window.performance.mark(`${source}.${category}.${event}.${phase}.${identifier}`, {\n          detail: args\n        });\n        window.performance.measure(\n          `${source}.${category}.${event}.Measure.${identifier}`,\n          `${source}.${category}.${event}.Begin.${identifier}`,\n          `${source}.${category}.${event}.End.${identifier}`\n        );\n        break;\n    }\n  }\n};\nvar AllLogger = class {\n  /**\n   * create new PerfLogger\n   */\n  constructor(loggers) {\n    this.loggers = loggers;\n  }\n  /** {@inheritDoc Logger.debug} */\n  debug(source, category, ...args) {\n    for (const logger of this.loggers) {\n      logger.debug(source, category, ...args);\n    }\n  }\n  /** {@inheritDoc Logger.info} */\n  info(source, category, ...args) {\n    for (const logger of this.loggers) {\n      logger.info(source, category, ...args);\n    }\n  }\n  /** {@inheritDoc Logger.warn} */\n  warn(source, category, ...args) {\n    for (const logger of this.loggers) {\n      logger.warn(source, category, ...args);\n    }\n  }\n  /** {@inheritDoc Logger.error} */\n  error(source, category, ...args) {\n    for (const logger of this.loggers) {\n      logger.error(source, category, ...args);\n    }\n  }\n  /** {@inheritDoc Logger.perf} */\n  perf(source, category, event, phase, ...args) {\n    for (const logger of this.loggers) {\n      logger.perf(source, category, event, phase, ...args);\n    }\n  }\n};\n\n// src/task.ts\nvar TaskStage = /* @__PURE__ */ ((TaskStage2) => {\n  TaskStage2[TaskStage2[\"Pending\"] = 0] = \"Pending\";\n  TaskStage2[TaskStage2[\"Resolved\"] = 1] = \"Resolved\";\n  TaskStage2[TaskStage2[\"Rejected\"] = 2] = \"Rejected\";\n  TaskStage2[TaskStage2[\"Aborted\"] = 3] = \"Aborted\";\n  return TaskStage2;\n})(TaskStage || {});\nvar TaskAbortedError = class extends Error {\n  constructor(reason) {\n    super(`Task aborted: ${JSON.stringify(reason)}`);\n    this.name = \"TaskAbortedError\";\n  }\n};\nvar TaskRejectedError = class extends Error {\n  constructor(reason) {\n    super(`Task rejected: ${JSON.stringify(reason)}`);\n    this.name = \"TaskRejectedError\";\n  }\n};\nvar Task = class _Task {\n  constructor() {\n    this.state = {\n      stage: 0 /* Pending */\n    };\n    /**\n     * callbacks that will be executed when task is resolved\n     */\n    this.resolvedCallbacks = [];\n    /**\n     * callbacks that will be executed when task is rejected\n     */\n    this.rejectedCallbacks = [];\n    /**\n     * Promise that will be resolved when task is settled\n     */\n    this._promise = null;\n  }\n  /**\n   * Convert task to promise\n   * @returns promise that will be resolved when task is settled\n   */\n  toPromise() {\n    if (!this._promise) {\n      this._promise = new Promise((resolve, reject) => {\n        this.wait(\n          (result) => resolve(result),\n          (error) => {\n            if (error.type === \"abort\") {\n              reject(new TaskAbortedError(error.reason));\n            } else {\n              reject(new TaskRejectedError(error.reason));\n            }\n          }\n        );\n      });\n    }\n    return this._promise;\n  }\n  /**\n   * wait for task to be settled\n   * @param resolvedCallback - callback for resolved value\n   * @param rejectedCallback - callback for rejected value\n   */\n  wait(resolvedCallback, rejectedCallback) {\n    switch (this.state.stage) {\n      case 0 /* Pending */:\n        this.resolvedCallbacks.push(resolvedCallback);\n        this.rejectedCallbacks.push(rejectedCallback);\n        break;\n      case 1 /* Resolved */:\n        resolvedCallback(this.state.result);\n        break;\n      case 2 /* Rejected */:\n        rejectedCallback({\n          type: \"reject\",\n          reason: this.state.reason\n        });\n        break;\n      case 3 /* Aborted */:\n        rejectedCallback({\n          type: \"abort\",\n          reason: this.state.reason\n        });\n        break;\n    }\n  }\n  /**\n   * resolve task with specific result\n   * @param result - result value\n   */\n  resolve(result) {\n    if (this.state.stage === 0 /* Pending */) {\n      this.state = {\n        stage: 1 /* Resolved */,\n        result\n      };\n      for (const resolvedCallback of this.resolvedCallbacks) {\n        try {\n          resolvedCallback(result);\n        } catch (e) {\n        }\n      }\n      this.resolvedCallbacks = [];\n      this.rejectedCallbacks = [];\n    }\n  }\n  /**\n   * reject task with specific reason\n   * @param reason - abort reason\n   *\n   */\n  reject(reason) {\n    if (this.state.stage === 0 /* Pending */) {\n      this.state = {\n        stage: 2 /* Rejected */,\n        reason\n      };\n      for (const rejectedCallback of this.rejectedCallbacks) {\n        try {\n          rejectedCallback({\n            type: \"reject\",\n            reason\n          });\n        } catch (e) {\n        }\n      }\n      this.resolvedCallbacks = [];\n      this.rejectedCallbacks = [];\n    }\n  }\n  /**\n   * abort task with specific reason\n   * @param reason - abort reason\n   */\n  abort(reason) {\n    if (this.state.stage === 0 /* Pending */) {\n      this.state = {\n        stage: 3 /* Aborted */,\n        reason\n      };\n      for (const rejectedCallback of this.rejectedCallbacks) {\n        try {\n          rejectedCallback({\n            type: \"abort\",\n            reason\n          });\n        } catch (e) {\n        }\n      }\n      this.resolvedCallbacks = [];\n      this.rejectedCallbacks = [];\n    }\n  }\n  /**\n   * fail task with a TaskError from another task\n   * This is a convenience method for error propagation between tasks\n   * @param error - TaskError from another task\n   */\n  fail(error) {\n    if (error.type === \"abort\") {\n      this.abort(error.reason);\n    } else {\n      this.reject(error.reason);\n    }\n  }\n  /**\n   * Static method to wait for all tasks to resolve\n   * Returns a new task that resolves with an array of all results\n   * Rejects immediately if any task fails\n   *\n   * @param tasks - array of tasks to wait for\n   * @returns new task that resolves when all input tasks resolve\n   * @public\n   */\n  static all(tasks) {\n    const combinedTask = new _Task();\n    if (tasks.length === 0) {\n      combinedTask.resolve([]);\n      return combinedTask;\n    }\n    const results = new Array(tasks.length);\n    let resolvedCount = 0;\n    let isSettled = false;\n    tasks.forEach((task, index) => {\n      task.wait(\n        (result) => {\n          if (isSettled) return;\n          results[index] = result;\n          resolvedCount++;\n          if (resolvedCount === tasks.length) {\n            isSettled = true;\n            combinedTask.resolve(results);\n          }\n        },\n        (error) => {\n          if (isSettled) return;\n          isSettled = true;\n          if (error.type === \"abort\") {\n            combinedTask.abort(error.reason);\n          } else {\n            combinedTask.reject(error.reason);\n          }\n        }\n      );\n    });\n    return combinedTask;\n  }\n  /**\n   * Static method to wait for all tasks to settle (resolve, reject, or abort)\n   * Always resolves with an array of settlement results\n   *\n   * @param tasks - array of tasks to wait for\n   * @returns new task that resolves when all input tasks settle\n   * @public\n   */\n  static allSettled(tasks) {\n    const combinedTask = new _Task();\n    if (tasks.length === 0) {\n      combinedTask.resolve([]);\n      return combinedTask;\n    }\n    const results = new Array(tasks.length);\n    let settledCount = 0;\n    tasks.forEach((task, index) => {\n      task.wait(\n        (result) => {\n          results[index] = { status: \"resolved\", value: result };\n          settledCount++;\n          if (settledCount === tasks.length) {\n            combinedTask.resolve(results);\n          }\n        },\n        (error) => {\n          results[index] = {\n            status: error.type === \"abort\" ? \"aborted\" : \"rejected\",\n            reason: error.reason\n          };\n          settledCount++;\n          if (settledCount === tasks.length) {\n            combinedTask.resolve(results);\n          }\n        }\n      );\n    });\n    return combinedTask;\n  }\n  /**\n   * Static method that resolves/rejects with the first task that settles\n   *\n   * @param tasks - array of tasks to race\n   * @returns new task that settles with the first input task that settles\n   * @public\n   */\n  static race(tasks) {\n    const combinedTask = new _Task();\n    if (tasks.length === 0) {\n      combinedTask.reject(\"No tasks provided\");\n      return combinedTask;\n    }\n    let isSettled = false;\n    tasks.forEach((task) => {\n      task.wait(\n        (result) => {\n          if (isSettled) return;\n          isSettled = true;\n          combinedTask.resolve(result);\n        },\n        (error) => {\n          if (isSettled) return;\n          isSettled = true;\n          if (error.type === \"abort\") {\n            combinedTask.abort(error.reason);\n          } else {\n            combinedTask.reject(error.reason);\n          }\n        }\n      );\n    });\n    return combinedTask;\n  }\n  /**\n   * Utility to track progress of multiple tasks\n   *\n   * @param tasks - array of tasks to track\n   * @param onProgress - callback called when any task completes\n   * @returns new task that resolves when all input tasks resolve\n   * @public\n   */\n  static withProgress(tasks, onProgress) {\n    const combinedTask = _Task.all(tasks);\n    if (onProgress) {\n      let completedCount = 0;\n      tasks.forEach((task) => {\n        task.wait(\n          () => {\n            completedCount++;\n            onProgress(completedCount, tasks.length);\n          },\n          () => {\n            completedCount++;\n            onProgress(completedCount, tasks.length);\n          }\n        );\n      });\n    }\n    return combinedTask;\n  }\n};\n\n// src/pdf.ts\nvar PdfSoftHyphenMarker = \"\\xAD\";\nvar PdfZeroWidthSpace = \"\\u200B\";\nvar PdfWordJoiner = \"\\u2060\";\nvar PdfBomOrZwnbsp = \"\\uFEFF\";\nvar PdfNonCharacterFFFE = \"\\uFFFE\";\nvar PdfNonCharacterFFFF = \"\\uFFFF\";\nvar PdfUnwantedTextMarkers = Object.freeze([\n  PdfSoftHyphenMarker,\n  PdfZeroWidthSpace,\n  PdfWordJoiner,\n  PdfBomOrZwnbsp,\n  PdfNonCharacterFFFE,\n  PdfNonCharacterFFFF\n]);\nvar PdfUnwantedTextRegex = new RegExp(`[${PdfUnwantedTextMarkers.join(\"\")}]`, \"g\");\nfunction stripPdfUnwantedMarkers(text) {\n  return text.replace(PdfUnwantedTextRegex, \"\");\n}\nvar PdfZoomMode = /* @__PURE__ */ ((PdfZoomMode2) => {\n  PdfZoomMode2[PdfZoomMode2[\"Unknown\"] = 0] = \"Unknown\";\n  PdfZoomMode2[PdfZoomMode2[\"XYZ\"] = 1] = \"XYZ\";\n  PdfZoomMode2[PdfZoomMode2[\"FitPage\"] = 2] = \"FitPage\";\n  PdfZoomMode2[PdfZoomMode2[\"FitHorizontal\"] = 3] = \"FitHorizontal\";\n  PdfZoomMode2[PdfZoomMode2[\"FitVertical\"] = 4] = \"FitVertical\";\n  PdfZoomMode2[PdfZoomMode2[\"FitRectangle\"] = 5] = \"FitRectangle\";\n  return PdfZoomMode2;\n})(PdfZoomMode || {});\nvar PdfBlendMode = /* @__PURE__ */ ((PdfBlendMode2) => {\n  PdfBlendMode2[PdfBlendMode2[\"Normal\"] = 0] = \"Normal\";\n  PdfBlendMode2[PdfBlendMode2[\"Multiply\"] = 1] = \"Multiply\";\n  PdfBlendMode2[PdfBlendMode2[\"Screen\"] = 2] = \"Screen\";\n  PdfBlendMode2[PdfBlendMode2[\"Overlay\"] = 3] = \"Overlay\";\n  PdfBlendMode2[PdfBlendMode2[\"Darken\"] = 4] = \"Darken\";\n  PdfBlendMode2[PdfBlendMode2[\"Lighten\"] = 5] = \"Lighten\";\n  PdfBlendMode2[PdfBlendMode2[\"ColorDodge\"] = 6] = \"ColorDodge\";\n  PdfBlendMode2[PdfBlendMode2[\"ColorBurn\"] = 7] = \"ColorBurn\";\n  PdfBlendMode2[PdfBlendMode2[\"HardLight\"] = 8] = \"HardLight\";\n  PdfBlendMode2[PdfBlendMode2[\"SoftLight\"] = 9] = \"SoftLight\";\n  PdfBlendMode2[PdfBlendMode2[\"Difference\"] = 10] = \"Difference\";\n  PdfBlendMode2[PdfBlendMode2[\"Exclusion\"] = 11] = \"Exclusion\";\n  PdfBlendMode2[PdfBlendMode2[\"Hue\"] = 12] = \"Hue\";\n  PdfBlendMode2[PdfBlendMode2[\"Saturation\"] = 13] = \"Saturation\";\n  PdfBlendMode2[PdfBlendMode2[\"Color\"] = 14] = \"Color\";\n  PdfBlendMode2[PdfBlendMode2[\"Luminosity\"] = 15] = \"Luminosity\";\n  return PdfBlendMode2;\n})(PdfBlendMode || {});\nvar MixedBlendMode = Symbol(\"mixed\");\nvar BLEND_MODE_INFOS = Object.freeze([\n  { id: 0 /* Normal */, label: \"Normal\", css: \"normal\" },\n  { id: 1 /* Multiply */, label: \"Multiply\", css: \"multiply\" },\n  { id: 2 /* Screen */, label: \"Screen\", css: \"screen\" },\n  { id: 3 /* Overlay */, label: \"Overlay\", css: \"overlay\" },\n  { id: 4 /* Darken */, label: \"Darken\", css: \"darken\" },\n  { id: 5 /* Lighten */, label: \"Lighten\", css: \"lighten\" },\n  { id: 6 /* ColorDodge */, label: \"Color Dodge\", css: \"color-dodge\" },\n  { id: 7 /* ColorBurn */, label: \"Color Burn\", css: \"color-burn\" },\n  { id: 8 /* HardLight */, label: \"Hard Light\", css: \"hard-light\" },\n  { id: 9 /* SoftLight */, label: \"Soft Light\", css: \"soft-light\" },\n  { id: 10 /* Difference */, label: \"Difference\", css: \"difference\" },\n  { id: 11 /* Exclusion */, label: \"Exclusion\", css: \"exclusion\" },\n  { id: 12 /* Hue */, label: \"Hue\", css: \"hue\" },\n  { id: 13 /* Saturation */, label: \"Saturation\", css: \"saturation\" },\n  { id: 14 /* Color */, label: \"Color\", css: \"color\" },\n  { id: 15 /* Luminosity */, label: \"Luminosity\", css: \"luminosity\" }\n]);\nvar enumToInfo = BLEND_MODE_INFOS.reduce(\n  (m, info) => {\n    m[info.id] = info;\n    return m;\n  },\n  {}\n);\nvar cssToEnum = BLEND_MODE_INFOS.reduce((m, info) => {\n  m[info.css] = info.id;\n  return m;\n}, {});\nfunction getBlendModeInfo(mode) {\n  return enumToInfo[mode] ?? enumToInfo[0 /* Normal */];\n}\nfunction blendModeToCss(mode) {\n  return getBlendModeInfo(mode).css;\n}\nfunction cssToBlendMode(value) {\n  return cssToEnum[value];\n}\nfunction blendModeLabel(mode) {\n  return getBlendModeInfo(mode).label;\n}\nfunction reduceBlendModes(modes) {\n  if (!modes.length) return 0 /* Normal */;\n  const first = modes[0];\n  return modes.every((m) => m === first) ? first : MixedBlendMode;\n}\nvar blendModeSelectOptions = BLEND_MODE_INFOS.map((info) => ({\n  value: info.id,\n  label: info.label\n}));\nfunction uiBlendModeDisplay(value) {\n  return value === MixedBlendMode ? \"(mixed)\" : blendModeLabel(value);\n}\nvar PdfActionType = /* @__PURE__ */ ((PdfActionType2) => {\n  PdfActionType2[PdfActionType2[\"Unsupported\"] = 0] = \"Unsupported\";\n  PdfActionType2[PdfActionType2[\"Goto\"] = 1] = \"Goto\";\n  PdfActionType2[PdfActionType2[\"RemoteGoto\"] = 2] = \"RemoteGoto\";\n  PdfActionType2[PdfActionType2[\"URI\"] = 3] = \"URI\";\n  PdfActionType2[PdfActionType2[\"LaunchAppOrOpenFile\"] = 4] = \"LaunchAppOrOpenFile\";\n  return PdfActionType2;\n})(PdfActionType || {});\nvar PdfAnnotationSubtype = /* @__PURE__ */ ((PdfAnnotationSubtype2) => {\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"TEXT\"] = 1] = \"TEXT\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"LINK\"] = 2] = \"LINK\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"FREETEXT\"] = 3] = \"FREETEXT\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"LINE\"] = 4] = \"LINE\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"SQUARE\"] = 5] = \"SQUARE\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"CIRCLE\"] = 6] = \"CIRCLE\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"POLYGON\"] = 7] = \"POLYGON\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"POLYLINE\"] = 8] = \"POLYLINE\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"HIGHLIGHT\"] = 9] = \"HIGHLIGHT\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"UNDERLINE\"] = 10] = \"UNDERLINE\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"SQUIGGLY\"] = 11] = \"SQUIGGLY\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"STRIKEOUT\"] = 12] = \"STRIKEOUT\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"STAMP\"] = 13] = \"STAMP\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"CARET\"] = 14] = \"CARET\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"INK\"] = 15] = \"INK\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"POPUP\"] = 16] = \"POPUP\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"FILEATTACHMENT\"] = 17] = \"FILEATTACHMENT\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"SOUND\"] = 18] = \"SOUND\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"MOVIE\"] = 19] = \"MOVIE\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"WIDGET\"] = 20] = \"WIDGET\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"SCREEN\"] = 21] = \"SCREEN\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"PRINTERMARK\"] = 22] = \"PRINTERMARK\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"TRAPNET\"] = 23] = \"TRAPNET\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"WATERMARK\"] = 24] = \"WATERMARK\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"THREED\"] = 25] = \"THREED\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"RICHMEDIA\"] = 26] = \"RICHMEDIA\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"XFAWIDGET\"] = 27] = \"XFAWIDGET\";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2[\"REDACT\"] = 28] = \"REDACT\";\n  return PdfAnnotationSubtype2;\n})(PdfAnnotationSubtype || {});\nvar PdfAnnotationSubtypeName = {\n  [0 /* UNKNOWN */]: \"unknow\",\n  [1 /* TEXT */]: \"text\",\n  [2 /* LINK */]: \"link\",\n  [3 /* FREETEXT */]: \"freetext\",\n  [4 /* LINE */]: \"line\",\n  [5 /* SQUARE */]: \"square\",\n  [6 /* CIRCLE */]: \"circle\",\n  [7 /* POLYGON */]: \"polygon\",\n  [8 /* POLYLINE */]: \"polyline\",\n  [9 /* HIGHLIGHT */]: \"highlight\",\n  [10 /* UNDERLINE */]: \"underline\",\n  [11 /* SQUIGGLY */]: \"squiggly\",\n  [12 /* STRIKEOUT */]: \"strikeout\",\n  [13 /* STAMP */]: \"stamp\",\n  [14 /* CARET */]: \"caret\",\n  [15 /* INK */]: \"ink\",\n  [16 /* POPUP */]: \"popup\",\n  [17 /* FILEATTACHMENT */]: \"fileattachment\",\n  [18 /* SOUND */]: \"sound\",\n  [19 /* MOVIE */]: \"movie\",\n  [20 /* WIDGET */]: \"widget\",\n  [21 /* SCREEN */]: \"screen\",\n  [22 /* PRINTERMARK */]: \"printermark\",\n  [23 /* TRAPNET */]: \"trapnet\",\n  [24 /* WATERMARK */]: \"watermark\",\n  [25 /* THREED */]: \"threed\",\n  [26 /* RICHMEDIA */]: \"richmedia\",\n  [27 /* XFAWIDGET */]: \"xfawidget\",\n  [28 /* REDACT */]: \"redact\"\n};\nvar PdfAnnotationObjectStatus = /* @__PURE__ */ ((PdfAnnotationObjectStatus2) => {\n  PdfAnnotationObjectStatus2[PdfAnnotationObjectStatus2[\"Created\"] = 0] = \"Created\";\n  PdfAnnotationObjectStatus2[PdfAnnotationObjectStatus2[\"Committed\"] = 1] = \"Committed\";\n  return PdfAnnotationObjectStatus2;\n})(PdfAnnotationObjectStatus || {});\nvar AppearanceMode = /* @__PURE__ */ ((AppearanceMode2) => {\n  AppearanceMode2[AppearanceMode2[\"Normal\"] = 0] = \"Normal\";\n  AppearanceMode2[AppearanceMode2[\"Rollover\"] = 1] = \"Rollover\";\n  AppearanceMode2[AppearanceMode2[\"Down\"] = 2] = \"Down\";\n  return AppearanceMode2;\n})(AppearanceMode || {});\nvar PdfAnnotationState = /* @__PURE__ */ ((PdfAnnotationState2) => {\n  PdfAnnotationState2[\"Marked\"] = \"Marked\";\n  PdfAnnotationState2[\"Unmarked\"] = \"Unmarked\";\n  PdfAnnotationState2[\"Accepted\"] = \"Accepted\";\n  PdfAnnotationState2[\"Rejected\"] = \"Rejected\";\n  PdfAnnotationState2[\"Complete\"] = \"Complete\";\n  PdfAnnotationState2[\"Cancelled\"] = \"Cancelled\";\n  PdfAnnotationState2[\"None\"] = \"None\";\n  return PdfAnnotationState2;\n})(PdfAnnotationState || {});\nvar PdfAnnotationStateModel = /* @__PURE__ */ ((PdfAnnotationStateModel2) => {\n  PdfAnnotationStateModel2[\"Marked\"] = \"Marked\";\n  PdfAnnotationStateModel2[\"Reviewed\"] = \"Reviewed\";\n  return PdfAnnotationStateModel2;\n})(PdfAnnotationStateModel || {});\nvar PDF_FORM_FIELD_TYPE = /* @__PURE__ */ ((PDF_FORM_FIELD_TYPE2) => {\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"PUSHBUTTON\"] = 1] = \"PUSHBUTTON\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"CHECKBOX\"] = 2] = \"CHECKBOX\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"RADIOBUTTON\"] = 3] = \"RADIOBUTTON\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"COMBOBOX\"] = 4] = \"COMBOBOX\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"LISTBOX\"] = 5] = \"LISTBOX\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"TEXTFIELD\"] = 6] = \"TEXTFIELD\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"SIGNATURE\"] = 7] = \"SIGNATURE\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"XFA\"] = 8] = \"XFA\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"XFA_CHECKBOX\"] = 9] = \"XFA_CHECKBOX\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"XFA_COMBOBOX\"] = 10] = \"XFA_COMBOBOX\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"XFA_IMAGEFIELD\"] = 11] = \"XFA_IMAGEFIELD\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"XFA_LISTBOX\"] = 12] = \"XFA_LISTBOX\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"XFA_PUSHBUTTON\"] = 13] = \"XFA_PUSHBUTTON\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"XFA_SIGNATURE\"] = 14] = \"XFA_SIGNATURE\";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2[\"XFA_TEXTFIELD\"] = 15] = \"XFA_TEXTFIELD\";\n  return PDF_FORM_FIELD_TYPE2;\n})(PDF_FORM_FIELD_TYPE || {});\nvar PdfAnnotationColorType = /* @__PURE__ */ ((PdfAnnotationColorType2) => {\n  PdfAnnotationColorType2[PdfAnnotationColorType2[\"Color\"] = 0] = \"Color\";\n  PdfAnnotationColorType2[PdfAnnotationColorType2[\"InteriorColor\"] = 1] = \"InteriorColor\";\n  return PdfAnnotationColorType2;\n})(PdfAnnotationColorType || {});\nvar PdfAnnotationBorderStyle = /* @__PURE__ */ ((PdfAnnotationBorderStyle2) => {\n  PdfAnnotationBorderStyle2[PdfAnnotationBorderStyle2[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n  PdfAnnotationBorderStyle2[PdfAnnotationBorderStyle2[\"SOLID\"] = 1] = \"SOLID\";\n  PdfAnnotationBorderStyle2[PdfAnnotationBorderStyle2[\"DASHED\"] = 2] = \"DASHED\";\n  PdfAnnotationBorderStyle2[PdfAnnotationBorderStyle2[\"BEVELED\"] = 3] = \"BEVELED\";\n  PdfAnnotationBorderStyle2[PdfAnnotationBorderStyle2[\"INSET\"] = 4] = \"INSET\";\n  PdfAnnotationBorderStyle2[PdfAnnotationBorderStyle2[\"UNDERLINE\"] = 5] = \"UNDERLINE\";\n  PdfAnnotationBorderStyle2[PdfAnnotationBorderStyle2[\"CLOUDY\"] = 6] = \"CLOUDY\";\n  return PdfAnnotationBorderStyle2;\n})(PdfAnnotationBorderStyle || {});\nvar PdfAnnotationFlags = /* @__PURE__ */ ((PdfAnnotationFlags2) => {\n  PdfAnnotationFlags2[PdfAnnotationFlags2[\"NONE\"] = 0] = \"NONE\";\n  PdfAnnotationFlags2[PdfAnnotationFlags2[\"INVISIBLE\"] = 1] = \"INVISIBLE\";\n  PdfAnnotationFlags2[PdfAnnotationFlags2[\"HIDDEN\"] = 2] = \"HIDDEN\";\n  PdfAnnotationFlags2[PdfAnnotationFlags2[\"PRINT\"] = 4] = \"PRINT\";\n  PdfAnnotationFlags2[PdfAnnotationFlags2[\"NO_ZOOM\"] = 8] = \"NO_ZOOM\";\n  PdfAnnotationFlags2[PdfAnnotationFlags2[\"NO_ROTATE\"] = 16] = \"NO_ROTATE\";\n  PdfAnnotationFlags2[PdfAnnotationFlags2[\"NO_VIEW\"] = 32] = \"NO_VIEW\";\n  PdfAnnotationFlags2[PdfAnnotationFlags2[\"READ_ONLY\"] = 64] = \"READ_ONLY\";\n  PdfAnnotationFlags2[PdfAnnotationFlags2[\"LOCKED\"] = 128] = \"LOCKED\";\n  PdfAnnotationFlags2[PdfAnnotationFlags2[\"TOGGLE_NOVIEW\"] = 256] = \"TOGGLE_NOVIEW\";\n  return PdfAnnotationFlags2;\n})(PdfAnnotationFlags || {});\nvar PDF_FORM_FIELD_FLAG = /* @__PURE__ */ ((PDF_FORM_FIELD_FLAG2) => {\n  PDF_FORM_FIELD_FLAG2[PDF_FORM_FIELD_FLAG2[\"NONE\"] = 0] = \"NONE\";\n  PDF_FORM_FIELD_FLAG2[PDF_FORM_FIELD_FLAG2[\"READONLY\"] = 1] = \"READONLY\";\n  PDF_FORM_FIELD_FLAG2[PDF_FORM_FIELD_FLAG2[\"REQUIRED\"] = 2] = \"REQUIRED\";\n  PDF_FORM_FIELD_FLAG2[PDF_FORM_FIELD_FLAG2[\"NOEXPORT\"] = 4] = \"NOEXPORT\";\n  PDF_FORM_FIELD_FLAG2[PDF_FORM_FIELD_FLAG2[\"TEXT_MULTIPLINE\"] = 4096] = \"TEXT_MULTIPLINE\";\n  PDF_FORM_FIELD_FLAG2[PDF_FORM_FIELD_FLAG2[\"TEXT_PASSWORD\"] = 8192] = \"TEXT_PASSWORD\";\n  PDF_FORM_FIELD_FLAG2[PDF_FORM_FIELD_FLAG2[\"CHOICE_COMBO\"] = 131072] = \"CHOICE_COMBO\";\n  PDF_FORM_FIELD_FLAG2[PDF_FORM_FIELD_FLAG2[\"CHOICE_EDIT\"] = 262144] = \"CHOICE_EDIT\";\n  PDF_FORM_FIELD_FLAG2[PDF_FORM_FIELD_FLAG2[\"CHOICE_MULTL_SELECT\"] = 2097152] = \"CHOICE_MULTL_SELECT\";\n  return PDF_FORM_FIELD_FLAG2;\n})(PDF_FORM_FIELD_FLAG || {});\nvar PdfPageObjectType = /* @__PURE__ */ ((PdfPageObjectType2) => {\n  PdfPageObjectType2[PdfPageObjectType2[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n  PdfPageObjectType2[PdfPageObjectType2[\"TEXT\"] = 1] = \"TEXT\";\n  PdfPageObjectType2[PdfPageObjectType2[\"PATH\"] = 2] = \"PATH\";\n  PdfPageObjectType2[PdfPageObjectType2[\"IMAGE\"] = 3] = \"IMAGE\";\n  PdfPageObjectType2[PdfPageObjectType2[\"SHADING\"] = 4] = \"SHADING\";\n  PdfPageObjectType2[PdfPageObjectType2[\"FORM\"] = 5] = \"FORM\";\n  return PdfPageObjectType2;\n})(PdfPageObjectType || {});\nvar PdfAnnotationFlagName = Object.freeze({\n  [1 /* INVISIBLE */]: \"invisible\",\n  [2 /* HIDDEN */]: \"hidden\",\n  [4 /* PRINT */]: \"print\",\n  [8 /* NO_ZOOM */]: \"noZoom\",\n  [16 /* NO_ROTATE */]: \"noRotate\",\n  [32 /* NO_VIEW */]: \"noView\",\n  [64 /* READ_ONLY */]: \"readOnly\",\n  [128 /* LOCKED */]: \"locked\",\n  [256 /* TOGGLE_NOVIEW */]: \"toggleNoView\"\n});\nvar PdfAnnotationFlagValue = Object.entries(\n  PdfAnnotationFlagName\n).reduce(\n  (acc, [bit, name]) => {\n    acc[name] = Number(bit);\n    return acc;\n  },\n  {}\n);\nfunction flagsToNames(raw) {\n  return Object.keys(PdfAnnotationFlagName).filter((flag) => (raw & flag) !== 0).map((flag) => PdfAnnotationFlagName[flag]);\n}\nfunction namesToFlags(names) {\n  return names.reduce(\n    (mask, name) => mask | PdfAnnotationFlagValue[name],\n    0 /* NONE */\n  );\n}\nvar PdfSegmentObjectType = /* @__PURE__ */ ((PdfSegmentObjectType2) => {\n  PdfSegmentObjectType2[PdfSegmentObjectType2[\"UNKNOWN\"] = -1] = \"UNKNOWN\";\n  PdfSegmentObjectType2[PdfSegmentObjectType2[\"LINETO\"] = 0] = \"LINETO\";\n  PdfSegmentObjectType2[PdfSegmentObjectType2[\"BEZIERTO\"] = 1] = \"BEZIERTO\";\n  PdfSegmentObjectType2[PdfSegmentObjectType2[\"MOVETO\"] = 2] = \"MOVETO\";\n  return PdfSegmentObjectType2;\n})(PdfSegmentObjectType || {});\nvar PdfEngineFeature = /* @__PURE__ */ ((PdfEngineFeature2) => {\n  PdfEngineFeature2[PdfEngineFeature2[\"RenderPage\"] = 0] = \"RenderPage\";\n  PdfEngineFeature2[PdfEngineFeature2[\"RenderPageRect\"] = 1] = \"RenderPageRect\";\n  PdfEngineFeature2[PdfEngineFeature2[\"Thumbnails\"] = 2] = \"Thumbnails\";\n  PdfEngineFeature2[PdfEngineFeature2[\"Bookmarks\"] = 3] = \"Bookmarks\";\n  PdfEngineFeature2[PdfEngineFeature2[\"Annotations\"] = 4] = \"Annotations\";\n  return PdfEngineFeature2;\n})(PdfEngineFeature || {});\nvar PdfEngineOperation = /* @__PURE__ */ ((PdfEngineOperation2) => {\n  PdfEngineOperation2[PdfEngineOperation2[\"Create\"] = 0] = \"Create\";\n  PdfEngineOperation2[PdfEngineOperation2[\"Read\"] = 1] = \"Read\";\n  PdfEngineOperation2[PdfEngineOperation2[\"Update\"] = 2] = \"Update\";\n  PdfEngineOperation2[PdfEngineOperation2[\"Delete\"] = 3] = \"Delete\";\n  return PdfEngineOperation2;\n})(PdfEngineOperation || {});\nvar MatchFlag = /* @__PURE__ */ ((MatchFlag2) => {\n  MatchFlag2[MatchFlag2[\"None\"] = 0] = \"None\";\n  MatchFlag2[MatchFlag2[\"MatchCase\"] = 1] = \"MatchCase\";\n  MatchFlag2[MatchFlag2[\"MatchWholeWord\"] = 2] = \"MatchWholeWord\";\n  MatchFlag2[MatchFlag2[\"MatchConsecutive\"] = 4] = \"MatchConsecutive\";\n  return MatchFlag2;\n})(MatchFlag || {});\nfunction unionFlags(flags) {\n  return flags.reduce((flag, currFlag) => {\n    return flag | currFlag;\n  }, 0 /* None */);\n}\nfunction compareSearchTarget(targetA, targetB) {\n  const flagA = unionFlags(targetA.flags);\n  const flagB = unionFlags(targetB.flags);\n  return flagA === flagB && targetA.keyword === targetB.keyword;\n}\nvar PdfPermission = /* @__PURE__ */ ((PdfPermission2) => {\n  PdfPermission2[PdfPermission2[\"PrintDocument\"] = 8] = \"PrintDocument\";\n  PdfPermission2[PdfPermission2[\"ModifyContent\"] = 16] = \"ModifyContent\";\n  PdfPermission2[PdfPermission2[\"CopyOrExtract\"] = 32] = \"CopyOrExtract\";\n  PdfPermission2[PdfPermission2[\"AddOrModifyTextAnnot\"] = 64] = \"AddOrModifyTextAnnot\";\n  PdfPermission2[PdfPermission2[\"FillInExistingForm\"] = 512] = \"FillInExistingForm\";\n  PdfPermission2[PdfPermission2[\"ExtractTextOrGraphics\"] = 1024] = \"ExtractTextOrGraphics\";\n  PdfPermission2[PdfPermission2[\"AssembleDocument\"] = 2048] = \"AssembleDocument\";\n  PdfPermission2[PdfPermission2[\"PrintHighQuality\"] = 4096] = \"PrintHighQuality\";\n  return PdfPermission2;\n})(PdfPermission || {});\nvar PdfPageFlattenFlag = /* @__PURE__ */ ((PdfPageFlattenFlag2) => {\n  PdfPageFlattenFlag2[PdfPageFlattenFlag2[\"Display\"] = 0] = \"Display\";\n  PdfPageFlattenFlag2[PdfPageFlattenFlag2[\"Print\"] = 1] = \"Print\";\n  return PdfPageFlattenFlag2;\n})(PdfPageFlattenFlag || {});\nvar PdfPageFlattenResult = /* @__PURE__ */ ((PdfPageFlattenResult2) => {\n  PdfPageFlattenResult2[PdfPageFlattenResult2[\"Fail\"] = 0] = \"Fail\";\n  PdfPageFlattenResult2[PdfPageFlattenResult2[\"Success\"] = 1] = \"Success\";\n  PdfPageFlattenResult2[PdfPageFlattenResult2[\"NothingToDo\"] = 2] = \"NothingToDo\";\n  return PdfPageFlattenResult2;\n})(PdfPageFlattenResult || {});\nvar PdfErrorCode = /* @__PURE__ */ ((PdfErrorCode2) => {\n  PdfErrorCode2[PdfErrorCode2[\"Ok\"] = 0] = \"Ok\";\n  PdfErrorCode2[PdfErrorCode2[\"Unknown\"] = 1] = \"Unknown\";\n  PdfErrorCode2[PdfErrorCode2[\"NotFound\"] = 2] = \"NotFound\";\n  PdfErrorCode2[PdfErrorCode2[\"WrongFormat\"] = 3] = \"WrongFormat\";\n  PdfErrorCode2[PdfErrorCode2[\"Password\"] = 4] = \"Password\";\n  PdfErrorCode2[PdfErrorCode2[\"Security\"] = 5] = \"Security\";\n  PdfErrorCode2[PdfErrorCode2[\"PageError\"] = 6] = \"PageError\";\n  PdfErrorCode2[PdfErrorCode2[\"XFALoad\"] = 7] = \"XFALoad\";\n  PdfErrorCode2[PdfErrorCode2[\"XFALayout\"] = 8] = \"XFALayout\";\n  PdfErrorCode2[PdfErrorCode2[\"Cancelled\"] = 9] = \"Cancelled\";\n  PdfErrorCode2[PdfErrorCode2[\"Initialization\"] = 10] = \"Initialization\";\n  PdfErrorCode2[PdfErrorCode2[\"NotReady\"] = 11] = \"NotReady\";\n  PdfErrorCode2[PdfErrorCode2[\"NotSupport\"] = 12] = \"NotSupport\";\n  PdfErrorCode2[PdfErrorCode2[\"LoadDoc\"] = 13] = \"LoadDoc\";\n  PdfErrorCode2[PdfErrorCode2[\"DocNotOpen\"] = 14] = \"DocNotOpen\";\n  PdfErrorCode2[PdfErrorCode2[\"CantCloseDoc\"] = 15] = \"CantCloseDoc\";\n  PdfErrorCode2[PdfErrorCode2[\"CantCreateNewDoc\"] = 16] = \"CantCreateNewDoc\";\n  PdfErrorCode2[PdfErrorCode2[\"CantImportPages\"] = 17] = \"CantImportPages\";\n  PdfErrorCode2[PdfErrorCode2[\"CantCreateAnnot\"] = 18] = \"CantCreateAnnot\";\n  PdfErrorCode2[PdfErrorCode2[\"CantSetAnnotRect\"] = 19] = \"CantSetAnnotRect\";\n  PdfErrorCode2[PdfErrorCode2[\"CantSetAnnotContent\"] = 20] = \"CantSetAnnotContent\";\n  PdfErrorCode2[PdfErrorCode2[\"CantRemoveInkList\"] = 21] = \"CantRemoveInkList\";\n  PdfErrorCode2[PdfErrorCode2[\"CantAddInkStoke\"] = 22] = \"CantAddInkStoke\";\n  PdfErrorCode2[PdfErrorCode2[\"CantReadAttachmentSize\"] = 23] = \"CantReadAttachmentSize\";\n  PdfErrorCode2[PdfErrorCode2[\"CantReadAttachmentContent\"] = 24] = \"CantReadAttachmentContent\";\n  PdfErrorCode2[PdfErrorCode2[\"CantFocusAnnot\"] = 25] = \"CantFocusAnnot\";\n  PdfErrorCode2[PdfErrorCode2[\"CantSelectText\"] = 26] = \"CantSelectText\";\n  PdfErrorCode2[PdfErrorCode2[\"CantSelectOption\"] = 27] = \"CantSelectOption\";\n  PdfErrorCode2[PdfErrorCode2[\"CantCheckField\"] = 28] = \"CantCheckField\";\n  return PdfErrorCode2;\n})(PdfErrorCode || {});\nvar PdfTaskHelper = class {\n  /**\n   * Create a task\n   * @returns new task\n   */\n  static create() {\n    return new Task();\n  }\n  /**\n   * Create a task that has been resolved with value\n   * @param result - resolved value\n   * @returns resolved task\n   */\n  static resolve(result) {\n    const task = new Task();\n    task.resolve(result);\n    return task;\n  }\n  /**\n   * Create a task that has been rejected with error\n   * @param reason - rejected error\n   * @returns rejected task\n   */\n  static reject(reason) {\n    const task = new Task();\n    task.reject(reason);\n    return task;\n  }\n  /**\n   * Create a task that has been aborted with error\n   * @param reason - aborted error\n   * @returns aborted task\n   */\n  static abort(reason) {\n    const task = new Task();\n    task.reject(reason);\n    return task;\n  }\n};\n\n// src/color.ts\nfunction pdfAlphaColorToWebAlphaColor(c) {\n  const clamp = (n) => Math.max(0, Math.min(255, n));\n  const toHex = (n) => clamp(n).toString(16).padStart(2, \"0\");\n  const color = `#${toHex(c.red)}${toHex(c.green)}${toHex(c.blue)}`;\n  const opacity = clamp(c.alpha) / 255;\n  return { color, opacity };\n}\nfunction webAlphaColorToPdfAlphaColor({ color, opacity }) {\n  if (/^#?[0-9a-f]{3}$/i.test(color)) {\n    color = color.replace(/^#?([0-9a-f])([0-9a-f])([0-9a-f])$/i, \"#$1$1$2$2$3$3\").toLowerCase();\n  }\n  const [, r, g, b] = /^#?([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$/i.exec(color) ?? (() => {\n    throw new Error(`Invalid hex colour: \\u201C${color}\\u201D`);\n  })();\n  const clamp = (n, hi = 255) => Math.max(0, Math.min(hi, n));\n  return {\n    red: parseInt(r, 16),\n    green: parseInt(g, 16),\n    blue: parseInt(b, 16),\n    alpha: clamp(Math.round(opacity * 255))\n  };\n}\n\n// src/date.ts\nfunction pdfDateToDate(pdf) {\n  if (!pdf?.startsWith(\"D:\") || pdf.length < 16) return;\n  const y = +pdf.slice(2, 6);\n  const mo = +pdf.slice(6, 8) - 1;\n  const d = +pdf.slice(8, 10);\n  const H = +pdf.slice(10, 12);\n  const M = +pdf.slice(12, 14);\n  const S = +pdf.slice(14, 16);\n  return new Date(Date.UTC(y, mo, d, H, M, S));\n}\nfunction dateToPdfDate(date = /* @__PURE__ */ new Date()) {\n  const z = (n, len = 2) => n.toString().padStart(len, \"0\");\n  const YYYY = date.getUTCFullYear();\n  const MM = z(date.getUTCMonth() + 1);\n  const DD = z(date.getUTCDate());\n  const HH = z(date.getUTCHours());\n  const mm = z(date.getUTCMinutes());\n  const SS = z(date.getUTCSeconds());\n  return `D:${YYYY}${MM}${DD}${HH}${mm}${SS}`;\n}\n\n// src/index.ts\nfunction ignore() {\n}\nexport {\n  AllLogger,\n  AppearanceMode,\n  ConsoleLogger,\n  LevelLogger,\n  LogLevel,\n  MatchFlag,\n  MixedBlendMode,\n  NoopLogger,\n  PDF_FORM_FIELD_FLAG,\n  PDF_FORM_FIELD_TYPE,\n  PdfActionType,\n  PdfAnnotationBorderStyle,\n  PdfAnnotationColorType,\n  PdfAnnotationFlagName,\n  PdfAnnotationFlags,\n  PdfAnnotationObjectStatus,\n  PdfAnnotationState,\n  PdfAnnotationStateModel,\n  PdfAnnotationSubtype,\n  PdfAnnotationSubtypeName,\n  PdfBlendMode,\n  PdfBomOrZwnbsp,\n  PdfEngineFeature,\n  PdfEngineOperation,\n  PdfErrorCode,\n  PdfNonCharacterFFFE,\n  PdfNonCharacterFFFF,\n  PdfPageFlattenFlag,\n  PdfPageFlattenResult,\n  PdfPageObjectType,\n  PdfPermission,\n  PdfSegmentObjectType,\n  PdfSoftHyphenMarker,\n  PdfTaskHelper,\n  PdfUnwantedTextMarkers,\n  PdfUnwantedTextRegex,\n  PdfWordJoiner,\n  PdfZeroWidthSpace,\n  PdfZoomMode,\n  PerfLogger,\n  Rotation,\n  Task,\n  TaskAbortedError,\n  TaskRejectedError,\n  TaskStage,\n  blendModeLabel,\n  blendModeSelectOptions,\n  blendModeToCss,\n  boundingRect,\n  calculateAngle,\n  calculateDegree,\n  compareSearchTarget,\n  cssToBlendMode,\n  dateToPdfDate,\n  flagsToNames,\n  getBlendModeInfo,\n  ignore,\n  makeMatrix,\n  namesToFlags,\n  pdfAlphaColorToWebAlphaColor,\n  pdfDateToDate,\n  quadToRect,\n  rectToQuad,\n  reduceBlendModes,\n  restoreOffset,\n  restorePosition,\n  restoreRect,\n  rotatePosition,\n  rotateRect,\n  scalePosition,\n  scaleRect,\n  stripPdfUnwantedMarkers,\n  swap,\n  toIntPos,\n  toIntRect,\n  toIntSize,\n  transformPosition,\n  transformRect,\n  transformSize,\n  uiBlendModeDisplay,\n  unionFlags,\n  webAlphaColorToPdfAlphaColor\n};\n//# sourceMappingURL=index.js.map","import { Action } from '@embedpdf/core';\nimport { PdfPageGeometry, Rect } from '@embedpdf/models';\nimport { SelectionRangeX } from './types';\n\nexport const CACHE_PAGE_GEOMETRY = 'CACHE_PAGE_GEOMETRY';\nexport const SET_SELECTION = 'SET_SELECTION';\nexport const START_SELECTION = 'START_SELECTION';\nexport const END_SELECTION = 'END_SELECTION';\nexport const CLEAR_SELECTION = 'CLEAR_SELECTION';\nexport const SET_RECTS = 'SET_RECTS';\nexport const SET_SLICES = 'SET_SLICES';\nexport const RESET = 'RESET';\n\nexport interface CachePageGeometryAction extends Action {\n  type: typeof CACHE_PAGE_GEOMETRY;\n  payload: { page: number; geo: PdfPageGeometry };\n}\nexport interface SetSelectionAction extends Action {\n  type: typeof SET_SELECTION;\n  payload: SelectionRangeX | null;\n}\n\nexport interface StartSelectionAction extends Action {\n  type: typeof START_SELECTION;\n}\n\nexport interface EndSelectionAction extends Action {\n  type: typeof END_SELECTION;\n}\n\nexport interface ClearSelectionAction extends Action {\n  type: typeof CLEAR_SELECTION;\n}\n\nexport interface SetRectsAction extends Action {\n  type: typeof SET_RECTS;\n  payload: Record<number, Rect[]>;\n}\n\nexport interface SetSlicesAction extends Action {\n  type: typeof SET_SLICES;\n  payload: Record<number, { start: number; count: number }>;\n}\n\nexport interface ResetAction extends Action {\n  type: typeof RESET;\n}\n\nexport type SelectionAction =\n  | CachePageGeometryAction\n  | SetSelectionAction\n  | StartSelectionAction\n  | EndSelectionAction\n  | ClearSelectionAction\n  | SetRectsAction\n  | SetSlicesAction\n  | ResetAction;\n\nexport const cachePageGeometry = (page: number, geo: PdfPageGeometry): CachePageGeometryAction => ({\n  type: CACHE_PAGE_GEOMETRY,\n  payload: { page, geo },\n});\n\nexport const setSelection = (sel: SelectionRangeX): SetSelectionAction => ({\n  type: SET_SELECTION,\n  payload: sel,\n});\n\nexport const startSelection = (): StartSelectionAction => ({ type: START_SELECTION });\n\nexport const endSelection = (): EndSelectionAction => ({ type: END_SELECTION });\n\nexport const clearSelection = (): ClearSelectionAction => ({ type: CLEAR_SELECTION });\n\nexport const setRects = (allRects: Record<number, Rect[]>): SetRectsAction => ({\n  type: SET_RECTS,\n  payload: allRects,\n});\n\nexport const setSlices = (\n  slices: Record<number, { start: number; count: number }>,\n): SetSlicesAction => ({ type: SET_SLICES, payload: slices });\n\nexport const reset = (): ResetAction => ({ type: RESET });\n","import { Rect, boundingRect } from '@embedpdf/models';\nimport { FormattedSelection, SelectionState } from './types';\n\nexport function selectRectsForPage(state: SelectionState, page: number) {\n  return state.rects[page] ?? [];\n}\n\nexport function selectBoundingRectForPage(state: SelectionState, page: number) {\n  return boundingRect(selectRectsForPage(state, page));\n}\n\nexport function selectRectsAndBoundingRectForPage(state: SelectionState, page: number) {\n  return {\n    rects: selectRectsForPage(state, page),\n    boundingRect: selectBoundingRectForPage(state, page),\n  };\n}\n\nexport function selectBoundingRectsForAllPages(state: SelectionState) {\n  const out: { page: number; rect: Rect }[] = [];\n  const rectMap = state.rects;\n\n  for (const key in rectMap) {\n    const page = Number(key);\n    const bRect = boundingRect(rectMap[page]);\n    if (bRect) out.push({ page, rect: bRect });\n  }\n  return out;\n}\n\nexport function getFormattedSelectionForPage(\n  state: SelectionState,\n  page: number,\n): FormattedSelection | null {\n  const segmentRects = state.rects[page] || [];\n  if (segmentRects.length === 0) return null;\n  const boundingRect = selectBoundingRectForPage(state, page);\n  if (!boundingRect) return null;\n  return { pageIndex: page, rect: boundingRect, segmentRects };\n}\n\nexport function getFormattedSelection(state: SelectionState) {\n  const result: FormattedSelection[] = [];\n\n  // Get all pages that have rects\n  const pages = Object.keys(state.rects).map(Number);\n\n  for (const pageIndex of pages) {\n    const segmentRects = state.rects[pageIndex] || [];\n\n    if (segmentRects.length === 0) continue;\n\n    // Calculate bounding rect for this page\n    const boundingRect = selectBoundingRectForPage(state, pageIndex);\n\n    if (boundingRect) {\n      result.push({\n        pageIndex,\n        rect: boundingRect,\n        segmentRects,\n      });\n    }\n  }\n\n  return result;\n}\n","import { PdfPageGeometry, Position, Rect } from '@embedpdf/models';\nimport { SelectionRangeX } from './types';\n\n/**\n * Hit-test helper using runs\n * @param geo - page geometry\n * @param pt - point\n * @returns glyph index\n */\nexport function glyphAt(geo: PdfPageGeometry, pt: Position) {\n  for (const run of geo.runs) {\n    const inRun =\n      pt.y >= run.rect.y &&\n      pt.y <= run.rect.y + run.rect.height &&\n      pt.x >= run.rect.x &&\n      pt.x <= run.rect.x + run.rect.width;\n\n    if (!inRun) continue;\n\n    // Simply check if the point is within any glyph's bounding box\n    const rel = run.glyphs.findIndex(\n      (g) => pt.x >= g.x && pt.x <= g.x + g.width && pt.y >= g.y && pt.y <= g.y + g.height,\n    );\n\n    if (rel !== -1) {\n      return run.charStart + rel;\n    }\n  }\n  return -1;\n}\n\n/**\n * Helper: min/max glyph indices on `page` for current sel\n * @param sel - selection range\n * @param geo - page geometry\n * @param page - page index\n * @returns { from: number; to: number } | null\n */\nexport function sliceBounds(\n  sel: SelectionRangeX | null,\n  geo: PdfPageGeometry | undefined,\n  page: number,\n): { from: number; to: number } | null {\n  if (!sel || !geo) return null;\n  if (page < sel.start.page || page > sel.end.page) return null;\n\n  const from = page === sel.start.page ? sel.start.index : 0;\n\n  const lastRun = geo.runs[geo.runs.length - 1];\n  const lastCharOnPage = lastRun.charStart + lastRun.glyphs.length - 1;\n\n  const to = page === sel.end.page ? sel.end.index : lastCharOnPage;\n\n  return { from, to };\n}\n\n/**\n * Helper: build rects for a slice of the page\n * @param geo - page geometry\n * @param from - from index\n * @param to - to index\n * @param merge - whether to merge adjacent rects (default: true)\n * @returns rects\n */\nexport function rectsWithinSlice(\n  geo: PdfPageGeometry,\n  from: number,\n  to: number,\n  merge: boolean = true,\n): Rect[] {\n  const textRuns: TextRunInfo[] = [];\n\n  for (const run of geo.runs) {\n    const runStart = run.charStart;\n    const runEnd = runStart + run.glyphs.length - 1;\n    if (runEnd < from || runStart > to) continue;\n\n    const sIdx = Math.max(from, runStart) - runStart;\n    const eIdx = Math.min(to, runEnd) - runStart;\n\n    let minX = Infinity,\n      maxX = -Infinity;\n    let minY = Infinity,\n      maxY = -Infinity;\n    let charCount = 0;\n\n    for (let i = sIdx; i <= eIdx; i++) {\n      const g = run.glyphs[i];\n      if (g.flags === 2) continue; // empty glyph\n\n      minX = Math.min(minX, g.x);\n      maxX = Math.max(maxX, g.x + g.width);\n      minY = Math.min(minY, g.y);\n      maxY = Math.max(maxY, g.y + g.height);\n      charCount++;\n    }\n\n    if (minX !== Infinity && charCount > 0) {\n      textRuns.push({\n        rect: {\n          origin: { x: minX, y: minY },\n          size: { width: maxX - minX, height: maxY - minY },\n        },\n        charCount,\n      });\n    }\n  }\n\n  // If merge is false, just return the individual rects\n  if (!merge) {\n    return textRuns.map((run) => run.rect);\n  }\n\n  // Otherwise merge adjacent rects\n  return mergeAdjacentRects(textRuns);\n}\n\n/**\n * ============================================================================\n * Rectangle Merging Algorithm\n * ============================================================================\n *\n * The following code is adapted from Chromium's PDF text selection implementation.\n *\n * Copyright 2010 The Chromium Authors\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file: https://source.chromium.org/chromium/chromium/src/+/main:LICENSE\n *\n * Original source:\n * https://source.chromium.org/chromium/chromium/src/+/main:pdf/pdfium/pdfium_range.cc\n *\n * Adapted for TypeScript and this project's Rect/geometry types.\n */\n\n/**\n * Text run info for rect merging (similar to Chromium's ScreenRectTextRunInfo)\n */\nexport interface TextRunInfo {\n  rect: Rect;\n  charCount: number;\n}\n\n/**\n * Helper functions for Rect operations\n */\nexport function rectUnion(rect1: Rect, rect2: Rect): Rect {\n  const left = Math.min(rect1.origin.x, rect2.origin.x);\n  const top = Math.min(rect1.origin.y, rect2.origin.y);\n  const right = Math.max(rect1.origin.x + rect1.size.width, rect2.origin.x + rect2.size.width);\n  const bottom = Math.max(rect1.origin.y + rect1.size.height, rect2.origin.y + rect2.size.height);\n\n  return {\n    origin: { x: left, y: top },\n    size: { width: right - left, height: bottom - top },\n  };\n}\n\nexport function rectIntersect(rect1: Rect, rect2: Rect): Rect {\n  const left = Math.max(rect1.origin.x, rect2.origin.x);\n  const top = Math.max(rect1.origin.y, rect2.origin.y);\n  const right = Math.min(rect1.origin.x + rect1.size.width, rect2.origin.x + rect2.size.width);\n  const bottom = Math.min(rect1.origin.y + rect1.size.height, rect2.origin.y + rect2.size.height);\n\n  const width = Math.max(0, right - left);\n  const height = Math.max(0, bottom - top);\n\n  return {\n    origin: { x: left, y: top },\n    size: { width, height },\n  };\n}\n\nexport function rectIsEmpty(rect: Rect): boolean {\n  return rect.size.width <= 0 || rect.size.height <= 0;\n}\n\n/**\n * Returns a ratio between [0, 1] representing vertical overlap\n */\nexport function getVerticalOverlap(rect1: Rect, rect2: Rect): number {\n  if (rectIsEmpty(rect1) || rectIsEmpty(rect2)) return 0;\n\n  const unionRect = rectUnion(rect1, rect2);\n\n  if (unionRect.size.height === rect1.size.height || unionRect.size.height === rect2.size.height) {\n    return 1.0;\n  }\n\n  const intersectRect = rectIntersect(rect1, rect2);\n  return intersectRect.size.height / unionRect.size.height;\n}\n\n/**\n * Returns true if there is sufficient horizontal and vertical overlap\n */\nexport function shouldMergeHorizontalRects(textRun1: TextRunInfo, textRun2: TextRunInfo): boolean {\n  const VERTICAL_OVERLAP_THRESHOLD = 0.8;\n  const rect1 = textRun1.rect;\n  const rect2 = textRun2.rect;\n\n  if (getVerticalOverlap(rect1, rect2) < VERTICAL_OVERLAP_THRESHOLD) {\n    return false;\n  }\n\n  const HORIZONTAL_WIDTH_FACTOR = 1.0;\n  const averageWidth1 = (HORIZONTAL_WIDTH_FACTOR * rect1.size.width) / textRun1.charCount;\n  const averageWidth2 = (HORIZONTAL_WIDTH_FACTOR * rect2.size.width) / textRun2.charCount;\n\n  const rect1Left = rect1.origin.x - averageWidth1;\n  const rect1Right = rect1.origin.x + rect1.size.width + averageWidth1;\n  const rect2Left = rect2.origin.x - averageWidth2;\n  const rect2Right = rect2.origin.x + rect2.size.width + averageWidth2;\n\n  return rect1Left < rect2Right && rect1Right > rect2Left;\n}\n\n/**\n * Merge adjacent rectangles based on proximity and overlap (similar to Chromium's algorithm)\n */\nexport function mergeAdjacentRects(textRuns: TextRunInfo[]): Rect[] {\n  const results: Rect[] = [];\n  let previousTextRun: TextRunInfo | null = null;\n  let currentRect: Rect | null = null;\n\n  for (const textRun of textRuns) {\n    if (previousTextRun && currentRect) {\n      if (shouldMergeHorizontalRects(previousTextRun, textRun)) {\n        currentRect = rectUnion(currentRect, textRun.rect);\n      } else {\n        results.push(currentRect);\n        currentRect = textRun.rect;\n      }\n    } else {\n      currentRect = textRun.rect;\n    }\n    previousTextRun = textRun;\n  }\n\n  if (currentRect && !rectIsEmpty(currentRect)) {\n    results.push(currentRect);\n  }\n\n  return results;\n}\n","import {\n  BasePlugin,\n  PluginRegistry,\n  SET_DOCUMENT,\n  createBehaviorEmitter,\n  createEmitter,\n} from '@embedpdf/core';\nimport {\n  PdfEngine,\n  PdfPageGeometry,\n  Rect,\n  PdfTask,\n  PdfTaskHelper,\n  PdfErrorCode,\n  ignore,\n  PageTextSlice,\n} from '@embedpdf/models';\n\nimport {\n  cachePageGeometry,\n  setSelection,\n  SelectionAction,\n  endSelection,\n  startSelection,\n  clearSelection,\n  reset,\n  setRects,\n  setSlices,\n} from './actions';\nimport * as selector from './selectors';\nimport {\n  SelectionCapability,\n  SelectionPluginConfig,\n  SelectionRangeX,\n  SelectionState,\n} from './types';\nimport { sliceBounds, rectsWithinSlice } from './utils';\n\nexport class SelectionPlugin extends BasePlugin<\n  SelectionPluginConfig,\n  SelectionCapability,\n  SelectionState,\n  SelectionAction\n> {\n  static readonly id = 'selection' as const;\n\n  /** Modes that should trigger text-selection logic */\n  private enabledModes = new Set<string>(['default']);\n\n  /* interactive state */\n  private selecting = false;\n  private anchor?: { page: number; index: number };\n\n  private readonly selChange$ = createBehaviorEmitter<SelectionState['selection']>();\n  private readonly textRetrieved$ = createBehaviorEmitter<string[]>();\n  private readonly copyToClipboard$ = createEmitter<string>();\n  private readonly beginSelection$ = createEmitter<{ page: number; index: number }>();\n  private readonly endSelection$ = createEmitter<void>();\n\n  constructor(\n    id: string,\n    registry: PluginRegistry,\n    private engine: PdfEngine,\n  ) {\n    super(id, registry);\n\n    this.coreStore.onAction(SET_DOCUMENT, (_action) => {\n      this.dispatch(reset());\n    });\n  }\n\n  /* ── life-cycle ────────────────────────────────────────── */\n  async initialize() {}\n  async destroy() {\n    this.selChange$.clear();\n  }\n\n  /* ── capability exposed to UI / other plugins ─────────── */\n  buildCapability(): SelectionCapability {\n    return {\n      getGeometry: (p) => this.getOrLoadGeometry(p),\n      getFormattedSelection: () => selector.getFormattedSelection(this.state),\n      getFormattedSelectionForPage: (p) => selector.getFormattedSelectionForPage(this.state, p),\n      getHighlightRectsForPage: (p) => selector.selectRectsForPage(this.state, p),\n      getHighlightRects: () => this.state.rects,\n      getBoundingRectForPage: (p) => selector.selectBoundingRectForPage(this.state, p),\n      getBoundingRects: () => selector.selectBoundingRectsForAllPages(this.state),\n      begin: (p, i) => this.beginSelection(p, i),\n      update: (p, i) => this.updateSelection(p, i),\n      end: () => this.endSelection(),\n      clear: () => this.clearSelection(),\n      onCopyToClipboard: this.copyToClipboard$.on,\n      onSelectionChange: this.selChange$.on,\n      onTextRetrieved: this.textRetrieved$.on,\n      onBeginSelection: this.beginSelection$.on,\n      onEndSelection: this.endSelection$.on,\n      getSelectedText: () => this.getSelectedText(),\n      copyToClipboard: () => this.copyToClipboard(),\n      enableForMode: (id: string) => this.enabledModes.add(id),\n      isEnabledForMode: (id: string) => this.enabledModes.has(id),\n      getState: () => this.state,\n    };\n  }\n\n  /* ── geometry cache ───────────────────────────────────── */\n  private getOrLoadGeometry(pageIdx: number): PdfTask<PdfPageGeometry> {\n    const cached = this.state.geometry[pageIdx];\n    if (cached) return PdfTaskHelper.resolve(cached);\n\n    if (!this.coreState.core.document)\n      return PdfTaskHelper.reject({ code: PdfErrorCode.NotFound, message: 'Doc Not Found' });\n    const page = this.coreState.core.document.pages.find((p) => p.index === pageIdx)!;\n\n    const task = this.engine.getPageGeometry(this.coreState.core.document, page);\n\n    task.wait((geo) => {\n      this.dispatch(cachePageGeometry(pageIdx, geo));\n    }, ignore);\n\n    return task;\n  }\n\n  /* ── selection state updates ───────────────────────────── */\n  private beginSelection(page: number, index: number) {\n    this.selecting = true;\n    this.anchor = { page, index };\n    this.dispatch(startSelection());\n    this.beginSelection$.emit({ page, index });\n  }\n\n  private endSelection() {\n    this.selecting = false;\n    this.anchor = undefined;\n    this.dispatch(endSelection());\n    this.endSelection$.emit();\n  }\n\n  private clearSelection() {\n    this.selecting = false;\n    this.anchor = undefined;\n    this.dispatch(clearSelection());\n    this.selChange$.emit(null);\n  }\n\n  private updateSelection(page: number, index: number) {\n    if (!this.selecting || !this.anchor) return;\n\n    const a = this.anchor;\n    const forward = page > a.page || (page === a.page && index >= a.index);\n\n    const start = forward ? a : { page, index };\n    const end = forward ? { page, index } : a;\n\n    const range = { start, end };\n    this.dispatch(setSelection(range));\n    this.updateRectsAndSlices(range);\n    this.selChange$.emit(range);\n  }\n\n  private updateRectsAndSlices(range: SelectionRangeX) {\n    const allRects: Record<number, Rect[]> = {};\n    const allSlices: Record<number, { start: number; count: number }> = {};\n\n    for (let p = range.start.page; p <= range.end.page; p++) {\n      const geo = this.state.geometry[p];\n      const sb = sliceBounds(range, geo, p);\n      if (!sb) continue;\n\n      allRects[p] = rectsWithinSlice(geo!, sb.from, sb.to);\n      allSlices[p] = { start: sb.from, count: sb.to - sb.from + 1 };\n    }\n\n    this.dispatch(setRects(allRects));\n    this.dispatch(setSlices(allSlices));\n  }\n\n  private getSelectedText(): PdfTask<string[]> {\n    if (!this.coreState.core.document || !this.state.selection) {\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.NotFound,\n        message: 'Doc Not Found or No Selection',\n      });\n    }\n\n    const sel = this.state.selection;\n    const req: PageTextSlice[] = [];\n\n    for (let p = sel.start.page; p <= sel.end.page; p++) {\n      const s = this.state.slices[p];\n      if (s) req.push({ pageIndex: p, charIndex: s.start, charCount: s.count });\n    }\n\n    if (req.length === 0) return PdfTaskHelper.resolve([] as string[]);\n\n    const task = this.engine.getTextSlices(this.coreState.core.document, req);\n\n    // Emit the text when it's retrieved\n    task.wait((text) => {\n      this.textRetrieved$.emit(text);\n    }, ignore);\n\n    return task;\n  }\n\n  private copyToClipboard() {\n    const text = this.getSelectedText();\n    text.wait((text) => {\n      this.copyToClipboard$.emit(text.join('\\n'));\n    }, ignore);\n  }\n}\n","var M = \"­\", H = \"​\", T = \"⁠\", $ = \"\\uFEFF\", R = \"￾\", I = \"￿\", P = Object.freeze([\n  M,\n  H,\n  T,\n  $,\n  R,\n  I\n]);\nnew RegExp(`[${P.join(\"\")}]`, \"g\");\nvar y = Object.freeze([\n  { id: 0, label: \"Normal\", css: \"normal\" },\n  { id: 1, label: \"Multiply\", css: \"multiply\" },\n  { id: 2, label: \"Screen\", css: \"screen\" },\n  { id: 3, label: \"Overlay\", css: \"overlay\" },\n  { id: 4, label: \"Darken\", css: \"darken\" },\n  { id: 5, label: \"Lighten\", css: \"lighten\" },\n  { id: 6, label: \"Color Dodge\", css: \"color-dodge\" },\n  { id: 7, label: \"Color Burn\", css: \"color-burn\" },\n  { id: 8, label: \"Hard Light\", css: \"hard-light\" },\n  { id: 9, label: \"Soft Light\", css: \"soft-light\" },\n  { id: 10, label: \"Difference\", css: \"difference\" },\n  { id: 11, label: \"Exclusion\", css: \"exclusion\" },\n  { id: 12, label: \"Hue\", css: \"hue\" },\n  { id: 13, label: \"Saturation\", css: \"saturation\" },\n  { id: 14, label: \"Color\", css: \"color\" },\n  { id: 15, label: \"Luminosity\", css: \"luminosity\" }\n]);\ny.reduce(\n  (o, t) => (o[t.id] = t, o),\n  {}\n);\ny.reduce((o, t) => (o[t.css] = t.id, o), {});\ny.map((o) => ({\n  value: o.id,\n  label: o.label\n}));\nvar k = Object.freeze({\n  1: \"invisible\",\n  2: \"hidden\",\n  4: \"print\",\n  8: \"noZoom\",\n  16: \"noRotate\",\n  32: \"noView\",\n  64: \"readOnly\",\n  128: \"locked\",\n  256: \"toggleNoView\"\n});\nObject.entries(\n  k\n).reduce(\n  (o, [t, e]) => (o[e] = Number(t), o),\n  {}\n);\nfunction g(o, t, e) {\n  if (o === t)\n    return !0;\n  if (o == null || t == null)\n    return o === t;\n  const s = typeof o;\n  if (s !== typeof t) return !1;\n  if (s === \"object\") {\n    e || (e = /* @__PURE__ */ new Set());\n    const i = O(o, t);\n    if (e.has(i))\n      return !0;\n    e.add(i);\n    const r = Array.isArray(o), a = Array.isArray(t);\n    return r && a ? N(o, t, e) : !r && !a ? U(o, t, e) : !1;\n  }\n  return !1;\n}\nfunction O(o, t) {\n  return `${C(o)}__${C(t)}`;\n}\nlet F = 0;\nconst b = /* @__PURE__ */ new WeakMap();\nfunction C(o) {\n  return b.has(o) || b.set(o, ++F), b.get(o);\n}\nfunction N(o, t, e) {\n  if (o.length !== t.length) return !1;\n  const s = new Array(t.length).fill(!1);\n  t: for (let i = 0; i < o.length; i++) {\n    const r = o[i];\n    for (let a = 0; a < t.length; a++)\n      if (!s[a] && g(r, t[a], e)) {\n        s[a] = !0;\n        continue t;\n      }\n    return !1;\n  }\n  return !0;\n}\nfunction U(o, t, e) {\n  const s = Object.keys(o).sort(), i = Object.keys(t).sort();\n  if (s.length !== i.length) return !1;\n  for (let r = 0; r < s.length; r++)\n    if (s[r] !== i[r]) return !1;\n  for (const r of s) {\n    const a = o[r], n = t[r];\n    if (!g(a, n, e))\n      return !1;\n  }\n  return !0;\n}\nclass _ {\n  constructor(t, e) {\n    if (this.id = t, this.registry = e, this.debouncedActions = {}, this.unsubscribeFromState = null, this.unsubscribeFromCoreStore = null, t !== this.constructor.id)\n      throw new Error(\n        `Plugin ID mismatch: ${t} !== ${this.constructor.id}`\n      );\n    this.coreStore = this.registry.getStore(), this.pluginStore = this.coreStore.getPluginStore(this.id), this.unsubscribeFromState = this.pluginStore.subscribeToState((s, i, r) => {\n      this.onStoreUpdated(r, i);\n    }), this.unsubscribeFromCoreStore = this.coreStore.subscribe((s, i, r) => {\n      this.onCoreStoreUpdated(r, i);\n    }), this.readyPromise = new Promise((s) => {\n      this.readyResolve = s;\n    }), this.readyResolve();\n  }\n  provides() {\n    if (!this._capability) {\n      const t = this.buildCapability();\n      this._capability = Object.freeze(t);\n    }\n    return this._capability;\n  }\n  /**\n   *  Get a copy of the current state\n   */\n  get state() {\n    return this.pluginStore.getState();\n  }\n  /**\n   *  Get a copy of the current core state\n   */\n  get coreState() {\n    return this.coreStore.getState();\n  }\n  /**\n   * @deprecated  use `this.state` Get a copy of the current state\n   */\n  getState() {\n    return this.pluginStore.getState();\n  }\n  /**\n   * @deprecated  use `this.coreState` Get a copy of the current core state\n   */\n  getCoreState() {\n    return this.coreStore.getState();\n  }\n  /**\n   * Core Dispatch\n   */\n  dispatchCoreAction(t) {\n    return this.coreStore.dispatchToCore(t);\n  }\n  /**\n   * Dispatch an action to all plugins\n   */\n  dispatchToAllPlugins(t) {\n    return this.coreStore.dispatch(t);\n  }\n  /**\n   * Dispatch an action\n   */\n  dispatch(t) {\n    return this.pluginStore.dispatch(t);\n  }\n  /**\n   * Dispatch an action with debouncing to prevent rapid repeated calls\n   * @param action The action to dispatch\n   * @param debounceTime Time in ms to debounce (default: 100ms)\n   * @returns boolean indicating whether the action was dispatched or debounced\n   */\n  debouncedDispatch(t, e = 100) {\n    const s = Date.now(), i = this.debouncedActions[t.type] || 0;\n    return s - i >= e ? (this.debouncedActions[t.type] = s, this.dispatch(t), !0) : !1;\n  }\n  /**\n   * Subscribe to state changes\n   */\n  subscribe(t) {\n    return this.pluginStore.subscribeToState(t);\n  }\n  /**\n   * Subscribe to core store changes\n   */\n  subscribeToCoreStore(t) {\n    return this.coreStore.subscribe(t);\n  }\n  /**\n   * Called when the plugin store state is updated\n   * @param oldState Previous state\n   * @param newState New state\n   */\n  onStoreUpdated(t, e) {\n  }\n  /**\n   * Called when the core store state is updated\n   * @param oldState Previous state\n   * @param newState New state\n   */\n  onCoreStoreUpdated(t, e) {\n  }\n  /**\n   * Cleanup method to be called when plugin is being destroyed\n   */\n  destroy() {\n    this.unsubscribeFromState && (this.unsubscribeFromState(), this.unsubscribeFromState = null), this.unsubscribeFromCoreStore && (this.unsubscribeFromCoreStore(), this.unsubscribeFromCoreStore = null);\n  }\n  /**\n   * Returns a promise that resolves when the plugin is ready\n   */\n  ready() {\n    return this.readyPromise;\n  }\n  /**\n   * Mark the plugin as ready\n   */\n  markReady() {\n    this.readyResolve();\n  }\n  /**\n   * Reset the ready state (useful for plugins that need to reinitialize)\n   */\n  resetReady() {\n    this.readyPromise = new Promise((t) => {\n      this.readyResolve = t;\n    });\n  }\n}\nclass x {\n  constructor(t, e) {\n    this.handler = t, this.options = e, this.lastRun = 0, this.handle = (s) => {\n      this.options.mode === \"debounce\" ? this.debounce(s) : this.throttle(s);\n    };\n  }\n  debounce(t) {\n    this.timeoutId && window.clearTimeout(this.timeoutId), this.timeoutId = window.setTimeout(() => {\n      this.handler(t), this.timeoutId = void 0;\n    }, this.options.wait);\n  }\n  throttle(t) {\n    if (this.options.mode === \"debounce\") return;\n    const e = Date.now(), s = this.options.throttleMode || \"leading-trailing\";\n    e - this.lastRun >= this.options.wait && (s === \"leading-trailing\" && this.handler(t), this.lastRun = e), this.timeoutId && window.clearTimeout(this.timeoutId), this.timeoutId = window.setTimeout(\n      () => {\n        this.handler(t), this.lastRun = Date.now(), this.timeoutId = void 0;\n      },\n      this.options.wait - (e - this.lastRun)\n    );\n  }\n  destroy() {\n    this.timeoutId && window.clearTimeout(this.timeoutId);\n  }\n}\nfunction p() {\n  const o = /* @__PURE__ */ new Set();\n  return {\n    emit: (t = void 0) => o.forEach((e) => e(t)),\n    on: (t) => (o.add(t), () => o.delete(t)),\n    off: (t) => o.delete(t),\n    clear: () => o.clear()\n  };\n}\nfunction D(o, t = g) {\n  const e = /* @__PURE__ */ new Set(), s = /* @__PURE__ */ new Map();\n  let i = o;\n  const r = (n) => e.forEach((c) => c(n)), a = (n, c) => {\n    let u = n, h = () => {\n    };\n    if (c) {\n      const l = new x(n, c);\n      u = l.handle, h = () => l.destroy(), s.set(n, { wrapped: u, destroy: h });\n    }\n    return i !== void 0 && u(i), e.add(u), () => {\n      e.delete(u), h(), s.delete(n);\n    };\n  };\n  return {\n    /* emitter behaviour ---------------------------------------- */\n    get value() {\n      return i;\n    },\n    emit(n = void 0) {\n      (i === void 0 || !t(i, n)) && (i = n, r(n));\n    },\n    on: a,\n    off(n) {\n      const c = s.get(n);\n      c ? (e.delete(c.wrapped), c.destroy(), s.delete(n)) : e.delete(n);\n    },\n    clear() {\n      e.clear(), s.forEach((n) => n.destroy()), s.clear();\n    },\n    /* derived hook --------------------------------------------- */\n    select(n, c = g) {\n      return (u, h) => {\n        let l;\n        if (i !== void 0) {\n          const d = n(i);\n          l = d, u(d);\n        }\n        return a(\n          (d) => {\n            const f = n(d);\n            (l === void 0 || !c(l, f)) && (l = f, u(f));\n          },\n          h\n        );\n      };\n    }\n  };\n}\nconst v = \"INTERACTION/ACTIVATE_MODE\", m = \"INTERACTION/PAUSE\", E = \"INTERACTION/RESUME\", A = \"INTERACTION/SET_CURSOR\", j = (o) => ({\n  type: v,\n  payload: { mode: o }\n}), z = (o) => ({\n  type: A,\n  payload: { cursor: o }\n}), G = () => ({\n  type: m\n}), L = () => ({\n  type: E\n});\nfunction V(o) {\n  const t = [\n    \"onPointerDown\",\n    \"onPointerUp\",\n    \"onPointerMove\",\n    \"onPointerEnter\",\n    \"onPointerLeave\",\n    \"onPointerCancel\"\n  ], e = {};\n  for (const s of t)\n    e[s] = (i, r, a) => {\n      var n;\n      for (const c of o) (n = c[s]) == null || n.call(c, i, r, a);\n    };\n  return e;\n}\nconst S = class S extends _ {\n  constructor(t, e) {\n    super(t, e), this.modes = /* @__PURE__ */ new Map(), this.cursorClaims = /* @__PURE__ */ new Map(), this.buckets = /* @__PURE__ */ new Map(), this.alwaysGlobal = /* @__PURE__ */ new Set(), this.alwaysPage = /* @__PURE__ */ new Map(), this.onModeChange$ = p(), this.onHandlerChange$ = p(), this.onCursorChange$ = p(), this.onStateChange$ = D(), this.registerMode({\n      id: \"default\",\n      scope: \"page\",\n      exclusive: !1,\n      cursor: \"auto\"\n    });\n  }\n  async initialize(t) {\n  }\n  buildCapability() {\n    return {\n      activate: (t) => this.activate(t),\n      onModeChange: this.onModeChange$.on,\n      onCursorChange: this.onCursorChange$.on,\n      onHandlerChange: this.onHandlerChange$.on,\n      onStateChange: this.onStateChange$.on,\n      getActiveMode: () => this.state.activeMode,\n      getActiveInteractionMode: () => this.getActiveInteractionMode(),\n      finish: () => this.activate(\"default\"),\n      registerMode: (t) => this.registerMode(t),\n      registerHandlers: (t) => this.registerHandlers(t),\n      registerAlways: (t) => this.registerAlways(t),\n      setCursor: (t, e, s = 0) => this.setCursor(t, e, s),\n      removeCursor: (t) => this.removeCursor(t),\n      getCurrentCursor: () => this.state.cursor,\n      getHandlersForScope: (t) => this.getHandlersForScope(t),\n      activeModeIsExclusive: () => this.activeModeIsExclusive(),\n      pause: () => this.dispatch(G()),\n      resume: () => this.dispatch(L()),\n      isPaused: () => this.state.paused\n    };\n  }\n  activate(t) {\n    if (!this.modes.has(t))\n      throw new Error(`[interaction] unknown mode '${t}'`);\n    if (t === this.state.activeMode) return;\n    const e = this.state.activeMode;\n    this.cursorClaims.clear(), this.notifyHandlersInactive(e), this.dispatch(j(t)), this.emitCursor(), this.notifyHandlersActive(t), this.onModeChange$.emit({ ...this.state, activeMode: t });\n  }\n  notifyHandlersActive(t) {\n    this.alwaysGlobal.forEach((i) => {\n      var r;\n      (r = i.onHandlerActiveStart) == null || r.call(i, t);\n    }), this.alwaysPage.forEach((i) => {\n      i.forEach((r) => {\n        var a;\n        (a = r.onHandlerActiveStart) == null || a.call(r, t);\n      });\n    });\n    const e = this.modes.get(t);\n    if (!e) return;\n    const s = this.buckets.get(t);\n    s && (e.scope === \"global\" && s.global.forEach((i) => {\n      var r;\n      (r = i.onHandlerActiveStart) == null || r.call(i, t);\n    }), e.scope === \"page\" && s.page.forEach((i, r) => {\n      i.forEach((a) => {\n        var n;\n        (n = a.onHandlerActiveStart) == null || n.call(a, t);\n      });\n    }));\n  }\n  notifyHandlersInactive(t) {\n    this.alwaysGlobal.forEach((i) => {\n      var r;\n      (r = i.onHandlerActiveEnd) == null || r.call(i, t);\n    }), this.alwaysPage.forEach((i) => {\n      i.forEach((r) => {\n        var a;\n        (a = r.onHandlerActiveEnd) == null || a.call(r, t);\n      });\n    });\n    const e = this.modes.get(t);\n    if (!e) return;\n    const s = this.buckets.get(t);\n    s && (e.scope === \"global\" && s.global.forEach((i) => {\n      var r;\n      (r = i.onHandlerActiveEnd) == null || r.call(i, t);\n    }), e.scope === \"page\" && s.page.forEach((i, r) => {\n      i.forEach((a) => {\n        var n;\n        (n = a.onHandlerActiveEnd) == null || n.call(a, t);\n      });\n    }));\n  }\n  registerMode(t) {\n    this.modes.set(t.id, t), this.buckets.has(t.id) || this.buckets.set(t.id, { global: /* @__PURE__ */ new Set(), page: /* @__PURE__ */ new Map() });\n  }\n  /** ---------- pointer-handler handling ------------ */\n  registerHandlers({ modeId: t, handlers: e, pageIndex: s }) {\n    const i = Array.isArray(t) ? t : [t], r = [];\n    for (const a of i) {\n      const n = this.buckets.get(a);\n      if (!n) throw new Error(`unknown mode '${a}'`);\n      if (s == null)\n        n.global.add(e);\n      else {\n        const c = n.page.get(s) ?? /* @__PURE__ */ new Set();\n        c.add(e), n.page.set(s, c);\n      }\n      r.push(() => {\n        if (s == null)\n          n.global.delete(e);\n        else {\n          const c = n.page.get(s);\n          c && (c.delete(e), c.size === 0 && n.page.delete(s));\n        }\n      });\n    }\n    return this.onHandlerChange$.emit({ ...this.state }), () => {\n      r.forEach((a) => a()), this.onHandlerChange$.emit({ ...this.state });\n    };\n  }\n  registerAlways({ scope: t, handlers: e }) {\n    if (t.type === \"global\")\n      return this.alwaysGlobal.add(e), this.onHandlerChange$.emit({ ...this.state }), () => this.alwaysGlobal.delete(e);\n    const s = this.alwaysPage.get(t.pageIndex) ?? /* @__PURE__ */ new Set();\n    return s.add(e), this.alwaysPage.set(t.pageIndex, s), this.onHandlerChange$.emit({ ...this.state }), () => {\n      s.delete(e), this.onHandlerChange$.emit({ ...this.state });\n    };\n  }\n  /** Returns the *merged* handler set that should be active for the given\n   *  provider (`global` wrapper or a single page wrapper).\n   *  – `alwaysGlobal` / `alwaysPage` are **always** active.\n   *  – Handlers that belong to the current mode are added on top **iff**\n   *    the mode’s own scope matches the provider’s scope.            */\n  getHandlersForScope(t) {\n    if (!this.state) return null;\n    const e = this.modes.get(this.state.activeMode);\n    if (!e) return null;\n    const s = this.buckets.get(e.id);\n    if (!s) return null;\n    const i = (n, c) => n.size || c.size ? V([...n, ...c]) : null;\n    if (t.type === \"global\") {\n      const n = e.scope === \"global\" ? s.global : /* @__PURE__ */ new Set();\n      return i(this.alwaysGlobal, n);\n    }\n    const r = this.alwaysPage.get(t.pageIndex) ?? /* @__PURE__ */ new Set(), a = e.scope === \"page\" ? s.page.get(t.pageIndex) ?? /* @__PURE__ */ new Set() : /* @__PURE__ */ new Set();\n    return i(r, a);\n  }\n  /** ---------- cursor handling --------------------- */\n  setCursor(t, e, s = 0) {\n    this.cursorClaims.set(t, { cursor: e, priority: s }), this.emitCursor();\n  }\n  removeCursor(t) {\n    this.cursorClaims.delete(t), this.emitCursor();\n  }\n  emitCursor() {\n    var e;\n    const t = [...this.cursorClaims.values()].sort((s, i) => i.priority - s.priority)[0] ?? {\n      cursor: ((e = this.modes.get(this.state.activeMode)) == null ? void 0 : e.cursor) ?? \"auto\"\n    };\n    t.cursor !== this.state.cursor && (this.dispatch(z(t.cursor)), this.onCursorChange$.emit(t.cursor));\n  }\n  onStoreUpdated(t, e) {\n    this.onStateChange$.emit(e);\n  }\n  activeModeIsExclusive() {\n    const t = this.modes.get(this.state.activeMode);\n    return !!(t != null && t.exclusive);\n  }\n  getActiveInteractionMode() {\n    return this.modes.get(this.state.activeMode) ?? null;\n  }\n  // keep emitter clean\n  async destroy() {\n    this.onModeChange$.clear(), this.onCursorChange$.clear(), await super.destroy();\n  }\n};\nS.id = \"interaction-manager\";\nlet w = S;\nconst B = {\n  activeMode: \"default\",\n  cursor: \"auto\",\n  paused: !1\n}, W = (o, t) => {\n  switch (t.type) {\n    case v:\n      return {\n        ...o,\n        activeMode: t.payload.mode\n      };\n    case A:\n      return {\n        ...o,\n        cursor: t.payload.cursor\n      };\n    case m:\n      return {\n        ...o,\n        paused: !0\n      };\n    case E:\n      return {\n        ...o,\n        paused: !1\n      };\n    default:\n      return o;\n  }\n};\nexport {\n  w as I,\n  B as i,\n  W as r\n};\n//# sourceMappingURL=reducer-Dda407Go.js.map\n","function j(e, r, o, l) {\n  let n = e.getHandlersForScope(r);\n  const f = e.onModeChange(() => {\n    if (r.type === \"global\") {\n      const t = e.getActiveInteractionMode();\n      o.style.cursor = (t == null ? void 0 : t.scope) === \"global\" ? t.cursor ?? \"auto\" : \"auto\";\n    }\n    n = e.getHandlersForScope(r);\n  }), y = e.onHandlerChange(() => {\n    n = e.getHandlersForScope(r);\n  }), d = e.getActiveInteractionMode(), b = e.getCurrentCursor();\n  r.type === \"global\" ? o.style.cursor = (d == null ? void 0 : d.scope) === \"global\" ? b : \"auto\" : o.style.cursor = b;\n  const h = e.onCursorChange((t) => {\n    var s;\n    r.type === \"global\" && !(((s = e.getActiveInteractionMode()) == null ? void 0 : s.scope) === \"global\") || (o.style.cursor = t);\n  }), i = {\n    onPointerDown: \"pointerdown\",\n    onPointerUp: \"pointerup\",\n    onPointerMove: \"pointermove\",\n    onPointerEnter: \"pointerenter\",\n    onPointerLeave: \"pointerleave\",\n    onPointerCancel: \"pointercancel\"\n  }, c = {}, v = (t, s) => {\n    if (l) return l(t, s);\n    const a = s.getBoundingClientRect();\n    return { x: t.clientX - a.left, y: t.clientY - a.top };\n  };\n  return Object.keys(i).forEach((t) => {\n    c[t] = (s) => {\n      var g;\n      if (e.isPaused()) return;\n      const a = s, F = e.getActiveMode();\n      (g = n == null ? void 0 : n[t]) == null || g.call(n, v(a, o), a, F);\n    }, o.addEventListener(i[t], c[t]);\n  }), () => {\n    Object.keys(i).forEach(\n      (t) => o.removeEventListener(i[t], c[t])\n    ), f(), h(), y();\n  };\n}\nfunction P(e, r, o) {\n  let l = r.x, n = r.y;\n  switch (o) {\n    case 0:\n      l = r.x, n = r.y;\n      break;\n    case 1:\n      l = e.height - r.y, n = r.x;\n      break;\n    case 2:\n      l = e.width - r.x, n = e.height - r.y;\n      break;\n    case 3:\n      l = r.y, n = e.width - r.x;\n      break;\n  }\n  return {\n    x: l,\n    y: n\n  };\n}\nfunction x(e, r) {\n  return {\n    x: e.x * r,\n    y: e.y * r\n  };\n}\nfunction k(e, r, o, l) {\n  return x(\n    P(e, r, (4 - o) % 4),\n    1 / l\n  );\n}\nvar C = \"­\", M = \"​\", E = \"⁠\", O = \"\\uFEFF\", w = \"￾\", H = \"￿\", L = Object.freeze([\n  C,\n  M,\n  E,\n  O,\n  w,\n  H\n]);\nnew RegExp(`[${L.join(\"\")}]`, \"g\");\nvar u = Object.freeze([\n  { id: 0, label: \"Normal\", css: \"normal\" },\n  { id: 1, label: \"Multiply\", css: \"multiply\" },\n  { id: 2, label: \"Screen\", css: \"screen\" },\n  { id: 3, label: \"Overlay\", css: \"overlay\" },\n  { id: 4, label: \"Darken\", css: \"darken\" },\n  { id: 5, label: \"Lighten\", css: \"lighten\" },\n  { id: 6, label: \"Color Dodge\", css: \"color-dodge\" },\n  { id: 7, label: \"Color Burn\", css: \"color-burn\" },\n  { id: 8, label: \"Hard Light\", css: \"hard-light\" },\n  { id: 9, label: \"Soft Light\", css: \"soft-light\" },\n  { id: 10, label: \"Difference\", css: \"difference\" },\n  { id: 11, label: \"Exclusion\", css: \"exclusion\" },\n  { id: 12, label: \"Hue\", css: \"hue\" },\n  { id: 13, label: \"Saturation\", css: \"saturation\" },\n  { id: 14, label: \"Color\", css: \"color\" },\n  { id: 15, label: \"Luminosity\", css: \"luminosity\" }\n]);\nu.reduce(\n  (e, r) => (e[r.id] = r, e),\n  {}\n);\nu.reduce((e, r) => (e[r.css] = r.id, e), {});\nu.map((e) => ({\n  value: e.id,\n  label: e.label\n}));\nvar N = Object.freeze({\n  1: \"invisible\",\n  2: \"hidden\",\n  4: \"print\",\n  8: \"noZoom\",\n  16: \"noRotate\",\n  32: \"noView\",\n  64: \"readOnly\",\n  128: \"locked\",\n  256: \"toggleNoView\"\n});\nObject.entries(\n  N\n).reduce(\n  (e, [r, o]) => (e[o] = Number(r), e),\n  {}\n);\nexport {\n  j as c,\n  k as r\n};\n//# sourceMappingURL=index-Q-vI1_iw.js.map\n","import { createContext as b } from \"preact\";\nimport { u as w } from \"../jsxRuntime.module-Bzuv3cXw.js\";\nimport { useState as a, useRef as m, useEffect as f, useContext as S } from \"preact/hooks\";\nimport { P as v, a as C } from \"../math-ChSRQF3r.js\";\nconst P = b({\n  registry: null,\n  isInitializing: !0,\n  pluginsReady: !1\n});\nfunction F({ engine: t, onInitialized: r, plugins: e, children: i }) {\n  const [o, s] = a(null), [u, c] = a(!0), [y, d] = a(!1), l = m(r);\n  return f(() => {\n    l.current = r;\n  }, [r]), f(() => {\n    const n = new v(t);\n    return n.registerPluginBatch(e), (async () => {\n      var p;\n      await n.initialize(), !n.isDestroyed() && (await ((p = l.current) == null ? void 0 : p.call(l, n)), !n.isDestroyed() && (n.pluginsReady().then(() => {\n        n.isDestroyed() || d(!0);\n      }), s(n), c(!1)));\n    })().catch(console.error), () => {\n      n.destroy(), s(null), c(!0), d(!1);\n    };\n  }, [t, e]), /* @__PURE__ */ w(P.Provider, { value: { registry: o, isInitializing: u, pluginsReady: y }, children: typeof i == \"function\" ? i({ registry: o, isInitializing: u, pluginsReady: y }) : i });\n}\nfunction g() {\n  const t = S(P);\n  if (t === void 0)\n    throw new Error(\"useCapability must be used within a PDFContext.Provider\");\n  const { registry: r, isInitializing: e } = t;\n  if (e)\n    return t;\n  if (r === null)\n    throw new Error(\"PDF registry failed to initialize properly\");\n  return t;\n}\nfunction h(t) {\n  const { registry: r } = g();\n  if (r === null)\n    return {\n      plugin: null,\n      isLoading: !0,\n      ready: new Promise(() => {\n      })\n    };\n  const e = r.getPlugin(t);\n  if (!e)\n    throw new Error(`Plugin ${t} not found`);\n  return {\n    plugin: e,\n    isLoading: !1,\n    ready: e.ready()\n  };\n}\nfunction L(t) {\n  const { plugin: r, isLoading: e, ready: i } = h(t);\n  if (!r)\n    return {\n      provides: null,\n      isLoading: e,\n      ready: i\n    };\n  if (!r.provides)\n    throw new Error(`Plugin ${t} does not provide a capability`);\n  return {\n    provides: r.provides(),\n    isLoading: e,\n    ready: i\n  };\n}\nfunction V() {\n  const { registry: t } = g(), [r, e] = a(null);\n  return f(() => {\n    if (!t) return;\n    e(t.getStore().getState());\n    const i = t.getStore().subscribe((o, s) => {\n      e(s);\n    });\n    return () => i();\n  }, [t]), r;\n}\nfunction $() {\n  const { registry: t } = g(), [r, e] = a(null);\n  return f(() => {\n    if (!t) return;\n    const i = t.getStore();\n    e(i.getState().core);\n    const o = i.subscribe((s, u, c) => {\n      i.isCoreAction(s) && !C(u.core, c.core) && e(u.core);\n    });\n    return () => o();\n  }, [t]), r;\n}\nexport {\n  F as EmbedPDF,\n  P as PDFContext,\n  L as useCapability,\n  $ as useCoreState,\n  h as usePlugin,\n  g as useRegistry,\n  V as useStoreState\n};\n//# sourceMappingURL=index.js.map\n","import { useCapability, usePlugin } from '@embedpdf/core/preact';\nimport { SelectionPlugin } from '@embedpdf/plugin-selection';\n\nexport const useSelectionCapability = () => useCapability<SelectionPlugin>(SelectionPlugin.id);\nexport const useSelectionPlugin = () => usePlugin<SelectionPlugin>(SelectionPlugin.id);\n","import { u as g } from \"../jsxRuntime.module-D89ud_rY.js\";\nimport { useContext as E, useState as y, useEffect as a, useRef as P, useCallback as M } from \"preact/hooks\";\nimport { c as v, r as L } from \"../index-Q-vI1_iw.js\";\nimport { createContext as z } from \"preact\";\nimport { I, i as S } from \"../reducer-Dda407Go.js\";\nconst A = z({\n  registry: null,\n  isInitializing: !0,\n  pluginsReady: !1\n});\nfunction R() {\n  const e = E(A);\n  if (e === void 0)\n    throw new Error(\"useCapability must be used within a PDFContext.Provider\");\n  const { registry: n, isInitializing: t } = e;\n  if (t)\n    return e;\n  if (n === null)\n    throw new Error(\"PDF registry failed to initialize properly\");\n  return e;\n}\nfunction x(e) {\n  const { registry: n } = R();\n  if (n === null)\n    return {\n      plugin: null,\n      isLoading: !0,\n      ready: new Promise(() => {\n      })\n    };\n  const t = n.getPlugin(e);\n  if (!t)\n    throw new Error(`Plugin ${e} not found`);\n  return {\n    plugin: t,\n    isLoading: !1,\n    ready: t.ready()\n  };\n}\nfunction D(e) {\n  const { plugin: n, isLoading: t, ready: r } = x(e);\n  if (!n)\n    return {\n      provides: null,\n      isLoading: t,\n      ready: r\n    };\n  if (!n.provides)\n    throw new Error(`Plugin ${e} does not provide a capability`);\n  return {\n    provides: n.provides(),\n    isLoading: t,\n    ready: r\n  };\n}\nconst X = () => x(I.id), s = () => D(I.id);\nfunction Y() {\n  const { provides: e } = s(), [n, t] = y(S);\n  return a(() => {\n    if (e)\n      return e.onStateChange((r) => {\n        t(r);\n      });\n  }, [e]), {\n    provides: e,\n    state: n\n  };\n}\nfunction j() {\n  const { provides: e } = s();\n  return {\n    setCursor: (n, t, r = 0) => {\n      e == null || e.setCursor(n, t, r);\n    },\n    removeCursor: (n) => {\n      e == null || e.removeCursor(n);\n    }\n  };\n}\nfunction q({ modeId: e, pageIndex: n }) {\n  const { provides: t } = s();\n  return {\n    register: (r, i) => {\n      const u = (i == null ? void 0 : i.modeId) ?? e, o = (i == null ? void 0 : i.pageIndex) ?? n;\n      return u ? t == null ? void 0 : t.registerHandlers({\n        modeId: u,\n        handlers: r,\n        pageIndex: o\n      }) : t == null ? void 0 : t.registerAlways({\n        scope: o !== void 0 ? { type: \"page\", pageIndex: o } : { type: \"global\" },\n        handlers: r\n      });\n    }\n  };\n}\nfunction F() {\n  const { provides: e } = s(), [n, t] = y(() => {\n    const r = e == null ? void 0 : e.getActiveInteractionMode();\n    return (r == null ? void 0 : r.scope) === \"page\" && !!r.exclusive;\n  });\n  return a(() => {\n    if (e)\n      return e.onModeChange(() => {\n        const r = e.getActiveInteractionMode();\n        t((r == null ? void 0 : r.scope) === \"page\" && !!(r != null && r.exclusive));\n      });\n  }, [e]), n;\n}\nconst J = ({\n  children: e,\n  style: n,\n  ...t\n}) => {\n  const r = P(null), { provides: i } = s();\n  return a(() => {\n    if (!(!i || !r.current))\n      return v(i, { type: \"global\" }, r.current);\n  }, [i]), /* @__PURE__ */ g(\n    \"div\",\n    {\n      ref: r,\n      style: {\n        width: \"100%\",\n        height: \"100%\",\n        ...n\n      },\n      ...t,\n      children: e\n    }\n  );\n}, K = ({\n  pageIndex: e,\n  children: n,\n  pageWidth: t,\n  pageHeight: r,\n  rotation: i,\n  scale: u,\n  convertEventToPoint: o,\n  style: C,\n  ...h\n}) => {\n  const c = P(null), { provides: l } = s(), m = F(), d = M(\n    (f, w) => {\n      const p = w.getBoundingClientRect(), b = {\n        x: f.clientX - p.left,\n        y: f.clientY - p.top\n      };\n      return L(\n        { width: t, height: r },\n        b,\n        i,\n        u\n      );\n    },\n    [t, r, i, u]\n  );\n  return a(() => {\n    if (!(!l || !c.current))\n      return v(\n        l,\n        { type: \"page\", pageIndex: e },\n        c.current,\n        o || d\n      );\n  }, [l, e, o, d]), /* @__PURE__ */ g(\n    \"div\",\n    {\n      ref: c,\n      style: {\n        ...C\n      },\n      ...h,\n      children: [\n        n,\n        m && /* @__PURE__ */ g(\"div\", { style: { position: \"absolute\", top: 0, left: 0, right: 0, bottom: 0, zIndex: 10 } })\n      ]\n    }\n  );\n};\nexport {\n  J as GlobalPointerProvider,\n  K as PagePointerProvider,\n  j as useCursor,\n  Y as useInteractionManager,\n  s as useInteractionManagerCapability,\n  X as useInteractionManagerPlugin,\n  F as useIsPageExclusive,\n  q as usePointerHandlers\n};\n//# sourceMappingURL=index.js.map\n","/** @jsxImportSource preact */\nimport { useCallback, useEffect, useMemo, useRef, useState } from 'preact/hooks';\nimport { ignore, PdfErrorCode, PdfPageGeometry, Position, Rect } from '@embedpdf/models';\nimport {\n  useCursor,\n  useInteractionManagerCapability,\n  usePointerHandlers,\n} from '@embedpdf/plugin-interaction-manager/preact';\nimport { PointerEventHandlersWithLifecycle } from '@embedpdf/plugin-interaction-manager';\nimport { glyphAt } from '@embedpdf/plugin-selection';\n\nimport { useSelectionCapability } from '../hooks';\n\ntype Props = {\n  pageIndex: number;\n  scale: number;\n  background?: string;\n};\n\nexport function SelectionLayer({ pageIndex, scale, background = 'rgba(33,150,243)' }: Props) {\n  const { provides: sel } = useSelectionCapability();\n  const { provides: im } = useInteractionManagerCapability();\n  const { register } = usePointerHandlers({ pageIndex });\n  const [rects, setRects] = useState<Array<Rect>>([]);\n  const [boundingRect, setBoundingRect] = useState<Rect | null>(null);\n  const { setCursor, removeCursor } = useCursor();\n  const geoCacheRef = useRef<PdfPageGeometry | null>(null);\n\n  /* subscribe to rect updates */\n  useEffect(() => {\n    if (!sel) return;\n    return sel.onSelectionChange(() => {\n      const mode = im?.getActiveMode();\n      if (mode === 'default') {\n        setRects(sel.getHighlightRectsForPage(pageIndex));\n        setBoundingRect(sel.getBoundingRectForPage(pageIndex));\n      } else {\n        setRects([]);\n        setBoundingRect(null);\n      }\n    });\n  }, [sel, pageIndex]);\n\n  /* cheap glyphAt cache for the active page */\n  const cachedGlyphAt = useCallback((pt: Position) => {\n    const geo = geoCacheRef.current;\n    return geo ? glyphAt(geo, pt) : -1;\n  }, []);\n\n  // Initialize geometry cache\n  useEffect(() => {\n    if (!sel) return;\n    const task = sel.getGeometry(pageIndex);\n    task.wait((g) => (geoCacheRef.current = g), ignore);\n\n    return () => {\n      task.abort({\n        code: PdfErrorCode.Cancelled,\n        message: 'Cancelled',\n      });\n      geoCacheRef.current = null;\n    };\n  }, [sel, pageIndex]);\n\n  const handlers = useMemo(\n    (): PointerEventHandlersWithLifecycle<PointerEvent> => ({\n      onPointerDown: (point, _evt, modeId) => {\n        if (!sel) return;\n        if (!sel.isEnabledForMode(modeId)) return;\n        // clear the selection\n        sel.clear();\n        const task = sel.getGeometry(pageIndex);\n        task.wait((geo) => {\n          const g = glyphAt(geo, point);\n          if (g !== -1) sel.begin(pageIndex, g);\n        }, ignore);\n      },\n      onPointerMove: (point, _evt, modeId) => {\n        if (!sel) return;\n        if (!sel.isEnabledForMode(modeId)) return;\n        const g = cachedGlyphAt(point);\n        if (g !== -1) {\n          setCursor('selection-text', 'text', 10);\n        } else {\n          removeCursor('selection-text');\n        }\n        if (g !== -1) sel.update(pageIndex, g);\n      },\n      onPointerUp: (_point, _evt, modeId) => {\n        if (!sel) return;\n        if (!sel.isEnabledForMode(modeId)) return;\n        sel.end();\n      },\n      onHandlerActiveEnd(modeId) {\n        if (!sel) return;\n        if (!sel.isEnabledForMode(modeId)) return;\n\n        sel.clear();\n      },\n    }),\n    [sel, pageIndex, cachedGlyphAt],\n  );\n\n  useEffect(() => {\n    if (!register) return;\n    return register(handlers);\n  }, [register, handlers]);\n\n  if (!boundingRect) return null;\n\n  return (\n    <div\n      style={{\n        position: 'absolute',\n        left: boundingRect.origin.x * scale,\n        top: boundingRect.origin.y * scale,\n        width: boundingRect.size.width * scale,\n        height: boundingRect.size.height * scale,\n        mixBlendMode: 'multiply',\n        isolation: 'isolate',\n      }}\n    >\n      {rects.map((b, i) => (\n        <div\n          key={i}\n          style={{\n            position: 'absolute',\n            left: (b.origin.x - boundingRect.origin.x) * scale,\n            top: (b.origin.y - boundingRect.origin.y) * scale,\n            width: b.size.width * scale,\n            height: b.size.height * scale,\n            background,\n            pointerEvents: 'none',\n          }}\n        />\n      ))}\n    </div>\n  );\n}\n","import { useEffect } from 'preact/hooks';\n\nimport { useSelectionCapability } from '../hooks';\n\nexport function CopyToClipboard() {\n  const { provides: sel } = useSelectionCapability();\n\n  useEffect(() => {\n    if (!sel) return;\n    return sel.onCopyToClipboard((text) => {\n      navigator.clipboard.writeText(text);\n    });\n  }, [sel]);\n\n  return null;\n}\n","import {\n  PdfAnnotationObject,\n  PdfAnnotationSubtype,\n  PdfInkAnnoObject,\n  Rect,\n} from '@embedpdf/models';\nimport { ResizeDirection } from './types';\n\n/**\n * Computes a patch for resizing an ink annotation.\n * - Scales all points in inkList to fit the new rect.\n * - Scales strokeWidth proportionally (using average scale factor).\n * - Handles non-uniform scaling (stretch).\n * - Optionally preserves aspect ratio (set uniform=true).\n *\n * @param original The original ink annotation object.\n * @param newRect The new bounding rect after resize.\n * @param direction The resize handle direction (affects origin adjustments if needed).\n * @param uniform If true, constrains to uniform scaling (uses min scale factor).\n * @returns Partial patch { rect, inkList, strokeWidth } to apply.\n */\nexport function resizeInkAnnotation(\n  original: PdfAnnotationObject, // Assumes type=INK\n  newRect: Rect,\n  direction: ResizeDirection,\n  uniform: boolean = false,\n): Partial<PdfInkAnnoObject> {\n  if (original.type !== PdfAnnotationSubtype.INK) {\n    throw new Error('resizeInkAnnotation: original is not an ink annotation');\n  }\n\n  const oldRect = original.rect;\n  let scaleX = newRect.size.width / oldRect.size.width;\n  let scaleY = newRect.size.height / oldRect.size.height;\n\n  // Enforce minimum size to avoid collapse\n  const minSize = 10; // Arbitrary PDF units; adjust as needed\n  if (newRect.size.width < minSize || newRect.size.height < minSize) {\n    // Return empty patch or throw; for now, clamp\n    scaleX = Math.max(scaleX, minSize / oldRect.size.width);\n    scaleY = Math.max(scaleY, minSize / oldRect.size.height);\n    newRect = {\n      origin: newRect.origin,\n      size: {\n        width: oldRect.size.width * scaleX,\n        height: oldRect.size.height * scaleY,\n      },\n    };\n  }\n\n  // Optional: Uniform scaling (preserve aspect ratio)\n  if (uniform) {\n    const minScale = Math.min(scaleX, scaleY);\n    scaleX = minScale;\n    scaleY = minScale;\n    // Adjust newRect size accordingly (keep origin the same)\n    newRect.size = {\n      width: oldRect.size.width * minScale,\n      height: oldRect.size.height * minScale,\n    };\n  }\n\n  // Scale points: Normalize relative to old origin, scale, then add new origin\n  const newInkList = original.inkList.map((stroke) => ({\n    points: stroke.points.map((p) => ({\n      x: newRect.origin.x + (p.x - oldRect.origin.x) * scaleX,\n      y: newRect.origin.y + (p.y - oldRect.origin.y) * scaleY,\n    })),\n  }));\n\n  // Scale strokeWidth: Use average scale (preserves \"thickness feel\")\n  // Alternatives: Math.min(scaleX, scaleY) for conservative, or sqrt(scaleX * scaleY) for area-preserving\n  const avgScale = (scaleX + scaleY) / 2;\n  const newStrokeWidth = original.strokeWidth * avgScale;\n\n  // Optional: Adjust based on direction (e.g., if resizing from top-left, points might need flip/recalc, but usually not needed as scaling handles it)\n\n  return {\n    rect: newRect,\n    inkList: newInkList,\n    strokeWidth: newStrokeWidth,\n  };\n}\n","/** @jsxImportSource preact */\nimport { JSX } from 'preact';\nimport { blendModeToCss, PdfAnnotationSubtype, PdfBlendMode, Rect } from '@embedpdf/models';\nimport { ActiveTool, makeVariantKey } from '@embedpdf/plugin-annotation';\nimport { useSelectionCapability } from '@embedpdf/plugin-selection/preact';\n\nimport { useEffect, useState } from 'preact/hooks';\nimport { useAnnotationCapability } from '../hooks';\nimport { Highlight } from './text-markup/highlight';\nimport { Squiggly } from './text-markup/squiggly';\nimport { Underline } from './text-markup/underline';\nimport { Strikeout } from './text-markup/strikeout';\n\ninterface TextMarkupProps {\n  pageIndex: number;\n  scale: number;\n}\n\nexport function TextMarkup({ pageIndex, scale }: TextMarkupProps) {\n  const { provides: selectionProvides } = useSelectionCapability();\n  const { provides: annotationProvides } = useAnnotationCapability();\n  const [rects, setRects] = useState<Array<Rect>>([]);\n  const [boundingRect, setBoundingRect] = useState<Rect | null>(null);\n  const [activeTool, setActiveTool] = useState<ActiveTool>({ variantKey: null, defaults: null });\n\n  useEffect(() => {\n    if (!selectionProvides) return;\n\n    const off = selectionProvides.onSelectionChange(() => {\n      setRects(selectionProvides.getHighlightRectsForPage(pageIndex));\n      setBoundingRect(selectionProvides.getBoundingRectForPage(pageIndex));\n    });\n    return off;\n  }, [selectionProvides, pageIndex]);\n\n  useEffect(() => {\n    if (!annotationProvides) return;\n\n    const off = annotationProvides.onActiveToolChange(setActiveTool);\n    return off;\n  }, [annotationProvides]);\n\n  if (!boundingRect) return null;\n\n  switch (activeTool.variantKey) {\n    case makeVariantKey(PdfAnnotationSubtype.UNDERLINE):\n      return (\n        <div\n          style={{\n            mixBlendMode: blendModeToCss(activeTool.defaults?.blendMode ?? PdfBlendMode.Normal),\n            pointerEvents: 'none',\n            position: 'absolute',\n            inset: 0,\n          }}\n        >\n          <Underline\n            color={activeTool.defaults?.color}\n            opacity={activeTool.defaults?.opacity}\n            rects={rects}\n            scale={scale}\n          />\n        </div>\n      );\n    case makeVariantKey(PdfAnnotationSubtype.HIGHLIGHT):\n      return (\n        <div\n          style={{\n            mixBlendMode: blendModeToCss(activeTool.defaults?.blendMode ?? PdfBlendMode.Multiply),\n            pointerEvents: 'none',\n            position: 'absolute',\n            inset: 0,\n          }}\n        >\n          <Highlight\n            color={activeTool.defaults?.color}\n            opacity={activeTool.defaults?.opacity}\n            rects={rects}\n            scale={scale}\n          />\n        </div>\n      );\n    case makeVariantKey(PdfAnnotationSubtype.STRIKEOUT):\n      return (\n        <div\n          style={{\n            mixBlendMode: blendModeToCss(activeTool.defaults?.blendMode ?? PdfBlendMode.Normal),\n            pointerEvents: 'none',\n            position: 'absolute',\n            inset: 0,\n          }}\n        >\n          <Strikeout\n            color={activeTool.defaults?.color}\n            opacity={activeTool.defaults?.opacity}\n            rects={rects}\n            scale={scale}\n          />\n        </div>\n      );\n    case makeVariantKey(PdfAnnotationSubtype.SQUIGGLY):\n      return (\n        <div\n          style={{\n            mixBlendMode: blendModeToCss(activeTool.defaults?.blendMode ?? PdfBlendMode.Normal),\n            pointerEvents: 'none',\n            position: 'absolute',\n            inset: 0,\n          }}\n        >\n          <Squiggly\n            color={activeTool.defaults?.color}\n            opacity={activeTool.defaults?.opacity}\n            rects={rects}\n            scale={scale}\n          />\n        </div>\n      );\n    default:\n      return null;\n  }\n}\n","/** @jsxImportSource preact */\nimport { useEffect, useMemo, useRef, useState } from 'preact/hooks';\nimport type { PointerEventHandlers } from '@embedpdf/plugin-interaction-manager';\nimport { usePointerHandlers } from '@embedpdf/plugin-interaction-manager/preact';\nimport { ActiveTool } from '@embedpdf/plugin-annotation';\nimport { PdfInkListObject, Rect, PdfAnnotationSubtype, PdfInkAnnoObject } from '@embedpdf/models';\nimport { useAnnotationCapability } from '../../hooks';\n\ninterface InkPaintProps {\n  /** Index of the page this layer lives on */\n  pageIndex: number;\n  /** Scale of the page */\n  scale: number;\n  /** Width of the page */\n  pageWidth: number;\n  /** Height of the page */\n  pageHeight: number;\n}\n\nconst MAX_STROKE_WIDTH = 30;\n\n/**\n * Allows the user to draw freehand ink annotations.\n * Hook it into the interaction-manager with modeId = 'inkPaint'.\n * Supports multi-stroke annotations: if the user starts a new stroke within 3 seconds of releasing the previous one, it adds to the same annotation.\n */\nexport const InkPaint = ({ pageIndex, scale, pageWidth, pageHeight }: InkPaintProps) => {\n  /* ------------------------------------------------------------------ */\n  /* annotation capability                                              */\n  /* ------------------------------------------------------------------ */\n  const { provides: annotationProvides } = useAnnotationCapability();\n\n  /* ------------------------------------------------------------------ */\n  /* active tool state                                                  */\n  /* ------------------------------------------------------------------ */\n  const [activeTool, setActiveTool] = useState<ActiveTool>({ variantKey: null, defaults: null });\n\n  useEffect(() => {\n    if (!annotationProvides) return;\n\n    const off = annotationProvides.onActiveToolChange(setActiveTool);\n    return off;\n  }, [annotationProvides]);\n\n  if (!activeTool.defaults) return null;\n  if (activeTool.defaults.subtype !== PdfAnnotationSubtype.INK) return null;\n\n  const toolColor = activeTool.defaults?.color ?? '#000000';\n  const toolOpacity = activeTool.defaults?.opacity ?? 1;\n  const toolStrokeWidth = activeTool.defaults?.strokeWidth ?? 2;\n\n  /* ------------------------------------------------------------------ */\n  /* integration with interaction-manager                               */\n  /* ------------------------------------------------------------------ */\n  const { register } = usePointerHandlers({ modeId: 'ink', pageIndex });\n\n  /* ------------------------------------------------------------------ */\n  /* helpers                                                            */\n  /* ------------------------------------------------------------------ */\n  const clamp = (v: number, min: number, max: number) => Math.max(min, Math.min(max, v));\n\n  /* ------------------------------------------------------------------ */\n  /* local state – current strokes (preview), persist timer, and drawing flag */\n  /* ------------------------------------------------------------------ */\n  const [currentStrokes, setCurrentStrokes] = useState<PdfInkListObject[]>([]);\n  const [isDrawing, setIsDrawing] = useState(false);\n  const timerRef = useRef<NodeJS.Timeout | null>(null);\n\n  /* page size in **PDF-space** (unscaled) ----------------------------- */\n  const pageWidthPDF = pageWidth / scale;\n  const pageHeightPDF = pageHeight / scale;\n\n  /* ------------------------------------------------------------------ */\n  /* pointer handlers                                                   */\n  /* ------------------------------------------------------------------ */\n  const handlers = useMemo<PointerEventHandlers<PointerEvent>>(\n    () => ({\n      onPointerDown: (pos, evt) => {\n        const curX = clamp(pos.x, 0, pageWidthPDF);\n        const curY = clamp(pos.y, 0, pageHeightPDF);\n\n        setIsDrawing(true);\n\n        if (timerRef.current) {\n          // Continuing the current annotation – clear timer and add new stroke\n          clearTimeout(timerRef.current);\n          timerRef.current = null;\n          setCurrentStrokes((prev) => [...prev, { points: [{ x: curX, y: curY }] }]);\n        } else {\n          // Start a new annotation\n          setCurrentStrokes([{ points: [{ x: curX, y: curY }] }]);\n        }\n\n        (evt.target as HTMLElement)?.setPointerCapture?.(evt.pointerId);\n      },\n      onPointerMove: (pos) => {\n        if (!isDrawing) return;\n\n        const curX = clamp(pos.x, 0, pageWidthPDF);\n        const curY = clamp(pos.y, 0, pageHeightPDF);\n\n        // Add point to the last stroke\n        setCurrentStrokes((prev) => {\n          if (!prev.length) return prev;\n          const last = prev[prev.length - 1];\n          const newLast = { points: [...last.points, { x: curX, y: curY }] };\n          return [...prev.slice(0, -1), newLast];\n        });\n      },\n      onPointerUp: (_, evt) => {\n        setIsDrawing(false);\n        (evt.target as HTMLElement)?.releasePointerCapture?.(evt.pointerId);\n\n        // Start/restart the persist timer\n        if (timerRef.current) clearTimeout(timerRef.current);\n        timerRef.current = setTimeout(() => {\n          if (currentStrokes.length && annotationProvides) {\n            const allPoints = currentStrokes.flatMap((s) => s.points);\n            if (!allPoints.length) return;\n\n            const minX = Math.min(...allPoints.map((p) => p.x));\n            const minY = Math.min(...allPoints.map((p) => p.y));\n            const maxX = Math.max(...allPoints.map((p) => p.x));\n            const maxY = Math.max(...allPoints.map((p) => p.y));\n\n            // Account for stroke width - expand rect by half stroke width on all sides\n            const halfStroke = MAX_STROKE_WIDTH / 2;\n            const rectMinX = minX - halfStroke;\n            const rectMinY = minY - halfStroke;\n            const rectMaxX = maxX + halfStroke;\n            const rectMaxY = maxY + halfStroke;\n\n            // Ignore tiny drawings\n            if (rectMaxX - rectMinX < 1 || rectMaxY - rectMinY < 1) return;\n\n            const rect: Rect = {\n              origin: { x: rectMinX, y: rectMinY },\n              size: { width: rectMaxX - rectMinX, height: rectMaxY - rectMinY },\n            };\n\n            const anno: PdfInkAnnoObject = {\n              type: PdfAnnotationSubtype.INK,\n              rect,\n              inkList: currentStrokes,\n              color: toolColor,\n              opacity: toolOpacity,\n              strokeWidth: toolStrokeWidth,\n              pageIndex,\n              id: Date.now() + Math.random(),\n            };\n\n            annotationProvides.createAnnotation(pageIndex, anno);\n            annotationProvides.setActiveVariant(null);\n            annotationProvides.selectAnnotation(pageIndex, anno.id);\n          }\n\n          setCurrentStrokes([]);\n          timerRef.current = null;\n        }, 3000);\n      },\n      onPointerCancel: (_, evt) => {\n        setIsDrawing(false);\n        (evt.target as HTMLElement)?.releasePointerCapture?.(evt.pointerId);\n\n        // Cancel – clear preview without persisting\n        setCurrentStrokes([]);\n        if (timerRef.current) {\n          clearTimeout(timerRef.current);\n          timerRef.current = null;\n        }\n      },\n    }),\n    [\n      pageWidthPDF,\n      pageHeightPDF,\n      currentStrokes,\n      annotationProvides,\n      pageIndex,\n      toolColor,\n      toolOpacity,\n      toolStrokeWidth,\n      isDrawing,\n    ],\n  );\n\n  /* register with the interaction-manager */\n  useEffect(() => {\n    if (!register) return;\n    return register(handlers);\n  }, [register, handlers]);\n\n  /* cleanup timer on unmount */\n  useEffect(() => {\n    return () => {\n      if (timerRef.current) clearTimeout(timerRef.current);\n    };\n  }, []);\n\n  /* ------------------------------------------------------------------ */\n  /* render preview                                                     */\n  /* ------------------------------------------------------------------ */\n  if (!currentStrokes.length) return null;\n\n  const allPoints = currentStrokes.flatMap((s) => s.points);\n  if (!allPoints.length) return null;\n\n  const minX = Math.min(...allPoints.map((p) => p.x));\n  const minY = Math.min(...allPoints.map((p) => p.y));\n  const maxX = Math.max(...allPoints.map((p) => p.x));\n  const maxY = Math.max(...allPoints.map((p) => p.y));\n\n  // Account for stroke width - expand bounds by half stroke width on all sides\n  const halfStroke = MAX_STROKE_WIDTH / 2;\n  const svgMinX = minX - halfStroke;\n  const svgMinY = minY - halfStroke;\n  const svgMaxX = maxX + halfStroke;\n  const svgMaxY = maxY + halfStroke;\n\n  const dw = svgMaxX - svgMinX;\n  const dh = svgMaxY - svgMinY;\n\n  const paths = currentStrokes.map(({ points }) => {\n    let d = '';\n    points.forEach(({ x, y }, i) => {\n      // Adjust coordinates relative to the expanded SVG bounds\n      const lx = x - svgMinX;\n      const ly = y - svgMinY;\n      d += (i === 0 ? 'M' : 'L') + lx + ' ' + ly + ' ';\n    });\n    return d.trim();\n  });\n\n  return (\n    <svg\n      style={{\n        position: 'absolute',\n        left: svgMinX * scale,\n        top: svgMinY * scale,\n        width: dw * scale,\n        height: dh * scale,\n        pointerEvents: 'none',\n        zIndex: 2,\n      }}\n      width={dw * scale}\n      height={dh * scale}\n      viewBox={`0 0 ${dw} ${dh}`}\n    >\n      {paths.map((d, i) => (\n        <path\n          key={i}\n          d={d}\n          fill=\"none\"\n          stroke={toolColor}\n          strokeWidth={toolStrokeWidth}\n          strokeLinecap=\"round\"\n          strokeLinejoin=\"round\"\n          opacity={toolOpacity}\n        />\n      ))}\n    </svg>\n  );\n};\n","/** @jsxImportSource preact */\nimport { JSX } from 'preact';\nimport { Annotations } from './annotations';\nimport { TextMarkup } from './text-markup';\nimport { InkPaint } from './annotations/ink-paint';\n\ntype AnnotationLayerProps = Omit<JSX.HTMLAttributes<HTMLDivElement>, 'style'> & {\n  pageIndex: number;\n  scale: number;\n  pageWidth: number;\n  pageHeight: number;\n  rotation: number;\n  style?: JSX.CSSProperties;\n};\n\nexport function AnnotationLayer({\n  pageIndex,\n  scale,\n  pageWidth,\n  pageHeight,\n  rotation,\n  style,\n  ...props\n}: AnnotationLayerProps) {\n  return (\n    <div\n      style={{\n        ...style,\n      }}\n      {...props}\n    >\n      <Annotations pageIndex={pageIndex} scale={scale} rotation={rotation} />\n      <TextMarkup pageIndex={pageIndex} scale={scale} />\n      <InkPaint pageIndex={pageIndex} scale={scale} pageWidth={pageWidth} pageHeight={pageHeight} />\n    </div>\n  );\n}\n"],"mappings":"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","names":["PdfSoftHyphenMarker","PdfZeroWidthSpace","PdfWordJoiner","PdfBomOrZwnbsp","PdfNonCharacterFFFE","PdfNonCharacterFFFF","PdfUnwantedTextMarkers","BLEND_MODE_INFOS","m","info","PdfAnnotationFlagName","acc","bit","name","PDFContext","createContext","useRegistry","contextValue","useContext","PDFContext","registry","isInitializing","usePlugin","pluginId","plugin","useCapability","isLoading","ready","SET_DOCUMENT","PdfSoftHyphenMarker","PdfZeroWidthSpace","PdfWordJoiner","PdfBomOrZwnbsp","PdfNonCharacterFFFE","PdfNonCharacterFFFF","PdfUnwantedTextMarkers","BLEND_MODE_INFOS","m","info","PdfAnnotationFlagName","acc","bit","name","arePropsEqual","a","b","visited","aType","pairId","getPairId","aIsArray","bIsArray","arraysEqualUnordered","objectsEqual","objectId","objectIdCounter","objectIds","obj","used","outer","i","elemA","j","aKeys","bKeys","key","valA","valB","BasePlugin","id","registry","action","newState","oldState","resolve","cap","debounceTime","now","lastActionTime","listener","EventControl","handler","options","data","throttleMode","createBehaviorEmitter","initial","equality","listeners","proxyMap","_value","notify","v","l","baseOn","realListener","destroy","ctl","proxy","p","selector","eq","prev","mapped","next","Rotation","PdfBlendMode","PdfAnnotationSubtype","AppearanceMode","PdfErrorCode","c","k","s","s","s","w","f","s","p","page","task","a","b","L","PdfSoftHyphenMarker","PdfZeroWidthSpace","PdfWordJoiner","PdfBomOrZwnbsp","PdfNonCharacterFFFE","PdfNonCharacterFFFF","PdfUnwantedTextMarkers","PdfUnwantedTextRegex","PdfBlendMode","MixedBlendMode","BLEND_MODE_INFOS","enumToInfo","m","cssToEnum","blendModeSelectOptions","BLEND_MODE_INFOS","PdfAnnotationSubtype","PdfAnnotationFlagName","PdfAnnotationFlagValue","PdfSoftHyphenMarker","PdfZeroWidthSpace","PdfWordJoiner","PdfBomOrZwnbsp","PdfNonCharacterFFFE","PdfNonCharacterFFFF","PdfUnwantedTextMarkers","BLEND_MODE_INFOS","m","info","PdfAnnotationFlagName","acc","bit","name","z","M","L","$","F","N","k","P","i","e","_","t","v","r","n","x","a","o","U","B","S","G","d","s","w","c","b","E","C","m","p","u","h","l","ACTIVATE_MODE","PAUSE_INTERACTION","RESUME_INTERACTION","SET_CURSOR","activateMode","mode","setCursor","cursor","pauseInteraction","resumeInteraction","mergeHandlers","list","keys","out","evt","nativeEvt","modeId","_a","_InteractionManagerPlugin","BasePlugin","id","registry","createEmitter","createBehaviorEmitter","options","token","priority","scope","previousMode","handler","handlerSet","bucket","pageIndex","handlers","modeIds","cleanupFunctions","set","cleanup","mergeSets","modeSpecific","alwaysPageSet","modePageSet","top","newState","InteractionManagerPlugin","P","b","g","t","S","r","e","h","L","i","useInteractionManagerCapability","useCapability","InteractionManagerPlugin","usePointerHandlers","modeId","pageIndex","provides","useInteractionManagerCapability","handlers","options","finalModeId","finalPageIndex","import_hooks","import_hooks","import_jsx_runtime","b","i","import_jsx_runtime","i","import_jsx_runtime","i","import_jsx_runtime","i","import_hooks","import_jsx_runtime","d","x","y","i","f","z","M","L","$","F","N","k","P","i","e","_","t","v","r","x","a","o","U","B","S","G","d","s","n","w","c","b","E","C","m","p","u","h","l","boundingRect","rects","minX","minY","maxX","maxY","TaskAbortedError","reason","TaskRejectedError","Task","_Task","resolve","reject","result","error","resolvedCallback","rejectedCallback","tasks","combinedTask","results","resolvedCount","isSettled","task","index","settledCount","onProgress","completedCount","PdfSoftHyphenMarker","PdfZeroWidthSpace","PdfWordJoiner","PdfBomOrZwnbsp","PdfNonCharacterFFFE","PdfNonCharacterFFFF","PdfUnwantedTextMarkers","BLEND_MODE_INFOS","info","PdfAnnotationFlagName","acc","bit","name","PdfErrorCode","PdfErrorCode2","PdfTaskHelper","ignore","CACHE_PAGE_GEOMETRY","SET_SELECTION","START_SELECTION","END_SELECTION","CLEAR_SELECTION","SET_RECTS","SET_SLICES","RESET","cachePageGeometry","page","geo","setSelection","sel","startSelection","endSelection","clearSelection","setRects","allRects","setSlices","slices","reset","selectRectsForPage","state","selectBoundingRectForPage","selectBoundingRectsForAllPages","out","rectMap","key","bRect","getFormattedSelectionForPage","segmentRects","getFormattedSelection","pages","pageIndex","sliceBounds","sel","geo","page","from","lastRun","lastCharOnPage","to","rectsWithinSlice","merge","textRuns","run","runStart","runEnd","sIdx","eIdx","minX","maxX","minY","maxY","charCount","i","g","mergeAdjacentRects","rectUnion","rect1","rect2","left","top","right","bottom","rectIntersect","width","height","rectIsEmpty","rect","getVerticalOverlap","unionRect","shouldMergeHorizontalRects","textRun1","textRun2","HORIZONTAL_WIDTH_FACTOR","averageWidth1","averageWidth2","rect1Left","rect1Right","rect2Left","rect2Right","results","previousTextRun","currentRect","textRun","_SelectionPlugin","BasePlugin","id","registry","engine","createBehaviorEmitter","createEmitter","SET_DOCUMENT","_action","reset","p","selector.getFormattedSelection","selector.getFormattedSelectionForPage","selector.selectRectsForPage","selector.selectBoundingRectForPage","selector.selectBoundingRectsForAllPages","pageIdx","cached","PdfTaskHelper","PdfErrorCode","task","cachePageGeometry","ignore","index","startSelection","endSelection","clearSelection","a","forward","range","setSelection","allRects","allSlices","sb","setRects","setSlices","req","s","text","SelectionPlugin","M","H","T","$","R","I","P","y","o","t","k","e","g","s","i","O","r","a","N","U","C","F","b","n","_","x","p","D","c","u","h","l","d","f","v","m","E","A","j","z","G","L","V","S","C","M","E","O","w","H","L","u","e","r","N","o","P","b","g","t","S","e","h","L","i","useSelectionCapability","useCapability","SelectionPlugin","A","z","PdfAnnotationSubtype","p","import_jsx_runtime","x","setAnnotations","_","PdfAnnotationSubtype","PdfBlendMode","import_hooks","import_jsx_runtime","x","PdfAnnotationSubtype","PdfBlendMode","import_hooks","import_jsx_runtime","PdfAnnotationSubtype","v","_","allPoints","s","minX","p","minY","maxX","maxY","halfStroke","d","x","y","i","import_jsx_runtime"]}