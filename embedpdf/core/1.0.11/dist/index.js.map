{"version":3,"file":"index.js","sources":["../src/lib/utils/dependency-resolver.ts","../src/lib/types/errors.ts","../src/lib/store/plugin-store.ts","../src/lib/store/actions.ts","../src/lib/store/store.ts","../src/lib/store/initial-state.ts","../src/lib/store/selectors.ts","../src/lib/store/reducer.ts","../src/lib/registry/plugin-registry.ts","../src/lib/utils/plugin-helpers.ts","../src/lib/base/base-plugin.ts","../src/lib/utils/event-control.ts","../src/lib/utils/math.ts","../src/lib/utils/eventing.ts","../src/lib/utils/typed-object.ts"],"sourcesContent":["export class DependencyResolver {\n  private dependencyGraph = new Map<string, Set<string>>();\n\n  addNode(id: string, dependencies: string[] = []) {\n    this.dependencyGraph.set(id, new Set(dependencies));\n  }\n\n  private hasCircularDependencies(): boolean {\n    const visited = new Set<string>();\n    const recursionStack = new Set<string>();\n\n    const dfs = (id: string): boolean => {\n      visited.add(id);\n      recursionStack.add(id);\n\n      const dependencies = this.dependencyGraph.get(id) || new Set();\n      for (const dep of dependencies) {\n        if (!visited.has(dep)) {\n          if (dfs(dep)) return true;\n        } else if (recursionStack.has(dep)) {\n          return true; // Circular dependency found\n        }\n      }\n\n      recursionStack.delete(id);\n      return false;\n    };\n\n    for (const id of this.dependencyGraph.keys()) {\n      if (!visited.has(id)) {\n        if (dfs(id)) return true;\n      }\n    }\n\n    return false;\n  }\n\n  resolveLoadOrder(): string[] {\n    if (this.hasCircularDependencies()) {\n      throw new Error('Circular dependencies detected');\n    }\n\n    const result: string[] = [];\n    const visited = new Set<string>();\n    const temp = new Set<string>();\n\n    const visit = (id: string) => {\n      if (temp.has(id)) throw new Error('Circular dependency');\n      if (visited.has(id)) return;\n\n      temp.add(id);\n\n      const dependencies = this.dependencyGraph.get(id) || new Set();\n      for (const dep of dependencies) {\n        visit(dep);\n      }\n\n      temp.delete(id);\n      visited.add(id);\n      result.push(id);\n    };\n\n    for (const id of this.dependencyGraph.keys()) {\n      if (!visited.has(id)) {\n        visit(id);\n      }\n    }\n\n    return result;\n  }\n}\n","export class PluginRegistrationError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'PluginRegistrationError';\n  }\n}\n\nexport class PluginNotFoundError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'PluginNotFoundError';\n  }\n}\n\nexport class CircularDependencyError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'CircularDependencyError';\n  }\n}\n\nexport class CapabilityNotFoundError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'CapabilityNotFoundError';\n  }\n}\n\n// You might also want to add:\nexport class CapabilityConflictError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'CapabilityConflictError';\n  }\n}\n\nexport class PluginInitializationError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'PluginInitializationError';\n  }\n}\n\nexport class PluginConfigurationError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'PluginConfigurationError';\n  }\n}\n","import { Store } from './store';\nimport { Action } from './types';\n\n/**\n * A type-safe store handle for plugins, providing access to plugin-specific state and actions.\n */\nexport class PluginStore<PluginState, PluginAction extends Action> {\n  private store: Store<any, any>;\n  private pluginId: string;\n\n  /**\n   * Initializes the PluginStore with the main store and plugin ID.\n   * @param store The main store instance.\n   * @param pluginId The unique identifier for the plugin.\n   */\n  constructor(store: Store<any, any>, pluginId: string) {\n    this.store = store;\n    this.pluginId = pluginId;\n  }\n\n  /**\n   * Gets the current state of the plugin.\n   * @returns The plugin's state.\n   */\n  getState(): PluginState {\n    return this.store.getState().plugins[this.pluginId] as PluginState;\n  }\n\n  /**\n   * Dispatches an action for the plugin and returns the *new* global state.\n   * If you only need the plugin’s updated state, call `getState()` afterward.\n   * @param action The action to dispatch.\n   * @returns The updated global store state (after plugin reducer).\n   */\n  dispatch(action: PluginAction): PluginState {\n    return this.store.dispatchToPlugin(this.pluginId, action);\n  }\n\n  /**\n   * Subscribes to state changes only for this specific plugin.\n   * You now receive (action, newPluginState, oldPluginState) in the callback.\n   *\n   * @param listener The callback to invoke when plugin state changes.\n   * @returns A function to unsubscribe the listener.\n   */\n  subscribeToState(\n    listener: (action: PluginAction, newState: PluginState, oldState: PluginState) => void,\n  ) {\n    return this.store.subscribeToPlugin(this.pluginId, (action, newPluginState, oldPluginState) => {\n      listener(\n        action as PluginAction,\n        newPluginState as PluginState,\n        oldPluginState as PluginState,\n      );\n    });\n  }\n\n  /**\n   * Subscribes to a specific action type for the plugin.\n   * This still uses the main store's `onAction`, so you get the *global*\n   * old/new store states there. If you specifically want old/new plugin state,\n   * use `subscribeToState` instead.\n   *\n   * @param type The action type to listen for.\n   * @param handler The callback to invoke when the action occurs.\n   * @returns A function to unsubscribe the handler.\n   */\n  onAction<T extends PluginAction['type']>(\n    type: T,\n    handler: (\n      action: Extract<PluginAction, { type: T }>,\n      state: PluginState,\n      oldState: PluginState,\n    ) => void,\n  ) {\n    return this.store.onAction(type, (action, state, oldState) => {\n      handler(\n        action as Extract<PluginAction, { type: T }>,\n        state.plugins[this.pluginId] as PluginState,\n        oldState.plugins[this.pluginId] as PluginState,\n      );\n    });\n  }\n}\n","import { PdfDocumentObject, PdfPageObject, Rotation } from '@embedpdf/models';\n\nexport const LOAD_DOCUMENT = 'LOAD_DOCUMENT';\nexport const SET_DOCUMENT = 'SET_DOCUMENT';\nexport const SET_DOCUMENT_ERROR = 'SET_DOCUMENT_ERROR';\nexport const SET_SCALE = 'SET_SCALE';\nexport const SET_ROTATION = 'SET_ROTATION';\nexport const SET_PAGES = 'SET_PAGES';\n\nexport const CORE_ACTION_TYPES = [\n  LOAD_DOCUMENT,\n  SET_DOCUMENT,\n  SET_DOCUMENT_ERROR,\n  SET_SCALE,\n  SET_ROTATION,\n  SET_PAGES,\n] as const;\n\n// Action Type Interfaces\nexport interface LoadDocumentAction {\n  type: typeof LOAD_DOCUMENT;\n}\n\nexport interface SetDocumentAction {\n  type: typeof SET_DOCUMENT;\n  payload: PdfDocumentObject;\n}\n\nexport interface SetDocumentErrorAction {\n  type: typeof SET_DOCUMENT_ERROR;\n  payload: string;\n}\n\nexport interface SetScaleAction {\n  type: typeof SET_SCALE;\n  payload: number;\n}\n\nexport interface SetRotationAction {\n  type: typeof SET_ROTATION;\n  payload: Rotation;\n}\n\nexport interface SetPagesAction {\n  type: typeof SET_PAGES;\n  payload: PdfPageObject[][];\n}\n\nexport type DocumentAction =\n  | LoadDocumentAction\n  | SetDocumentAction\n  | SetDocumentErrorAction\n  | SetScaleAction\n  | SetRotationAction\n  | SetPagesAction;\n\n// Core actions\nexport type CoreAction = DocumentAction;\n\nexport const loadDocument = (): CoreAction => ({ type: LOAD_DOCUMENT });\nexport const setDocument = (document: PdfDocumentObject): CoreAction => ({\n  type: SET_DOCUMENT,\n  payload: document,\n});\nexport const setDocumentError = (error: string): CoreAction => ({\n  type: SET_DOCUMENT_ERROR,\n  payload: error,\n});\nexport const setScale = (scale: number): CoreAction => ({ type: SET_SCALE, payload: scale });\nexport const setRotation = (rotation: Rotation): CoreAction => ({\n  type: SET_ROTATION,\n  payload: rotation,\n});\nexport const setPages = (pages: PdfPageObject[][]): CoreAction => ({\n  type: SET_PAGES,\n  payload: pages,\n});\n","import { Reducer, Action, StoreState, StoreListener, PluginListener } from './types';\nimport { PluginStore } from './plugin-store';\nimport { CORE_ACTION_TYPES } from './actions';\n\n/**\n * A generic, type-safe store class managing core and plugin states, reducers, and subscriptions.\n * @template CoreState The type of the core state.\n * @template CoreAction The type of actions handled by core reducers (extends Action).\n */\nexport class Store<CoreState, CoreAction extends Action = Action> {\n  private state: StoreState<CoreState>;\n  private coreReducer: Reducer<CoreState, CoreAction>;\n  private pluginReducers: Record<string, Reducer<any, Action>> = {};\n\n  private listeners: StoreListener<CoreState>[] = [];\n  private pluginListeners: Record<string, PluginListener[]> = {};\n\n  /**\n   * Initializes the store with the provided core state.\n   * @param reducer          The core reducer function\n   * @param initialCoreState The initial core state\n   */\n  constructor(\n    reducer: Reducer<CoreState, CoreAction>,\n    public initialCoreState: CoreState,\n  ) {\n    this.state = { core: initialCoreState, plugins: {} };\n    this.coreReducer = reducer;\n  }\n\n  /**\n   * Adds a reducer for a plugin-specific state.\n   * @param pluginId The unique identifier for the plugin.\n   * @param reducer The reducer function for the plugin state.\n   * @param initialState The initial state for the plugin.\n   */\n  addPluginReducer<PluginState>(\n    pluginId: string,\n    reducer: Reducer<PluginState, Action>,\n    initialState: PluginState,\n  ) {\n    this.state.plugins[pluginId] = initialState;\n    this.pluginReducers[pluginId] = reducer;\n  }\n\n  /**\n   * Dispatches an action *only* to the core reducer.\n   * Notifies the global store listeners with (action, newState, oldState).\n   *\n   * @param action The action to dispatch, typed as CoreAction\n   * @returns The updated *global* store state\n   */\n  dispatchToCore(action: CoreAction): StoreState<CoreState> {\n    if (!this.coreReducer) {\n      return this.getState();\n    }\n\n    const oldState = this.getState();\n    // Update core state via its reducer\n    this.state.core = this.coreReducer(this.state.core, action);\n\n    const newState = this.getState();\n    // Notify all main-store subscribers\n    this.listeners.forEach((listener) => listener(action, newState, oldState));\n\n    return newState;\n  }\n\n  /**\n   * Dispatches an action *only* to a specific plugin.\n   * Optionally notifies global store listeners if `notifyGlobal` is true.\n   * Always notifies plugin-specific listeners with (action, newPluginState, oldPluginState).\n   *\n   * @param pluginId   The plugin identifier\n   * @param action     The plugin action to dispatch\n   * @param notifyGlobal Whether to also notify global store listeners\n   * @returns The updated *global* store state\n   */\n  dispatchToPlugin<PluginAction extends Action>(\n    pluginId: string,\n    action: PluginAction,\n    notifyGlobal: boolean = true,\n  ): any {\n    const oldGlobalState = this.getState();\n\n    const reducer = this.pluginReducers[pluginId];\n    if (!reducer) {\n      // No plugin found, just return the old state\n      return oldGlobalState;\n    }\n\n    // Grab the old plugin state\n    const oldPluginState = oldGlobalState.plugins[pluginId];\n    // Reduce to new plugin state\n    const newPluginState = reducer(oldPluginState, action);\n    // Update the store's plugin slice\n    this.state.plugins[pluginId] = newPluginState;\n\n    const newGlobalState = this.getState();\n\n    // If we are notifying the main store subscribers about plugin changes\n    if (notifyGlobal) {\n      this.listeners.forEach((listener) => listener(action, newGlobalState, oldGlobalState));\n    }\n\n    // Notify plugin-specific listeners\n    if (this.pluginListeners[pluginId]) {\n      this.pluginListeners[pluginId].forEach((listener) => {\n        listener(action, newPluginState, oldPluginState);\n      });\n    }\n\n    return newPluginState;\n  }\n\n  /**\n   * Dispatches an action to update the state using:\n   * - the core reducer (if it's a CoreAction)\n   * - *all* plugin reducers (regardless of action type), with no global notify for each plugin\n   *\n   * Returns the new *global* store state after all reducers have processed the action.\n   *\n   * @param action The action to dispatch (can be CoreAction or any Action).\n   */\n  dispatch(action: CoreAction | Action): StoreState<CoreState> {\n    // Keep old state to notify global listeners *once*, after all reducers run.\n    const oldState = this.getState();\n    // 1) Apply core reducer (only if action is a CoreAction)\n    if (this.isCoreAction(action)) {\n      this.state.core = this.coreReducer(this.state.core, action);\n    }\n\n    // 2) Apply plugin reducers (without globally notifying after each plugin)\n    for (const pluginId in this.pluginReducers) {\n      const reducer = this.pluginReducers[pluginId];\n      const oldPluginState = oldState.plugins[pluginId];\n      if (reducer) {\n        this.state.plugins[pluginId] = reducer(oldPluginState, action);\n      }\n      // We do *not* notify global listeners or plugin listeners here,\n      // as that might be undesired \"fan-out\". If you want per-plugin subscription\n      // triggered on every dispatch, you can do so here, but that’s up to you.\n    }\n\n    // 3) Notify global listeners *once* with the final new state\n    const newState = this.getState();\n    this.listeners.forEach((listener) => listener(action, newState, oldState));\n\n    // 4) Return the new global store state\n    return newState;\n  }\n\n  /**\n   * Returns a shallow copy of the current state.\n   * @returns The current store state.\n   */\n  getState(): StoreState<CoreState> {\n    return {\n      core: { ...this.state.core },\n      plugins: { ...this.state.plugins },\n    };\n  }\n\n  /**\n   * Subscribes a listener to *global* state changes.\n   * The callback signature is now (action, newState, oldState).\n   *\n   * @param listener The callback to invoke on state changes\n   * @returns A function to unsubscribe the listener\n   */\n  subscribe(listener: StoreListener<CoreState>) {\n    this.listeners.push(listener);\n    return () => {\n      this.listeners = this.listeners.filter((l) => l !== listener);\n    };\n  }\n\n  /**\n   * Subscribes a listener to *plugin-specific* state changes.\n   * The callback signature is now (action, newPluginState, oldPluginState).\n   *\n   * @param pluginId The unique identifier for the plugin.\n   * @param listener The callback to invoke on plugin state changes.\n   * @returns A function to unsubscribe the listener.\n   */\n  subscribeToPlugin(pluginId: string, listener: PluginListener) {\n    if (!(pluginId in this.state.plugins)) {\n      throw new Error(\n        `Plugin state not found for plugin \"${pluginId}\". Did you forget to call addPluginReducer?`,\n      );\n    }\n\n    if (!this.pluginListeners[pluginId]) {\n      this.pluginListeners[pluginId] = [];\n    }\n    this.pluginListeners[pluginId].push(listener);\n\n    return () => {\n      this.pluginListeners[pluginId] = this.pluginListeners[pluginId].filter((l) => l !== listener);\n      if (this.pluginListeners[pluginId].length === 0) {\n        delete this.pluginListeners[pluginId];\n      }\n    };\n  }\n\n  /**\n   * Subscribes to a specific action type (only from the core's action union).\n   * The callback signature is (action, newState, oldState).\n   *\n   * @param type The action type to listen for.\n   * @param handler The callback to invoke when the action occurs.\n   * @returns A function to unsubscribe the handler.\n   */\n  onAction<T extends CoreAction['type']>(\n    type: T,\n    handler: (\n      action: Extract<CoreAction, { type: T }>,\n      state: StoreState<CoreState>,\n      oldState: StoreState<CoreState>,\n    ) => void,\n  ) {\n    return this.subscribe((action, newState, oldState) => {\n      if (action.type === type) {\n        handler(action as Extract<CoreAction, { type: T }>, newState, oldState);\n      }\n    });\n  }\n\n  /**\n   * Gets a PluginStore handle for a specific plugin.\n   * @param pluginId The unique identifier for the plugin.\n   * @returns A PluginStore instance for the plugin.\n   */\n  getPluginStore<PluginState, PluginAction extends Action>(\n    pluginId: string,\n  ): PluginStore<PluginState, PluginAction> {\n    if (!(pluginId in this.state.plugins)) {\n      throw new Error(\n        `Plugin state not found for plugin \"${pluginId}\". Did you forget to call addPluginReducer?`,\n      );\n    }\n    return new PluginStore<PluginState, PluginAction>(this, pluginId);\n  }\n\n  /**\n   * Helper method to check if an action is a CoreAction.\n   * Adjust if you have a more refined way to differentiate CoreAction vs. any other Action.\n   */\n  public isCoreAction(action: Action): action is CoreAction {\n    // In many codebases you'd do something more robust here\n    // or rely on TypeScript's narrowing logic if possible.\n    return CORE_ACTION_TYPES.includes(action.type as (typeof CORE_ACTION_TYPES)[number]);\n  }\n\n  /**\n   * Destroy the store: drop every listener and plugin reducer\n   */\n  public destroy(): void {\n    // 1. empty listener collections\n    this.listeners.length = 0;\n    for (const id in this.pluginListeners) {\n      this.pluginListeners[id]?.splice?.(0);\n    }\n    this.pluginListeners = {};\n\n    // 2. wipe plugin reducers and states\n    this.pluginReducers = {};\n    this.state.plugins = {};\n\n    // 3. reset core state to initial\n    this.state.core = { ...this.initialCoreState };\n  }\n}\n","import { PdfDocumentObject, PdfPageObject, Rotation } from '@embedpdf/models';\nimport { PluginRegistryConfig } from '../types/plugin';\n\nexport interface CoreState {\n  scale: number;\n  rotation: Rotation;\n  document: PdfDocumentObject | null;\n  pages: PdfPageObject[][];\n  loading: boolean;\n  error: string | null;\n}\n\nexport const initialCoreState: (config?: PluginRegistryConfig) => CoreState = (config) => ({\n  scale: config?.scale ?? 1,\n  rotation: config?.rotation ?? Rotation.Degree0,\n  document: null,\n  pages: [],\n  loading: false,\n  error: null,\n});\n","import { CoreState } from './initial-state';\nimport { transformSize, PdfPageObjectWithRotatedSize } from '@embedpdf/models';\n\nexport const getPagesWithRotatedSize = (state: CoreState): PdfPageObjectWithRotatedSize[][] => {\n  return state.pages.map((page) =>\n    page.map((p) => ({\n      ...p,\n      rotatedSize: transformSize(p.size, state.rotation, 1),\n    })),\n  );\n};\n","import { Reducer } from './types';\nimport { CoreState } from './initial-state';\nimport {\n  CoreAction,\n  LOAD_DOCUMENT,\n  SET_DOCUMENT,\n  SET_DOCUMENT_ERROR,\n  SET_PAGES,\n  SET_ROTATION,\n  SET_SCALE,\n} from './actions';\n\nexport const coreReducer: Reducer<CoreState, CoreAction> = (state, action): CoreState => {\n  switch (action.type) {\n    case LOAD_DOCUMENT:\n      return {\n        ...state,\n        loading: true,\n        error: null,\n      };\n\n    case SET_DOCUMENT:\n      return {\n        ...state,\n        document: action.payload,\n        pages: action.payload.pages.map((page) => [page]),\n        loading: false,\n        error: null,\n      };\n\n    case SET_ROTATION:\n      return {\n        ...state,\n        rotation: action.payload,\n      };\n\n    case SET_PAGES:\n      return {\n        ...state,\n        pages: action.payload,\n      };\n\n    case SET_DOCUMENT_ERROR:\n      return {\n        ...state,\n        loading: false,\n        error: action.payload,\n      };\n\n    case SET_SCALE:\n      return {\n        ...state,\n        scale: action.payload,\n      };\n\n    default:\n      return state;\n  }\n};\n","import { DependencyResolver } from '../utils/dependency-resolver';\nimport {\n  IPlugin,\n  PluginBatchRegistration,\n  PluginManifest,\n  PluginStatus,\n  PluginPackage,\n  PluginRegistryConfig,\n} from '../types/plugin';\nimport {\n  PluginRegistrationError,\n  PluginNotFoundError,\n  CircularDependencyError,\n  CapabilityNotFoundError,\n  PluginConfigurationError,\n} from '../types/errors';\nimport { ignore, PdfEngine, Rotation } from '@embedpdf/models';\nimport { Action, CoreState, Store, initialCoreState, Reducer } from '../store';\nimport { CoreAction } from '../store/actions';\nimport { coreReducer } from '../store/reducer';\n\n// Define a more flexible generic type for plugin registrations\ninterface PluginRegistration {\n  // Use existential types for the plugin package to allow accepting any plugin type\n  package: PluginPackage<any, any, any, any>;\n  config?: any;\n}\n\nexport class PluginRegistry {\n  private plugins: Map<string, IPlugin> = new Map();\n  private manifests: Map<string, PluginManifest> = new Map();\n  private capabilities: Map<string, string> = new Map(); // capability -> pluginId\n  private status: Map<string, PluginStatus> = new Map();\n  private resolver: DependencyResolver;\n  private configurations: Map<string, unknown> = new Map();\n  private engine: PdfEngine;\n  private engineInitialized = false;\n  private store: Store<CoreState, CoreAction>;\n  private initPromise: Promise<void> | null = null;\n\n  private pendingRegistrations: PluginRegistration[] = [];\n  private processingRegistrations: PluginRegistration[] = [];\n  private initialized = false;\n  private isInitializing = false;\n  private initialCoreState: CoreState;\n  private pluginsReadyPromise: Promise<void> | null = null;\n  private destroyed = false;\n\n  constructor(engine: PdfEngine, config?: PluginRegistryConfig) {\n    this.resolver = new DependencyResolver();\n    this.engine = engine;\n    this.initialCoreState = initialCoreState(config);\n    this.store = new Store<CoreState, CoreAction>(coreReducer, this.initialCoreState);\n  }\n\n  /**\n   * Ensure engine is initialized before proceeding\n   */\n  private async ensureEngineInitialized(): Promise<void> {\n    if (this.engineInitialized) {\n      return;\n    }\n\n    if (this.engine.initialize) {\n      const task = this.engine.initialize();\n      await task.toPromise();\n      this.engineInitialized = true;\n    } else {\n      this.engineInitialized = true;\n    }\n  }\n\n  /**\n   * Register a plugin without initializing it\n   */\n  registerPlugin<\n    TPlugin extends IPlugin<TConfig>,\n    TConfig = unknown,\n    TState = unknown,\n    TAction extends Action = Action,\n  >(\n    pluginPackage: PluginPackage<TPlugin, TConfig, TState, TAction>,\n    config?: Partial<TConfig>,\n  ): void {\n    if (this.initialized && !this.isInitializing) {\n      throw new PluginRegistrationError('Cannot register plugins after initialization');\n    }\n\n    this.validateManifest(pluginPackage.manifest);\n\n    // Use appropriate typing for store methods\n    this.store.addPluginReducer(\n      pluginPackage.manifest.id,\n      // We need one type assertion here since we can't fully reconcile TAction with Action\n      // due to TypeScript's type system limitations with generic variance\n      pluginPackage.reducer as Reducer<TState, Action>,\n      'function' === typeof pluginPackage.initialState\n        ? (pluginPackage.initialState as (coreState: CoreState, config: TConfig) => TState)(\n            this.initialCoreState,\n            {\n              ...pluginPackage.manifest.defaultConfig,\n              ...config,\n            },\n          )\n        : pluginPackage.initialState,\n    );\n\n    this.pendingRegistrations.push({\n      package: pluginPackage,\n      config,\n    });\n  }\n\n  /**\n   * Get the central store instance\n   */\n  getStore(): Store<CoreState, CoreAction> {\n    return this.store;\n  }\n\n  /**\n   * Get the engine instance\n   */\n  getEngine(): PdfEngine {\n    return this.engine;\n  }\n\n  /**\n   * Get a promise that resolves when all plugins are ready\n   */\n  public pluginsReady(): Promise<void> {\n    // Re-use the same promise every time it’s asked for\n    if (this.pluginsReadyPromise) {\n      return this.pluginsReadyPromise;\n    }\n\n    // Build the promise the *first* time it’s requested\n    this.pluginsReadyPromise = (async () => {\n      // 1. Wait until the registry itself has finished initialising\n      if (!this.initialized) {\n        await this.initialize();\n      }\n\n      // 2. Wait for every plugin’s ready() promise (if it has one)\n      const readyPromises = Array.from(this.plugins.values()).map((p) =>\n        typeof p.ready === 'function' ? p.ready() : Promise.resolve(),\n      );\n\n      await Promise.all(readyPromises); // resolves when the slowest is done\n    })();\n\n    return this.pluginsReadyPromise;\n  }\n\n  /**\n   * INITIALISE THE REGISTRY – runs once no-matter-how-many calls   *\n   */\n  async initialize(): Promise<void> {\n    if (this.destroyed) {\n      throw new PluginRegistrationError('Registry has been destroyed');\n    }\n\n    // If an initialisation is already in-flight (or finished)\n    // return the very same promise so callers can await it.\n    if (this.initPromise) {\n      return this.initPromise;\n    }\n\n    // Wrap your existing body in a single promise and cache it\n    this.initPromise = (async () => {\n      if (this.initialized) {\n        throw new PluginRegistrationError('Registry is already initialized');\n      }\n\n      this.isInitializing = true;\n\n      try {\n        /* ---------------- original body starts ------------------ */\n        await this.ensureEngineInitialized();\n        // Check if destroyed after engine initialization\n        if (this.destroyed) {\n          return;\n        }\n\n        while (this.pendingRegistrations.length > 0) {\n          // Check if destroyed before processing each batch\n          if (this.destroyed) {\n            return;\n          }\n          this.processingRegistrations = [...this.pendingRegistrations];\n          this.pendingRegistrations = [];\n\n          for (const reg of this.processingRegistrations) {\n            const dependsOn = new Set<string>();\n            const allDeps = [...reg.package.manifest.requires, ...reg.package.manifest.optional];\n            for (const cap of allDeps) {\n              const provider = this.processingRegistrations.find((r) =>\n                r.package.manifest.provides.includes(cap),\n              );\n              if (provider) dependsOn.add(provider.package.manifest.id);\n            }\n            this.resolver.addNode(reg.package.manifest.id, [...dependsOn]);\n          }\n\n          const loadOrder = this.resolver.resolveLoadOrder();\n          for (const id of loadOrder) {\n            const reg = this.processingRegistrations.find((r) => r.package.manifest.id === id)!;\n            await this.initializePlugin(reg.package.manifest, reg.package.create, reg.config);\n          }\n\n          this.processingRegistrations = [];\n          this.resolver = new DependencyResolver();\n        }\n\n        for (const plugin of this.plugins.values()) {\n          await plugin.postInitialize?.().catch((e) => {\n            console.error(`Error in postInitialize for plugin ${plugin.id}`, e);\n            this.status.set(plugin.id, 'error');\n          });\n        }\n\n        this.initialized = true;\n        /* ----------------- original body ends ------------------- */\n      } catch (err) {\n        if (err instanceof Error) {\n          throw new CircularDependencyError(\n            `Failed to resolve plugin dependencies: ${err.message}`,\n          );\n        }\n        throw err;\n      } finally {\n        this.isInitializing = false;\n      }\n    })();\n\n    return this.initPromise;\n  }\n\n  /**\n   * Initialize a single plugin with all necessary checks\n   */\n  private async initializePlugin<TConfig>(\n    manifest: PluginManifest<TConfig>,\n    packageCreator: (\n      registry: PluginRegistry,\n      engine: PdfEngine,\n      config?: TConfig,\n    ) => IPlugin<TConfig>,\n    config?: Partial<TConfig>,\n  ): Promise<void> {\n    const finalConfig = {\n      ...manifest.defaultConfig,\n      ...config,\n    };\n\n    this.validateConfig(manifest.id, finalConfig, manifest.defaultConfig);\n\n    // Create plugin instance during initialization\n    const plugin = packageCreator(this, this.engine, finalConfig);\n    this.validatePlugin(plugin);\n\n    // Verify all required capabilities are available\n    for (const capability of manifest.requires) {\n      if (!this.capabilities.has(capability)) {\n        throw new PluginRegistrationError(\n          `Missing required capability: ${capability} for plugin ${manifest.id}`,\n        );\n      }\n    }\n\n    // Optional capabilities can be null, so we don't throw errors for them\n    for (const capability of manifest.optional) {\n      if (this.capabilities.has(capability)) {\n        // Optional capability is available, but we don't require it\n        console.debug(`Optional capability ${capability} is available for plugin ${manifest.id}`);\n      }\n    }\n\n    console.log('initializePlugin', manifest.id, manifest.provides);\n\n    // Register provided capabilities\n    for (const capability of manifest.provides) {\n      if (this.capabilities.has(capability)) {\n        throw new PluginRegistrationError(\n          `Capability ${capability} is already provided by plugin ${this.capabilities.get(capability)}`,\n        );\n      }\n      this.capabilities.set(capability, manifest.id);\n    }\n\n    // Store plugin and manifest\n    this.plugins.set(manifest.id, plugin);\n    this.manifests.set(manifest.id, manifest);\n    this.status.set(manifest.id, 'registered');\n    this.configurations.set(manifest.id, finalConfig);\n\n    try {\n      if (plugin.initialize) {\n        await plugin.initialize(finalConfig);\n      }\n      this.status.set(manifest.id, 'active');\n    } catch (error) {\n      // Cleanup on initialization failure\n      this.plugins.delete(manifest.id);\n      this.manifests.delete(manifest.id);\n      console.log('initializePlugin failed', manifest.id, manifest.provides);\n      manifest.provides.forEach((cap) => this.capabilities.delete(cap));\n      throw error;\n    }\n  }\n\n  getPluginConfig<TConfig>(pluginId: string): TConfig {\n    const config = this.configurations.get(pluginId);\n    if (!config) {\n      throw new PluginNotFoundError(`Configuration for plugin ${pluginId} not found`);\n    }\n    return config as TConfig;\n  }\n\n  private validateConfig(pluginId: string, config: unknown, defaultConfig: unknown): void {\n    // Check all required fields exist\n    const requiredKeys = Object.keys(defaultConfig as object);\n    const missingKeys = requiredKeys.filter((key) => !(config as object).hasOwnProperty(key));\n\n    if (missingKeys.length > 0) {\n      throw new PluginConfigurationError(\n        `Missing required configuration keys for plugin ${pluginId}: ${missingKeys.join(', ')}`,\n      );\n    }\n\n    // You could add more validation here:\n    // - Type checking\n    // - Value range validation\n    // - Format validation\n    // etc.\n  }\n\n  async updatePluginConfig<TConfig>(pluginId: string, config: Partial<TConfig>): Promise<void> {\n    const plugin = this.getPlugin(pluginId);\n\n    if (!plugin) {\n      throw new PluginNotFoundError(`Plugin ${pluginId} not found`);\n    }\n\n    const manifest = this.manifests.get(pluginId);\n    const currentConfig = this.configurations.get(pluginId);\n\n    if (!manifest || !currentConfig) {\n      throw new PluginNotFoundError(`Plugin ${pluginId} not found`);\n    }\n\n    // Merge new config with current\n    const newConfig = {\n      ...currentConfig,\n      ...config,\n    };\n\n    // Validate new configuration\n    this.validateConfig(pluginId, newConfig, manifest.defaultConfig);\n\n    // Store new configuration\n    this.configurations.set(pluginId, newConfig);\n\n    // Reinitialize plugin if needed\n    if (plugin.initialize) {\n      await plugin.initialize(newConfig);\n    }\n  }\n\n  /**\n   * Register multiple plugins at once\n   */\n  registerPluginBatch(registrations: PluginBatchRegistration<IPlugin<any>, any, any, any>[]): void {\n    for (const reg of registrations) {\n      this.registerPlugin(reg.package, reg.config);\n    }\n  }\n\n  /**\n   * Unregister a plugin\n   */\n  async unregisterPlugin(pluginId: string): Promise<void> {\n    const plugin = this.plugins.get(pluginId);\n    if (!plugin) {\n      throw new PluginNotFoundError(`Plugin ${pluginId} is not registered`);\n    }\n\n    const manifest = this.manifests.get(pluginId);\n    if (!manifest) {\n      throw new PluginNotFoundError(`Manifest for plugin ${pluginId} not found`);\n    }\n\n    // Check if any other plugins depend on this one\n    for (const [otherId, otherManifest] of this.manifests.entries()) {\n      if (otherId === pluginId) continue;\n\n      const dependsOnThis = [...otherManifest.requires, ...otherManifest.optional].some((cap) =>\n        manifest.provides.includes(cap),\n      );\n\n      if (dependsOnThis) {\n        throw new PluginRegistrationError(\n          `Cannot unregister plugin ${pluginId}: plugin ${otherId} depends on it`,\n        );\n      }\n    }\n\n    // Cleanup plugin\n    try {\n      if (plugin.destroy) {\n        await plugin.destroy();\n      }\n\n      // Remove capabilities\n      for (const capability of manifest.provides) {\n        this.capabilities.delete(capability);\n      }\n\n      // Remove plugin and manifest\n      this.plugins.delete(pluginId);\n      this.manifests.delete(pluginId);\n      this.status.delete(pluginId);\n    } catch (error) {\n      if (error instanceof Error) {\n        throw new Error(`Failed to unregister plugin ${pluginId}: ${error.message}`);\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Get a plugin instance\n   * @param pluginId The ID of the plugin to get\n   * @returns The plugin instance or null if not found\n   */\n  getPlugin<T extends IPlugin>(pluginId: string): T | null {\n    const plugin = this.plugins.get(pluginId);\n    if (!plugin) {\n      return null;\n    }\n    return plugin as T;\n  }\n\n  /**\n   * Get a plugin that provides a specific capability\n   * @param capability The capability to get a provider for\n   * @returns The plugin providing the capability or null if not found\n   */\n  getCapabilityProvider(capability: string): IPlugin | null {\n    const pluginId = this.capabilities.get(capability);\n    if (!pluginId) {\n      return null;\n    }\n    return this.getPlugin(pluginId);\n  }\n\n  /**\n   * Check if a capability is available\n   */\n  hasCapability(capability: string): boolean {\n    return this.capabilities.has(capability);\n  }\n\n  /**\n   * Get all registered plugins\n   */\n  getAllPlugins(): IPlugin[] {\n    return Array.from(this.plugins.values());\n  }\n\n  /**\n   * Get plugin status\n   */\n  getPluginStatus(pluginId: string): PluginStatus {\n    const status = this.status.get(pluginId);\n    if (!status) {\n      throw new PluginNotFoundError(`Plugin ${pluginId} not found`);\n    }\n    return status;\n  }\n\n  /**\n   * Validate plugin object\n   */\n  private validatePlugin(plugin: IPlugin): void {\n    if (!plugin.id) {\n      throw new PluginRegistrationError('Plugin must have an id');\n    }\n  }\n\n  /**\n   * Validate plugin manifest\n   */\n  private validateManifest(manifest: PluginManifest): void {\n    if (!manifest.id) {\n      throw new PluginRegistrationError('Manifest must have an id');\n    }\n    if (!manifest.name) {\n      throw new PluginRegistrationError('Manifest must have a name');\n    }\n    if (!manifest.version) {\n      throw new PluginRegistrationError('Manifest must have a version');\n    }\n    if (!Array.isArray(manifest.provides)) {\n      throw new PluginRegistrationError('Manifest must have a provides array');\n    }\n    if (!Array.isArray(manifest.requires)) {\n      throw new PluginRegistrationError('Manifest must have a requires array');\n    }\n    if (!Array.isArray(manifest.optional)) {\n      throw new PluginRegistrationError('Manifest must have an optional array');\n    }\n  }\n\n  isDestroyed(): boolean {\n    return this.destroyed;\n  }\n\n  /**\n   * DESTROY EVERYTHING – waits for any ongoing initialise(), once  *\n   */\n  async destroy(): Promise<void> {\n    if (this.destroyed) throw new PluginRegistrationError('Registry has already been destroyed');\n    this.destroyed = true;\n\n    // If initialisation is still underway, wait (success OR failure)\n    try {\n      await this.initPromise;\n    } catch {\n      /* ignore – still need to clean up */\n    }\n\n    /* ------- original teardown, unchanged except the guard ------ */\n    for (const plugin of Array.from(this.plugins.values()).reverse()) {\n      await plugin.destroy?.();\n    }\n\n    this.store.destroy();\n\n    this.plugins.clear();\n    this.manifests.clear();\n    this.capabilities.clear();\n    this.status.clear();\n    this.pendingRegistrations.length = 0;\n    this.processingRegistrations.length = 0;\n  }\n}\n","import { Action } from '../store';\nimport { IPlugin, PluginBatchRegistration, PluginPackage } from '../types/plugin';\n\n/**\n * Helper function to create a properly typed plugin registration\n */\nexport function createPluginRegistration<\n  T extends IPlugin<TConfig>,\n  TConfig,\n  TState,\n  TAction extends Action,\n>(\n  pluginPackage: PluginPackage<T, TConfig, TState, TAction>,\n  config?: Partial<TConfig>,\n): PluginBatchRegistration<T, TConfig, any, any> {\n  return {\n    package: pluginPackage,\n    config,\n  };\n}\n","import { IPlugin } from '../types/plugin';\nimport { PluginRegistry } from '../registry/plugin-registry';\nimport { Action, CoreAction, CoreState, PluginStore, Store, StoreState } from '../store';\n\nexport interface StateChangeHandler<TState> {\n  (state: TState): void;\n}\n\nexport abstract class BasePlugin<\n  TConfig = unknown,\n  TCapability = unknown,\n  TState = unknown,\n  TAction extends Action = Action,\n> implements IPlugin<TConfig>\n{\n  static readonly id: string;\n\n  protected pluginStore: PluginStore<TState, TAction>;\n  protected coreStore: Store<CoreState, CoreAction>;\n  // Track debounced actions\n  private debouncedActions: Record<string, number> = {};\n  private unsubscribeFromState: (() => void) | null = null;\n  private unsubscribeFromCoreStore: (() => void) | null = null;\n\n  private _capability?: Readonly<TCapability>;\n\n  private readyPromise: Promise<void>;\n  private readyResolve!: () => void;\n\n  constructor(\n    public readonly id: string,\n    protected registry: PluginRegistry,\n  ) {\n    if (id !== (this.constructor as typeof BasePlugin).id) {\n      throw new Error(\n        `Plugin ID mismatch: ${id} !== ${(this.constructor as typeof BasePlugin).id}`,\n      );\n    }\n    this.coreStore = this.registry.getStore();\n    this.pluginStore = this.coreStore.getPluginStore<TState, TAction>(this.id);\n    this.unsubscribeFromState = this.pluginStore.subscribeToState((action, newState, oldState) => {\n      this.onStoreUpdated(oldState, newState);\n    });\n    this.unsubscribeFromCoreStore = this.coreStore.subscribe((action, newState, oldState) => {\n      this.onCoreStoreUpdated(oldState, newState);\n    });\n\n    // Initialize ready state\n    this.readyPromise = new Promise((resolve) => {\n      this.readyResolve = resolve;\n    });\n    // By default, plugins are ready immediately\n    this.readyResolve();\n  }\n\n  /** Construct the public capability (called once & cached). */\n  protected abstract buildCapability(): TCapability;\n\n  public provides(): Readonly<TCapability> {\n    if (!this._capability) {\n      const cap = this.buildCapability();\n\n      this._capability = Object.freeze(cap);\n    }\n    return this._capability;\n  }\n\n  /**\n   * Initialize plugin with config\n   */\n  abstract initialize(config: TConfig): Promise<void>;\n\n  /**\n   *  Get a copy of the current state\n   */\n  protected get state(): Readonly<TState> {\n    return this.pluginStore.getState();\n  }\n\n  /**\n   *  Get a copy of the current core state\n   */\n  protected get coreState(): Readonly<StoreState<CoreState>> {\n    return this.coreStore.getState();\n  }\n\n  /**\n   * @deprecated  use `this.state` Get a copy of the current state\n   */\n  protected getState(): TState {\n    return this.pluginStore.getState();\n  }\n\n  /**\n   * @deprecated  use `this.coreState` Get a copy of the current core state\n   */\n  protected getCoreState(): StoreState<CoreState> {\n    return this.coreStore.getState();\n  }\n\n  /**\n   * Core Dispatch\n   */\n  protected dispatchCoreAction(action: CoreAction): StoreState<CoreState> {\n    return this.coreStore.dispatchToCore(action);\n  }\n\n  /**\n   * Dispatch an action to all plugins\n   */\n  protected dispatchToAllPlugins(action: TAction): StoreState<CoreState> {\n    return this.coreStore.dispatch(action);\n  }\n\n  /**\n   * Dispatch an action\n   */\n  protected dispatch(action: TAction): TState {\n    return this.pluginStore.dispatch(action);\n  }\n\n  /**\n   * Dispatch an action with debouncing to prevent rapid repeated calls\n   * @param action The action to dispatch\n   * @param debounceTime Time in ms to debounce (default: 100ms)\n   * @returns boolean indicating whether the action was dispatched or debounced\n   */\n  protected debouncedDispatch(action: TAction, debounceTime: number = 100): boolean {\n    const now = Date.now();\n    const lastActionTime = this.debouncedActions[action.type] || 0;\n\n    if (now - lastActionTime >= debounceTime) {\n      this.debouncedActions[action.type] = now;\n      this.dispatch(action);\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Subscribe to state changes\n   */\n  protected subscribe(listener: (action: TAction, state: TState) => void): () => void {\n    return this.pluginStore.subscribeToState(listener);\n  }\n\n  /**\n   * Subscribe to core store changes\n   */\n  protected subscribeToCoreStore(\n    listener: (action: Action, state: StoreState<CoreState>) => void,\n  ): () => void {\n    return this.coreStore.subscribe(listener);\n  }\n\n  /**\n   * Called when the plugin store state is updated\n   * @param oldState Previous state\n   * @param newState New state\n   */\n  protected onStoreUpdated(oldState: TState, newState: TState): void {\n    // Default implementation does nothing - can be overridden by plugins\n  }\n\n  /**\n   * Called when the core store state is updated\n   * @param oldState Previous state\n   * @param newState New state\n   */\n  protected onCoreStoreUpdated(\n    oldState: StoreState<CoreState>,\n    newState: StoreState<CoreState>,\n  ): void {\n    // Default implementation does nothing - can be overridden by plugins\n  }\n\n  /**\n   * Cleanup method to be called when plugin is being destroyed\n   */\n  public destroy(): void {\n    if (this.unsubscribeFromState) {\n      this.unsubscribeFromState();\n      this.unsubscribeFromState = null;\n    }\n    if (this.unsubscribeFromCoreStore) {\n      this.unsubscribeFromCoreStore();\n      this.unsubscribeFromCoreStore = null;\n    }\n  }\n\n  /**\n   * Returns a promise that resolves when the plugin is ready\n   */\n  public ready(): Promise<void> {\n    return this.readyPromise;\n  }\n\n  /**\n   * Mark the plugin as ready\n   */\n  protected markReady(): void {\n    this.readyResolve();\n  }\n\n  /**\n   * Reset the ready state (useful for plugins that need to reinitialize)\n   */\n  protected resetReady(): void {\n    this.readyPromise = new Promise((resolve) => {\n      this.readyResolve = resolve;\n    });\n  }\n}\n","export type EventHandler<T> = (data: T) => void;\n\nexport interface BaseEventControlOptions {\n  wait: number;\n}\n\nexport interface DebounceOptions extends BaseEventControlOptions {\n  mode: 'debounce';\n}\n\nexport interface ThrottleOptions extends BaseEventControlOptions {\n  mode: 'throttle';\n  throttleMode?: 'leading-trailing' | 'trailing';\n}\n\nexport type EventControlOptions = DebounceOptions | ThrottleOptions;\n\nexport class EventControl<T> {\n  private timeoutId?: number;\n  private lastRun: number = 0;\n\n  constructor(\n    private handler: EventHandler<T>,\n    private options: EventControlOptions,\n  ) {}\n\n  handle = (data: T): void => {\n    if (this.options.mode === 'debounce') {\n      this.debounce(data);\n    } else {\n      this.throttle(data);\n    }\n  };\n\n  private debounce(data: T): void {\n    if (this.timeoutId) {\n      window.clearTimeout(this.timeoutId);\n    }\n\n    this.timeoutId = window.setTimeout(() => {\n      this.handler(data);\n      this.timeoutId = undefined;\n    }, this.options.wait);\n  }\n\n  private throttle(data: T): void {\n    if (this.options.mode === 'debounce') return;\n\n    const now = Date.now();\n    const throttleMode = this.options.throttleMode || 'leading-trailing';\n\n    if (now - this.lastRun >= this.options.wait) {\n      if (throttleMode === 'leading-trailing') {\n        this.handler(data);\n      }\n      this.lastRun = now;\n    }\n\n    // Always schedule the trailing execution\n    if (this.timeoutId) {\n      window.clearTimeout(this.timeoutId);\n    }\n\n    this.timeoutId = window.setTimeout(\n      () => {\n        this.handler(data);\n        this.lastRun = Date.now();\n        this.timeoutId = undefined;\n      },\n      this.options.wait - (now - this.lastRun),\n    );\n  }\n\n  destroy(): void {\n    if (this.timeoutId) {\n      window.clearTimeout(this.timeoutId);\n    }\n  }\n}\n","/**\n * Restrict a numeric value to the inclusive range [min, max].\n *\n * @example\n *   clamp( 5, 0, 10)  // 5\n *   clamp(-3, 0, 10)  // 0\n *   clamp(17, 0, 10)  // 10\n */\nexport function clamp(value: number, min: number, max: number): number {\n  return value < min ? min : value > max ? max : value;\n}\n\n/**\n * Deeply compares two values (objects, arrays, primitives)\n * with the following rules:\n *  - Objects are compared ignoring property order.\n *  - Arrays are compared ignoring element order (multiset comparison).\n *  - Primitives are compared by strict equality.\n *  - null/undefined are treated as normal primitives.\n *\n * @param a First value\n * @param b Second value\n * @param visited Used internally to detect cycles\n */\nexport function arePropsEqual(a: any, b: any, visited?: Set<any>): boolean {\n  // Quick path for reference equality or same primitive\n  if (a === b) {\n    return true;\n  }\n\n  // Handle null/undefined mismatch\n  if (a == null || b == null) {\n    // If one is null/undefined and the other isn't, no match\n    return a === b;\n  }\n\n  // Check types\n  const aType = typeof a;\n  const bType = typeof b;\n  if (aType !== bType) return false;\n\n  // If they are both objects or arrays, handle recursively\n  if (aType === 'object') {\n    // Optionally handle cyclical references\n    if (!visited) visited = new Set();\n    const pairId = getPairId(a, b);\n    if (visited.has(pairId)) {\n      // Already compared these two objects => assume true to avoid infinite recursion\n      // or return false if you want to treat cycles as inequality\n      return true;\n    }\n    visited.add(pairId);\n\n    const aIsArray = Array.isArray(a);\n    const bIsArray = Array.isArray(b);\n    if (aIsArray && bIsArray) {\n      // Compare as arrays ignoring order\n      return arraysEqualUnordered(a, b, visited);\n    } else if (!aIsArray && !bIsArray) {\n      // Compare as plain objects (order of properties doesn't matter)\n      return objectsEqual(a, b, visited);\n    } else {\n      // One is array, the other is object => not equal\n      return false;\n    }\n  }\n\n  // If both are function, symbol, etc. - typically we might say false\n  // But you can decide your own logic for function or symbol equality\n  return false;\n}\n\nfunction getPairId(a: any, b: any) {\n  // Could do something more advanced. This is a cheap approach:\n  // e.g. use the memory reference or an object identity approach\n  return `${objectId(a)}__${objectId(b)}`;\n}\n\n/**\n * If you want stable object IDs, you'd need a WeakMap to store them.\n * This simplistic approach just calls toString on the object.\n */\nlet objectIdCounter = 0;\nconst objectIds = new WeakMap<object, number>();\n\nfunction objectId(obj: object): number {\n  if (!objectIds.has(obj)) {\n    objectIds.set(obj, ++objectIdCounter);\n  }\n  return objectIds.get(obj)!;\n}\n\nfunction arraysEqualUnordered(a: any[], b: any[], visited?: Set<any>): boolean {\n  if (a.length !== b.length) return false;\n\n  const used = new Array<boolean>(b.length).fill(false);\n\n  // For each element in a, find an unused matching element in b\n  outer: for (let i = 0; i < a.length; i++) {\n    const elemA = a[i];\n    for (let j = 0; j < b.length; j++) {\n      if (used[j]) continue; // already used that slot\n      if (arePropsEqual(elemA, b[j], visited)) {\n        used[j] = true;\n        continue outer; // found match for a[i], proceed\n      }\n    }\n    // If we never found a match\n    return false;\n  }\n\n  return true;\n}\n\nfunction objectsEqual(a: object, b: object, visited?: Set<any>): boolean {\n  // Get all prop keys\n  const aKeys = Object.keys(a).sort();\n  const bKeys = Object.keys(b).sort();\n  if (aKeys.length !== bKeys.length) return false;\n\n  // Compare each property name\n  for (let i = 0; i < aKeys.length; i++) {\n    if (aKeys[i] !== bKeys[i]) return false;\n  }\n\n  // Compare each property value\n  for (const key of aKeys) {\n    // @ts-ignore\n    const valA = a[key];\n    // @ts-ignore\n    const valB = b[key];\n    if (!arePropsEqual(valA, valB, visited)) {\n      return false;\n    }\n  }\n  return true;\n}\n","import { EventControl, EventControlOptions } from './event-control';\nimport { arePropsEqual } from './math';\n\n/* ------------------------------------------------------------------ */\n/* basic types                                                        */\n/* ------------------------------------------------------------------ */\nexport type Listener<T = any> = (value: T) => void;\nexport type Unsubscribe = () => void;\n\n/* ------------------------------------------------------------------ */\n/* EventListener                                                      */\n/* ------------------------------------------------------------------ */\nexport type EventListener<T> =\n  | ((listener: Listener<T>) => Unsubscribe)\n  | ((listener: Listener<T>, options?: EventControlOptions) => Unsubscribe);\n\n/* ------------------------------------------------------------ */\n/* helpers for typing `.on()` with an optional second argument  */\n/* ------------------------------------------------------------ */\nexport type EventHook<T = any> = EventListener<T>;\n/* ------------------------------------------------------------------ */\n/* minimal “dumb” emitter (no value cache, no equality)               */\n/* ------------------------------------------------------------------ */\nexport interface Emitter<T = any> {\n  emit(value?: T): void;\n  on(listener: Listener<T>): Unsubscribe;\n  off(listener: Listener<T>): void;\n  clear(): void;\n}\n\nexport function createEmitter<T = any>(): Emitter<T> {\n  const listeners = new Set<Listener<T>>();\n\n  const on: EventHook<T> = (l: Listener<T>) => {\n    listeners.add(l);\n    return () => listeners.delete(l);\n  };\n\n  return {\n    emit: (v = undefined as T) => listeners.forEach((l) => l(v)),\n    on,\n    off: (l) => listeners.delete(l),\n    clear: () => listeners.clear(),\n  };\n}\n\n/* ------------------------------------------------------------ */\n/* public interface                                              */\n/* ------------------------------------------------------------ */\nexport interface BehaviorEmitter<T = any> extends Omit<Emitter<T>, 'on' | 'off'> {\n  readonly value?: T;\n  on: EventHook<T>;\n  off(listener: Listener<T>): void;\n  select<U>(selector: (v: T) => U, equality?: (a: U, b: U) => boolean): EventHook<U>;\n}\n\n/* ------------------------------------------------------------ */\n/* implementation                                               */\n/* ------------------------------------------------------------ */\nexport function createBehaviorEmitter<T = any>(\n  initial?: T,\n  equality: (a: T, b: T) => boolean = arePropsEqual,\n): BehaviorEmitter<T> {\n  const listeners = new Set<Listener<T>>();\n  const proxyMap = new Map<Listener<T>, { wrapped: Listener<T>; destroy: () => void }>();\n  let _value = initial; // cached value\n\n  /* -------------- helpers ----------------------------------- */\n  const notify = (v: T) => listeners.forEach((l) => l(v));\n\n  const baseOn: EventHook<T> = (listener: Listener<T>, options?: EventControlOptions) => {\n    /* wrap & remember if we have control options ------------------ */\n    let realListener = listener;\n    let destroy = () => {};\n\n    if (options) {\n      const ctl = new EventControl(listener, options);\n      realListener = ctl.handle as Listener<T>;\n      destroy = () => ctl.destroy();\n      proxyMap.set(listener, { wrapped: realListener, destroy });\n    }\n\n    /* immediate replay of last value ------------------------------ */\n    if (_value !== undefined) realListener(_value);\n\n    listeners.add(realListener);\n\n    return () => {\n      listeners.delete(realListener);\n      destroy();\n      proxyMap.delete(listener);\n    };\n  };\n\n  /* -------------- public object ------------------------------ */\n  return {\n    /* emitter behaviour ---------------------------------------- */\n    get value() {\n      return _value;\n    },\n\n    emit(v = undefined as T) {\n      if (_value === undefined || !equality(_value, v)) {\n        _value = v;\n        notify(v);\n      }\n    },\n\n    on: baseOn,\n    off(listener: Listener<T>) {\n      /* did we wrap this listener? */\n      const proxy = proxyMap.get(listener);\n      if (proxy) {\n        listeners.delete(proxy.wrapped);\n        proxy.destroy();\n        proxyMap.delete(listener);\n      } else {\n        listeners.delete(listener);\n      }\n    },\n\n    clear() {\n      listeners.clear();\n      proxyMap.forEach((p) => p.destroy());\n      proxyMap.clear();\n    },\n\n    /* derived hook --------------------------------------------- */\n    select<U>(selector: (v: T) => U, eq: (a: U, b: U) => boolean = arePropsEqual): EventHook<U> {\n      return (listener: Listener<U>, options?: EventControlOptions) => {\n        let prev: U | undefined;\n\n        /* replay */\n        if (_value !== undefined) {\n          const mapped = selector(_value);\n          prev = mapped;\n          listener(mapped);\n        }\n\n        /* subscribe to parent */\n        return baseOn(\n          (next) => {\n            const mapped = selector(next);\n            if (prev === undefined || !eq(prev, mapped)) {\n              prev = mapped;\n              listener(mapped);\n            }\n          },\n          options as EventControlOptions | undefined,\n        ); // pass control opts straight through\n      };\n    },\n  };\n}\n","/* ------------------------------------------------------------------ */\n/*  enumEntries – iterate over enum-keyed Records with strong typing  */\n/* ------------------------------------------------------------------ */\n\ntype EnumKey = string | number;\n\n/**\n * Iterate over a Record whose keys are enum members (numeric or string),\n * getting back a fully-typed `[key, value]` tuple array.\n *\n * Usage:\n *   for (const [subtype, defaults] of enumEntries(this.state.toolDefaults)) {\n *     // subtype is inferred as keyof ToolDefaultsBySubtype\n *   }\n */\nexport function enumEntries<E extends EnumKey, V>(record: Record<E, V>): Array<[E, V]> {\n  // Tell TS the values are V (not unknown) *before* we map.\n  return (Object.entries(record) as [string, V][]).map(([k, v]) => {\n    // Numeric enums come out of Object.entries as \"0\", \"1\", …  → convert.\n    const maybeNum = Number(k);\n    const typedKey: E =\n      Number.isFinite(maybeNum) && k.trim() !== '' // looks like a number?\n        ? (maybeNum as unknown as E) // numeric enum key\n        : (k as unknown as E); // string enum key\n\n    return [typedKey, v]; // v is already typed as V\n  });\n}\n"],"names":["DependencyResolver","id","dependencies","visited","recursionStack","dfs","dep","result","temp","visit","PluginRegistrationError","message","PluginNotFoundError","CircularDependencyError","CapabilityNotFoundError","CapabilityConflictError","PluginInitializationError","PluginConfigurationError","PluginStore","store","pluginId","action","listener","newPluginState","oldPluginState","type","handler","state","oldState","LOAD_DOCUMENT","SET_DOCUMENT","SET_DOCUMENT_ERROR","SET_SCALE","SET_ROTATION","SET_PAGES","CORE_ACTION_TYPES","loadDocument","setDocument","document","setDocumentError","error","setScale","scale","setRotation","rotation","setPages","pages","Store","reducer","initialCoreState","initialState","newState","notifyGlobal","oldGlobalState","newGlobalState","l","_b","_a","config","Rotation","getPagesWithRotatedSize","page","p","transformSize","coreReducer","PluginRegistry","engine","pluginPackage","readyPromises","reg","dependsOn","allDeps","cap","provider","r","loadOrder","plugin","e","err","manifest","packageCreator","finalConfig","capability","defaultConfig","missingKeys","key","currentConfig","newConfig","registrations","otherId","otherManifest","status","createPluginRegistration","BasePlugin","registry","resolve","debounceTime","now","lastActionTime","EventControl","options","data","throttleMode","clamp","value","min","max","arePropsEqual","a","b","aType","pairId","getPairId","aIsArray","bIsArray","arraysEqualUnordered","objectsEqual","objectId","objectIdCounter","objectIds","obj","used","outer","i","elemA","j","aKeys","bKeys","valA","valB","createEmitter","listeners","v","createBehaviorEmitter","initial","equality","proxyMap","_value","notify","baseOn","realListener","destroy","ctl","proxy","selector","eq","prev","mapped","next","enumEntries","record","k","maybeNum"],"mappings":"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"}