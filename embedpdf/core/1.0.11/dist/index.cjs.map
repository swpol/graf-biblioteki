{"version":3,"file":"index.cjs","sources":["../src/lib/utils/dependency-resolver.ts","../src/lib/types/errors.ts","../src/lib/store/plugin-store.ts","../src/lib/store/actions.ts","../src/lib/store/store.ts","../src/lib/store/initial-state.ts","../src/lib/store/selectors.ts","../src/lib/store/reducer.ts","../src/lib/registry/plugin-registry.ts","../src/lib/utils/plugin-helpers.ts","../src/lib/base/base-plugin.ts","../src/lib/utils/event-control.ts","../src/lib/utils/math.ts","../src/lib/utils/eventing.ts","../src/lib/utils/typed-object.ts"],"sourcesContent":["export class DependencyResolver {\n  private dependencyGraph = new Map<string, Set<string>>();\n\n  addNode(id: string, dependencies: string[] = []) {\n    this.dependencyGraph.set(id, new Set(dependencies));\n  }\n\n  private hasCircularDependencies(): boolean {\n    const visited = new Set<string>();\n    const recursionStack = new Set<string>();\n\n    const dfs = (id: string): boolean => {\n      visited.add(id);\n      recursionStack.add(id);\n\n      const dependencies = this.dependencyGraph.get(id) || new Set();\n      for (const dep of dependencies) {\n        if (!visited.has(dep)) {\n          if (dfs(dep)) return true;\n        } else if (recursionStack.has(dep)) {\n          return true; // Circular dependency found\n        }\n      }\n\n      recursionStack.delete(id);\n      return false;\n    };\n\n    for (const id of this.dependencyGraph.keys()) {\n      if (!visited.has(id)) {\n        if (dfs(id)) return true;\n      }\n    }\n\n    return false;\n  }\n\n  resolveLoadOrder(): string[] {\n    if (this.hasCircularDependencies()) {\n      throw new Error('Circular dependencies detected');\n    }\n\n    const result: string[] = [];\n    const visited = new Set<string>();\n    const temp = new Set<string>();\n\n    const visit = (id: string) => {\n      if (temp.has(id)) throw new Error('Circular dependency');\n      if (visited.has(id)) return;\n\n      temp.add(id);\n\n      const dependencies = this.dependencyGraph.get(id) || new Set();\n      for (const dep of dependencies) {\n        visit(dep);\n      }\n\n      temp.delete(id);\n      visited.add(id);\n      result.push(id);\n    };\n\n    for (const id of this.dependencyGraph.keys()) {\n      if (!visited.has(id)) {\n        visit(id);\n      }\n    }\n\n    return result;\n  }\n}\n","export class PluginRegistrationError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'PluginRegistrationError';\n  }\n}\n\nexport class PluginNotFoundError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'PluginNotFoundError';\n  }\n}\n\nexport class CircularDependencyError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'CircularDependencyError';\n  }\n}\n\nexport class CapabilityNotFoundError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'CapabilityNotFoundError';\n  }\n}\n\n// You might also want to add:\nexport class CapabilityConflictError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'CapabilityConflictError';\n  }\n}\n\nexport class PluginInitializationError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'PluginInitializationError';\n  }\n}\n\nexport class PluginConfigurationError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'PluginConfigurationError';\n  }\n}\n","import { Store } from './store';\nimport { Action } from './types';\n\n/**\n * A type-safe store handle for plugins, providing access to plugin-specific state and actions.\n */\nexport class PluginStore<PluginState, PluginAction extends Action> {\n  private store: Store<any, any>;\n  private pluginId: string;\n\n  /**\n   * Initializes the PluginStore with the main store and plugin ID.\n   * @param store The main store instance.\n   * @param pluginId The unique identifier for the plugin.\n   */\n  constructor(store: Store<any, any>, pluginId: string) {\n    this.store = store;\n    this.pluginId = pluginId;\n  }\n\n  /**\n   * Gets the current state of the plugin.\n   * @returns The plugin's state.\n   */\n  getState(): PluginState {\n    return this.store.getState().plugins[this.pluginId] as PluginState;\n  }\n\n  /**\n   * Dispatches an action for the plugin and returns the *new* global state.\n   * If you only need the plugin’s updated state, call `getState()` afterward.\n   * @param action The action to dispatch.\n   * @returns The updated global store state (after plugin reducer).\n   */\n  dispatch(action: PluginAction): PluginState {\n    return this.store.dispatchToPlugin(this.pluginId, action);\n  }\n\n  /**\n   * Subscribes to state changes only for this specific plugin.\n   * You now receive (action, newPluginState, oldPluginState) in the callback.\n   *\n   * @param listener The callback to invoke when plugin state changes.\n   * @returns A function to unsubscribe the listener.\n   */\n  subscribeToState(\n    listener: (action: PluginAction, newState: PluginState, oldState: PluginState) => void,\n  ) {\n    return this.store.subscribeToPlugin(this.pluginId, (action, newPluginState, oldPluginState) => {\n      listener(\n        action as PluginAction,\n        newPluginState as PluginState,\n        oldPluginState as PluginState,\n      );\n    });\n  }\n\n  /**\n   * Subscribes to a specific action type for the plugin.\n   * This still uses the main store's `onAction`, so you get the *global*\n   * old/new store states there. If you specifically want old/new plugin state,\n   * use `subscribeToState` instead.\n   *\n   * @param type The action type to listen for.\n   * @param handler The callback to invoke when the action occurs.\n   * @returns A function to unsubscribe the handler.\n   */\n  onAction<T extends PluginAction['type']>(\n    type: T,\n    handler: (\n      action: Extract<PluginAction, { type: T }>,\n      state: PluginState,\n      oldState: PluginState,\n    ) => void,\n  ) {\n    return this.store.onAction(type, (action, state, oldState) => {\n      handler(\n        action as Extract<PluginAction, { type: T }>,\n        state.plugins[this.pluginId] as PluginState,\n        oldState.plugins[this.pluginId] as PluginState,\n      );\n    });\n  }\n}\n","import { PdfDocumentObject, PdfPageObject, Rotation } from '@embedpdf/models';\n\nexport const LOAD_DOCUMENT = 'LOAD_DOCUMENT';\nexport const SET_DOCUMENT = 'SET_DOCUMENT';\nexport const SET_DOCUMENT_ERROR = 'SET_DOCUMENT_ERROR';\nexport const SET_SCALE = 'SET_SCALE';\nexport const SET_ROTATION = 'SET_ROTATION';\nexport const SET_PAGES = 'SET_PAGES';\n\nexport const CORE_ACTION_TYPES = [\n  LOAD_DOCUMENT,\n  SET_DOCUMENT,\n  SET_DOCUMENT_ERROR,\n  SET_SCALE,\n  SET_ROTATION,\n  SET_PAGES,\n] as const;\n\n// Action Type Interfaces\nexport interface LoadDocumentAction {\n  type: typeof LOAD_DOCUMENT;\n}\n\nexport interface SetDocumentAction {\n  type: typeof SET_DOCUMENT;\n  payload: PdfDocumentObject;\n}\n\nexport interface SetDocumentErrorAction {\n  type: typeof SET_DOCUMENT_ERROR;\n  payload: string;\n}\n\nexport interface SetScaleAction {\n  type: typeof SET_SCALE;\n  payload: number;\n}\n\nexport interface SetRotationAction {\n  type: typeof SET_ROTATION;\n  payload: Rotation;\n}\n\nexport interface SetPagesAction {\n  type: typeof SET_PAGES;\n  payload: PdfPageObject[][];\n}\n\nexport type DocumentAction =\n  | LoadDocumentAction\n  | SetDocumentAction\n  | SetDocumentErrorAction\n  | SetScaleAction\n  | SetRotationAction\n  | SetPagesAction;\n\n// Core actions\nexport type CoreAction = DocumentAction;\n\nexport const loadDocument = (): CoreAction => ({ type: LOAD_DOCUMENT });\nexport const setDocument = (document: PdfDocumentObject): CoreAction => ({\n  type: SET_DOCUMENT,\n  payload: document,\n});\nexport const setDocumentError = (error: string): CoreAction => ({\n  type: SET_DOCUMENT_ERROR,\n  payload: error,\n});\nexport const setScale = (scale: number): CoreAction => ({ type: SET_SCALE, payload: scale });\nexport const setRotation = (rotation: Rotation): CoreAction => ({\n  type: SET_ROTATION,\n  payload: rotation,\n});\nexport const setPages = (pages: PdfPageObject[][]): CoreAction => ({\n  type: SET_PAGES,\n  payload: pages,\n});\n","import { Reducer, Action, StoreState, StoreListener, PluginListener } from './types';\nimport { PluginStore } from './plugin-store';\nimport { CORE_ACTION_TYPES } from './actions';\n\n/**\n * A generic, type-safe store class managing core and plugin states, reducers, and subscriptions.\n * @template CoreState The type of the core state.\n * @template CoreAction The type of actions handled by core reducers (extends Action).\n */\nexport class Store<CoreState, CoreAction extends Action = Action> {\n  private state: StoreState<CoreState>;\n  private coreReducer: Reducer<CoreState, CoreAction>;\n  private pluginReducers: Record<string, Reducer<any, Action>> = {};\n\n  private listeners: StoreListener<CoreState>[] = [];\n  private pluginListeners: Record<string, PluginListener[]> = {};\n\n  /**\n   * Initializes the store with the provided core state.\n   * @param reducer          The core reducer function\n   * @param initialCoreState The initial core state\n   */\n  constructor(\n    reducer: Reducer<CoreState, CoreAction>,\n    public initialCoreState: CoreState,\n  ) {\n    this.state = { core: initialCoreState, plugins: {} };\n    this.coreReducer = reducer;\n  }\n\n  /**\n   * Adds a reducer for a plugin-specific state.\n   * @param pluginId The unique identifier for the plugin.\n   * @param reducer The reducer function for the plugin state.\n   * @param initialState The initial state for the plugin.\n   */\n  addPluginReducer<PluginState>(\n    pluginId: string,\n    reducer: Reducer<PluginState, Action>,\n    initialState: PluginState,\n  ) {\n    this.state.plugins[pluginId] = initialState;\n    this.pluginReducers[pluginId] = reducer;\n  }\n\n  /**\n   * Dispatches an action *only* to the core reducer.\n   * Notifies the global store listeners with (action, newState, oldState).\n   *\n   * @param action The action to dispatch, typed as CoreAction\n   * @returns The updated *global* store state\n   */\n  dispatchToCore(action: CoreAction): StoreState<CoreState> {\n    if (!this.coreReducer) {\n      return this.getState();\n    }\n\n    const oldState = this.getState();\n    // Update core state via its reducer\n    this.state.core = this.coreReducer(this.state.core, action);\n\n    const newState = this.getState();\n    // Notify all main-store subscribers\n    this.listeners.forEach((listener) => listener(action, newState, oldState));\n\n    return newState;\n  }\n\n  /**\n   * Dispatches an action *only* to a specific plugin.\n   * Optionally notifies global store listeners if `notifyGlobal` is true.\n   * Always notifies plugin-specific listeners with (action, newPluginState, oldPluginState).\n   *\n   * @param pluginId   The plugin identifier\n   * @param action     The plugin action to dispatch\n   * @param notifyGlobal Whether to also notify global store listeners\n   * @returns The updated *global* store state\n   */\n  dispatchToPlugin<PluginAction extends Action>(\n    pluginId: string,\n    action: PluginAction,\n    notifyGlobal: boolean = true,\n  ): any {\n    const oldGlobalState = this.getState();\n\n    const reducer = this.pluginReducers[pluginId];\n    if (!reducer) {\n      // No plugin found, just return the old state\n      return oldGlobalState;\n    }\n\n    // Grab the old plugin state\n    const oldPluginState = oldGlobalState.plugins[pluginId];\n    // Reduce to new plugin state\n    const newPluginState = reducer(oldPluginState, action);\n    // Update the store's plugin slice\n    this.state.plugins[pluginId] = newPluginState;\n\n    const newGlobalState = this.getState();\n\n    // If we are notifying the main store subscribers about plugin changes\n    if (notifyGlobal) {\n      this.listeners.forEach((listener) => listener(action, newGlobalState, oldGlobalState));\n    }\n\n    // Notify plugin-specific listeners\n    if (this.pluginListeners[pluginId]) {\n      this.pluginListeners[pluginId].forEach((listener) => {\n        listener(action, newPluginState, oldPluginState);\n      });\n    }\n\n    return newPluginState;\n  }\n\n  /**\n   * Dispatches an action to update the state using:\n   * - the core reducer (if it's a CoreAction)\n   * - *all* plugin reducers (regardless of action type), with no global notify for each plugin\n   *\n   * Returns the new *global* store state after all reducers have processed the action.\n   *\n   * @param action The action to dispatch (can be CoreAction or any Action).\n   */\n  dispatch(action: CoreAction | Action): StoreState<CoreState> {\n    // Keep old state to notify global listeners *once*, after all reducers run.\n    const oldState = this.getState();\n    // 1) Apply core reducer (only if action is a CoreAction)\n    if (this.isCoreAction(action)) {\n      this.state.core = this.coreReducer(this.state.core, action);\n    }\n\n    // 2) Apply plugin reducers (without globally notifying after each plugin)\n    for (const pluginId in this.pluginReducers) {\n      const reducer = this.pluginReducers[pluginId];\n      const oldPluginState = oldState.plugins[pluginId];\n      if (reducer) {\n        this.state.plugins[pluginId] = reducer(oldPluginState, action);\n      }\n      // We do *not* notify global listeners or plugin listeners here,\n      // as that might be undesired \"fan-out\". If you want per-plugin subscription\n      // triggered on every dispatch, you can do so here, but that’s up to you.\n    }\n\n    // 3) Notify global listeners *once* with the final new state\n    const newState = this.getState();\n    this.listeners.forEach((listener) => listener(action, newState, oldState));\n\n    // 4) Return the new global store state\n    return newState;\n  }\n\n  /**\n   * Returns a shallow copy of the current state.\n   * @returns The current store state.\n   */\n  getState(): StoreState<CoreState> {\n    return {\n      core: { ...this.state.core },\n      plugins: { ...this.state.plugins },\n    };\n  }\n\n  /**\n   * Subscribes a listener to *global* state changes.\n   * The callback signature is now (action, newState, oldState).\n   *\n   * @param listener The callback to invoke on state changes\n   * @returns A function to unsubscribe the listener\n   */\n  subscribe(listener: StoreListener<CoreState>) {\n    this.listeners.push(listener);\n    return () => {\n      this.listeners = this.listeners.filter((l) => l !== listener);\n    };\n  }\n\n  /**\n   * Subscribes a listener to *plugin-specific* state changes.\n   * The callback signature is now (action, newPluginState, oldPluginState).\n   *\n   * @param pluginId The unique identifier for the plugin.\n   * @param listener The callback to invoke on plugin state changes.\n   * @returns A function to unsubscribe the listener.\n   */\n  subscribeToPlugin(pluginId: string, listener: PluginListener) {\n    if (!(pluginId in this.state.plugins)) {\n      throw new Error(\n        `Plugin state not found for plugin \"${pluginId}\". Did you forget to call addPluginReducer?`,\n      );\n    }\n\n    if (!this.pluginListeners[pluginId]) {\n      this.pluginListeners[pluginId] = [];\n    }\n    this.pluginListeners[pluginId].push(listener);\n\n    return () => {\n      this.pluginListeners[pluginId] = this.pluginListeners[pluginId].filter((l) => l !== listener);\n      if (this.pluginListeners[pluginId].length === 0) {\n        delete this.pluginListeners[pluginId];\n      }\n    };\n  }\n\n  /**\n   * Subscribes to a specific action type (only from the core's action union).\n   * The callback signature is (action, newState, oldState).\n   *\n   * @param type The action type to listen for.\n   * @param handler The callback to invoke when the action occurs.\n   * @returns A function to unsubscribe the handler.\n   */\n  onAction<T extends CoreAction['type']>(\n    type: T,\n    handler: (\n      action: Extract<CoreAction, { type: T }>,\n      state: StoreState<CoreState>,\n      oldState: StoreState<CoreState>,\n    ) => void,\n  ) {\n    return this.subscribe((action, newState, oldState) => {\n      if (action.type === type) {\n        handler(action as Extract<CoreAction, { type: T }>, newState, oldState);\n      }\n    });\n  }\n\n  /**\n   * Gets a PluginStore handle for a specific plugin.\n   * @param pluginId The unique identifier for the plugin.\n   * @returns A PluginStore instance for the plugin.\n   */\n  getPluginStore<PluginState, PluginAction extends Action>(\n    pluginId: string,\n  ): PluginStore<PluginState, PluginAction> {\n    if (!(pluginId in this.state.plugins)) {\n      throw new Error(\n        `Plugin state not found for plugin \"${pluginId}\". Did you forget to call addPluginReducer?`,\n      );\n    }\n    return new PluginStore<PluginState, PluginAction>(this, pluginId);\n  }\n\n  /**\n   * Helper method to check if an action is a CoreAction.\n   * Adjust if you have a more refined way to differentiate CoreAction vs. any other Action.\n   */\n  public isCoreAction(action: Action): action is CoreAction {\n    // In many codebases you'd do something more robust here\n    // or rely on TypeScript's narrowing logic if possible.\n    return CORE_ACTION_TYPES.includes(action.type as (typeof CORE_ACTION_TYPES)[number]);\n  }\n\n  /**\n   * Destroy the store: drop every listener and plugin reducer\n   */\n  public destroy(): void {\n    // 1. empty listener collections\n    this.listeners.length = 0;\n    for (const id in this.pluginListeners) {\n      this.pluginListeners[id]?.splice?.(0);\n    }\n    this.pluginListeners = {};\n\n    // 2. wipe plugin reducers and states\n    this.pluginReducers = {};\n    this.state.plugins = {};\n\n    // 3. reset core state to initial\n    this.state.core = { ...this.initialCoreState };\n  }\n}\n","import { PdfDocumentObject, PdfPageObject, Rotation } from '@embedpdf/models';\nimport { PluginRegistryConfig } from '../types/plugin';\n\nexport interface CoreState {\n  scale: number;\n  rotation: Rotation;\n  document: PdfDocumentObject | null;\n  pages: PdfPageObject[][];\n  loading: boolean;\n  error: string | null;\n}\n\nexport const initialCoreState: (config?: PluginRegistryConfig) => CoreState = (config) => ({\n  scale: config?.scale ?? 1,\n  rotation: config?.rotation ?? Rotation.Degree0,\n  document: null,\n  pages: [],\n  loading: false,\n  error: null,\n});\n","import { CoreState } from './initial-state';\nimport { transformSize, PdfPageObjectWithRotatedSize } from '@embedpdf/models';\n\nexport const getPagesWithRotatedSize = (state: CoreState): PdfPageObjectWithRotatedSize[][] => {\n  return state.pages.map((page) =>\n    page.map((p) => ({\n      ...p,\n      rotatedSize: transformSize(p.size, state.rotation, 1),\n    })),\n  );\n};\n","import { Reducer } from './types';\nimport { CoreState } from './initial-state';\nimport {\n  CoreAction,\n  LOAD_DOCUMENT,\n  SET_DOCUMENT,\n  SET_DOCUMENT_ERROR,\n  SET_PAGES,\n  SET_ROTATION,\n  SET_SCALE,\n} from './actions';\n\nexport const coreReducer: Reducer<CoreState, CoreAction> = (state, action): CoreState => {\n  switch (action.type) {\n    case LOAD_DOCUMENT:\n      return {\n        ...state,\n        loading: true,\n        error: null,\n      };\n\n    case SET_DOCUMENT:\n      return {\n        ...state,\n        document: action.payload,\n        pages: action.payload.pages.map((page) => [page]),\n        loading: false,\n        error: null,\n      };\n\n    case SET_ROTATION:\n      return {\n        ...state,\n        rotation: action.payload,\n      };\n\n    case SET_PAGES:\n      return {\n        ...state,\n        pages: action.payload,\n      };\n\n    case SET_DOCUMENT_ERROR:\n      return {\n        ...state,\n        loading: false,\n        error: action.payload,\n      };\n\n    case SET_SCALE:\n      return {\n        ...state,\n        scale: action.payload,\n      };\n\n    default:\n      return state;\n  }\n};\n","import { DependencyResolver } from '../utils/dependency-resolver';\nimport {\n  IPlugin,\n  PluginBatchRegistration,\n  PluginManifest,\n  PluginStatus,\n  PluginPackage,\n  PluginRegistryConfig,\n} from '../types/plugin';\nimport {\n  PluginRegistrationError,\n  PluginNotFoundError,\n  CircularDependencyError,\n  CapabilityNotFoundError,\n  PluginConfigurationError,\n} from '../types/errors';\nimport { ignore, PdfEngine, Rotation } from '@embedpdf/models';\nimport { Action, CoreState, Store, initialCoreState, Reducer } from '../store';\nimport { CoreAction } from '../store/actions';\nimport { coreReducer } from '../store/reducer';\n\n// Define a more flexible generic type for plugin registrations\ninterface PluginRegistration {\n  // Use existential types for the plugin package to allow accepting any plugin type\n  package: PluginPackage<any, any, any, any>;\n  config?: any;\n}\n\nexport class PluginRegistry {\n  private plugins: Map<string, IPlugin> = new Map();\n  private manifests: Map<string, PluginManifest> = new Map();\n  private capabilities: Map<string, string> = new Map(); // capability -> pluginId\n  private status: Map<string, PluginStatus> = new Map();\n  private resolver: DependencyResolver;\n  private configurations: Map<string, unknown> = new Map();\n  private engine: PdfEngine;\n  private engineInitialized = false;\n  private store: Store<CoreState, CoreAction>;\n  private initPromise: Promise<void> | null = null;\n\n  private pendingRegistrations: PluginRegistration[] = [];\n  private processingRegistrations: PluginRegistration[] = [];\n  private initialized = false;\n  private isInitializing = false;\n  private initialCoreState: CoreState;\n  private pluginsReadyPromise: Promise<void> | null = null;\n  private destroyed = false;\n\n  constructor(engine: PdfEngine, config?: PluginRegistryConfig) {\n    this.resolver = new DependencyResolver();\n    this.engine = engine;\n    this.initialCoreState = initialCoreState(config);\n    this.store = new Store<CoreState, CoreAction>(coreReducer, this.initialCoreState);\n  }\n\n  /**\n   * Ensure engine is initialized before proceeding\n   */\n  private async ensureEngineInitialized(): Promise<void> {\n    if (this.engineInitialized) {\n      return;\n    }\n\n    if (this.engine.initialize) {\n      const task = this.engine.initialize();\n      await task.toPromise();\n      this.engineInitialized = true;\n    } else {\n      this.engineInitialized = true;\n    }\n  }\n\n  /**\n   * Register a plugin without initializing it\n   */\n  registerPlugin<\n    TPlugin extends IPlugin<TConfig>,\n    TConfig = unknown,\n    TState = unknown,\n    TAction extends Action = Action,\n  >(\n    pluginPackage: PluginPackage<TPlugin, TConfig, TState, TAction>,\n    config?: Partial<TConfig>,\n  ): void {\n    if (this.initialized && !this.isInitializing) {\n      throw new PluginRegistrationError('Cannot register plugins after initialization');\n    }\n\n    this.validateManifest(pluginPackage.manifest);\n\n    // Use appropriate typing for store methods\n    this.store.addPluginReducer(\n      pluginPackage.manifest.id,\n      // We need one type assertion here since we can't fully reconcile TAction with Action\n      // due to TypeScript's type system limitations with generic variance\n      pluginPackage.reducer as Reducer<TState, Action>,\n      'function' === typeof pluginPackage.initialState\n        ? (pluginPackage.initialState as (coreState: CoreState, config: TConfig) => TState)(\n            this.initialCoreState,\n            {\n              ...pluginPackage.manifest.defaultConfig,\n              ...config,\n            },\n          )\n        : pluginPackage.initialState,\n    );\n\n    this.pendingRegistrations.push({\n      package: pluginPackage,\n      config,\n    });\n  }\n\n  /**\n   * Get the central store instance\n   */\n  getStore(): Store<CoreState, CoreAction> {\n    return this.store;\n  }\n\n  /**\n   * Get the engine instance\n   */\n  getEngine(): PdfEngine {\n    return this.engine;\n  }\n\n  /**\n   * Get a promise that resolves when all plugins are ready\n   */\n  public pluginsReady(): Promise<void> {\n    // Re-use the same promise every time it’s asked for\n    if (this.pluginsReadyPromise) {\n      return this.pluginsReadyPromise;\n    }\n\n    // Build the promise the *first* time it’s requested\n    this.pluginsReadyPromise = (async () => {\n      // 1. Wait until the registry itself has finished initialising\n      if (!this.initialized) {\n        await this.initialize();\n      }\n\n      // 2. Wait for every plugin’s ready() promise (if it has one)\n      const readyPromises = Array.from(this.plugins.values()).map((p) =>\n        typeof p.ready === 'function' ? p.ready() : Promise.resolve(),\n      );\n\n      await Promise.all(readyPromises); // resolves when the slowest is done\n    })();\n\n    return this.pluginsReadyPromise;\n  }\n\n  /**\n   * INITIALISE THE REGISTRY – runs once no-matter-how-many calls   *\n   */\n  async initialize(): Promise<void> {\n    if (this.destroyed) {\n      throw new PluginRegistrationError('Registry has been destroyed');\n    }\n\n    // If an initialisation is already in-flight (or finished)\n    // return the very same promise so callers can await it.\n    if (this.initPromise) {\n      return this.initPromise;\n    }\n\n    // Wrap your existing body in a single promise and cache it\n    this.initPromise = (async () => {\n      if (this.initialized) {\n        throw new PluginRegistrationError('Registry is already initialized');\n      }\n\n      this.isInitializing = true;\n\n      try {\n        /* ---------------- original body starts ------------------ */\n        await this.ensureEngineInitialized();\n        // Check if destroyed after engine initialization\n        if (this.destroyed) {\n          return;\n        }\n\n        while (this.pendingRegistrations.length > 0) {\n          // Check if destroyed before processing each batch\n          if (this.destroyed) {\n            return;\n          }\n          this.processingRegistrations = [...this.pendingRegistrations];\n          this.pendingRegistrations = [];\n\n          for (const reg of this.processingRegistrations) {\n            const dependsOn = new Set<string>();\n            const allDeps = [...reg.package.manifest.requires, ...reg.package.manifest.optional];\n            for (const cap of allDeps) {\n              const provider = this.processingRegistrations.find((r) =>\n                r.package.manifest.provides.includes(cap),\n              );\n              if (provider) dependsOn.add(provider.package.manifest.id);\n            }\n            this.resolver.addNode(reg.package.manifest.id, [...dependsOn]);\n          }\n\n          const loadOrder = this.resolver.resolveLoadOrder();\n          for (const id of loadOrder) {\n            const reg = this.processingRegistrations.find((r) => r.package.manifest.id === id)!;\n            await this.initializePlugin(reg.package.manifest, reg.package.create, reg.config);\n          }\n\n          this.processingRegistrations = [];\n          this.resolver = new DependencyResolver();\n        }\n\n        for (const plugin of this.plugins.values()) {\n          await plugin.postInitialize?.().catch((e) => {\n            console.error(`Error in postInitialize for plugin ${plugin.id}`, e);\n            this.status.set(plugin.id, 'error');\n          });\n        }\n\n        this.initialized = true;\n        /* ----------------- original body ends ------------------- */\n      } catch (err) {\n        if (err instanceof Error) {\n          throw new CircularDependencyError(\n            `Failed to resolve plugin dependencies: ${err.message}`,\n          );\n        }\n        throw err;\n      } finally {\n        this.isInitializing = false;\n      }\n    })();\n\n    return this.initPromise;\n  }\n\n  /**\n   * Initialize a single plugin with all necessary checks\n   */\n  private async initializePlugin<TConfig>(\n    manifest: PluginManifest<TConfig>,\n    packageCreator: (\n      registry: PluginRegistry,\n      engine: PdfEngine,\n      config?: TConfig,\n    ) => IPlugin<TConfig>,\n    config?: Partial<TConfig>,\n  ): Promise<void> {\n    const finalConfig = {\n      ...manifest.defaultConfig,\n      ...config,\n    };\n\n    this.validateConfig(manifest.id, finalConfig, manifest.defaultConfig);\n\n    // Create plugin instance during initialization\n    const plugin = packageCreator(this, this.engine, finalConfig);\n    this.validatePlugin(plugin);\n\n    // Verify all required capabilities are available\n    for (const capability of manifest.requires) {\n      if (!this.capabilities.has(capability)) {\n        throw new PluginRegistrationError(\n          `Missing required capability: ${capability} for plugin ${manifest.id}`,\n        );\n      }\n    }\n\n    // Optional capabilities can be null, so we don't throw errors for them\n    for (const capability of manifest.optional) {\n      if (this.capabilities.has(capability)) {\n        // Optional capability is available, but we don't require it\n        console.debug(`Optional capability ${capability} is available for plugin ${manifest.id}`);\n      }\n    }\n\n    console.log('initializePlugin', manifest.id, manifest.provides);\n\n    // Register provided capabilities\n    for (const capability of manifest.provides) {\n      if (this.capabilities.has(capability)) {\n        throw new PluginRegistrationError(\n          `Capability ${capability} is already provided by plugin ${this.capabilities.get(capability)}`,\n        );\n      }\n      this.capabilities.set(capability, manifest.id);\n    }\n\n    // Store plugin and manifest\n    this.plugins.set(manifest.id, plugin);\n    this.manifests.set(manifest.id, manifest);\n    this.status.set(manifest.id, 'registered');\n    this.configurations.set(manifest.id, finalConfig);\n\n    try {\n      if (plugin.initialize) {\n        await plugin.initialize(finalConfig);\n      }\n      this.status.set(manifest.id, 'active');\n    } catch (error) {\n      // Cleanup on initialization failure\n      this.plugins.delete(manifest.id);\n      this.manifests.delete(manifest.id);\n      console.log('initializePlugin failed', manifest.id, manifest.provides);\n      manifest.provides.forEach((cap) => this.capabilities.delete(cap));\n      throw error;\n    }\n  }\n\n  getPluginConfig<TConfig>(pluginId: string): TConfig {\n    const config = this.configurations.get(pluginId);\n    if (!config) {\n      throw new PluginNotFoundError(`Configuration for plugin ${pluginId} not found`);\n    }\n    return config as TConfig;\n  }\n\n  private validateConfig(pluginId: string, config: unknown, defaultConfig: unknown): void {\n    // Check all required fields exist\n    const requiredKeys = Object.keys(defaultConfig as object);\n    const missingKeys = requiredKeys.filter((key) => !(config as object).hasOwnProperty(key));\n\n    if (missingKeys.length > 0) {\n      throw new PluginConfigurationError(\n        `Missing required configuration keys for plugin ${pluginId}: ${missingKeys.join(', ')}`,\n      );\n    }\n\n    // You could add more validation here:\n    // - Type checking\n    // - Value range validation\n    // - Format validation\n    // etc.\n  }\n\n  async updatePluginConfig<TConfig>(pluginId: string, config: Partial<TConfig>): Promise<void> {\n    const plugin = this.getPlugin(pluginId);\n\n    if (!plugin) {\n      throw new PluginNotFoundError(`Plugin ${pluginId} not found`);\n    }\n\n    const manifest = this.manifests.get(pluginId);\n    const currentConfig = this.configurations.get(pluginId);\n\n    if (!manifest || !currentConfig) {\n      throw new PluginNotFoundError(`Plugin ${pluginId} not found`);\n    }\n\n    // Merge new config with current\n    const newConfig = {\n      ...currentConfig,\n      ...config,\n    };\n\n    // Validate new configuration\n    this.validateConfig(pluginId, newConfig, manifest.defaultConfig);\n\n    // Store new configuration\n    this.configurations.set(pluginId, newConfig);\n\n    // Reinitialize plugin if needed\n    if (plugin.initialize) {\n      await plugin.initialize(newConfig);\n    }\n  }\n\n  /**\n   * Register multiple plugins at once\n   */\n  registerPluginBatch(registrations: PluginBatchRegistration<IPlugin<any>, any, any, any>[]): void {\n    for (const reg of registrations) {\n      this.registerPlugin(reg.package, reg.config);\n    }\n  }\n\n  /**\n   * Unregister a plugin\n   */\n  async unregisterPlugin(pluginId: string): Promise<void> {\n    const plugin = this.plugins.get(pluginId);\n    if (!plugin) {\n      throw new PluginNotFoundError(`Plugin ${pluginId} is not registered`);\n    }\n\n    const manifest = this.manifests.get(pluginId);\n    if (!manifest) {\n      throw new PluginNotFoundError(`Manifest for plugin ${pluginId} not found`);\n    }\n\n    // Check if any other plugins depend on this one\n    for (const [otherId, otherManifest] of this.manifests.entries()) {\n      if (otherId === pluginId) continue;\n\n      const dependsOnThis = [...otherManifest.requires, ...otherManifest.optional].some((cap) =>\n        manifest.provides.includes(cap),\n      );\n\n      if (dependsOnThis) {\n        throw new PluginRegistrationError(\n          `Cannot unregister plugin ${pluginId}: plugin ${otherId} depends on it`,\n        );\n      }\n    }\n\n    // Cleanup plugin\n    try {\n      if (plugin.destroy) {\n        await plugin.destroy();\n      }\n\n      // Remove capabilities\n      for (const capability of manifest.provides) {\n        this.capabilities.delete(capability);\n      }\n\n      // Remove plugin and manifest\n      this.plugins.delete(pluginId);\n      this.manifests.delete(pluginId);\n      this.status.delete(pluginId);\n    } catch (error) {\n      if (error instanceof Error) {\n        throw new Error(`Failed to unregister plugin ${pluginId}: ${error.message}`);\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Get a plugin instance\n   * @param pluginId The ID of the plugin to get\n   * @returns The plugin instance or null if not found\n   */\n  getPlugin<T extends IPlugin>(pluginId: string): T | null {\n    const plugin = this.plugins.get(pluginId);\n    if (!plugin) {\n      return null;\n    }\n    return plugin as T;\n  }\n\n  /**\n   * Get a plugin that provides a specific capability\n   * @param capability The capability to get a provider for\n   * @returns The plugin providing the capability or null if not found\n   */\n  getCapabilityProvider(capability: string): IPlugin | null {\n    const pluginId = this.capabilities.get(capability);\n    if (!pluginId) {\n      return null;\n    }\n    return this.getPlugin(pluginId);\n  }\n\n  /**\n   * Check if a capability is available\n   */\n  hasCapability(capability: string): boolean {\n    return this.capabilities.has(capability);\n  }\n\n  /**\n   * Get all registered plugins\n   */\n  getAllPlugins(): IPlugin[] {\n    return Array.from(this.plugins.values());\n  }\n\n  /**\n   * Get plugin status\n   */\n  getPluginStatus(pluginId: string): PluginStatus {\n    const status = this.status.get(pluginId);\n    if (!status) {\n      throw new PluginNotFoundError(`Plugin ${pluginId} not found`);\n    }\n    return status;\n  }\n\n  /**\n   * Validate plugin object\n   */\n  private validatePlugin(plugin: IPlugin): void {\n    if (!plugin.id) {\n      throw new PluginRegistrationError('Plugin must have an id');\n    }\n  }\n\n  /**\n   * Validate plugin manifest\n   */\n  private validateManifest(manifest: PluginManifest): void {\n    if (!manifest.id) {\n      throw new PluginRegistrationError('Manifest must have an id');\n    }\n    if (!manifest.name) {\n      throw new PluginRegistrationError('Manifest must have a name');\n    }\n    if (!manifest.version) {\n      throw new PluginRegistrationError('Manifest must have a version');\n    }\n    if (!Array.isArray(manifest.provides)) {\n      throw new PluginRegistrationError('Manifest must have a provides array');\n    }\n    if (!Array.isArray(manifest.requires)) {\n      throw new PluginRegistrationError('Manifest must have a requires array');\n    }\n    if (!Array.isArray(manifest.optional)) {\n      throw new PluginRegistrationError('Manifest must have an optional array');\n    }\n  }\n\n  isDestroyed(): boolean {\n    return this.destroyed;\n  }\n\n  /**\n   * DESTROY EVERYTHING – waits for any ongoing initialise(), once  *\n   */\n  async destroy(): Promise<void> {\n    if (this.destroyed) throw new PluginRegistrationError('Registry has already been destroyed');\n    this.destroyed = true;\n\n    // If initialisation is still underway, wait (success OR failure)\n    try {\n      await this.initPromise;\n    } catch {\n      /* ignore – still need to clean up */\n    }\n\n    /* ------- original teardown, unchanged except the guard ------ */\n    for (const plugin of Array.from(this.plugins.values()).reverse()) {\n      await plugin.destroy?.();\n    }\n\n    this.store.destroy();\n\n    this.plugins.clear();\n    this.manifests.clear();\n    this.capabilities.clear();\n    this.status.clear();\n    this.pendingRegistrations.length = 0;\n    this.processingRegistrations.length = 0;\n  }\n}\n","import { Action } from '../store';\nimport { IPlugin, PluginBatchRegistration, PluginPackage } from '../types/plugin';\n\n/**\n * Helper function to create a properly typed plugin registration\n */\nexport function createPluginRegistration<\n  T extends IPlugin<TConfig>,\n  TConfig,\n  TState,\n  TAction extends Action,\n>(\n  pluginPackage: PluginPackage<T, TConfig, TState, TAction>,\n  config?: Partial<TConfig>,\n): PluginBatchRegistration<T, TConfig, any, any> {\n  return {\n    package: pluginPackage,\n    config,\n  };\n}\n","import { IPlugin } from '../types/plugin';\nimport { PluginRegistry } from '../registry/plugin-registry';\nimport { Action, CoreAction, CoreState, PluginStore, Store, StoreState } from '../store';\n\nexport interface StateChangeHandler<TState> {\n  (state: TState): void;\n}\n\nexport abstract class BasePlugin<\n  TConfig = unknown,\n  TCapability = unknown,\n  TState = unknown,\n  TAction extends Action = Action,\n> implements IPlugin<TConfig>\n{\n  static readonly id: string;\n\n  protected pluginStore: PluginStore<TState, TAction>;\n  protected coreStore: Store<CoreState, CoreAction>;\n  // Track debounced actions\n  private debouncedActions: Record<string, number> = {};\n  private unsubscribeFromState: (() => void) | null = null;\n  private unsubscribeFromCoreStore: (() => void) | null = null;\n\n  private _capability?: Readonly<TCapability>;\n\n  private readyPromise: Promise<void>;\n  private readyResolve!: () => void;\n\n  constructor(\n    public readonly id: string,\n    protected registry: PluginRegistry,\n  ) {\n    if (id !== (this.constructor as typeof BasePlugin).id) {\n      throw new Error(\n        `Plugin ID mismatch: ${id} !== ${(this.constructor as typeof BasePlugin).id}`,\n      );\n    }\n    this.coreStore = this.registry.getStore();\n    this.pluginStore = this.coreStore.getPluginStore<TState, TAction>(this.id);\n    this.unsubscribeFromState = this.pluginStore.subscribeToState((action, newState, oldState) => {\n      this.onStoreUpdated(oldState, newState);\n    });\n    this.unsubscribeFromCoreStore = this.coreStore.subscribe((action, newState, oldState) => {\n      this.onCoreStoreUpdated(oldState, newState);\n    });\n\n    // Initialize ready state\n    this.readyPromise = new Promise((resolve) => {\n      this.readyResolve = resolve;\n    });\n    // By default, plugins are ready immediately\n    this.readyResolve();\n  }\n\n  /** Construct the public capability (called once & cached). */\n  protected abstract buildCapability(): TCapability;\n\n  public provides(): Readonly<TCapability> {\n    if (!this._capability) {\n      const cap = this.buildCapability();\n\n      this._capability = Object.freeze(cap);\n    }\n    return this._capability;\n  }\n\n  /**\n   * Initialize plugin with config\n   */\n  abstract initialize(config: TConfig): Promise<void>;\n\n  /**\n   *  Get a copy of the current state\n   */\n  protected get state(): Readonly<TState> {\n    return this.pluginStore.getState();\n  }\n\n  /**\n   *  Get a copy of the current core state\n   */\n  protected get coreState(): Readonly<StoreState<CoreState>> {\n    return this.coreStore.getState();\n  }\n\n  /**\n   * @deprecated  use `this.state` Get a copy of the current state\n   */\n  protected getState(): TState {\n    return this.pluginStore.getState();\n  }\n\n  /**\n   * @deprecated  use `this.coreState` Get a copy of the current core state\n   */\n  protected getCoreState(): StoreState<CoreState> {\n    return this.coreStore.getState();\n  }\n\n  /**\n   * Core Dispatch\n   */\n  protected dispatchCoreAction(action: CoreAction): StoreState<CoreState> {\n    return this.coreStore.dispatchToCore(action);\n  }\n\n  /**\n   * Dispatch an action to all plugins\n   */\n  protected dispatchToAllPlugins(action: TAction): StoreState<CoreState> {\n    return this.coreStore.dispatch(action);\n  }\n\n  /**\n   * Dispatch an action\n   */\n  protected dispatch(action: TAction): TState {\n    return this.pluginStore.dispatch(action);\n  }\n\n  /**\n   * Dispatch an action with debouncing to prevent rapid repeated calls\n   * @param action The action to dispatch\n   * @param debounceTime Time in ms to debounce (default: 100ms)\n   * @returns boolean indicating whether the action was dispatched or debounced\n   */\n  protected debouncedDispatch(action: TAction, debounceTime: number = 100): boolean {\n    const now = Date.now();\n    const lastActionTime = this.debouncedActions[action.type] || 0;\n\n    if (now - lastActionTime >= debounceTime) {\n      this.debouncedActions[action.type] = now;\n      this.dispatch(action);\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Subscribe to state changes\n   */\n  protected subscribe(listener: (action: TAction, state: TState) => void): () => void {\n    return this.pluginStore.subscribeToState(listener);\n  }\n\n  /**\n   * Subscribe to core store changes\n   */\n  protected subscribeToCoreStore(\n    listener: (action: Action, state: StoreState<CoreState>) => void,\n  ): () => void {\n    return this.coreStore.subscribe(listener);\n  }\n\n  /**\n   * Called when the plugin store state is updated\n   * @param oldState Previous state\n   * @param newState New state\n   */\n  protected onStoreUpdated(oldState: TState, newState: TState): void {\n    // Default implementation does nothing - can be overridden by plugins\n  }\n\n  /**\n   * Called when the core store state is updated\n   * @param oldState Previous state\n   * @param newState New state\n   */\n  protected onCoreStoreUpdated(\n    oldState: StoreState<CoreState>,\n    newState: StoreState<CoreState>,\n  ): void {\n    // Default implementation does nothing - can be overridden by plugins\n  }\n\n  /**\n   * Cleanup method to be called when plugin is being destroyed\n   */\n  public destroy(): void {\n    if (this.unsubscribeFromState) {\n      this.unsubscribeFromState();\n      this.unsubscribeFromState = null;\n    }\n    if (this.unsubscribeFromCoreStore) {\n      this.unsubscribeFromCoreStore();\n      this.unsubscribeFromCoreStore = null;\n    }\n  }\n\n  /**\n   * Returns a promise that resolves when the plugin is ready\n   */\n  public ready(): Promise<void> {\n    return this.readyPromise;\n  }\n\n  /**\n   * Mark the plugin as ready\n   */\n  protected markReady(): void {\n    this.readyResolve();\n  }\n\n  /**\n   * Reset the ready state (useful for plugins that need to reinitialize)\n   */\n  protected resetReady(): void {\n    this.readyPromise = new Promise((resolve) => {\n      this.readyResolve = resolve;\n    });\n  }\n}\n","export type EventHandler<T> = (data: T) => void;\n\nexport interface BaseEventControlOptions {\n  wait: number;\n}\n\nexport interface DebounceOptions extends BaseEventControlOptions {\n  mode: 'debounce';\n}\n\nexport interface ThrottleOptions extends BaseEventControlOptions {\n  mode: 'throttle';\n  throttleMode?: 'leading-trailing' | 'trailing';\n}\n\nexport type EventControlOptions = DebounceOptions | ThrottleOptions;\n\nexport class EventControl<T> {\n  private timeoutId?: number;\n  private lastRun: number = 0;\n\n  constructor(\n    private handler: EventHandler<T>,\n    private options: EventControlOptions,\n  ) {}\n\n  handle = (data: T): void => {\n    if (this.options.mode === 'debounce') {\n      this.debounce(data);\n    } else {\n      this.throttle(data);\n    }\n  };\n\n  private debounce(data: T): void {\n    if (this.timeoutId) {\n      window.clearTimeout(this.timeoutId);\n    }\n\n    this.timeoutId = window.setTimeout(() => {\n      this.handler(data);\n      this.timeoutId = undefined;\n    }, this.options.wait);\n  }\n\n  private throttle(data: T): void {\n    if (this.options.mode === 'debounce') return;\n\n    const now = Date.now();\n    const throttleMode = this.options.throttleMode || 'leading-trailing';\n\n    if (now - this.lastRun >= this.options.wait) {\n      if (throttleMode === 'leading-trailing') {\n        this.handler(data);\n      }\n      this.lastRun = now;\n    }\n\n    // Always schedule the trailing execution\n    if (this.timeoutId) {\n      window.clearTimeout(this.timeoutId);\n    }\n\n    this.timeoutId = window.setTimeout(\n      () => {\n        this.handler(data);\n        this.lastRun = Date.now();\n        this.timeoutId = undefined;\n      },\n      this.options.wait - (now - this.lastRun),\n    );\n  }\n\n  destroy(): void {\n    if (this.timeoutId) {\n      window.clearTimeout(this.timeoutId);\n    }\n  }\n}\n","/**\n * Restrict a numeric value to the inclusive range [min, max].\n *\n * @example\n *   clamp( 5, 0, 10)  // 5\n *   clamp(-3, 0, 10)  // 0\n *   clamp(17, 0, 10)  // 10\n */\nexport function clamp(value: number, min: number, max: number): number {\n  return value < min ? min : value > max ? max : value;\n}\n\n/**\n * Deeply compares two values (objects, arrays, primitives)\n * with the following rules:\n *  - Objects are compared ignoring property order.\n *  - Arrays are compared ignoring element order (multiset comparison).\n *  - Primitives are compared by strict equality.\n *  - null/undefined are treated as normal primitives.\n *\n * @param a First value\n * @param b Second value\n * @param visited Used internally to detect cycles\n */\nexport function arePropsEqual(a: any, b: any, visited?: Set<any>): boolean {\n  // Quick path for reference equality or same primitive\n  if (a === b) {\n    return true;\n  }\n\n  // Handle null/undefined mismatch\n  if (a == null || b == null) {\n    // If one is null/undefined and the other isn't, no match\n    return a === b;\n  }\n\n  // Check types\n  const aType = typeof a;\n  const bType = typeof b;\n  if (aType !== bType) return false;\n\n  // If they are both objects or arrays, handle recursively\n  if (aType === 'object') {\n    // Optionally handle cyclical references\n    if (!visited) visited = new Set();\n    const pairId = getPairId(a, b);\n    if (visited.has(pairId)) {\n      // Already compared these two objects => assume true to avoid infinite recursion\n      // or return false if you want to treat cycles as inequality\n      return true;\n    }\n    visited.add(pairId);\n\n    const aIsArray = Array.isArray(a);\n    const bIsArray = Array.isArray(b);\n    if (aIsArray && bIsArray) {\n      // Compare as arrays ignoring order\n      return arraysEqualUnordered(a, b, visited);\n    } else if (!aIsArray && !bIsArray) {\n      // Compare as plain objects (order of properties doesn't matter)\n      return objectsEqual(a, b, visited);\n    } else {\n      // One is array, the other is object => not equal\n      return false;\n    }\n  }\n\n  // If both are function, symbol, etc. - typically we might say false\n  // But you can decide your own logic for function or symbol equality\n  return false;\n}\n\nfunction getPairId(a: any, b: any) {\n  // Could do something more advanced. This is a cheap approach:\n  // e.g. use the memory reference or an object identity approach\n  return `${objectId(a)}__${objectId(b)}`;\n}\n\n/**\n * If you want stable object IDs, you'd need a WeakMap to store them.\n * This simplistic approach just calls toString on the object.\n */\nlet objectIdCounter = 0;\nconst objectIds = new WeakMap<object, number>();\n\nfunction objectId(obj: object): number {\n  if (!objectIds.has(obj)) {\n    objectIds.set(obj, ++objectIdCounter);\n  }\n  return objectIds.get(obj)!;\n}\n\nfunction arraysEqualUnordered(a: any[], b: any[], visited?: Set<any>): boolean {\n  if (a.length !== b.length) return false;\n\n  const used = new Array<boolean>(b.length).fill(false);\n\n  // For each element in a, find an unused matching element in b\n  outer: for (let i = 0; i < a.length; i++) {\n    const elemA = a[i];\n    for (let j = 0; j < b.length; j++) {\n      if (used[j]) continue; // already used that slot\n      if (arePropsEqual(elemA, b[j], visited)) {\n        used[j] = true;\n        continue outer; // found match for a[i], proceed\n      }\n    }\n    // If we never found a match\n    return false;\n  }\n\n  return true;\n}\n\nfunction objectsEqual(a: object, b: object, visited?: Set<any>): boolean {\n  // Get all prop keys\n  const aKeys = Object.keys(a).sort();\n  const bKeys = Object.keys(b).sort();\n  if (aKeys.length !== bKeys.length) return false;\n\n  // Compare each property name\n  for (let i = 0; i < aKeys.length; i++) {\n    if (aKeys[i] !== bKeys[i]) return false;\n  }\n\n  // Compare each property value\n  for (const key of aKeys) {\n    // @ts-ignore\n    const valA = a[key];\n    // @ts-ignore\n    const valB = b[key];\n    if (!arePropsEqual(valA, valB, visited)) {\n      return false;\n    }\n  }\n  return true;\n}\n","import { EventControl, EventControlOptions } from './event-control';\nimport { arePropsEqual } from './math';\n\n/* ------------------------------------------------------------------ */\n/* basic types                                                        */\n/* ------------------------------------------------------------------ */\nexport type Listener<T = any> = (value: T) => void;\nexport type Unsubscribe = () => void;\n\n/* ------------------------------------------------------------------ */\n/* EventListener                                                      */\n/* ------------------------------------------------------------------ */\nexport type EventListener<T> =\n  | ((listener: Listener<T>) => Unsubscribe)\n  | ((listener: Listener<T>, options?: EventControlOptions) => Unsubscribe);\n\n/* ------------------------------------------------------------ */\n/* helpers for typing `.on()` with an optional second argument  */\n/* ------------------------------------------------------------ */\nexport type EventHook<T = any> = EventListener<T>;\n/* ------------------------------------------------------------------ */\n/* minimal “dumb” emitter (no value cache, no equality)               */\n/* ------------------------------------------------------------------ */\nexport interface Emitter<T = any> {\n  emit(value?: T): void;\n  on(listener: Listener<T>): Unsubscribe;\n  off(listener: Listener<T>): void;\n  clear(): void;\n}\n\nexport function createEmitter<T = any>(): Emitter<T> {\n  const listeners = new Set<Listener<T>>();\n\n  const on: EventHook<T> = (l: Listener<T>) => {\n    listeners.add(l);\n    return () => listeners.delete(l);\n  };\n\n  return {\n    emit: (v = undefined as T) => listeners.forEach((l) => l(v)),\n    on,\n    off: (l) => listeners.delete(l),\n    clear: () => listeners.clear(),\n  };\n}\n\n/* ------------------------------------------------------------ */\n/* public interface                                              */\n/* ------------------------------------------------------------ */\nexport interface BehaviorEmitter<T = any> extends Omit<Emitter<T>, 'on' | 'off'> {\n  readonly value?: T;\n  on: EventHook<T>;\n  off(listener: Listener<T>): void;\n  select<U>(selector: (v: T) => U, equality?: (a: U, b: U) => boolean): EventHook<U>;\n}\n\n/* ------------------------------------------------------------ */\n/* implementation                                               */\n/* ------------------------------------------------------------ */\nexport function createBehaviorEmitter<T = any>(\n  initial?: T,\n  equality: (a: T, b: T) => boolean = arePropsEqual,\n): BehaviorEmitter<T> {\n  const listeners = new Set<Listener<T>>();\n  const proxyMap = new Map<Listener<T>, { wrapped: Listener<T>; destroy: () => void }>();\n  let _value = initial; // cached value\n\n  /* -------------- helpers ----------------------------------- */\n  const notify = (v: T) => listeners.forEach((l) => l(v));\n\n  const baseOn: EventHook<T> = (listener: Listener<T>, options?: EventControlOptions) => {\n    /* wrap & remember if we have control options ------------------ */\n    let realListener = listener;\n    let destroy = () => {};\n\n    if (options) {\n      const ctl = new EventControl(listener, options);\n      realListener = ctl.handle as Listener<T>;\n      destroy = () => ctl.destroy();\n      proxyMap.set(listener, { wrapped: realListener, destroy });\n    }\n\n    /* immediate replay of last value ------------------------------ */\n    if (_value !== undefined) realListener(_value);\n\n    listeners.add(realListener);\n\n    return () => {\n      listeners.delete(realListener);\n      destroy();\n      proxyMap.delete(listener);\n    };\n  };\n\n  /* -------------- public object ------------------------------ */\n  return {\n    /* emitter behaviour ---------------------------------------- */\n    get value() {\n      return _value;\n    },\n\n    emit(v = undefined as T) {\n      if (_value === undefined || !equality(_value, v)) {\n        _value = v;\n        notify(v);\n      }\n    },\n\n    on: baseOn,\n    off(listener: Listener<T>) {\n      /* did we wrap this listener? */\n      const proxy = proxyMap.get(listener);\n      if (proxy) {\n        listeners.delete(proxy.wrapped);\n        proxy.destroy();\n        proxyMap.delete(listener);\n      } else {\n        listeners.delete(listener);\n      }\n    },\n\n    clear() {\n      listeners.clear();\n      proxyMap.forEach((p) => p.destroy());\n      proxyMap.clear();\n    },\n\n    /* derived hook --------------------------------------------- */\n    select<U>(selector: (v: T) => U, eq: (a: U, b: U) => boolean = arePropsEqual): EventHook<U> {\n      return (listener: Listener<U>, options?: EventControlOptions) => {\n        let prev: U | undefined;\n\n        /* replay */\n        if (_value !== undefined) {\n          const mapped = selector(_value);\n          prev = mapped;\n          listener(mapped);\n        }\n\n        /* subscribe to parent */\n        return baseOn(\n          (next) => {\n            const mapped = selector(next);\n            if (prev === undefined || !eq(prev, mapped)) {\n              prev = mapped;\n              listener(mapped);\n            }\n          },\n          options as EventControlOptions | undefined,\n        ); // pass control opts straight through\n      };\n    },\n  };\n}\n","/* ------------------------------------------------------------------ */\n/*  enumEntries – iterate over enum-keyed Records with strong typing  */\n/* ------------------------------------------------------------------ */\n\ntype EnumKey = string | number;\n\n/**\n * Iterate over a Record whose keys are enum members (numeric or string),\n * getting back a fully-typed `[key, value]` tuple array.\n *\n * Usage:\n *   for (const [subtype, defaults] of enumEntries(this.state.toolDefaults)) {\n *     // subtype is inferred as keyof ToolDefaultsBySubtype\n *   }\n */\nexport function enumEntries<E extends EnumKey, V>(record: Record<E, V>): Array<[E, V]> {\n  // Tell TS the values are V (not unknown) *before* we map.\n  return (Object.entries(record) as [string, V][]).map(([k, v]) => {\n    // Numeric enums come out of Object.entries as \"0\", \"1\", …  → convert.\n    const maybeNum = Number(k);\n    const typedKey: E =\n      Number.isFinite(maybeNum) && k.trim() !== '' // looks like a number?\n        ? (maybeNum as unknown as E) // numeric enum key\n        : (k as unknown as E); // string enum key\n\n    return [typedKey, v]; // v is already typed as V\n  });\n}\n"],"names":["DependencyResolver","id","dependencies","visited","recursionStack","dfs","dep","result","temp","visit","PluginRegistrationError","message","PluginNotFoundError","CircularDependencyError","CapabilityNotFoundError","CapabilityConflictError","PluginInitializationError","PluginConfigurationError","PluginStore","store","pluginId","action","listener","newPluginState","oldPluginState","type","handler","state","oldState","LOAD_DOCUMENT","SET_DOCUMENT","SET_DOCUMENT_ERROR","SET_SCALE","SET_ROTATION","SET_PAGES","CORE_ACTION_TYPES","loadDocument","setDocument","document","setDocumentError","error","setScale","scale","setRotation","rotation","setPages","pages","Store","reducer","initialCoreState","initialState","newState","notifyGlobal","oldGlobalState","newGlobalState","l","_b","_a","config","Rotation","getPagesWithRotatedSize","page","p","transformSize","coreReducer","PluginRegistry","engine","pluginPackage","readyPromises","reg","dependsOn","allDeps","cap","provider","r","loadOrder","plugin","e","err","manifest","packageCreator","finalConfig","capability","defaultConfig","missingKeys","key","currentConfig","newConfig","registrations","otherId","otherManifest","status","createPluginRegistration","BasePlugin","registry","resolve","debounceTime","now","lastActionTime","EventControl","options","data","throttleMode","clamp","value","min","max","arePropsEqual","a","b","aType","pairId","getPairId","aIsArray","bIsArray","arraysEqualUnordered","objectsEqual","objectId","objectIdCounter","objectIds","obj","used","outer","i","elemA","j","aKeys","bKeys","valA","valB","createEmitter","listeners","v","createBehaviorEmitter","initial","equality","proxyMap","_value","notify","baseOn","realListener","destroy","ctl","proxy","selector","eq","prev","mapped","next","enumEntries","record","k","maybeNum"],"mappings":"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"}