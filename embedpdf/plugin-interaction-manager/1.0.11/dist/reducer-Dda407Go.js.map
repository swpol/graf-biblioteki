{"version":3,"file":"reducer-Dda407Go.js","sources":["../../core/dist/math-ChSRQF3r.js","../../core/dist/index.js","../src/lib/actions.ts","../src/lib/helper.ts","../src/lib/interaction-manager-plugin.ts","../src/lib/reducer.ts"],"sourcesContent":["class b {\n  constructor() {\n    this.dependencyGraph = /* @__PURE__ */ new Map();\n  }\n  addNode(e, t = []) {\n    this.dependencyGraph.set(e, new Set(t));\n  }\n  hasCircularDependencies() {\n    const e = /* @__PURE__ */ new Set(), t = /* @__PURE__ */ new Set(), r = (s) => {\n      e.add(s), t.add(s);\n      const n = this.dependencyGraph.get(s) || /* @__PURE__ */ new Set();\n      for (const a of n)\n        if (e.has(a)) {\n          if (t.has(a))\n            return !0;\n        } else if (r(a)) return !0;\n      return t.delete(s), !1;\n    };\n    for (const s of this.dependencyGraph.keys())\n      if (!e.has(s) && r(s))\n        return !0;\n    return !1;\n  }\n  resolveLoadOrder() {\n    if (this.hasCircularDependencies())\n      throw new Error(\"Circular dependencies detected\");\n    const e = [], t = /* @__PURE__ */ new Set(), r = /* @__PURE__ */ new Set(), s = (n) => {\n      if (r.has(n)) throw new Error(\"Circular dependency\");\n      if (t.has(n)) return;\n      r.add(n);\n      const a = this.dependencyGraph.get(n) || /* @__PURE__ */ new Set();\n      for (const o of a)\n        s(o);\n      r.delete(n), t.add(n), e.push(n);\n    };\n    for (const n of this.dependencyGraph.keys())\n      t.has(n) || s(n);\n    return e;\n  }\n}\nclass l extends Error {\n  constructor(e) {\n    super(e), this.name = \"PluginRegistrationError\";\n  }\n}\nclass u extends Error {\n  constructor(e) {\n    super(e), this.name = \"PluginNotFoundError\";\n  }\n}\nclass m extends Error {\n  constructor(e) {\n    super(e), this.name = \"CircularDependencyError\";\n  }\n}\nclass K extends Error {\n  constructor(e) {\n    super(e), this.name = \"CapabilityNotFoundError\";\n  }\n}\nclass H extends Error {\n  constructor(e) {\n    super(e), this.name = \"CapabilityConflictError\";\n  }\n}\nclass W extends Error {\n  constructor(e) {\n    super(e), this.name = \"PluginInitializationError\";\n  }\n}\nclass R extends Error {\n  constructor(e) {\n    super(e), this.name = \"PluginConfigurationError\";\n  }\n}\nclass D {\n  /**\n   * Initializes the PluginStore with the main store and plugin ID.\n   * @param store The main store instance.\n   * @param pluginId The unique identifier for the plugin.\n   */\n  constructor(e, t) {\n    this.store = e, this.pluginId = t;\n  }\n  /**\n   * Gets the current state of the plugin.\n   * @returns The plugin's state.\n   */\n  getState() {\n    return this.store.getState().plugins[this.pluginId];\n  }\n  /**\n   * Dispatches an action for the plugin and returns the *new* global state.\n   * If you only need the plugin’s updated state, call `getState()` afterward.\n   * @param action The action to dispatch.\n   * @returns The updated global store state (after plugin reducer).\n   */\n  dispatch(e) {\n    return this.store.dispatchToPlugin(this.pluginId, e);\n  }\n  /**\n   * Subscribes to state changes only for this specific plugin.\n   * You now receive (action, newPluginState, oldPluginState) in the callback.\n   *\n   * @param listener The callback to invoke when plugin state changes.\n   * @returns A function to unsubscribe the listener.\n   */\n  subscribeToState(e) {\n    return this.store.subscribeToPlugin(this.pluginId, (t, r, s) => {\n      e(\n        t,\n        r,\n        s\n      );\n    });\n  }\n  /**\n   * Subscribes to a specific action type for the plugin.\n   * This still uses the main store's `onAction`, so you get the *global*\n   * old/new store states there. If you specifically want old/new plugin state,\n   * use `subscribeToState` instead.\n   *\n   * @param type The action type to listen for.\n   * @param handler The callback to invoke when the action occurs.\n   * @returns A function to unsubscribe the handler.\n   */\n  onAction(e, t) {\n    return this.store.onAction(e, (r, s, n) => {\n      t(\n        r,\n        s.plugins[this.pluginId],\n        n.plugins[this.pluginId]\n      );\n    });\n  }\n}\nconst g = \"LOAD_DOCUMENT\", f = \"SET_DOCUMENT\", p = \"SET_DOCUMENT_ERROR\", y = \"SET_SCALE\", w = \"SET_ROTATION\", E = \"SET_PAGES\", O = [\n  g,\n  f,\n  p,\n  y,\n  w,\n  E\n], Z = () => ({ type: g }), I = (i) => ({\n  type: f,\n  payload: i\n}), V = (i) => ({\n  type: p,\n  payload: i\n}), J = (i) => ({ type: y, payload: i }), Y = (i) => ({\n  type: w,\n  payload: i\n}), Q = (i) => ({\n  type: E,\n  payload: i\n});\nclass A {\n  /**\n   * Initializes the store with the provided core state.\n   * @param reducer          The core reducer function\n   * @param initialCoreState The initial core state\n   */\n  constructor(e, t) {\n    this.initialCoreState = t, this.pluginReducers = {}, this.listeners = [], this.pluginListeners = {}, this.state = { core: t, plugins: {} }, this.coreReducer = e;\n  }\n  /**\n   * Adds a reducer for a plugin-specific state.\n   * @param pluginId The unique identifier for the plugin.\n   * @param reducer The reducer function for the plugin state.\n   * @param initialState The initial state for the plugin.\n   */\n  addPluginReducer(e, t, r) {\n    this.state.plugins[e] = r, this.pluginReducers[e] = t;\n  }\n  /**\n   * Dispatches an action *only* to the core reducer.\n   * Notifies the global store listeners with (action, newState, oldState).\n   *\n   * @param action The action to dispatch, typed as CoreAction\n   * @returns The updated *global* store state\n   */\n  dispatchToCore(e) {\n    if (!this.coreReducer)\n      return this.getState();\n    const t = this.getState();\n    this.state.core = this.coreReducer(this.state.core, e);\n    const r = this.getState();\n    return this.listeners.forEach((s) => s(e, r, t)), r;\n  }\n  /**\n   * Dispatches an action *only* to a specific plugin.\n   * Optionally notifies global store listeners if `notifyGlobal` is true.\n   * Always notifies plugin-specific listeners with (action, newPluginState, oldPluginState).\n   *\n   * @param pluginId   The plugin identifier\n   * @param action     The plugin action to dispatch\n   * @param notifyGlobal Whether to also notify global store listeners\n   * @returns The updated *global* store state\n   */\n  dispatchToPlugin(e, t, r = !0) {\n    const s = this.getState(), n = this.pluginReducers[e];\n    if (!n)\n      return s;\n    const a = s.plugins[e], o = n(a, t);\n    this.state.plugins[e] = o;\n    const c = this.getState();\n    return r && this.listeners.forEach((h) => h(t, c, s)), this.pluginListeners[e] && this.pluginListeners[e].forEach((h) => {\n      h(t, o, a);\n    }), o;\n  }\n  /**\n   * Dispatches an action to update the state using:\n   * - the core reducer (if it's a CoreAction)\n   * - *all* plugin reducers (regardless of action type), with no global notify for each plugin\n   *\n   * Returns the new *global* store state after all reducers have processed the action.\n   *\n   * @param action The action to dispatch (can be CoreAction or any Action).\n   */\n  dispatch(e) {\n    const t = this.getState();\n    this.isCoreAction(e) && (this.state.core = this.coreReducer(this.state.core, e));\n    for (const s in this.pluginReducers) {\n      const n = this.pluginReducers[s], a = t.plugins[s];\n      n && (this.state.plugins[s] = n(a, e));\n    }\n    const r = this.getState();\n    return this.listeners.forEach((s) => s(e, r, t)), r;\n  }\n  /**\n   * Returns a shallow copy of the current state.\n   * @returns The current store state.\n   */\n  getState() {\n    return {\n      core: { ...this.state.core },\n      plugins: { ...this.state.plugins }\n    };\n  }\n  /**\n   * Subscribes a listener to *global* state changes.\n   * The callback signature is now (action, newState, oldState).\n   *\n   * @param listener The callback to invoke on state changes\n   * @returns A function to unsubscribe the listener\n   */\n  subscribe(e) {\n    return this.listeners.push(e), () => {\n      this.listeners = this.listeners.filter((t) => t !== e);\n    };\n  }\n  /**\n   * Subscribes a listener to *plugin-specific* state changes.\n   * The callback signature is now (action, newPluginState, oldPluginState).\n   *\n   * @param pluginId The unique identifier for the plugin.\n   * @param listener The callback to invoke on plugin state changes.\n   * @returns A function to unsubscribe the listener.\n   */\n  subscribeToPlugin(e, t) {\n    if (!(e in this.state.plugins))\n      throw new Error(\n        `Plugin state not found for plugin \"${e}\". Did you forget to call addPluginReducer?`\n      );\n    return this.pluginListeners[e] || (this.pluginListeners[e] = []), this.pluginListeners[e].push(t), () => {\n      this.pluginListeners[e] = this.pluginListeners[e].filter((r) => r !== t), this.pluginListeners[e].length === 0 && delete this.pluginListeners[e];\n    };\n  }\n  /**\n   * Subscribes to a specific action type (only from the core's action union).\n   * The callback signature is (action, newState, oldState).\n   *\n   * @param type The action type to listen for.\n   * @param handler The callback to invoke when the action occurs.\n   * @returns A function to unsubscribe the handler.\n   */\n  onAction(e, t) {\n    return this.subscribe((r, s, n) => {\n      r.type === e && t(r, s, n);\n    });\n  }\n  /**\n   * Gets a PluginStore handle for a specific plugin.\n   * @param pluginId The unique identifier for the plugin.\n   * @returns A PluginStore instance for the plugin.\n   */\n  getPluginStore(e) {\n    if (!(e in this.state.plugins))\n      throw new Error(\n        `Plugin state not found for plugin \"${e}\". Did you forget to call addPluginReducer?`\n      );\n    return new D(this, e);\n  }\n  /**\n   * Helper method to check if an action is a CoreAction.\n   * Adjust if you have a more refined way to differentiate CoreAction vs. any other Action.\n   */\n  isCoreAction(e) {\n    return O.includes(e.type);\n  }\n  /**\n   * Destroy the store: drop every listener and plugin reducer\n   */\n  destroy() {\n    var e, t;\n    this.listeners.length = 0;\n    for (const r in this.pluginListeners)\n      (t = (e = this.pluginListeners[r]) == null ? void 0 : e.splice) == null || t.call(e, 0);\n    this.pluginListeners = {}, this.pluginReducers = {}, this.state.plugins = {}, this.state.core = { ...this.initialCoreState };\n  }\n}\nvar C = /* @__PURE__ */ ((i) => (i[i.Degree0 = 0] = \"Degree0\", i[i.Degree90 = 1] = \"Degree90\", i[i.Degree180 = 2] = \"Degree180\", i[i.Degree270 = 3] = \"Degree270\", i))(C || {});\nfunction T(i) {\n  const { width: e, height: t } = i;\n  return {\n    width: t,\n    height: e\n  };\n}\nfunction X(i, e, t) {\n  return i = e % 2 === 0 ? i : T(i), {\n    width: i.width * t,\n    height: i.height * t\n  };\n}\nvar z = \"­\", M = \"​\", L = \"⁠\", $ = \"\\uFEFF\", F = \"￾\", N = \"￿\", k = Object.freeze([\n  z,\n  M,\n  L,\n  $,\n  F,\n  N\n]);\nnew RegExp(`[${k.join(\"\")}]`, \"g\");\nvar P = Object.freeze([\n  { id: 0, label: \"Normal\", css: \"normal\" },\n  { id: 1, label: \"Multiply\", css: \"multiply\" },\n  { id: 2, label: \"Screen\", css: \"screen\" },\n  { id: 3, label: \"Overlay\", css: \"overlay\" },\n  { id: 4, label: \"Darken\", css: \"darken\" },\n  { id: 5, label: \"Lighten\", css: \"lighten\" },\n  { id: 6, label: \"Color Dodge\", css: \"color-dodge\" },\n  { id: 7, label: \"Color Burn\", css: \"color-burn\" },\n  { id: 8, label: \"Hard Light\", css: \"hard-light\" },\n  { id: 9, label: \"Soft Light\", css: \"soft-light\" },\n  { id: 10, label: \"Difference\", css: \"difference\" },\n  { id: 11, label: \"Exclusion\", css: \"exclusion\" },\n  { id: 12, label: \"Hue\", css: \"hue\" },\n  { id: 13, label: \"Saturation\", css: \"saturation\" },\n  { id: 14, label: \"Color\", css: \"color\" },\n  { id: 15, label: \"Luminosity\", css: \"luminosity\" }\n]);\nP.reduce(\n  (i, e) => (i[e.id] = e, i),\n  {}\n);\nP.reduce((i, e) => (i[e.css] = e.id, i), {});\nP.map((i) => ({\n  value: i.id,\n  label: i.label\n}));\nvar _ = Object.freeze({\n  1: \"invisible\",\n  2: \"hidden\",\n  4: \"print\",\n  8: \"noZoom\",\n  16: \"noRotate\",\n  32: \"noView\",\n  64: \"readOnly\",\n  128: \"locked\",\n  256: \"toggleNoView\"\n});\nObject.entries(\n  _\n).reduce(\n  (i, [e, t]) => (i[t] = Number(e), i),\n  {}\n);\nconst j = (i) => ({\n  scale: (i == null ? void 0 : i.scale) ?? 1,\n  rotation: (i == null ? void 0 : i.rotation) ?? C.Degree0,\n  document: null,\n  pages: [],\n  loading: !1,\n  error: null\n}), q = (i, e) => {\n  switch (e.type) {\n    case g:\n      return {\n        ...i,\n        loading: !0,\n        error: null\n      };\n    case f:\n      return {\n        ...i,\n        document: e.payload,\n        pages: e.payload.pages.map((t) => [t]),\n        loading: !1,\n        error: null\n      };\n    case w:\n      return {\n        ...i,\n        rotation: e.payload\n      };\n    case E:\n      return {\n        ...i,\n        pages: e.payload\n      };\n    case p:\n      return {\n        ...i,\n        loading: !1,\n        error: e.payload\n      };\n    case y:\n      return {\n        ...i,\n        scale: e.payload\n      };\n    default:\n      return i;\n  }\n};\nclass ee {\n  constructor(e, t) {\n    this.plugins = /* @__PURE__ */ new Map(), this.manifests = /* @__PURE__ */ new Map(), this.capabilities = /* @__PURE__ */ new Map(), this.status = /* @__PURE__ */ new Map(), this.configurations = /* @__PURE__ */ new Map(), this.engineInitialized = !1, this.initPromise = null, this.pendingRegistrations = [], this.processingRegistrations = [], this.initialized = !1, this.isInitializing = !1, this.pluginsReadyPromise = null, this.destroyed = !1, this.resolver = new b(), this.engine = e, this.initialCoreState = j(t), this.store = new A(q, this.initialCoreState);\n  }\n  /**\n   * Ensure engine is initialized before proceeding\n   */\n  async ensureEngineInitialized() {\n    this.engineInitialized || (this.engine.initialize ? (await this.engine.initialize().toPromise(), this.engineInitialized = !0) : this.engineInitialized = !0);\n  }\n  /**\n   * Register a plugin without initializing it\n   */\n  registerPlugin(e, t) {\n    if (this.initialized && !this.isInitializing)\n      throw new l(\"Cannot register plugins after initialization\");\n    this.validateManifest(e.manifest), this.store.addPluginReducer(\n      e.manifest.id,\n      // We need one type assertion here since we can't fully reconcile TAction with Action\n      // due to TypeScript's type system limitations with generic variance\n      e.reducer,\n      typeof e.initialState == \"function\" ? e.initialState(\n        this.initialCoreState,\n        {\n          ...e.manifest.defaultConfig,\n          ...t\n        }\n      ) : e.initialState\n    ), this.pendingRegistrations.push({\n      package: e,\n      config: t\n    });\n  }\n  /**\n   * Get the central store instance\n   */\n  getStore() {\n    return this.store;\n  }\n  /**\n   * Get the engine instance\n   */\n  getEngine() {\n    return this.engine;\n  }\n  /**\n   * Get a promise that resolves when all plugins are ready\n   */\n  pluginsReady() {\n    return this.pluginsReadyPromise ? this.pluginsReadyPromise : (this.pluginsReadyPromise = (async () => {\n      this.initialized || await this.initialize();\n      const e = Array.from(this.plugins.values()).map(\n        (t) => typeof t.ready == \"function\" ? t.ready() : Promise.resolve()\n      );\n      await Promise.all(e);\n    })(), this.pluginsReadyPromise);\n  }\n  /**\n   * INITIALISE THE REGISTRY – runs once no-matter-how-many calls   *\n   */\n  async initialize() {\n    if (this.destroyed)\n      throw new l(\"Registry has been destroyed\");\n    return this.initPromise ? this.initPromise : (this.initPromise = (async () => {\n      var e;\n      if (this.initialized)\n        throw new l(\"Registry is already initialized\");\n      this.isInitializing = !0;\n      try {\n        if (await this.ensureEngineInitialized(), this.destroyed)\n          return;\n        for (; this.pendingRegistrations.length > 0; ) {\n          if (this.destroyed)\n            return;\n          this.processingRegistrations = [...this.pendingRegistrations], this.pendingRegistrations = [];\n          for (const r of this.processingRegistrations) {\n            const s = /* @__PURE__ */ new Set(), n = [...r.package.manifest.requires, ...r.package.manifest.optional];\n            for (const a of n) {\n              const o = this.processingRegistrations.find(\n                (c) => c.package.manifest.provides.includes(a)\n              );\n              o && s.add(o.package.manifest.id);\n            }\n            this.resolver.addNode(r.package.manifest.id, [...s]);\n          }\n          const t = this.resolver.resolveLoadOrder();\n          for (const r of t) {\n            const s = this.processingRegistrations.find((n) => n.package.manifest.id === r);\n            await this.initializePlugin(s.package.manifest, s.package.create, s.config);\n          }\n          this.processingRegistrations = [], this.resolver = new b();\n        }\n        for (const t of this.plugins.values())\n          await ((e = t.postInitialize) == null ? void 0 : e.call(t).catch((r) => {\n            console.error(`Error in postInitialize for plugin ${t.id}`, r), this.status.set(t.id, \"error\");\n          }));\n        this.initialized = !0;\n      } catch (t) {\n        throw t instanceof Error ? new m(\n          `Failed to resolve plugin dependencies: ${t.message}`\n        ) : t;\n      } finally {\n        this.isInitializing = !1;\n      }\n    })(), this.initPromise);\n  }\n  /**\n   * Initialize a single plugin with all necessary checks\n   */\n  async initializePlugin(e, t, r) {\n    const s = {\n      ...e.defaultConfig,\n      ...r\n    };\n    this.validateConfig(e.id, s, e.defaultConfig);\n    const n = t(this, this.engine, s);\n    this.validatePlugin(n);\n    for (const a of e.requires)\n      if (!this.capabilities.has(a))\n        throw new l(\n          `Missing required capability: ${a} for plugin ${e.id}`\n        );\n    for (const a of e.optional)\n      this.capabilities.has(a) && console.debug(`Optional capability ${a} is available for plugin ${e.id}`);\n    console.log(\"initializePlugin\", e.id, e.provides);\n    for (const a of e.provides) {\n      if (this.capabilities.has(a))\n        throw new l(\n          `Capability ${a} is already provided by plugin ${this.capabilities.get(a)}`\n        );\n      this.capabilities.set(a, e.id);\n    }\n    this.plugins.set(e.id, n), this.manifests.set(e.id, e), this.status.set(e.id, \"registered\"), this.configurations.set(e.id, s);\n    try {\n      n.initialize && await n.initialize(s), this.status.set(e.id, \"active\");\n    } catch (a) {\n      throw this.plugins.delete(e.id), this.manifests.delete(e.id), console.log(\"initializePlugin failed\", e.id, e.provides), e.provides.forEach((o) => this.capabilities.delete(o)), a;\n    }\n  }\n  getPluginConfig(e) {\n    const t = this.configurations.get(e);\n    if (!t)\n      throw new u(`Configuration for plugin ${e} not found`);\n    return t;\n  }\n  validateConfig(e, t, r) {\n    const n = Object.keys(r).filter((a) => !t.hasOwnProperty(a));\n    if (n.length > 0)\n      throw new R(\n        `Missing required configuration keys for plugin ${e}: ${n.join(\", \")}`\n      );\n  }\n  async updatePluginConfig(e, t) {\n    const r = this.getPlugin(e);\n    if (!r)\n      throw new u(`Plugin ${e} not found`);\n    const s = this.manifests.get(e), n = this.configurations.get(e);\n    if (!s || !n)\n      throw new u(`Plugin ${e} not found`);\n    const a = {\n      ...n,\n      ...t\n    };\n    this.validateConfig(e, a, s.defaultConfig), this.configurations.set(e, a), r.initialize && await r.initialize(a);\n  }\n  /**\n   * Register multiple plugins at once\n   */\n  registerPluginBatch(e) {\n    for (const t of e)\n      this.registerPlugin(t.package, t.config);\n  }\n  /**\n   * Unregister a plugin\n   */\n  async unregisterPlugin(e) {\n    const t = this.plugins.get(e);\n    if (!t)\n      throw new u(`Plugin ${e} is not registered`);\n    const r = this.manifests.get(e);\n    if (!r)\n      throw new u(`Manifest for plugin ${e} not found`);\n    for (const [s, n] of this.manifests.entries()) {\n      if (s === e) continue;\n      if ([...n.requires, ...n.optional].some(\n        (o) => r.provides.includes(o)\n      ))\n        throw new l(\n          `Cannot unregister plugin ${e}: plugin ${s} depends on it`\n        );\n    }\n    try {\n      t.destroy && await t.destroy();\n      for (const s of r.provides)\n        this.capabilities.delete(s);\n      this.plugins.delete(e), this.manifests.delete(e), this.status.delete(e);\n    } catch (s) {\n      throw s instanceof Error ? new Error(`Failed to unregister plugin ${e}: ${s.message}`) : s;\n    }\n  }\n  /**\n   * Get a plugin instance\n   * @param pluginId The ID of the plugin to get\n   * @returns The plugin instance or null if not found\n   */\n  getPlugin(e) {\n    const t = this.plugins.get(e);\n    return t || null;\n  }\n  /**\n   * Get a plugin that provides a specific capability\n   * @param capability The capability to get a provider for\n   * @returns The plugin providing the capability or null if not found\n   */\n  getCapabilityProvider(e) {\n    const t = this.capabilities.get(e);\n    return t ? this.getPlugin(t) : null;\n  }\n  /**\n   * Check if a capability is available\n   */\n  hasCapability(e) {\n    return this.capabilities.has(e);\n  }\n  /**\n   * Get all registered plugins\n   */\n  getAllPlugins() {\n    return Array.from(this.plugins.values());\n  }\n  /**\n   * Get plugin status\n   */\n  getPluginStatus(e) {\n    const t = this.status.get(e);\n    if (!t)\n      throw new u(`Plugin ${e} not found`);\n    return t;\n  }\n  /**\n   * Validate plugin object\n   */\n  validatePlugin(e) {\n    if (!e.id)\n      throw new l(\"Plugin must have an id\");\n  }\n  /**\n   * Validate plugin manifest\n   */\n  validateManifest(e) {\n    if (!e.id)\n      throw new l(\"Manifest must have an id\");\n    if (!e.name)\n      throw new l(\"Manifest must have a name\");\n    if (!e.version)\n      throw new l(\"Manifest must have a version\");\n    if (!Array.isArray(e.provides))\n      throw new l(\"Manifest must have a provides array\");\n    if (!Array.isArray(e.requires))\n      throw new l(\"Manifest must have a requires array\");\n    if (!Array.isArray(e.optional))\n      throw new l(\"Manifest must have an optional array\");\n  }\n  isDestroyed() {\n    return this.destroyed;\n  }\n  /**\n   * DESTROY EVERYTHING – waits for any ongoing initialise(), once  *\n   */\n  async destroy() {\n    var e;\n    if (this.destroyed) throw new l(\"Registry has already been destroyed\");\n    this.destroyed = !0;\n    try {\n      await this.initPromise;\n    } catch {\n    }\n    for (const t of Array.from(this.plugins.values()).reverse())\n      await ((e = t.destroy) == null ? void 0 : e.call(t));\n    this.store.destroy(), this.plugins.clear(), this.manifests.clear(), this.capabilities.clear(), this.status.clear(), this.pendingRegistrations.length = 0, this.processingRegistrations.length = 0;\n  }\n}\nfunction te(i, e, t) {\n  return i < e ? e : i > t ? t : i;\n}\nfunction v(i, e, t) {\n  if (i === e)\n    return !0;\n  if (i == null || e == null)\n    return i === e;\n  const r = typeof i;\n  if (r !== typeof e) return !1;\n  if (r === \"object\") {\n    t || (t = /* @__PURE__ */ new Set());\n    const n = x(i, e);\n    if (t.has(n))\n      return !0;\n    t.add(n);\n    const a = Array.isArray(i), o = Array.isArray(e);\n    return a && o ? U(i, e, t) : !a && !o ? B(i, e, t) : !1;\n  }\n  return !1;\n}\nfunction x(i, e) {\n  return `${S(i)}__${S(e)}`;\n}\nlet G = 0;\nconst d = /* @__PURE__ */ new WeakMap();\nfunction S(i) {\n  return d.has(i) || d.set(i, ++G), d.get(i);\n}\nfunction U(i, e, t) {\n  if (i.length !== e.length) return !1;\n  const r = new Array(e.length).fill(!1);\n  e: for (let s = 0; s < i.length; s++) {\n    const n = i[s];\n    for (let a = 0; a < e.length; a++)\n      if (!r[a] && v(n, e[a], t)) {\n        r[a] = !0;\n        continue e;\n      }\n    return !1;\n  }\n  return !0;\n}\nfunction B(i, e, t) {\n  const r = Object.keys(i).sort(), s = Object.keys(e).sort();\n  if (r.length !== s.length) return !1;\n  for (let n = 0; n < r.length; n++)\n    if (r[n] !== s[n]) return !1;\n  for (const n of r) {\n    const a = i[n], o = e[n];\n    if (!v(a, o, t))\n      return !1;\n  }\n  return !0;\n}\nexport {\n  m as C,\n  b as D,\n  g as L,\n  ee as P,\n  f as S,\n  v as a,\n  l as b,\n  u as c,\n  K as d,\n  H as e,\n  W as f,\n  R as g,\n  p as h,\n  y as i,\n  w as j,\n  E as k,\n  O as l,\n  Z as m,\n  V as n,\n  J as o,\n  Y as p,\n  Q as q,\n  j as r,\n  I as s,\n  X as t,\n  te as u\n};\n//# sourceMappingURL=math-ChSRQF3r.js.map\n","import { t as S, a as m } from \"./math-ChSRQF3r.js\";\nimport { l as v, e as D, d as I, C as F, D as _, L as O, g as A, f as N, c as M, b as U, P as z, S as x, h as L, k as j, j as q, i as B, u as K, r as $, m as k, s as G, n as W, q as Y, p as H, o as J } from \"./math-ChSRQF3r.js\";\nconst f = (o) => o.pages.map(\n  (t) => t.map((e) => ({\n    ...e,\n    rotatedSize: S(e.size, o.rotation, 1)\n  }))\n);\nfunction y(o, t) {\n  return {\n    package: o,\n    config: t\n  };\n}\nclass w {\n  constructor(t, e) {\n    if (this.id = t, this.registry = e, this.debouncedActions = {}, this.unsubscribeFromState = null, this.unsubscribeFromCoreStore = null, t !== this.constructor.id)\n      throw new Error(\n        `Plugin ID mismatch: ${t} !== ${this.constructor.id}`\n      );\n    this.coreStore = this.registry.getStore(), this.pluginStore = this.coreStore.getPluginStore(this.id), this.unsubscribeFromState = this.pluginStore.subscribeToState((i, s, c) => {\n      this.onStoreUpdated(c, s);\n    }), this.unsubscribeFromCoreStore = this.coreStore.subscribe((i, s, c) => {\n      this.onCoreStoreUpdated(c, s);\n    }), this.readyPromise = new Promise((i) => {\n      this.readyResolve = i;\n    }), this.readyResolve();\n  }\n  provides() {\n    if (!this._capability) {\n      const t = this.buildCapability();\n      this._capability = Object.freeze(t);\n    }\n    return this._capability;\n  }\n  /**\n   *  Get a copy of the current state\n   */\n  get state() {\n    return this.pluginStore.getState();\n  }\n  /**\n   *  Get a copy of the current core state\n   */\n  get coreState() {\n    return this.coreStore.getState();\n  }\n  /**\n   * @deprecated  use `this.state` Get a copy of the current state\n   */\n  getState() {\n    return this.pluginStore.getState();\n  }\n  /**\n   * @deprecated  use `this.coreState` Get a copy of the current core state\n   */\n  getCoreState() {\n    return this.coreStore.getState();\n  }\n  /**\n   * Core Dispatch\n   */\n  dispatchCoreAction(t) {\n    return this.coreStore.dispatchToCore(t);\n  }\n  /**\n   * Dispatch an action to all plugins\n   */\n  dispatchToAllPlugins(t) {\n    return this.coreStore.dispatch(t);\n  }\n  /**\n   * Dispatch an action\n   */\n  dispatch(t) {\n    return this.pluginStore.dispatch(t);\n  }\n  /**\n   * Dispatch an action with debouncing to prevent rapid repeated calls\n   * @param action The action to dispatch\n   * @param debounceTime Time in ms to debounce (default: 100ms)\n   * @returns boolean indicating whether the action was dispatched or debounced\n   */\n  debouncedDispatch(t, e = 100) {\n    const i = Date.now(), s = this.debouncedActions[t.type] || 0;\n    return i - s >= e ? (this.debouncedActions[t.type] = i, this.dispatch(t), !0) : !1;\n  }\n  /**\n   * Subscribe to state changes\n   */\n  subscribe(t) {\n    return this.pluginStore.subscribeToState(t);\n  }\n  /**\n   * Subscribe to core store changes\n   */\n  subscribeToCoreStore(t) {\n    return this.coreStore.subscribe(t);\n  }\n  /**\n   * Called when the plugin store state is updated\n   * @param oldState Previous state\n   * @param newState New state\n   */\n  onStoreUpdated(t, e) {\n  }\n  /**\n   * Called when the core store state is updated\n   * @param oldState Previous state\n   * @param newState New state\n   */\n  onCoreStoreUpdated(t, e) {\n  }\n  /**\n   * Cleanup method to be called when plugin is being destroyed\n   */\n  destroy() {\n    this.unsubscribeFromState && (this.unsubscribeFromState(), this.unsubscribeFromState = null), this.unsubscribeFromCoreStore && (this.unsubscribeFromCoreStore(), this.unsubscribeFromCoreStore = null);\n  }\n  /**\n   * Returns a promise that resolves when the plugin is ready\n   */\n  ready() {\n    return this.readyPromise;\n  }\n  /**\n   * Mark the plugin as ready\n   */\n  markReady() {\n    this.readyResolve();\n  }\n  /**\n   * Reset the ready state (useful for plugins that need to reinitialize)\n   */\n  resetReady() {\n    this.readyPromise = new Promise((t) => {\n      this.readyResolve = t;\n    });\n  }\n}\nclass b {\n  constructor(t, e) {\n    this.handler = t, this.options = e, this.lastRun = 0, this.handle = (i) => {\n      this.options.mode === \"debounce\" ? this.debounce(i) : this.throttle(i);\n    };\n  }\n  debounce(t) {\n    this.timeoutId && window.clearTimeout(this.timeoutId), this.timeoutId = window.setTimeout(() => {\n      this.handler(t), this.timeoutId = void 0;\n    }, this.options.wait);\n  }\n  throttle(t) {\n    if (this.options.mode === \"debounce\") return;\n    const e = Date.now(), i = this.options.throttleMode || \"leading-trailing\";\n    e - this.lastRun >= this.options.wait && (i === \"leading-trailing\" && this.handler(t), this.lastRun = e), this.timeoutId && window.clearTimeout(this.timeoutId), this.timeoutId = window.setTimeout(\n      () => {\n        this.handler(t), this.lastRun = Date.now(), this.timeoutId = void 0;\n      },\n      this.options.wait - (e - this.lastRun)\n    );\n  }\n  destroy() {\n    this.timeoutId && window.clearTimeout(this.timeoutId);\n  }\n}\nfunction E() {\n  const o = /* @__PURE__ */ new Set();\n  return {\n    emit: (e = void 0) => o.forEach((i) => i(e)),\n    on: (e) => (o.add(e), () => o.delete(e)),\n    off: (e) => o.delete(e),\n    clear: () => o.clear()\n  };\n}\nfunction C(o, t = m) {\n  const e = /* @__PURE__ */ new Set(), i = /* @__PURE__ */ new Map();\n  let s = o;\n  const c = (r) => e.forEach((n) => n(r)), p = (r, n) => {\n    let a = r, d = () => {\n    };\n    if (n) {\n      const u = new b(r, n);\n      a = u.handle, d = () => u.destroy(), i.set(r, { wrapped: a, destroy: d });\n    }\n    return s !== void 0 && a(s), e.add(a), () => {\n      e.delete(a), d(), i.delete(r);\n    };\n  };\n  return {\n    /* emitter behaviour ---------------------------------------- */\n    get value() {\n      return s;\n    },\n    emit(r = void 0) {\n      (s === void 0 || !t(s, r)) && (s = r, c(r));\n    },\n    on: p,\n    off(r) {\n      const n = i.get(r);\n      n ? (e.delete(n.wrapped), n.destroy(), i.delete(r)) : e.delete(r);\n    },\n    clear() {\n      e.clear(), i.forEach((r) => r.destroy()), i.clear();\n    },\n    /* derived hook --------------------------------------------- */\n    select(r, n = m) {\n      return (a, d) => {\n        let u;\n        if (s !== void 0) {\n          const h = r(s);\n          u = h, a(h);\n        }\n        return p(\n          (h) => {\n            const l = r(h);\n            (u === void 0 || !n(u, l)) && (u = l, a(l));\n          },\n          d\n        );\n      };\n    }\n  };\n}\nfunction T(o) {\n  return Object.entries(o).map(([t, e]) => {\n    const i = Number(t);\n    return [Number.isFinite(i) && t.trim() !== \"\" ? i : t, e];\n  });\n}\nexport {\n  w as BasePlugin,\n  v as CORE_ACTION_TYPES,\n  D as CapabilityConflictError,\n  I as CapabilityNotFoundError,\n  F as CircularDependencyError,\n  _ as DependencyResolver,\n  b as EventControl,\n  O as LOAD_DOCUMENT,\n  A as PluginConfigurationError,\n  N as PluginInitializationError,\n  M as PluginNotFoundError,\n  U as PluginRegistrationError,\n  z as PluginRegistry,\n  x as SET_DOCUMENT,\n  L as SET_DOCUMENT_ERROR,\n  j as SET_PAGES,\n  q as SET_ROTATION,\n  B as SET_SCALE,\n  m as arePropsEqual,\n  K as clamp,\n  C as createBehaviorEmitter,\n  E as createEmitter,\n  y as createPluginRegistration,\n  T as enumEntries,\n  f as getPagesWithRotatedSize,\n  $ as initialCoreState,\n  k as loadDocument,\n  G as setDocument,\n  W as setDocumentError,\n  Y as setPages,\n  H as setRotation,\n  J as setScale\n};\n//# sourceMappingURL=index.js.map\n","import { Action } from '@embedpdf/core';\n\nexport const ACTIVATE_MODE = 'INTERACTION/ACTIVATE_MODE';\nexport const PAUSE_INTERACTION = 'INTERACTION/PAUSE';\nexport const RESUME_INTERACTION = 'INTERACTION/RESUME';\nexport const SET_CURSOR = 'INTERACTION/SET_CURSOR';\n\nexport interface ActivateModeAction extends Action {\n  type: typeof ACTIVATE_MODE;\n  payload: { mode: string };\n}\n\nexport interface PauseInteractionAction extends Action {\n  type: typeof PAUSE_INTERACTION;\n}\n\nexport interface ResumeInteractionAction extends Action {\n  type: typeof RESUME_INTERACTION;\n}\n\nexport interface SetCursorAction extends Action {\n  type: typeof SET_CURSOR;\n  payload: { cursor: string };\n}\n\nexport const activateMode = (mode: string): ActivateModeAction => ({\n  type: ACTIVATE_MODE,\n  payload: { mode },\n});\n\nexport const setCursor = (cursor: string): SetCursorAction => ({\n  type: SET_CURSOR,\n  payload: { cursor },\n});\n\nexport const pauseInteraction = (): PauseInteractionAction => ({\n  type: PAUSE_INTERACTION,\n});\n\nexport const resumeInteraction = (): ResumeInteractionAction => ({\n  type: RESUME_INTERACTION,\n});\n\nexport type InteractionManagerAction =\n  | ActivateModeAction\n  | PauseInteractionAction\n  | ResumeInteractionAction\n  | SetCursorAction;\n","import { PointerEventHandlers } from './types';\n\nexport function mergeHandlers(list: PointerEventHandlers[]): PointerEventHandlers {\n  const keys: (keyof PointerEventHandlers)[] = [\n    'onPointerDown',\n    'onPointerUp',\n    'onPointerMove',\n    'onPointerEnter',\n    'onPointerLeave',\n    'onPointerCancel',\n  ];\n  const out: Partial<PointerEventHandlers> = {};\n  for (const k of keys) {\n    out[k] = (evt: any, nativeEvt: any, modeId: string) => {\n      for (const h of list) h[k]?.(evt, nativeEvt, modeId);\n    };\n  }\n  return out as PointerEventHandlers;\n}\n","import { BasePlugin, createBehaviorEmitter, createEmitter, PluginRegistry } from '@embedpdf/core';\n\nimport {\n  InteractionManagerCapability,\n  InteractionManagerPluginConfig,\n  InteractionManagerState,\n  InteractionMode,\n  InteractionScope,\n  PointerEventHandlers,\n  PointerEventHandlersWithLifecycle,\n  RegisterAlwaysOptions,\n  RegisterHandlersOptions,\n} from './types';\nimport { activateMode, pauseInteraction, resumeInteraction, setCursor } from './actions';\nimport { mergeHandlers } from './helper';\n\ninterface CursorClaim {\n  cursor: string;\n  priority: number;\n}\n\ntype HandlerSet = Set<PointerEventHandlersWithLifecycle>;\ntype PageHandlerMap = Map<number /*pageIdx*/, HandlerSet>;\n\ninterface ModeBuckets {\n  /** handlers that listen on the global wrapper (only once per viewer) */\n  global: HandlerSet;\n  /** handlers that listen on a *specific* page wrapper */\n  page: PageHandlerMap;\n}\n\nexport class InteractionManagerPlugin extends BasePlugin<\n  InteractionManagerPluginConfig,\n  InteractionManagerCapability,\n  InteractionManagerState\n> {\n  static readonly id = 'interaction-manager' as const;\n\n  private modes = new Map<string, InteractionMode>();\n  private cursorClaims = new Map<string, CursorClaim>();\n  private buckets = new Map<string, ModeBuckets>();\n\n  private alwaysGlobal = new Set<PointerEventHandlersWithLifecycle>();\n  private alwaysPage = new Map<number, Set<PointerEventHandlersWithLifecycle>>();\n\n  private readonly onModeChange$ = createEmitter<InteractionManagerState>();\n  private readonly onHandlerChange$ = createEmitter<InteractionManagerState>();\n  private readonly onCursorChange$ = createEmitter<string>();\n  private readonly onStateChange$ = createBehaviorEmitter<InteractionManagerState>();\n\n  constructor(id: string, registry: PluginRegistry) {\n    super(id, registry);\n\n    this.registerMode({\n      id: 'default',\n      scope: 'page',\n      exclusive: false,\n      cursor: 'auto',\n    });\n  }\n\n  async initialize(_: InteractionManagerPluginConfig): Promise<void> {}\n\n  protected buildCapability(): InteractionManagerCapability {\n    return {\n      activate: (modeId: string) => this.activate(modeId),\n      onModeChange: this.onModeChange$.on,\n      onCursorChange: this.onCursorChange$.on,\n      onHandlerChange: this.onHandlerChange$.on,\n      onStateChange: this.onStateChange$.on,\n      getActiveMode: () => this.state.activeMode,\n      getActiveInteractionMode: () => this.getActiveInteractionMode(),\n      finish: () => this.activate('default'),\n      registerMode: (mode: InteractionMode) => this.registerMode(mode),\n      registerHandlers: (options: RegisterHandlersOptions) => this.registerHandlers(options),\n      registerAlways: (options: RegisterAlwaysOptions) => this.registerAlways(options),\n      setCursor: (token: string, cursor: string, priority = 0) =>\n        this.setCursor(token, cursor, priority),\n      removeCursor: (token: string) => this.removeCursor(token),\n      getCurrentCursor: () => this.state.cursor,\n      getHandlersForScope: (scope: InteractionScope) => this.getHandlersForScope(scope),\n      activeModeIsExclusive: () => this.activeModeIsExclusive(),\n      pause: () => this.dispatch(pauseInteraction()),\n      resume: () => this.dispatch(resumeInteraction()),\n      isPaused: () => this.state.paused,\n    };\n  }\n\n  private activate(mode: string) {\n    if (!this.modes.has(mode)) {\n      throw new Error(`[interaction] unknown mode '${mode}'`);\n    }\n    if (mode === this.state.activeMode) return;\n\n    const previousMode = this.state.activeMode;\n    this.cursorClaims.clear(); // prevent cursor leaks\n\n    this.notifyHandlersInactive(previousMode);\n\n    this.dispatch(activateMode(mode));\n    this.emitCursor();\n\n    // Call lifecycle hooks for handlers going active\n    this.notifyHandlersActive(mode);\n\n    this.onModeChange$.emit({ ...this.state, activeMode: mode });\n  }\n\n  private notifyHandlersActive(modeId: string) {\n    this.alwaysGlobal.forEach((handler) => {\n      handler.onHandlerActiveStart?.(modeId);\n    });\n\n    this.alwaysPage.forEach((handlerSet) => {\n      handlerSet.forEach((handler) => {\n        handler.onHandlerActiveStart?.(modeId);\n      });\n    });\n\n    const mode = this.modes.get(modeId);\n    if (!mode) return;\n\n    const bucket = this.buckets.get(modeId);\n    if (!bucket) return;\n\n    // Notify global handlers if mode is global\n    if (mode.scope === 'global') {\n      bucket.global.forEach((handler) => {\n        handler.onHandlerActiveStart?.(modeId);\n      });\n    }\n\n    // Notify page handlers if mode is page\n    if (mode.scope === 'page') {\n      bucket.page.forEach((handlerSet, pageIndex) => {\n        handlerSet.forEach((handler) => {\n          handler.onHandlerActiveStart?.(modeId);\n        });\n      });\n    }\n  }\n\n  private notifyHandlersInactive(modeId: string) {\n    this.alwaysGlobal.forEach((handler) => {\n      handler.onHandlerActiveEnd?.(modeId);\n    });\n\n    this.alwaysPage.forEach((handlerSet) => {\n      handlerSet.forEach((handler) => {\n        handler.onHandlerActiveEnd?.(modeId);\n      });\n    });\n\n    const mode = this.modes.get(modeId);\n    if (!mode) return;\n\n    const bucket = this.buckets.get(modeId);\n    if (!bucket) return;\n\n    // Notify global handlers if mode is global\n    if (mode.scope === 'global') {\n      bucket.global.forEach((handler) => {\n        handler.onHandlerActiveEnd?.(modeId);\n      });\n    }\n\n    // Notify page handlers if mode is page\n    if (mode.scope === 'page') {\n      bucket.page.forEach((handlerSet, pageIndex) => {\n        handlerSet.forEach((handler) => {\n          handler.onHandlerActiveEnd?.(modeId);\n        });\n      });\n    }\n  }\n\n  private registerMode(mode: InteractionMode) {\n    this.modes.set(mode.id, mode);\n    if (!this.buckets.has(mode.id)) {\n      this.buckets.set(mode.id, { global: new Set(), page: new Map() });\n    }\n  }\n\n  /** ---------- pointer-handler handling ------------ */\n  private registerHandlers({ modeId, handlers, pageIndex }: RegisterHandlersOptions): () => void {\n    const modeIds = Array.isArray(modeId) ? modeId : [modeId];\n    const cleanupFunctions: (() => void)[] = [];\n\n    for (const id of modeIds) {\n      const bucket = this.buckets.get(id);\n      if (!bucket) throw new Error(`unknown mode '${id}'`);\n\n      if (pageIndex == null) {\n        bucket.global.add(handlers);\n      } else {\n        const set = bucket.page.get(pageIndex) ?? new Set();\n        set.add(handlers);\n        bucket.page.set(pageIndex, set);\n      }\n\n      // Create cleanup function for this specific mode\n      cleanupFunctions.push(() => {\n        if (pageIndex == null) {\n          bucket.global.delete(handlers);\n        } else {\n          const set = bucket.page.get(pageIndex);\n          if (set) {\n            set.delete(handlers);\n            if (set.size === 0) {\n              bucket.page.delete(pageIndex);\n            }\n          }\n        }\n      });\n    }\n\n    this.onHandlerChange$.emit({ ...this.state });\n\n    // Return a cleanup function that removes handlers from all registered modes\n    return () => {\n      cleanupFunctions.forEach((cleanup) => cleanup());\n      this.onHandlerChange$.emit({ ...this.state });\n    };\n  }\n\n  public registerAlways({ scope, handlers }: RegisterAlwaysOptions): () => void {\n    if (scope.type === 'global') {\n      this.alwaysGlobal.add(handlers);\n      this.onHandlerChange$.emit({ ...this.state });\n      return () => this.alwaysGlobal.delete(handlers);\n    }\n    const set = this.alwaysPage.get(scope.pageIndex) ?? new Set();\n    set.add(handlers);\n    this.alwaysPage.set(scope.pageIndex, set);\n    this.onHandlerChange$.emit({ ...this.state });\n    return () => {\n      set.delete(handlers);\n      this.onHandlerChange$.emit({ ...this.state });\n    };\n  }\n\n  /** Returns the *merged* handler set that should be active for the given\n   *  provider (`global` wrapper or a single page wrapper).\n   *  – `alwaysGlobal` / `alwaysPage` are **always** active.\n   *  – Handlers that belong to the current mode are added on top **iff**\n   *    the mode’s own scope matches the provider’s scope.            */\n  private getHandlersForScope(scope: InteractionScope): PointerEventHandlers | null {\n    if (!this.state) return null;\n\n    const mode = this.modes.get(this.state.activeMode);\n    if (!mode) return null;\n\n    const bucket = this.buckets.get(mode.id);\n    if (!bucket) return null;\n\n    /** helper – merge two handler sets into one object (or `null` if both are empty) */\n    const mergeSets = (a: HandlerSet, b: HandlerSet) =>\n      a.size || b.size ? mergeHandlers([...a, ...b]) : null;\n\n    /* ─────────────────────  GLOBAL PROVIDER  ─────────────────────── */\n    if (scope.type === 'global') {\n      const modeSpecific =\n        mode.scope === 'global' // only include mode handlers if the\n          ? bucket.global // mode itself is global-scoped\n          : new Set<PointerEventHandlers>();\n      return mergeSets(this.alwaysGlobal, modeSpecific);\n    }\n\n    /* ───────────────────────  PAGE PROVIDER  ──────────────────────── */\n    const alwaysPageSet = this.alwaysPage.get(scope.pageIndex) ?? new Set<PointerEventHandlers>();\n    const modePageSet =\n      mode.scope === 'page'\n        ? (bucket.page.get(scope.pageIndex) ?? new Set<PointerEventHandlers>())\n        : new Set<PointerEventHandlers>(); // global-scoped mode → ignore page buckets\n\n    return mergeSets(alwaysPageSet, modePageSet);\n  }\n\n  /** ---------- cursor handling --------------------- */\n  private setCursor(token: string, cursor: string, priority = 0) {\n    this.cursorClaims.set(token, { cursor, priority });\n    this.emitCursor();\n  }\n  private removeCursor(token: string) {\n    this.cursorClaims.delete(token);\n    this.emitCursor();\n  }\n\n  private emitCursor() {\n    /* pick highest priority claim, else mode baseline */\n    const top = [...this.cursorClaims.values()].sort((a, b) => b.priority - a.priority)[0] ?? {\n      cursor: this.modes.get(this.state.activeMode)?.cursor ?? 'auto',\n    };\n\n    if (top.cursor !== this.state.cursor) {\n      this.dispatch(setCursor(top.cursor));\n      this.onCursorChange$.emit(top.cursor);\n    }\n  }\n\n  override onStoreUpdated(_: InteractionManagerState, newState: InteractionManagerState): void {\n    this.onStateChange$.emit(newState);\n  }\n\n  private activeModeIsExclusive(): boolean {\n    const mode = this.modes.get(this.state.activeMode);\n    return !!mode?.exclusive;\n  }\n\n  private getActiveInteractionMode(): InteractionMode | null {\n    return this.modes.get(this.state.activeMode) ?? null;\n  }\n\n  // keep emitter clean\n  async destroy(): Promise<void> {\n    this.onModeChange$.clear();\n    this.onCursorChange$.clear();\n    await super.destroy();\n  }\n}\n","import { Reducer } from '@embedpdf/core';\nimport {\n  ACTIVATE_MODE,\n  InteractionManagerAction,\n  PAUSE_INTERACTION,\n  RESUME_INTERACTION,\n  SET_CURSOR,\n} from './actions';\nimport { InteractionManagerState } from './types';\n\nexport const initialState: InteractionManagerState = {\n  activeMode: 'default',\n  cursor: 'auto',\n  paused: false,\n};\n\nexport const reducer: Reducer<InteractionManagerState, InteractionManagerAction> = (\n  state,\n  action,\n) => {\n  switch (action.type) {\n    case ACTIVATE_MODE:\n      return {\n        ...state,\n        activeMode: action.payload.mode,\n      };\n    case SET_CURSOR:\n      return {\n        ...state,\n        cursor: action.payload.cursor,\n      };\n    case PAUSE_INTERACTION:\n      return {\n        ...state,\n        paused: true,\n      };\n    case RESUME_INTERACTION:\n      return {\n        ...state,\n        paused: false,\n      };\n    default:\n      return state;\n  }\n};\n"],"names":["z","M","L","F","N","k","P","i","e","_","t","v","r","n","x","a","o","U","B","S","G","d","s","w","c","b","E","C","m","p","u","h","l","ACTIVATE_MODE","PAUSE_INTERACTION","RESUME_INTERACTION","SET_CURSOR","activateMode","mode","setCursor","cursor","pauseInteraction","resumeInteraction","mergeHandlers","list","keys","out","evt","nativeEvt","modeId","_a","_InteractionManagerPlugin","BasePlugin","id","registry","createEmitter","createBehaviorEmitter","options","token","priority","scope","previousMode","handler","handlerSet","bucket","pageIndex","handlers","modeIds","cleanupFunctions","set","cleanup","mergeSets","modeSpecific","alwaysPageSet","modePageSet","top","newState","InteractionManagerPlugin","initialState","reducer","state","action"],"mappings":"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"}